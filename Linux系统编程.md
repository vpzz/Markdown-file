# 基础知识

1. 操作系统内核的接口被称作系统调用，system call。公用函数库建立在系统调用上，两者可以被应用程序使用。

2. 只要CPU拥有分页内存管理单元（PMMU），且移植了gcc编译器，就可以将Linux进行移植过去。

3. Linux也被移植到许多没有PMMU的体系结构中，不过功能会受到限制。

4. Linux也被移植到了自己身上。现在可以将内核作为用户空间应用程序运行，这被称为User Mode Linux（UML）。

5. Bash是GNU Shell，所有的linux都支持该shell，设计遵循POSIX标准，兼容Bsh，支持Csh和Ksh的特色功能。

6. 目录是一个包含目录项的文件，每条目录项包含该目录下的文件名，及其iNode。之所以不在目录项中存放文件的属性是因为一个文件可能有多个硬链接副本，很难在多个副本之间保持属性的一致。

7. /和空格不能作为文件名，因为/表示路径的分隔，空格表示文件名的终止。如果文件名中包含空格，在shell中需要使用双引号包括起来使用。

8. 文件名(filename)指的是某个文件的名称，路径名(pathname)分为绝对路径和相对路径。从路径名不能分辨出，指向的是文件还是目录。

9. 早期的UNIX将8个部分都集中在《UNIX程序员手册》，现在已经分开了，方便用户，程序员，系统管理员的使用。

10. 按照惯例，函数的返回值为0，表示正常结束。一般用-1表示出错。

11. 如果要对返回值进行校验，有宏名的用宏名，不要用宏值，因为宏值有可能会改变。

12. 每个进程都有一个工作目录，可以用chdir函数更改，所有的相对路径都以此开始解释。

13. 每当运行一个新的程序时，shell都会为其打开三个文件描述符，stdin，stdout，stderr。默认这三个文件描述符都链接向终端。

14. 系统I/O对应的三个标准文件描述符，STDIN_FILENO，STDOUT_FILENO和STDERR_FILENO，定义再unistd.h文件中。

15. 标准I/O对应的三个标准流，stdin，stdout，stderr，定义在stdio.h文件中。

16. ```shell
    ./a.out < in.txt > out.txt     #将a.out程序的标准输入重定向为in.txt，标准输出重定向为out.txt。
    ```

17. 系统I/O不带缓冲，标准I/O会自动选定合适的缓冲大小。

18. 程序（program）是指存储在硬盘上的某个可执行文件，使用exec函数将程序读入内存执行。

19. 进程（process）是程序执行的实例。

20. 使用函数的时候，应该将man提到的头文件原封不动的都包含进来。有时不包含对应的头文件也可以编译通过，但是会报警。例如：

    ```c
    int *p = malloc(sizeof(int));  //如果没有include stdlib.h的话,会报warning,提示说类型不匹配。其实并不是malloc的返回值void*和int*不匹配，而是当没有头文件时，编译器默认malloc的返回值为int，因此时int和int*的类型不匹配。
    ```

21. 进程在执行过程中会收到各种各样的信号，可以忽略（不推荐），或按照系统默认的方式（大多是结束该进程）处理，也可以捕捉信号，自己编写函数处理。键盘可以产生信号，例如Ctrl+C或Ctrl+\键。在一个进程中调用kill函数可以向另一个进程发送信号，此时需要是该进程的所有者或root。

22. UNIX中的两类时间：

    1. 日历时间：早期的UNIX使用格林尼治时间，后来使用了更精确的世界协调时UTC。表示从1970年1月1日00:00以来经过的秒数。使用time_t类型保存。
    2. 进程时间：也被称作CPU时间，用来度量进程使用的CPU资源。以时钟滴答计算，每秒钟曾经取过50,60，100个时钟滴答。使用sysconf(_SC_CLK_TCK)查询。

23. UNIX为一个进程维护了3个时间值，使用time命令查看，其中real又称为墙上时钟时间。

24. linux3.2大约定义了320个系统调用。在man 2中说明，用C语言书写成。早期的系统使用汇编语言定义内核入口点。

25. 系统调用本质上是设置一下寄存器，然后调用软中断int 0x80，原则上任何编程语言只要内部用汇编指令实现这样的操作，就可以为该语言提供系统调用接口。不过大部分的操作系统的系统调用都是用C语言编写的。

26. 一个库函数可能使用多个系统调用，也可能不使用，例如atoi或strcpy。

27. 内存分配函数malloc，内部就使用到了sbrk系统调用。不过该函数只是增加或进程的地址空间，如何管理改地址空间，取决于进程本身，malloc内部实现了分配。如果对库函数不满意，可以使用系统调用封装自己的库函数。

28. 系统调用只做最基础的操作，例如关于时间只有一个系统调用，返回一个整数秒数，具体的时间日期解析，交给库函数。系统调用通常提供的是最小接口，库函数通常提供比较复杂的功能。

29. 内核中有大量的宏定义（应用到了极致），因为宏只占用编译时间，不占用调用时间，这个和函数相反。

30. char型是无符号还是有符号的这件事，是未定义的，标准C中没有该数据类型。

31. 如果使用到了命令行传参，那么就该在main函数的开头就检查参数的个数和类型是否正确，不正确的话应该像标准错误中输出正确的用法，可以使用fprintf()。

32. 如果申请两个资源，要求第一个成功再申请第二个，那么就应该考虑在第二个申请失败时，释放第一个资源。

33. Linux和UNIX相比专有的特性：

    ```c
    epoll   //获取文件I/O事件通知的一种机制
    inotify //监控文件和目录变化的一种机制
    capabilities //把传统上赋予超级用户的权限划分为一组相互独立的单元,传统意义上的超级用户进程（有效用户ID为0）则相应开启了所有能力。
    扩展属性
    i-node标记
    clone系统调用
    /proc文件系统
    ```

34. Linux手册页中的第2，3，4，5，7部分都属于man-pages项目，API在这些手册页中描述。

35. 虽然在没有内核的情况下，计算机也能运行程序，像单片机一样，但是有了内核，会极大简化程序员的工作。Linux内核的可执行文件为：`/boot/vmlinuz`，其中vm表示实现了虚拟内存机制，z表示这是压缩过的。

36. Linux属于抢占式多任务操作系统，多任务指多个进程同时驻留内存，且每个进程都会获得CPU的使用权。抢占意味着存在一组规则，来分配CPU的使用权和时长。这两个特性都由内核的进程调度程序实现。

37. Linux使用了虚拟内存，有以下两个优势：

    1. 进程和进程之间，进程和内核之间彼此隔离，进程不能随意读写其他进程和内核的内容。
    2. 只需将进程的一部分保存在物理内存中，这使得可以同时在物理内存中驻留更多的进程，从而使得可以随时被CPU调度的进程数量增多，不用等到被赋予CPU使用权限后再载入内存。

38. 进程可利用内核入口点（也称为系统调用）请求内核去执行各种任务。

39. 现代CPU可以运行在内核态和用户态，可以通过指令切换。与之对应的是，虚拟内存机制将地址空间也划分为内核空间和用户空间。CPU处于用户态时，只能访问用户空间，否则会引发异常。操作系统的代码和数据保存在内核空间中，从而获得保护。

40. 信号的传递和进程间通信事件的触发由内核统一协调。进程无法直接使用外界设备，进程之间彼此不能直接通信，进程本身无法创建出新进程，哪怕杀死自己都不行，进程的运作类似于内核控制下的提线木偶。

41. 内核维护了各种各样的数据结构，例如进程相关信息，文件到磁盘位置的映射，虚拟内存地址到物理内存地址的映射，随着进程的运行，内核会及时更新这些数据结构。内核中的设备驱动程序会和设备进行通信。

42. 某些操作系统将shell集成进内核中，而UNIX中，shell只是一个用户进程而已。

43. POSIX.2-1992基于当时的Korn shell版本定义了一个shell的标准，如今的bash也是符合该标准的。

44. 早期的UNIX中，一个用户只能属于一个组，BSD率先支持多个组，POSIX.1-1990将其标准化。

45. 默认情况下，内核会递归解析符号链接获得实际文件，不过会限制递归的层数。如果符号链接指向的文件不存在，则称为悬空连接（dangling）。

46. 大多数Linux文件系统上，文件名最长为255个字符，可以使用/和空字符之外的所有字符。但是SUSv3建议只是用`[-._a-zA-Z0-9]`这65个字符，并称之为可移植文件名字符集。因为这以外的字符可能会在shell，正则表达式中有特殊含义。还应避免将`-`作为文件名开头字符，因为会被当作命令的选项。

47. 进程的当前工作目录继承自父进程，对于登录shell来说，初始当前工作目录保存在passwd文件中。

48. 目录的执行权限意味着是否可以进入该目录，而是否可以访问目录中具体文件，还得根据文件来判定。

49. 就本质而言，内核只提供一种文件类型：字节流序列。处理磁盘等块设备时，可以使用lseek来随机访问。

50. UNIX没有文件结束符这一实体，读取文件时，如果没有数据返回，就会认定到达文件末尾。

51. 由shell启动的进程会继承3个已经打开的文件描述符。在交互式终端上，这三个都指向终端。在stdio函数库中，这三个描述符分别和三个流对应。

52. 国际协调时（UTC）是以原子时秒长为基础，在时刻上尽量接近于世界时的一种时间计量系统。很多计时的起点都是UTC1970年1月1日凌晨，这个时间和UNIX诞生的时间很近，因此也成为纪元Epoch，也就是纪年的开始。

53. 实时性应用程序：需要对输入做出及时响应的程序。此类输入往往来自于外接的传感器或某些专门的输入设备，而输出则会去控制外接硬件。具有实时性需求的应用程序包括自动化装配流水线，银行ATM 机以及飞机导航系统等。

54. 实时性是指：在事件触发后的一定时限内，保证响应的交付。这就需要就需要底层操作系统的支持。

55. 由于实时响应的需求与多用户分时操作系统的需求存在冲突，大多数操作系统天生并不提供这样的支持。传统的UNIX实现都不是实时操作系统。近期的Linux内核正转向对实时性应用原生而全面的支持。

56. /proc文件系统是一种虚拟文件系统，以目录和文件的形式提供一个指向内核数据结构的接口。方便查看和改变各种系统属性。还可以通过一组以/proc/PID形式命名的目录查看系统中运行各进程的相关信息。

57. /proc目录下都是文本文件，大多数情况下，只有特权级进程才能修改/proc目录下的文件内容。

58. 目前尚无任何标准对/proc文件系统进行过规范。

59. 无论何时，只要执行了系统调用或者库函数，检查调用的返回状态以确定调用是否成功，这是一条编程铁律。

60. 系统调用是受控的内核入口，借助于这一机制，进程可以请求内核以自己的名义去执行某些动作。使用`man 2 syscalls`来查看所有的系统调用。

61. 系统调用将处理器从用户态切换到内核态，系统调用的组成是固定的，每个都由一个唯一的数字标识，程序通过名称来使用系统调用。每个系统调用都有一套参数，来对内核传递信息。

62. 从使用上来看，系统调用和C语言的函数调用很像。应用程序通过调用外壳（wrapper）函数来发起系统调用。外壳函数用来确保所有系统调用的参数可用，这些参数一般保存在栈上，而内核希望它们放在寄存器中，因此外壳函数还要将他们复制到寄存器中。

63. 所有系统调用进入内核的方式都一样，因此外壳函数会将系统调用编号复制到一个特殊的寄存器%eax中。

64. 外壳函数执行一条中断指令int0x80，引发处理器从用户态切换到内核态，并执行0x80中断的处理函数（system_call()例程，位于汇编文件arch/i386/entry.s中）。较新的x86-32硬件平台实现了sysenter指令，进入内核的速度更快，2.6 内核及glibc 2.3.2以后的版本都支持sysenter指令。

65. 中断处理函数的工作：在内核栈中保存寄存器的值，审查系统调用编号，根据编号在服务例程列表中查找例程（内核变量sys_call_table），检查参数的有效性，执行例程，将执行结果返回给system_call例程。从内核栈中恢复各寄存器，并将系统调用的返回值置于栈中，返回值外壳函数，切换回用户态。若系统调用的返回值表明有误，则外壳函数回根据该值来设置全局变量errno。然后外壳函数会返回到调用程序，并同时返回一个整型值，以表明系统调用是否成功。一般用户只用关心外壳函数的动作即可。

66. 在 Linux/x86-32 上，execve()的系统调用号为11(__NR_execve)，因此在sys_call_table向量中，条目11包含了该系统调用的服务例程sys_execve()的地址。

67. 在Linux中，系统调用服务例程的命名通常会采取sys_xyz()的形式，其中xyz()正是所论及的系统调用。

68. 系统调用由于存在上述一系列复杂的过程，因此时间开销比一般的C函数要多，例如一个只返回整数的函数开销约为调用getppid()的1/20。当然，大多数系统调用的开销都明显高于getppid()。

69. 可以直接在shell中运行glibc的动态库来获取其版本，不过要先确定该库文件的位置：

    ```shell
    zj@zj-hit:~/test/C$ ldd /usr/bin/ls | grep libc #获得该程序依赖的glibc位置
    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x000073982e000000)
    #执行该库文件。
    zj@zj-hit:~/test/C$ /lib/x86_64-linux-gnu/libc.so.6
    GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.7) stable release version 2.35.
    Copyright (C) 2022 Free Software Foundation, Inc.
    This is free software; see the source for copying conditions.
    There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
    PARTICULAR PURPOSE.
    Compiled by GNU CC version 11.4.0.
    libc ABIs: UNIQUE IFUNC ABSOLUTE
    For bug reporting instructions, please see:
    <https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs>.
    ```

70. 在程序中也可以使用库函数和常量来确定glibc的版本：

    1. 编译时测试：从glibc2.0开始，glibc就定义了2个常量，__GLIBC__和__GLIBC_MINOR__，供条件编译使用。例如在glibc 2.12中，二者分别为2和12。

    2. 运行时测试：

       ```c
       #include <gnu/libc-version.h>
       const char *gnu_get_libc_version(void); //返回一个"2.12"的字符串
       const char *gnu_get_libc_release(void); //返回类似"stable"的字符串
       //glibc特有
       #include <unistd.h>
       size_t confstr(int name, char *buf, size_t len); //name可以取以下值：
       // _CS_GNU_LIBC_VERSION，GLIBC版本，例如"glibc 2.12"
       // _CS_GNU_LIBPTHREAD_VERSION，POSIX线程实现，"NPTL 2.3.4"
       //_CS_PATH，POSIX.2工具的路径，"/bin:/usr/bin"
       ```

71. 少数几个系统函数在调用时从不失败。例如，getpid()总能成功返回进程的ID，而_exit()总能终止进程。无需对此类系统调用的返回值进行检查。

72. 程序应包含<errno.h>头文件，该文件提供了对errno的声明，以及一组针对各种错误编号而定义的常量。

73. 当库函数和系统调用成功时，不会修改errno，因此errno非0，也有可能是之前调用修改的。因此在检查函数调用成功与否时，应该先检查返回值，只有出错时才检查errno。

74. 少数系统调用在成功时，也会返回-1（例如getpriority），因此这种函数需要在调用前将errno设置为0，然后再调用，结束后检查errno来判断是否成功。

75. 在线程程序中，errno 实际已被定义为宏，展开后是返回可修改左值的一个函数调用。因此，每次使用errno 都会引发一次函数调用，这一方法效率不高。

76. POSIX 线程API 中，将errno 重新定义为一个函数，该函数会返回一个指向线程专用存储区域的指针。

77. errno的值随Linux硬件架构的不同而有所变化。

78. 编写可移植性应用程序时，有时会希望各个头文件只显露遵循特定标准的定义（常量、函数原型等）。此时需要定义特性测试宏。可以在程序源码包含任何头文件之前定义，也可以使用编译器-D选项来定义。

    ```c
    #define _BSD_SOURCE 1
    gcc -D_BSD_SOURCE main.c
    ```

79. 以下特性测试宏由相关标准定义而成，因而在支持这些标准的所有系统上，对这些宏的使用均是可移植的：

    1. `_POSIX_SOURCE`，一旦定义（任何值），头文件会显露符合POSIX.1-1990和ISO C（1990）标准的定义。该宏已被_POSIX_C_SOURCE取代。
    2. `_POSIX_C_SOURCE`，若定义为1，效果与_POSIX_SOURCE相同，若将其值定义为≥199309，头文件还会显露遵从POSIX.1b（实时）标准的定义；若将其值定义为≥199506，便会开启对POSIX.1c（线程）定义的支持。若将其值定义为200112，则开启对POSIX.1-2001 基本规范（排除了XSI 扩展）定义的支持。若将其值定义为200809，便会开启对POSIX.1-2008 基本规范定义的支持。
    3. 在不带任何特殊选项调用GNU C编译器时，即默认定义了`_POSIX_SOURCE`、`_POSIX_
       C_SOURCE=200809`（glibc 版本为2.5-2.9 时，其值为200112；glibc 版本低于2.4 时，其值为
       199506）、`_BSD_SOURCE`以及`_SVID_SOURCE`。

80. <features.h>头文件和feature_test_macros(7)手册页，针对赋给每个特性测试宏的值，提供了更多精确信息。

81. 标准系统数据类型中的大多数，其命名均以_t 结尾。其中的许多都声明于头文件<sys/types.h>中，余下的少量则定义于其他头文件中。

82. C99标准为printf定义了名为z的长度修饰符，以表明紧随其后的整型转换是与size_t或ssize_t类型相对应的，glibc支持，并非所有Linux都支持，因此不推荐使用。

83. 假定使用了非优化的编译器，且在应用程序二进制接口中，是通过栈来传递所有参数的。实际上，优化编译器会将频繁使用的变量分配于寄存器中，或者索性将变量彻底剔除。

84. 应用程序二进制接口（ABI）是一套规则，规定了二进制可执行文件在运行时应如何与某些服务（诸如内核或函数库所提供的服务）交换信息。ABI 特别规定了使用哪些寄存器。和栈地址来交换信息以及所交换值的含义，一旦针对某个特定ABI 进行了编译，其二进制可执行文件应能在ABI 相同的任何系统上运行。与之相反，标准化的API（如SUSv3）仅能通过编译源代码来保证应用程序的可移植性。

85. 大多数UNIX 实现（包括Linux）中C 语言编程环境提供了3个全局符号：etext、edata 和end，可在程序内使用这些符号以获取相应代码段、初始化数据段和非初始化数据段结尾处下一字节的地址。使用这些符号，必须显式声明如下：

    ```c
    extern char etext, edata, end; //例如&edata就是初始化数据段结尾处的下一个字节地址。
    //这三个段一般存在在低地址区域，地址从小到大依次是文本，初始化数据，未初始化数据，然后是堆。
    ```

86. 一般说的各种段和内存布局都是指的虚拟内存。

87. 虚拟内存技术利用了程序的局部性，来提高CPU和内存利用率。局部性分为2种：

    1. 空间局部性：是指程序倾向于访问在最近访问过的内存地址附近的内存（由于指令是顺序执行的，且有时会按顺序处理数据结构）。

    2. 时间局部性：是指程序倾向于在不久的将来再次访问最近刚访问过的内存地址（由于循环）。

88. 因此即便程序仅有部分地址空间存在于RAM中，依然可能得以执行。

89. 虚拟内存的规划之一是将程序要使用的内存切割成固定大小的页。相应地，将物理内存划分成尺寸相同的页。任一时刻，每个程序仅有部分页需要驻留在物理内存页中。这些页构成了驻留集（resident set）。

90. 程序未使用的页拷贝保存在磁盘交换区（swap area）内，作为物理内存的补充，仅在需要时才会载入物理内存。

91. 虚拟内存的实现需要硬件中分页内存管理单元（PMMU）的支持。它把要访问的每个虚拟内存地址转换成相应的物理内存地址，当特定虚拟内存地址所对应的页没有驻留于物理内存中时，将以页面错误通知内核。

92. 为支持虚拟内存使用，内核需要为每个进程维护一张页表，它描述了进程虚拟地址空间中的每页和物理内存页或磁盘的对应关系。

93. 通常情况下，会存在大段的虚拟地址空间没有被使用，故而也没必要为其维护相应的页表条目。若进程试图访问的地址并无页表条目与之对应，那么进程将收到一个段错误SIGSEGV信号。

94. 内核能够为进程分配和释放页和页表条目。

95. 在x86-32中，虚拟内存页面大小为4096个字节，程序可调用`sysconf(_SC_PAGESIZE)`来获取。

96. sysconf函数可以在运行时获取系统的信息，通过一系列枚举量来指定，可以通过man sysconf查询：

    ```c
    #include <unistd.h>
    long sysconf(int name);
    //获得一个内存页面的大小。
    printf("Size of a page in bytes:%ld\n",sysconf(_SC_PAGESIZE));
    ```

97. 多个进程共享内存页面时，允许每个进程对该页面采取不同的保护措施。例如，一个进程可能以只读方式访问某页面，而另一进程则以读写方式访问同一页面。

98. 

99. 

# man page

1. 

2. POSIX的一些不常用的函数不在标准man中，需要安装以下附属包：

   ```shell
   sudo apt install manpages-posix* #例如pthread_mutex_init函数
   ```

3. 对于像Ubuntu这样的系统来说，应用程序的手册页常常以后缀 `-doc` 的独立包方式存在特定软件的手册，需要单独安装：

   ```shell
   sudo apt install git-doc #git软件的文档
   ```

4. 还可以安装特定语言的版本：

   ```shell
   sudo apt install manpages-zh
   ```

5. 


# UNIX标准及实现

1. 在C语言诞生到标准出现的时间里，1978年K&R的C语言书籍充当实时上的标准，但是该书中并未就C语言的所有细节说明。后来第二版的K&R中对C89标准有详细的描述。
2. 1989年，ANSI开发的C标准X3.159-1989被采纳为国际标准ISO/IEC9899-1990。ANSI（美国国家标准协会）是在ISO中代表美国的组织，IEC是国际电子技术委员会。
3. ISO C的目标是提高C语言程序的移植性，使其能够使用于大量操作系统，不仅是UNIX。该标准定义了语法和语义，还定义了标准库。大部分的操作系统都提供了C标准中的库函数。
4. 1999年，ISO C更新为ISO/IEC9899-1999，增加了long long数据类型，C++风格注释(//)，受限指针和可变长数组等。自1999年以来，已经公布了3个技术勘误，分别在2001,2004,2007年。后续的标准有ISO/IEC9899-2011和2018。
5. gcc认为ansi c就是c89，这可以通过其命令行参数来体现。
6. 不同的编译器支持的C标准不同。
7. POSIX.1-2001和SUSv3可以认为是一套标准的两种称呼，目前由同一份文档描述。后继者为POSIX.1-2008和SUSv4。
8. 对UNIX的定义通常有2种：
   1. 通过SUS的官方一致性测试，且由OPEN GROUP（UNIX商标的持有者）正式授权冠以UNIX的操作系统，目前没有一个开源实现，主要原因是时间和费用，厂商的每个发行版都需要接收规范度检查。
   2. 运作方式类似于经典UNIX系统（例如最初的Bell实验室的UNIX系统，及其后来的主要分支System V和BSD）的操作系统。Linux和现代BSD是这一种。

9. POSIX是IEEE开发的，目标是提升应用程序在源码级别的可移植性，其名称来自于Stallman。
10. POSIX.1于1989 年成为IEEE标准，并在稍作修订后于1990年被正式采纳为ISO标准（ISO/IEC 9945-1:1990）。
11. POSIX.1b定义了文件同步，异步I/O，进程调度，高精度时钟和定时器。还定义了采用信号量，共享内存以及消息队列的进程间通信。古老的System V中也有对应的进程间通信API。
12. POSIX.1c定义了POSIX线程；POSIX.1g定义了套接字网络API。
13. POSIX.2是第二个标准，对shell和C编译器命令行接口在内的UNIX工具进行了标准化。

# I/O

1. 系统调用I/O（sysio）是和系统实现相关的，尽量使用标准I/O（stdio），标准I/O也是基于系统调用I/O的。标准的出现是为了兼容不同的系统的，一般来说标准只提供与一个函数的定义，规定了输入和输出应该是什么，具体的实现，在不同的操作系统上都是不一样的。
2. 标准I/O移植性好，标准I/O也是合并了系统调用，提供buffer和cache，为读写提供加速。
3. 例如C标准中，打开文件的函数fopen，在linux下依赖于open函数，在Windows下依赖于openfile函数。
4. I/O非常重要，设备，管道，套接字的读写都要依赖它。而且I/O非常有可能出错。一切皆文件，因此文件的读写非常重要。

## 标准I/O

1. 标准I/O中的函数

   1. 文件打开关闭：fopen()，fclose()。
   2. 字符读写：fgetc()，fputc()。
   3. 字符串读写：fgets()，fputs()。
   4. 二进制数据块的操作：fread()，fwrite()。
   5. 输入输出：printf()，scanf()。
   6. 文件位置指针操作：fseek()，ftell()，rewind()。
   7. buffer和cache的操作：fflush()。

2. 标准I/O中设计到一个核心的结构体，FILE。

3. man手册的第三章是标准库函数，也就是C标准的实现。第二章是系统调用。第一章是系统命令，第七章是机制讲解，例如socket，TCP。如果有重名的话，可以加上章号，例如：man 3 fopen。如果发现找不到对应的条目，可以更新man手册，yum install man-pages

4. 一个进程的空间中能打开的文件数量是有上限的（ulimit -a 可以查看或修改）。在不更改默认环境的情况下，进程创建时，默认打开3个流，标准输入stdin（指向键盘），标准输出stdout（指向屏幕），标准错误stderr（指向屏幕）。因此若ulimit -a中显示为1024，则只能再打开1021个文件。在当前shell中如果修改ulimit后，其子进程会继承这个上限，因此也会生效。如果新开一个shell，则是默认的ulimit。

   ```c
   #include <stdio.h>
   extern FILE *stdin;
   extern FILE *stdout;
   extern FILE *stderr;
   ```

5. 使用fopen创建文件时，文件的权限都是用户的默认权限（0666 & ~umask），不同的用户执行该程序，创建出来的文件权限不同。0666的0表示八进制数，因此这是三个八进制数，如果umask为0002时，取反为0775，再和0666按位与上，结果为066。相当于在rw-rw-rw-的基础上减去umask对应的权限，例如0002表示-------w-，所以结果为rw-rw-r--。文件的所有者和所属组默认是执行该程序的用户和它的默认组。

### fopen

1. fopen，fdopen，freopen都是流打开函数：

   ```c
   #include <stdio.h>
   FILE *fopen(const char *path, const char *mode);   //指定文件路径(相对和绝对都行)和打开权限。返回代表该文件的结构体的指针。如果失败，则返回NULL（空指针），并设置errno。
   FILE *fdopen(int fd, const char *mode); //将一个系统I/O的文件描述符封装为一个标准I/O的流。例如打开套接字会返回一个描述符，如果想要用标准I/O操作，就可以用这个函数。
   FILE *freopen(const char *pathname, const char *mode, FILE *stream);
   ```

2. 参数里的const声明是让用户放心，该函数内部不会对指针指向的内容进行修改。如果自定义的函数中的参数要接受的是字符串，但是形参不是const的，此时编译器会报warning。

3. 推荐应用尽用const还有一个原因，就是有时某些编译器会不将字符串字面常量放到常量区域。

   ```c
   char * ptr = "abc";
   ptr[0] = 'x';  //是有可能得到 "xbc"的
   ```

### errno

1. 大部分函数在出错时，会返回-1或者NULL，并且设置errno，记录出错的相关信息。在多线程环境中，每个线程都有自己的局部errno。

2. errno可以理解为全局变量（早期是一个整型变量，导致它容易被更新的错误覆盖，现在变成了一个宏定义），这样做的原因是为了方便调试，因为返回值的NULL并不能告诉调用者错误原因。errno会被其他的报错程序不断地刷新，因此出错后应该立即打印。errno会被替换为，这样就变成了一个线程私有化的了：

   ```c
   (*__errno_location ())   //一个函数调用的返回值，然后再解引用，
   ```

3. errno中关于错误的定义写在了/usr/include/asm-generic/errno-base.h和errno.h（后者include了前者）中，以宏定义的方式。当然打印出errno再去查找对应的头文件中的注释是比较麻烦的事情，可以用如下两个函数来简化：

   ```c
   void perror(const char *s);  //该函数会接受一个参数，并将该参数放在前面，后面加上当前的errno对应的信息一起打印，然后换行。该函数会自动关联全局变量errno
   char *strerror(int errnum);  //接受一个errnum，返回对应errnum的信息字符串。
   //这两个函数都是对语言环境敏感的函数，因此错误描述中都是本地语言。
   ```

4. ![image-20230430195623986](Linux系统编程.assets/image-20230430195623986.png)

5. 在遇到错误时，可以将errno和这些常量比较，来区别地处理错误。但这比较麻烦，因此C标准中定义了2个函数用来打印出错信息：

   ```c
   #include <string.h>
   char *strerror(int errnum); //errnum为errno，返回出错的信息字符串。
   #include <stdio.h>
   void perror(const char *msg);  //先在标准错误上输出msg指向的字符串，然后是冒号和空格，最后是errno对应的出错信息，最后是一个换行符。这个函数不用手动指定errno，他会自动关联errno。
   ```

6. 一般来说出错信息中，应该包含程序名，这样当程序作为管道的一部分执行时，可以区分出来错误是来自于那个程序。

### 文件打开 mode

1. 文件的打开权限mode是以如下6种字符中的一种开头的，且只从开头开始比对（即r123等价于r，r+456等价于r+）：
   1. r，只读方式，位置指针定位在文件的开始处。
   2. r+，读写方式，其余同上。
   3. w，有则清空，无则创建，以只写形式打开，位置指针定位在文件的开始处。
   4. w+，读写方式，其余同上。
   5. a，追加只写，如果文件不存在，则创建，位置指针定位在文件的末尾的下一个位置。
   6. a+，追加读写，如果文件不存在，则创建，如果第一个操作是读，则位置指针在文件的开头，如果第一个操作是写，则位置指针在末尾的下一个位置。
2. 文件的读写都是发生在位置指针所指的那个字符。这个位置指针是悬在字符的正上方的，读的话就是读取该字符，写的话，会覆盖该字符。因此以追加模式打开的话，位置指针指向文件最后一个字符的下一个位置。位置指针是从0开始计数的，存储在一个long整型中。例如文件有5个字节，以非追加模式打开，位置指针为0，否则为5。
3. r+模式比较特殊，如果一打开就获取位置指针的话，结果也是0，此时读从头开始，但是此时写入会却追加到末尾。因此r+模式，一开始读写是分离的，容易弄乱，所以建议以r+打开，然后手动来seek位置指针进行读写。r+模式在经历过一次写后或fseek之后，会将位置指针移动到对应的位置。但是即使seek到其他位置，无论何时再写入，仍然会写入到最后，也就是说写入的时候不会看当前位置指针，而是始终在末尾写入。
4. 可以发现6个权限中，除了r和r+以外，其余的权限在文件不存在是都会创建文件，而r和r+则会返回NULL。
5. fopen和open中文件打开权限的对应。可见，r+并不等于w+，因为w+可以在打开不存在的文件时会创建，r+会返回NULL，同时w+在打开存在的文件时会截断到0，r+不会。所以一般读写已存在的文件，应使用r+。
6. <img src="Linux系统编程.assets/image-20230430201356662.png" alt="image-20230430201356662" style="zoom:80%;" />
7. 打开文件的权限，够用就好，不要过多地申请，防止意外出错。慎用w和w+，可能会不慎截断已有的文件。
8. 在Windows下编程时，文件有两种类型：二进制流，文本流。而在POSIX系统中"b"选项会被忽略掉（即权限中可以加上b，也可以不加，这是兼容C89的作法），因为POSIX下只有一个流（stream）的概念。按照字符来读取就是字符流，按照字节来读取就是二进制流。
9. fopen内部用到了malloc，而fclose内部是free，二者是成对出现的。因此返回的FILE结构体本身存在于标准库所管理的堆中。
10. 一般来说，如果函数返回的是指针，同时又有逆操作，那么该指针指向内容是放在堆上的。也有些函数返回指针，但是指针所指的内容放在静态区。

### fclose

1. fclose关闭一个流：

   ```c
   int fclose(FILE *fp);  //成功返回0，失败返回宏值EOF。
   ```

2. 一般不回去校验fclose的返回值，因为很少失败。

### 字符读写函数

1. 字符读入函数：

   ```c
   #include <stdio.h>
   int fgetc(FILE *stream);  //读取到一个unsigned char，但是方便用户使用，同时也为了包含出错输出中的-1，替换为int类型。如果失败或读到文件末尾，则返回EOF。
   int getc(FILE *stream);  //等价于fgetc，最早被定义为宏来使用。返回值同上。
   int getchar(void);   //从标准输入读入，等价于getc(stdin)，返回值同上。
   ```

2. 字符输出函数：

   ```c
   int fputc(int c, FILE *stream);  //将指定的字符输出到指定的流上，可以是标准输出，标准错误，或打开的文件。
   int putc(int c, FILE *stream);  //同上面的fputc。
   int putchar(int c);  //输出到标准输出，等价于putc(c,stdout);
   ```

3. 推荐使用fgetc和fputc函数。

4. 虽然读到文件的末尾和发生错误都会返回EOF，但是此时errno是不一样的，前者的errno为0，表示没有错误。

### 字符串读写函数

1. 字符串读入函数（行缓冲模式）：

   ```c
   char *fgets(char *s, int size, FILE *stream);   //从流stream中读取size长度的字符串，放到s指向的空间，返回的指针就是参数s。
   char *gets(char *s);   //从标准输入读入一行数据到buffer，末尾的换行会被替换为"\0"。尽量不要使用该函数，因为它不检查缓冲区的溢出，尽量使用fgets来替代。
   ```

2. 上面的缓冲区溢出指的是用于接收字符串的s所指向的空间，可能会剩余的空间不够，进而覆盖掉别的有用的信息。

3. fgets正常结束有两种情况：

   1. 读取到size-1个字符，还没遇到EOF（文件结尾）或\n（行尾），此时停止读取，在缓冲区的末尾添加上一个'\0'，并写入到指针s对应的空间去。文件的位置指针向后移动size-1个字符。

      ```c
      //加入文件的内容如下，且size = 5：
      abcdef
      //写入的字符串如下，此时位置指针指向e：
      abcd'\0'
      ```
      
   2. 还没读到size-1个字符，就遇到文件末尾或者中间行尾了，位置指针会指向到下一行的开头。

      ```c
      //流的内容如下，且size = 5，这一行有3个字符：
      ab
      //写入的字符串如下，如果这是最后一行，也是'\n'。
      ab'\n''\0'
      ```

4. 文件的最后一行和中间行的区别在于，中间行包含一个换行符，而最后一行不包含。

   ```c
   //用vscode生成如下文件，一共3行，每行的字符个数为4，5，2个，一共有11个字符。
   abc
   absd
   as
   ```

5. 人工编辑的文件末尾有没有换行，取决于编辑器，vim会给末尾也添加一个换行符，这样每一行都是一样的。而vscode则不会自动给末尾添加换行符，因此尾行和其他行不一样。在Windows下，行尾的换行是以两个字符来代替的，CR和LF，分别表示回车（\r 光标回到本行开头），换行（\n光标下移一行）的意思。ASCII码分别为0xD 0xA，（如下图所示）。UNIX/Linux仅使用LF(\n)作为行尾的换行。

6. ![image-20230501003508267](Linux系统编程.assets/image-20230501003508267.png)

7. 特殊情况如下，需要两次才能读完如下一个4个字符文件：

   ```c
   //流的内容如下,且size = 5：
   abcd
   //第一次读取abcd 4个字符，写入的字符串如下：
   abcd'\0'
   //第二次读取一个\n就停止了，会写入如下：
   '\n' '\0'
   ```

8. 字符串输出函数：

   ```c
   int fputs(const char *s, FILE *stream);  //从s所指的位置开始输出字符串到流stream，直到遇到'\0'，'\0'本身是不会被输出的。
   int puts(const char *s);  //和fputs(s,stdout)不完全一样，因为该函数还会输出一个换行符。
   ```

### EOF

1. 最后一行的结尾什么也没有，他和中间行的末尾不同，没有\n。
2. 其实EOF和\n不同，它不是一个字符，而是定义在stdio.h中的一个常量，值为-1。
3. 在文件的结尾处并不存在一个EOF的字符。而是当系统读取到文件的末尾时，会返回一个信号值，为EOF。至于是否到了文件末尾，可以通过文件大小和位置指针的位置来判断。
4. 普通字符的ASCII范围为32-127，EOF定义为了-1，不会发生混淆。
5. 由于读取文件内容出错时，也会返回EOF，那么此时就需要一个函数来判断是出错了，还是真的到达了文件的末尾。
6. int feof (FILE *stream)是C语言标准库函数，定义在stdio.h中，其功能是检测流上的文件结束符，如果文件结束，则返回非0值，否则返回0。
7. EOF实际上是表示流的末尾，包含了文件的末尾，因此在标准输入中也可以有。从标准输入读取内容时，由于无法事先知道流长度，因此必须手动输入一个EOF。
8. Linux中，在新的一行的开头，按下Ctrl+D，就代表EOF（如果在一行的中间按下Ctrl+D，则表示输出"标准输入"的缓存区，所以这时必须按两次Ctrl+D）；Windows中，Ctrl+Z表示EOF。（顺便提一句，Linux中按下Ctrl+Z，表示将该进程中断，在后台挂起，用fg命令可以重新切回到前台；按下Ctrl+C表示终止该进程。）
9. 字符读取和字符串读取系列函数，遇到出错或读到文件末尾时的输出是不同的，前者返回EOF，后者返回NULL。因为这两个函数的返回值不同，字符读取的返回值是读取到的字符，而字符串读取的返回值是一个指针。因此EOF表示无效的字符，而NULL表示无效的指针。
10. 在每次读取之前会进行判断，当前的位置指针是否指向文件的结尾处，如果是的话，就不进行读取，直接返回对应的报错值，EOF或NULL。

### 二进制读写函数

1. 二进制读写函数，按照字节来读写：

   ```c
   size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); //从stream中读取nmemb个对象，每个对象size个字节，写入到ptr指向的空间。ptr指向的空间应该至少有size*nmemb剩余的空间。
   size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);  //将ptr指向的空间中，size*nmemb个字节的数据写入到流stream中。   ptr的const表示该函数不会修改ptr所指向的空间。
   ```

2. 以上两个函数的返回值表示成功读写的对象的个数，而不是字节数。每个对象为size个字节。如果剩余的内容不够一个对象的大小，则不会进行读写，返回0。

3. size_t是sizeof操作符的返回值类型，在32位环境下表示unsigned int，在64位环境下表示unsigned __int64。后缀t表示type。

4. 这个函数用在数据持久化（序列化和反序列化）上比较好，适合操作成块的数据。例如需要将10个结构体存储到文件中，就可以将size设置为1个结构体的大小，nmemb设置为10。不过需要这些结构体空间连续保存（例如为结构体数组），因为以上的读写都要求连续空间。

5. 进行成块的数据读写时，位置指针不能有一点偏差。

6. 使用二进制读写函数对文件进行读写时，不会考虑'\n'等因素，也不会再末尾加入'\0'，文件不是按照行来组织的，而是可以看成一个特别长的字符数组。

7. 如果文件的内容还剩很多，如下两个函数都能顺利读到10个字节，但是返回值分别为10和1。如果文件只剩5个字节了，那么第一个函数可以读到5个字节，返回值为5。第二个函数什么都读不到，返回值为0。

   ```c
   fread(buf, 1, 10, fp); //每个对象1个字节
   fread(buf, 10, 1, fp); //每个对象10个字节
   ```

8. 因此如果用这两个函数来做字符串的输入输出，一般都将第二个参数设为1。

9. 对于使用fread和fwrite进行文件复制（每个对象为1B）时，仅当fread的返回值>0时，才需要fwrite使用fread的返回值作为其写入的参数。因为最后一次的fread不一定恰好读够想要的对象个数。

### 格式化输入输出

1. 格式化输出：

   ```c
   //可变参数版本
   int printf(const char *format, ...);  //将待输出项以format的格式输出到标准输出中。
   int fprintf(FILE *stream, const char *format, ...);  //将待输出项以format的格式输出到流stream中。
   int sprintf(char *str, const char *format, ...);  //将待输出项以format的格式输出到指针str指向的空间。该函数可能会发生缓冲区溢出，应该使用下面的snprintf。最后会默认加上'\0'
   int snprintf(char *str, size_t size, const char *format, ...);  //将待输出项以format的格式输出到指针str指向的空间，最多输出size-1个字符。最后会默认加上'\0'
   
   //固定参数版本
   #include <stdarg.h>
   int vprintf(const char *format, va_list ap);//对应于printf
   int vfprintf(FILE *stream, const char *format, va_list ap); //对应于fprintf
   int vdprintf(int fd, const char *format, va_list ap);//类似于fprintf，不过输出到文件描述符。
   int vsprintf(char *str, const char *format, va_list ap);//对应于sprintf
   int vsnprintf(char *str, size_t size, const char *format, va_list ap);//对应于snprintf
   ```

2. 好的程序应该多使用fprintf，而不是printf，因为正常的输出和错误的输出应该分别输出到stdout和stderr，虽然默认情况下这俩都输出到屏幕，但是可以通过重定向来分离他们。无人值守的程序，推荐使用输出重定向到文件，这样方便之后查看运行过程。

3. 实际上snprintf()只是解决了sprintf可能会遇到的缓冲区溢出的问题，但是如果要写入的字符个数就是比size-1大，snprintf也只能丢弃多余的数据。只能通过动态内存分配来自适应输出的长度。

4. 字符串->数字如下，并没有itoa这样的函数，因为可以用sprintf来进行数字->字符串的操作：

   ```c
   #include <stdlib.h>
   int atoi(const char *nptr);   //将nptr所指向的字符串转化为整数，例如"123"->123，"12a3"->12
   long atol(const char *nptr);  //转化为long类型
   long long atoll(const char *nptr); //转化为long long类型
   double atof(const char *nptr);  //转化为double类型
   ```

5. 格式化读取：

   ```c
   int scanf(const char *format, ...);  //从标准输入中以format的格式读取数据，放到后续的参数中。
   int fscanf(FILE *stream, const char *format, ...);  //从流stream中以format的格式读取数据，放到后续的参数中。
   int sscanf(char *str, const char *format, ...);  //从指针str指向的空间中以format的格式读取数据，放到后续的参数中。
   ```

6. scanf在使用上最大的缺陷是由于终端输入的不确定性，有可能造成接受数据的缓冲区溢出。尤其是存在%s参数时。因为字符串参数的可用空间对于输入者来说是未知的。

### fseek

1. 文件位置指针操作函数：

   ```c
   int fseek(FILE *stream, long offset, int whence);  //将流stream的位置指针移动到，从whence偏移offset个字节的位置。whence有三种情况，SEEK_SET SEEK_CUR SEEK_END分别表示文件首，当前位置，文件尾。操作成功返回0，失败返回-1，并设置errno。
   long ftell(FILE *stream);  //返回流stream的位置指针的位置。先fseek到末尾，然后ftell可以获取文件的大小。
   void rewind(FILE *stream);  //把位置指针移动到文件首。相当于(void) fseek(stream, 0L, SEEK_SET);使用0L是严格用法，有些编译器会校验这个操作。
   ```

2. 上面说的SEEK_END，这里的文件尾指的是最后一个字节的下一个位置。这是和append操作相协调的，即读写都是操作的当前的位置。

3. 文件的位置指针默认是指向第0个字符的，读取一个字符完成后会移动该指针到下一个位置。写入一个字符完成后会移动该指针到下一个位置。以上指针的移动都是自动完成的。

4. long类型在C标准中没有规定字节数，但是说至少和int一样长。一般的编译器把他当做4字节的和int一样。

5. long默认为有符号的，范围是$[-2^{31}\to 2^{31}-1]$，在fseek中可以发现offset的取值范围为-2G~2G-1。因此文件最大可以有4G的范围。但是又因为ftell的返回值也是long，这里的文件位置指针又不能取负数。因此文件的位置指针只能是从0到2G-1的范围。

6. 因此后续给出了更为完善的关于文件位置指针的函数，不过这两个函数只有POSIX标准支持，C89,C99等都不支持，这意味着不能移植到Windows平台上：

   ```c
   int fseeko(FILE *stream, off_t offset, int whence);   //off_t是一个宏定义，默认情况下它和long都是32位的，如果编译时加入#define _FILE_OFFSET_BITS 64        则表示off_t为64位的。如果没有定义该宏，在某些平台上off_t的行为是未定义的。
   //gcc编译时加入 -D_FILE_OFFSET_BITS=64 即可。makefile写法：CFLAGS += -D_FILE_OFFSET_BITS=64
   off_t ftello(FILE *stream);
   ```

7. fseek可以用来创建空洞文件。只要seek到文件末尾以后的地方即可。这样文件的大小就会变化，增加的空间用'\0'填充。有的下载工具会在一开始创建一个空洞文件，然后多线程下载，从不同的地址写入，从而实现真正的多线程下载。

### fflush

1. 刷新缓存：

   ```c
   int fflush(FILE *stream);   //刷新流stream的缓冲区，如果stream为NULL，将会刷新所有打开的流。
   ```

2. 标准输出这样的流都是行缓冲模式的，直到遇到'\n'，才会将缓冲区的内容输出。

3. 如下情况，不会看到"Before while()"的输出，因为该缓冲区没有被刷新，因此要么加入'\n'，要么手动刷新fflush(stdout)。

   ```c
   printf("Before while()");
   while(1);
   printf("After while()");
   ```

4. 缓冲区的作用是合并系统调用，缓冲模式有：

   1. 行缓冲：遇到'\n'或缓冲区满的时候会自动刷新。也可以用fflush手动刷新。终端设备默认是行缓冲。
   2. 全缓冲：缓冲区满的时候才会刷新。fflush可以手动刷新。文件默认是全缓冲，应该及时地flush。'\n'只是换行的作用。
   3. 无缓冲：不进行缓冲，例如stderr，不能等待，需要立即输出。

5. 只要输出不是终端设备，默认都是全缓冲的。不过也可以修改流的缓冲模式，但是一般不会修改：

   ```c
   int setvbuf(FILE *stream, char *buf, int mode, size_t size);  //设置流stream的缓冲模式为mode，mode取值须为_IONBF(No Buffer)，_IOLBF(Line Buffer)，_IOFBF(Full Buffer)之一。
   ```

### 行输入和输出

1. 之前的所有函数都无法保证不丢失地读入一行的内容，因为不知道一行究竟有多长，因此需要使用动态内存分配。getline的内部就是封装了动态内存分配。malloc+realloc的结合。

2. 行读入和输出，getline函数时GNU C扩展支持的，不是C标准规定的，libc 4.6之后才支持：

   ```c
   #define _GNU_SOURCE    //可以在makefile 的CFLAGS中附加上。  CFLAGS += -D_GNU_SOURCE 不过在Ubuntu22.04中不定义这个宏，也可以使用。
   ssize_t getline(char **lineptr, size_t *n, FILE *stream);   //从流stream中读取一行，存放到一个地方，一级指针*lineptr指向该地方的首地址。*n是为了存储该行而在堆上开辟的内存空间大小。函数返回值表示读取到的字符数量，包含'\n'，但是不包含'\0'。失败时返回-1。
   //意思就是用户提供一个二级指针和一个一级指针。读完之后，该行的内容存储在\*linptr的地方，长度为\*n。
   ```

3. getline会逐个字符读取，直到遇到'\n'字符。才会停止，如果遇到'\0'也不会停止，但是此时*lineptr就得配合返回值来使用了，因为该行的中间有一个'\0'。如果读到行尾时，行尾没有'\n'，也不会自动加上的。

4. 如果在调用getline前，\*linebuf为NULL，且\*n为0，则getline会自己申请一块内存。否则会getline会优先使用提供的这块大小为\*n的内存\*linebuf，如果不够的话，会realloc，并更新这两个参数。因此，推荐在首次调用前，一定初始化两个参数。

5. 例子：

   ```c
   FILE *fp;
   char *linebuf = NULL;
   size_t linesize = 0;   //必须要在使用前赋值，否则容易产生bug。
   
   getline(&linebuf, &linesize, fp);  //这里之所以使用指针传参，是因为需要在getline函数内修改定义在它外面的linesize的值，如果传入的参数是linesize，那么修改的就只是getline函数内的形参，最终在函数外定义的linesize是无法被修改的。
   printf("该行的长度为：%zu。该行的内容为：%s", linesize, linebuf);
   ```

6. getline 会从流中开始读取，直到读到一个\n为止，会将读到的内容都放到一个malloc出来的区域中，并将用户传入的一级指针的地址修改为malloc的头地址，将读入的字节数赋值给第二个参数指针指向的空间。在这期间，如果分配的空间不够，则会realloc。

7. 第一次malloc的大小默认为120字节。读完一行后，会继续从头使用当前malloc的内存读取下一行，只有空间不够容纳新的一行时，才会realloc。可以看到，该函数没有对malloc的内存进行free，会产生一个可控的内存泄露。因为它不像守护进程一样，会长期运行而不终止，因此不会不断地产生泄露。I/O函数的泄露非常有限。实际上也不建议开发者自己free，因为该函数内部申请内存的函数可能不是malloc。

8. 例子：

   ```c
   //使用getline读取如下两行内容：
   abc
   aaa'\0'bb
   //第一次读取返回值为4，linebuffer指向的空间为 'a','b','c','\n','\0'...第二次读取返回值为6，linebuffer指向的空间为'a','a','a','\0','b','b','\0'...
   ```


### 临时文件

1. 临时文件，由于临时文件一般放在/tmp目录下（任何用户都可以访问），多用户环境下，可能冲突。临时文件用完要及时销毁，否则造成冲突的几率也会上升。

2. ```c
   char *tmpnam(char *s);     //返回一个可用的临时文件名称,如果参数s为NULL,字符串存在于标准库管理的堆内存中，可能会被下一次的tmpnam调用而覆盖掉。如果参数s不为NULL,则会将该字符串复制到s指向的字符数组中，此时s的空间应至少有L_tmpnam(定义在stdio.h中的一个宏，等于20)长度。文件名的前缀默认为P_tmpdir(stdio.h中被定义为/tmp/)。例如会创建一个文件名为 /tmp/fileDNhq93
   FILE *tmpfile(void);      //会打开一个独一无二的临时文件，以w+b的模式打开。关闭流或程序终止时会自动删除该文件。
   ```

3. 不太推荐使用tmpnam函数，因为创建一个临时文件需要两步，首先申请一个临时文件名，然后fopen。这期间可能被并发的其他进程打断，如果这个进程碰巧，也要申请一个文件，那么tmpnam可能会把之前分配的临时文件名分配给它，造成冲突。

4. 推荐使用tmpfile，实际上使用临时文件时，并不关心文件名，只是要有一个流可以进行读写就行了。这个文件在使用中是匿名的，ls -a也查看不到。系统统一管理，匿名文件，没有名字因此不会重名，但是会占用一个文件描述符资源，和ulimit的值有关。

## 系统I/O

1. 系统调用I/O也称为文件I/O。文件描述符fd是贯穿系统I/O的类型。
2. 标准I/O是依赖于系统调用I/O来实现的。常见的系统调用I/O函数有：open，close，read，write，lseek。

### 文件描述符

1. 文件描述符是整型数，本质是一个数组下标，数组中该位置存储了一个结构体的指针。该数组的长度为ulimit得到的值。结构体指针数组，每个元素都是结构体指针，该数组属于单个进程的。
2. fopen是依赖于open的，因此FILE结构体内部也有open得到的文件描述符fd。
3. 进程默认打开的三个FILE流stdin stdout stderr和默认的三个文件描述符0，1，2相互对应。

    ```c
    // unistd.h中定义的
    #define	STDIN_FILENO	0
    #define	STDOUT_FILENO	1
    #define	STDERR_FILENO	2
    ```
4. 实际上进程默认打开的文件描述符是从父进程继承来的，如果父进程关闭了2，则子进程打开一个文件会获得2这个文件描述符。
5. 文件描述符优先使用可用的最小的一个，可以插空。例如：0 1 3 4 5，再打开一个就会使用2。
6. 不同的进程打开同一个文件，会产生不同的结构体，存储在不同的数组中，fd之间没关系。在一个进程中打开同一个文件多次，则会创建多个结构体，存储在该数组中，互不影响，fd之间不能重复。每一个fd都有自己的位置指针。
7. close一个文件描述符，就是回收一个fd，然后将结构体指针数组的对应元素置为NULL，但不一定会释放结构体内存，因为有时有两个fd指向同一个结构体，这可以通过复制文件描述符dup的方式得到。只有结构体的引用计数归零，才会释放该结构体。
8. 一共有三级结构，数组↔结构体↔iNode。多个结构体可以同时指向一个iNode，这个一般出现在多次open同一个文件。一个结构体可以被数组中的多个元素同时指向，这个一般出现在复制数组的元素到其他位置。
9. 文件位置指针和文件状态标识存储在文件描述符关联的结构体中，dup的两个文件描述符共享这些状态。

### open

1. open打开一个文件：

   ```c
   #include <sys/types.h>
   #include <sys/stat.h>
   #include <fcntl.h>
   int open(const char *pathname, int flags);  //pathname为文件路径，flags为权限信息，作用和fopen的mode相同。成功时返回文件描述符，失败返回-1。
   int open(const char *pathname, int flags, mode_t mode); //这两个open不是重载，因为C语言中没有重载，而是变参函数实现的。只有flags中存在O_CREAT或O_TMPFILE，才不会忽略指定文件权限位的mode参数。同理如果flags包含O_CREAT或O_TMPFILE，也必须指定mode参数，否则会用栈上的其他内容作为该参数的值。mode会和进程的umask取反再相与，结果才是文件的真正权限位。和fopen不同的是，fopen只能使用默认的mode，这里可以手动指定mode。
   int creat(const char *pathname, mode_t mode); //等价于使用O_CREAT|O_WRONLY|O_TRUNC来调用open
   int openat(int dirfd, const char *pathname, int flags);  //和open类似，如果pathname参数是一个相对路径(不以/开头)，则被认为是相对于dirfd所指的路径而不是进程的当前工作目录。如果pathname参数为相对路径，且dirfd为AT_FDCWD则在进程的当前工作目录打开文件，这和open一样。如果pathname参数是绝对路径，则忽略dirfd，功能和open完全相同。
   int openat(int dirfd, const char *pathname, int flags, mode_t mode);
   ```

2. open函数的flags支持读写，创建，截断，阻塞，信号驱动等等模式。比fopen要复杂和强大的多。多个选项使用按位或 | 来组合，不过必须存在如下三个中的一个 O_RDONLY，O_WRONLY，O_RDWR，且不能用O_RDONLY | O_WRONLY来代替O_RDWR。后续可以跟零个或多个文件创建标识和文件状态标识来组合使用。

   1. 文件的创建标识，影响文件打开操作：

      ```c
      O_CLOEXEC  //
      O_CREAT    //如果文件不存在，则创建一个普通文件，新文件的所有者ID为进程的有效用户ID，新文件的所属组ID为进程的有效组ID(System V语法)或父目录的组ID(BSD语法)。Linux上如果设置了set-group-ID模式位,则使用System V语法，否则使用BSD语法。
      O_DIRECTORY//如果打开的路径不是一个目录，则会报错。一般打开目录可以跟openat结合使用。
      O_EXCL     //
      O_NOCTTY   //
      O_NOFOLLOW //如果路径名的末尾部分是一个符号链接，则打开失败。末尾之前的部分如果包含符号链接还是会被跟踪的，不会失败。
      O_TMP‐FILE //
      O_TRUNC    //如果文件存在，是一个普通文件，且访问模式允许写入(使用了O_RDWR或O_WONLY)时，文件长度会被截断到0，如果文件是一个FIFO或终端设备文件，则忽略这个标识。
      ```

   2. 文件状态标识，影响后续的I/O操作，后续可以通过fcntl获取和修改：

      ```c
      O_APPEND   //
      O_ASYNC    //
      O_DIRECT   //
      O_DSYNC    //
      O_LARGEFILE//如果打开大小不能用off_t表示(但可以用off64_t表示)的文件，需要定义_LARGEFILE64_SOURCE宏才可以使用。不过在32位系统上更推荐使用定义宏_FILE_OFFSET_BITS=64，结合ftello和fseeko使用。
      O_NOATIME  //当read文件时，不更新最近访问时间(存储在inode的st_time)，只有当进程的有效用户ID和文件的所有者ID相同时，才可以设置此标识。
      O_NONBLOCK 和 O_NDELAY //非阻塞
      O_PATH     //
      O_SYNC     //不进行缓冲，调用write时，直接写入数据。write函数返回时，表明输出的数据和响应的元数据修改已经完成。相当于每次write后都调用fsync。
      ```

3. open函数中mode参数的取值：

   ```c
   S_IRUSR S_IWUSR S_IXUSR //分别表示所有者的读写执行权限，也可以用S_IRWXU来代替这三个的或，三个宏的取值分别为00400,00200,00100，综合宏的取值为00700
   S_IRGRP S_IWGRP S_IXGRP //分别表示所属组的读写执行权限，也可以用S_IRWXG来代替这三个的或，三个宏的取值分别为00040,00020,00010，综合宏的取值为00070
   S_IROTH S_IWOTH S_IXOTH //分别表示其他人的读写执行权限，也可以用S_IRWXO来代替这三个的或，三个宏的取值分别为00004,00002,00001，综合宏的取值为00007
   S_ISUID //set-user-ID，取值为0004000
   S_ISGID //set-group-ID，取值为0002000。会影响O_CREAT创建文件时，文件的所属组ID的取值。
   S_ISVTX //sticky bit，取值为0001000。粘滞位。
   ```

4. 从程序设计的角度来理解cache和buffer：cache看作是读的缓冲区，一般称为缓存，实际上是缓取，例如cpu的多级缓存，DNS缓存，CDN等，可以提高重复读取的效率。buffer是写的缓冲区，例如标准I/O会先将每次的写入存到缓冲区内，然后再统一调用一次系统I/O，效率高。

### read write lseek

1. read和write

   ```c
   #include <unistd.h>
   ssize_t read(int fd, void *buf, size_t count); //从fd中读取count个字节，存储到buf指向的地址中。如果成功，返回读取到的字节数，为0表示读到了文件末尾，也视为一次成功的读取。失败(任何内容都没读到)返回-1，并设置errno。
   ssize_t write(int fd, const void *buf, size_t count); //将buf指向的地址中count个字节的内容写入到fd中。如果成功，返回写入的字节数，为0表示。失败(任何内容都没写入)返回-1，并设置errno。
   //可以写入0个字节，例如被信号打断时。应对函数的返回值进行判断，如果>=0时，是否等于count，如果不等于则表明没有完全写完，那就继续从中断的位置写，即第二个参数应为buf+write返回值，同时写入的字节数也应减去之前分次写入的和。一次写入可能会被中断多次，因此需要while(1)，直到分片的write的返回值的和等于初次的count才可以。
   //例如要从buf向fd中写入10个字节，如果第一次写入了3个字节就中断了，则第二次应该从buf+3处开始向fd中写入10-3=7个字节，如果第二次写入5个字节又中断了，则第三次应该从(buf+3)+5处开始向fd中写入7-5=2个字节。中间还可能中断，直到某一次write的返回值等于该次调用的count参数，则表明10个字节已经完全写入。
   ```

2. 一次成功的读写，返回值可能小于count，例如：

   1. 当read被信号中断或剩余的字节不够count时，返回值会 < count。

   2. 当write被信号中断或磁盘空间不够时，返回值会 < count。

3. 一次失败的读写意味着任何内容都没读写到，此时返回值为-1，并设置errno。例如：

   1. 当errno为EINTR时，表示因为被信号打断，才导致任何内容都没被读到或写入。

4. 因此综上，信号可能会在没有读到或写入任何内容时就打断阻塞的read和write。也有可能在读写了一部分后，再打断。通过返回值来标识是哪种情况。

5. lseek，综合fseek和ftell的功能

   ```c
   #include <sys/types.h>
   #include <unistd.h>
   off_t lseek(int fd, off_t offset, int whence); //移动fd的文件位置指针，定位到whence偏移offset的位置。whence的取值和fseek中whence一样。返回值为移动后的文件位置指针的位置，类似于ftell的功能。lseek(fd,0,SEEK_CUR)的结果就是当前位置。
   ```

### 标准I/O和系统I/O的区别

1. 标准I/O具有缓冲机制，吞吐量大，系统调用I/O没有缓冲，实时性高，响应速度快，每次调用都进入内核态。缓冲的作用就是合并系统调用。实际上更推荐使用标准I/O。标准I/O和文件I/O不应混用，容易出错。

2. ```c
   int fileno(FILE *stream);  //返回流对应的文件描述符
   FILE *fdopen(int fd, const char *mode);  //将已经打开的文件描述符的fd封装为一个流，以供使用。要求mode参数和创建fd时的mode参数兼容。文件位置指针也会关联，mode中的w和w+参数不会导致文件被截断，当fclose该流时，fd也会被close。
   ```

3. 标准I/O和系统I/O中结构体的部分成员（例如文件位置指针）的值不一定相同。因为标准I/O有缓冲机制，在标准I/O中写入后，流的位置指针会变动，但是fd对应的位置指针并不跟着变动，因为没有刷新缓冲区。读取也存在这种情况，当标准I/O读取少量内容时，系统I/O可能会按块一口气读取较多的内容，放到缓存中，此时二者的文件位置指针也不相同。如下例子表明了标准I/O的系统I/O互不影响，各自工作。

   ```c
   putchar('a')    //顺序执行这六个函数，输出的结果为bbbaaa。
   write(1,"b",1)
   putchar('a')
   write(1,"b",1)
   putchar('a')
   write(1,"b",1)
   ```

4. 使用strace命令来跟踪系统调用，从第8行可以看出，标准I/O会合并系统调用。

   ```shell
   [zj@ZJ test]$ strace ./sysio
   execve("./sysio", ["./sysio"], 0x7fff5e2e6280 /* 26 vars */) = 0
   brk(NULL)                               = 0xbe6000
   ...
   write(1, "b", 1b)                        = 1
   write(1, "b", 1b)                        = 1
   write(1, "b", 1b)                        = 1
   write(1, "aaa", 3aaa)                      = 3 #合并为了一个系统调用
   exit_group(0)                           = ?
   +++ exited with 0 +++
   ```

5. 随着buffersize的值变大，性能存在一个拐点，大约是4k。读写太频繁，每次读写非常少的内容和读写太不频繁，每次读写非常大的内容，这两种方案都是效率低下的。当buffersize增大到一定程度后，会产生栈溢出错误，ulimit -a中可以查看到，一般为8M。


### 文件共享

1. 文件共享：一个文件被多次打开，产生多个文件描述符，每个文件描述符都存在自己的文件位置指针。例如：要删除一个文件的第10行，此时可以将改文件以r和r+打开两次，一个用来读取11行，另一个用来将读到的内容写入第10行，然后依次向后移动。最后将文件大小截断，减去第10行的大小。

2. ```C
   #include <unistd.h>
   #include <sys/types.h>
   int truncate(const char *path, off_t length);  //将一个未打开的文件截断到length长度。
   int ftruncate(int fd, off_t length);  //将一个打开的文件截断到length长度。
   ```

### dup dup2

1. 原子操作：不可分割的操作。作用是为了解决竞争和冲突。例如：进程1使用tmpnam获取临时文件名A后，时间片耗尽，切换到另一个进程2，恰好进程2也要调用tmpnam申请临时文件名，由于此时进程1还未使用文件名A，tmpnam可能会将文件名A分配给进程2。此时就发生了关于临时文件名A的竞争。出现竞争的原因是因为创建文件名和创建文件是分成两步进行的，不是一个原子操作。多进程/线程并发时，会使用到原子操作。

2. 重定向 dup dup2：

   ```c
   #include <unistd.h>
   int dup(int oldfd);   //复制一个文件描述符，新的文件描述符为当前可用的最小序号。如果成功返回新的文件描述符，失败返回-1。
   int dup2(int oldfd, int newfd);  //和dup的工作类似，但是不使用最小的可用文件描述符，而是使用newfd参数。将数组oldfd的指针复制一份到newfd中去，如果newfd已经被打开，则会先关闭。等价于close(newfd);dup(oldfd)。如果oldfd无效，则报错，也不会关闭newfd。成功的话，返回新的文件描述符。
   ```

3. dup操作并不会复制结构体，而是在数组中新增了一个结构体指针，指向oldfd描述符对应的结构体。两个文件描述符关联了同一个结构体。

4. 例子：将printf输出的内容重定向到文件a中。

   ```c
   oldfd = open("a",O_WRONLY | O_CREAT | O_TRUNC, 0600); //打开文件a，获得文件描述符oldfd。
   close(1); //关闭标准输出
   int newfd = dup(oldfd); //此时新的描述符会是1,和oldfd关联同一个结构体。
   puts("abcd"); //此时向标准输出中写入内容时，例如printf，就相当于write(1,buf,count);会写入到1和oldfd共同对应的文件了，从而实现了将标准输出输出重定向到文件。
   ```

5. 上述操作如果在第二步和第三步中间被中断，有可能出现bug。例如关闭了1号文件描述符，但是切换到另一个线程，如果该线程碰巧正要打开一个文件，则该文件就会占用1号文件描述符，这样等到第三步再执行时，就newfd就不是1了，就不能实现将标准输出重定向到文件了。出现这种情况的原因是close和dup这两个函数不是原子操作，因此推荐使用dup2函数。上述代码还存在一个问题，如果该进程默认关闭了1号文件描述符，那么第二步会关闭掉第一步打开的文件。

6. 原子操作dup2比非原子的close+dup好处：

   1. 如果newfd=oldfd，dup2什么也不做，不会报错。因为close(newfd)后，此时如果再dup(oldfd)，就会发现oldfd的位置已经没有指向结构体了。
   2. dup2函数可以手动指定新的文件描述符，而close+dup只能依次使用可用的最小文件描述符。

   ```c
   dup2(oldfd,1);    //如果oldfd=5,那么会使得1号文件描述符和5号指向相同的结构体。关闭的时候需要关闭1和5。
   if (oldfd != 1); //如果oldfd=1,那么dup2不会做任何动作，此时只需要关闭一次1或者oldfd即可。
       close(oldfd);
   close(1);
   ```

7. 可以重定向的原因是printf之类的函数都是指定文件描述符，他不认识文件描述符后面是不是标准输出。

8. 实际用的时候，如果中途需要改变进行重定向，使用完成后，需要及时恢复过来。尽量不改变其他部分运行的环境。

### sync fcntl ioctl

1. 同步sync，将该进程内核层面的buffer，cache（例如待写入的数据或待更新的属性）同步到磁盘中。一般在卸载设备前，需要将buffer和cache中的数据及时地写入到设备中。

   ```c
   #include <unistd.h>
   void sync(void);    //同步所有的文件描述符
   int syncfs(int fd); //只同步fd。
   
   int fsync(int fd); //同步一个文件fd。
   int fdatasync(int fd); //只同步fd的数据，不同步元数据metadata。metadata是指文件的属性，修改时间等等信息。
   ```

2. fcntl操作文件描述符，管家函数。

   ```c
   #include <unistd.h>
   #include <fcntl.h>
   int fcntl(int fd, int cmd, ... /* arg */ );  //几乎之前讲的所有文件描述符相关的操作都可以用该函数实现。cmd是命令，后续的变参列表为cmd的参数
   ```

3. ioctl()是设备相关的管家函数。硬件工程师经常使用。一切皆文件的思想方便了系统及以上的程序员，但是对硬件程序员不友好，因为一些硬件不仅仅只有文件的5个常用操作。

   ```c
   #include <sys/ioctl.h>
   int ioctl(int fd, unsigned long request, ...); //request是设备相关的请求码，
   ```

4. /dev/fd目录是一个虚目录，显示当前进程的文件描述符信息。

   ```shell
   [zj@ZJ test]$ ls /dev/fd #此处看到的是ls进程的文件描述符。
   0  1  2  3
   [zj@ZJ test]$ ll /dev/fd
   lrwxrwxrwx. 1 root root 13 5月   3 08:33 /dev/fd -> /proc/self/fd
   [zj@ZJ test]$ ll /proc/self/fd
   总用量 0
   lrwx------. 1 zj zj 64 5月   3 20:39 0 -> /dev/pts/0
   lrwx------. 1 zj zj 64 5月   3 20:39 1 -> /dev/pts/0
   lrwx------. 1 zj zj 64 5月   3 20:39 2 -> /dev/pts/0
   lr-x------. 1 zj zj 64 5月   3 20:39 3 -> /var/lib/sss/mc/passwd
   lrwx------. 1 zj zj 64 5月   3 20:39 4 -> 'socket:[41112]'
   lr-x------. 1 zj zj 64 5月   3 20:39 5 -> /var/lib/sss/mc/group
   lr-x------. 1 zj zj 64 5月   3 20:39 6 -> /proc/3403/fd
   ```

## 高级I/O

1. 上面介绍的I/O模型都是单个进程每次只在一个文件描述符上执行I/O操作，而且都会阻塞直到完成数据传输，这对大部分应用是足够的。
2. 高级I/O主要研究非阻塞I/O。对于一个非阻塞I/O的调用，如果没有达到目的时返回，会设置errno为EAGAIN来标记，应该再进行尝试，这个类似于阻塞I/O的EINTR，都是假错误。
3. 磁盘文件是个特例。内核采用缓冲区cache来加速磁盘I/O请求。因而一旦请求的数据从用户缓冲区传输到内核的缓冲区cache，write()将立刻返回，而不用等到将数据实际写入磁盘（除非在打开文件时指定了O_SYNC标志）。同时，read()将数据从内核缓冲区cache移动到用户的缓冲区中，如果请求的数据不在内核缓冲区cache，那么内核就会让进程休眠，同时执行对磁盘的读操作。
4. 非阻塞I/O可以检查文件描述符上是否可进行I/O 操作，或同时检查多个文件描述符，看它们中的任何一个是否可以执行I/O操作。
5. 非阻塞I/O可以运用到管道、FIFO、套接字、终端、伪终端以及其他一些类型的设备上。
6. 如果在打开文件时设定了O_NONBLOCK标志，会以非阻塞方式打开文件。可以周期性地检查（轮询）某个文件描述符上是否可执行I/O操作。如果轮询的频率不高，那么应用程序响应I/O事件的延时可能会较高。如果太高，就会浪费CPU，在一个紧凑的循环中做轮询就是在浪费CPU。
7. 如果不希望进程在执行I/O操作时被阻塞，可以创建一个子进程来执行 I/O。此时父进程就可以去处理其他任务了，而子进程将阻塞直到I/O操作完成。如果需要处理多个文件描述符上的I/O，此时可以为每个文件描述符创建一个子进程。这种方法开销昂贵且复杂。创建及维护进程对系统来说都有开销，而且子进程需要使用某种IPC机制来通知父进程有关I/O操作的状态。
8. 可以使用多线程来代替，但线程之间仍然需要通信，以告知其他线程有关I/O操作的状态，这将使编程工作变得复杂。尤其是如果我们使用线程池技术来最小化需要处理大量并发客户的线程数量时。
9. 多线程特别有用的一个地方是如果应用程序需要调用一个会执行阻塞式I/O操作的第三方库，那么可以通过在分离的线程中调用这个库从而避免应用被阻塞。
10. 非阻塞式I/O和多进（线）程都有各自的局限性。以下方法可以解决这些问题：
   1. I/O多路复用，允许进程同时检查多个文件描述符以找出它们中的任何一个是否可执行I/O操作。select()和poll()用来执行I/O多路复用，它们在UNIX系统中已经存在了很长的时间，可移植性很好。
   2. 信号驱动I/O，是指当有输入或者数据可以写到指定的文件描述符上时，内核向请求数据的进程发送一个信号。进程可以处理其他的任务，当I/O操作可执行时通过接收信号来获得通知。当同时检查大量的文件描述符时，信号驱动I/O相比select()和poll()有显著的性能提升。
   3. epoll是Linux专有的特性，首次出现是在Linux 2.6。结合了I/O多路复用和信号驱动I/O的优点，允许进程同时检查多个文件描述符，看其中任意一个是否能执行I/O操作。当同时检查大量文件描述符时，epoll能提供更好的性能。
11. 以上三种技术都是用来实现同一个目标，即同时检查多个文件描述符，看它们是否准备好了执行I/O操作，也就是看I/O系统调用是否可以非阻塞地执行。这些技术都不会执行实际的I/O操作。它们只是告诉我们某个文件描述符已经处于就绪状态了。这时需要调用其他的系统调用来完成实际的I/O操作。
12. 文件描述符就绪状态的转化是通过一些I/O事件来触发的，比如输入数据到达，套接字连接建立完成，或者是之前满载的套接字发送缓冲区在TCP将队列中的数据传送到接收端之后有了剩余空间。
13. 同时检查多个文件描述符在类似网络服务器的应用中很有用处，或者是那些必须同时检查终端以及管道或套接字输入的应用程序。
14. epoll有一些信号驱动I/O所没有的优点。
    1. 避免了处理信号的复杂性。
    2. 可以指定想要检查的事件类型（即，读就绪或者写就绪）。
    3. 可以选择以水平触发或边缘触发的形式来通知进程。
15. 要完全利用信号I/O的优点需要用到不可移植的Linux专有的特性，此时信号驱动I/O的可移植性也不会比epoll更好。
16. 由于上述原因，可以提供一个中间抽象层，可移植的程序就能在有epoll机制的系统上应用epoll，而在其他系统上继续使用select()和poll()。Libevent库就是这样的，它提供了检查文件描述符I/O事件的抽象，已经移植到了多个UNIX系统中。它的底层机制能够以透明的方式应用上面描述的任意一种技术。
17. 两种文件描述符准备就绪的通知模式：
    1. 水平触发通知：如果文件描述符上可以非阻塞地执行I/O系统调用，此时认为它已经就绪。
    2. 边缘触发通知：如果文件描述符自上次状态检查以来有了新的I/O活动（比如新的输入），此时会触发通知。
18. I/O多路复用支持水平触发，信号驱动I/O支持边缘触发，而epoll这两种都支持。
19. 
20. 当采用水平触发通知时，可以在任意时刻检查文件描述符的就绪状态。这表示当我们确定了文件描述符处于就绪态时（比如存在有输入数据），就可以对其执行一些I/O 操作，然后重复检查文件描述符，看看是否仍然处于就绪态（比如还有更多的输入数据），此时我们就能执行更多的I/O，以此类准。换句话说，由于水平触发模式允许我们在任意时刻重复检查 I/O 状态，没有必要每次当文件描述符就绪后需要尽可能多地执行I/O（也就是尽可能多地读取字节，亦或是根本不去执行任何I/O）。
21. 当我们采用边缘触发时，只有当I/O事件发生时我们才会收到通知。在另一个I/O 事件到来前我们不会收到任何新的通知。另外，当文件描述符收到I/O 事件通知时，通常我们并不知道要处理多少I/O（例如有多少字节可读）。因此，采用边缘触发通知的程序通常要按照如下规则来设计。
    1. 在接收到一个I/O 事件通知后，程序在某个时刻应该在相应的文件描述符上尽可能多地执行I/O（比如尽可能多地读取字节）。如果程序没这么做，那么就可能失去执行I/O的机会。因为直到产生另一个I/O 事件为止，在此之前程序都不会再接收到通知了，因此也就不知道此时应该执行I/O 操作。这将导致数据丢失或者程序中出现阻塞。前面我们说“在某个时刻”，是因为有时候当我们确定了文件描述符是就绪态时，此时可能并不适合马上执行所有的I/O 操作。问题的原因在于如果我们仅对一个文件描述符执行大量的I/O 操作，可能会让其他文件描述符处于饥饿状态。
    2. 如果程序采用循环来对文件描述符执行尽可能多的I/O，而文件描述符又被置为可阻塞的，那么最终当没有更多的I/O 可执行时，I/O 系统调用就会阻塞。基于这个原因，每个被检查的文件描述符通常都应该置为非阻塞模式，在得到I/O 事件通知后重复执行I/O操作，直到相应的系统调用（比如read() ，write() ）以错误码EAGAIN 或EWOULDBLOCK 的形式失败。

### I/O多路复用

1. 有两个功能几乎相同的系统调用来执行I/O多路复用。select()，它首次出现在BSD 系统的套接字API 中。poll()，它出现在System V中。二者现在都是SUSv3中规定的标准接口。

2. 可以在普通文件、终端、伪终端、管道、FIFO、套接字以及一些其他类型的字符型设备上使用select()和poll()来检查文件描述符。

3. 这两个系统调用都允许进程要么一直等待文件描述符成为就绪态，要么在调用中指定一个超时时间。

4. select：

   ```c
   #include <sys/time.h>
   #include <sys/select.h>
   int select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval *timeout); //会一直阻塞，直到一个或多个文件描述符集合成为就绪态。返回值为就绪的文件描述符个数。readfds,writefds,exceptfds指定了要检查的文件描述的集合，分别为输入就绪，输出就绪，异常发生。
   //fd_set是文件描述符集合，用位掩码的形式来实现。所有操作都是通过四个宏来完成的：
   void FD_ZERO(fd_set* fdset); //将fdset初始化为空集
   void FD_SET(int fd, fd_set* fdset); //将fd添加到fdset中
   void FS_CLR(int fd, fd_set* fdset); //将fd从fdset中删除
   int  FD_ISSET(int fd, fd_set* fdset); //判定fd是否在fdset中，若在返回true。
   //文件描述符集合有一个最大容量限制，由常量FD_SETSIZE来决定。在Linux上，该值为1024。尽管FD_*宏操作的是用户空间数据结构，select()的内核实现却能处理更大的文件描述符集合。
   //调用select时，参数readfds,writefds,exceptfds必须使用FD_ZERO或FD_SET初始化，以包含感兴趣的文件描述符。select()调用会修改这些集合，返回时它们包含的就是已处于就绪态的文件描述符集合了，之后可以通过FD_ISSET()来检查结果中是否包含某个文件描述符。如果要在循环中重复调用select()，必须保证每次都要重新初始化它们。
   //如果我们对某一类型的事件不感兴趣，那么相应的fd_set参数可以指定为NULL。
   //参数nfds必须设为比这3个文件描述符集合中各自所包含的最大文件描述符号还要大1。该参数让select()变得更有效率，因为此时内核就不用去检查大于这个值的文件描述符号是否就绪。
   //timeout指定了要阻塞的时间上限，NULL时一直阻塞。
   struct timeval{
       time_t tv_sec; //秒
       suseconds_t tv_usec; //微秒，long int实现
   }
   //如果timeval的两个域都为0，则select()不会阻塞，它只是简单地轮询指定的文件描述符集合，看看其中是否有就绪的文件描述符并立刻返回。否则，timeout将为select()指定一个等待时间的上限值。尽管timeval能支持微秒级的精度，其准确度仍受软件时钟粒度的限制。SUSv3规定，当timeout不是该粒度的整数倍时将向上取整。
   ```

5. Linux上，一个异常情况只会在下面两种情况下发生：

   1. 连接到处于信包模式下的伪终端主设备上的从设备状态发生了改变。
   2. 流式套接字上接收到了带外数据。

6. select从阻塞态返回需要有以下事件发生：

   1. readfds、writefds或exceptfds中指定的文件描述符中至少有一个成为就绪态。对于这种情况，select()会更新timeout以此来表示剩余的超时时间。在循环中使用select()的可移植的应用程序应该总是确保timeout在每次调用select()之前都要得到初始化，而且在调用完成后应
      该忽略该结构体中返回的信息。

   2. 该调用被信号处理例程中断。会产生EINTR，timeout会被修改以表示剩余的超时时间。

   3. timeout中指定的时间上限已超时。

7. 在缺少亚秒级sleep（例如nanosleep()）的老式UNIX实现中，select()被用来模拟这个功能。可以通过指定nfds为0，readfds、writefds以及exceptfds全设为NULL，而期望的休眠时间在timeout中指定来完成。

8. 

9. 

10. 

11. 

12. 

13. 

14. 

15. 

16. 

17. 

18. 

19. 

20. 

21. 

22. 

23. 

24. 

25. 

26. 

27. 

28. 

29. 

30. 

31. 

32. 

33. 

34. 

35. 

# 文件系统

## 文件属性

1. 获取文件的属性：

   ```c
   #include <sys/types.h>
   #include <sys/stat.h>
   #include <unistd.h>
   //使用之前，要先创建一个struct stat类型的结构体。然后将结构体的地址传给第二个参数。以下函数成功返回0，失败返回-1。
   int stat(const char *pathname, struct stat *statbuf); //根据文件路径，获取文件的信息，存储到statbuf指向的位置。对待符号链接时，获取的是被链接文件的属性。
   int fstat(int fd, struct stat *statbuf); //接受文件描述符，功能和stat一样。
   int lstat(const char *pathname, struct stat *statbuf); //对待符号链接时，获取的是符号链接本身的属性，即不跟踪符号链接。
   ```

2. struct stat类型：

   ```c
   struct stat {
       dev_t     st_dev;         /* ID of device containing file */ 当前文件所在的设备ID号
       ino_t     st_ino;         /* Inode number */ iNode号。
       mode_t    st_mode;        /* File type and mode */ 文件类型和权限信息
       nlink_t   st_nlink;       /* Number of hard links */ 硬链接计数
       uid_t     st_uid;         /* User ID of owner */ 所有者ID
       gid_t     st_gid;         /* Group ID of owner */ 所属组ID
       dev_t     st_rdev;        /* Device ID (if special file) */ 如果当前文件是一个设备的话，此处表示设备的ID
       off_t     st_size;        /* Total size, in bytes */文件大小，单位为字节
       blksize_t st_blksize;     /* Block size for filesystem I/O */ 最佳I/O块的大小，默认4096B，一般是读写缓冲区的拐点。
       blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */ 当前文件所占512B块的数量，不包含空洞产生的无效数据，因此比st_size/512B小。
       /* Since Linux 2.6, the kernel supports nanosecond precision for the following timestamp fields. For the details before Linux 2.6, see NOTES. */
       struct timespec st_atim;  /* Time of last access */  最后一次读的时间
       struct timespec st_mtim;  /* Time of last modification */ 最后一次写的时间，数据修改
       struct timespec st_ctim;  /* Time of last status change */ 最后一次元数据修改的时间
       #define st_atime st_atim.tv_sec      /* Backward compatibility */
       #define st_mtime st_mtim.tv_sec
       #define st_ctime st_ctim.tv_sec
   };
   ```

3. 文件实际所占的用的空间大小为st_blocks\*512B，因为操作系统是按照block来分配存储空间的，即使文件没有用完一个block，该block的剩余空间也不能给别的文件使用。而st_size指的是文件的内容所占的大小，st_size只是一个属性，并不表示实际占用的空间。对于非空洞文件来说，块数量的分配也不都是按照字节数量/512来分配的，例如一个1个字节的文件，会被分配8个block。

4. 需要注意的是st_blocks所指的块并非是st_blksize这么大。两者一个是用来描述所占存储空间的，一个是描述最佳I/O行为的块大小。即使刚touch的一个空文件，st_blksize也不为0，而其st_size和st_blocks均为0。

5. 产生一个5G大小的空洞文件：

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <sys/types.h>
   #include <sys/stat.h>
   #include <fcntl.h>
   #include <unistd.h>
   int main(int argc, char** argv) {
       int fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC, 0600);
       if (fd < 0) {
           perror("open()");
           exit(1);
       }
       lseek(fd, 5LL * 1024LL * 1024LL * 1024LL - 1LL, SEEK_SET); //需要对每个常量用LL修饰，否则会溢出，因为结果为5G-1，而int的范围最大为2G-1。
       write(fd, "", 1);  //如果不执行这一步，文件的size和blocks都是0
       close(fd);
       exit(0);
   }
   //源文件的blocks是8，如果此时用cp命令拷贝这个文件，则新文件的blocks为0，因为cp会检查文件的字节，结果发现都是'\0'。
   ```

6. 除了使用这些系统调用之外，stat命令也可以获取文件的相关信息：

   ```shell
   [zj@ZJ test]$ ll test
   -rwxrwxr-x. 1 zj zj 13K 5月   3 09:18 test #1为硬链接计数
   [zj@ZJ test]$ stat test
     文件：test
     大小：13152           块：32         IO 块：4096   普通文件
   设备：fd00h/64768d      Inode：134295685   硬链接：1
   权限：(0775/-rwxrwxr-x)  Uid：( 1000/      zj)   Gid：( 1000/      zj)
   环境：unconfined_u:object_r:user_home_t:s0
   最近访问：2021-05-03 09:18:10.706737642 +0800
   最近更改：2021-05-03 09:18:07.583666022 +0800  #ls默认显示的时间
   最近改动：2021-05-03 09:18:07.583666022 +0800
   ```

7. st_mode权限信息有两部分组成，一个是文件的类型，一共有7种，分别为：d c b - l s p，分别表示目录，字符设备，块设备，常规文件，符号链接，套接字，管道文件（FIFO，特指命名管道，因为匿名管道在文件系统中看不到）。系统提供了一系列的宏来测试st_mode中的字段来获取文件类型，例如S_ISREG(st_mode)如果为true，则表示文件是常规文件，否则不是。或者用S_ISDIR(st_mode)判断路径名是否是目录。目录是一种特殊的文件。

8. st_mode是一个16位的整型数，例如0170000，0开头表示8进制。

9. 3位二进制，组合起来有8种情况，可以用来表示7种文件类型。9位二进制分别标识所有者，所属组，其他人的RWX权限是否存在。最后是3位，分别标识Set-User-ID，Set-Group-ID，Sticky Bit。一共3+9+3=15，因此一般使用16位数据来存储st_mode。

10. 

## 文件权限

1. 一个新文件的默认权限为0666&~umask。umask命令是显示或更改创建文件的进程的掩码。umask的存在是为了限制创建文件的权限过松。默认的umask为0002。文件权限为4位8进制数，第一位表示特殊权限。umask函数可以更该进程的掩码，这样后续创建的所有文件都会受影响。umask命令和函数都不能更改Set-User-ID，Set-Group-ID，Sticky Bit。

2. ```c
   #include <sys/types.h>
   #include <sys/stat.h>
   mode_t umask(mode_t mask);  //功能和使用umask命令相同。返回之前的umask值
   ```

3. 更改文件的权限位：

   ```c
   #include <sys/stat.h>
   int chmod(const char *pathname, mode_t mode);  //根据路径索引，修改文件的权限位为mode，不会受umask影响，因为umask只在创建文件时起作用。
   int fchmod(int fd, mode_t mode);  //根据文件描述符索引
   ```

4. 粘滞位，也称为t位，原本是给可执行文件设置，使得其能够在内存中驻留，使得下次装在此模块时较快，由于现在内存已经使用了page cache，此功能用处不大。更多是为目录设置，例如/tmp。

## 文件系统

1. FAT和UFS系统。UFS是UNIX早期的文件系统，和ext2较为接近。

2. 一个FAT（File Allocation table）文件的本质是一个静态存储的单链表。静态指的是使用数组存储。比较轻量级，现在多用在U盘等设备中。有两种思路：

   1. 用一个结构体数组来存储多个文件，每个元素都是一个结构体，结构体中至少存在两个字段，next：指向下一个结构体在数组中的下标；data[size]：数据字段，存储size个字节。这样一来，从一个文件的头结构体，可以依次找到后续的所有结构体，将这些所有的结构体的data字段拼接到一起，就得到整个文件的内容。

   2. 用一个整型数组来记录文件的下一个块的下标值。用另一个结构体数组来记录每个块的数据。通过在下标数组中查找下标，同时可以在结构体数组中查找下一个块的数据。

3. 分完区之后还要格式化mkfs，才能挂载，因为格式化后才会有文件系统。

4. 早期linux系统使用的是Minix系统的文件系统，后来才发展出了ext2。

5. ```
   Filesystem OS type:          Linux
   Inode count:                 103424
   Block count:                 25856
   Reserved block count:        1292
   Free blocks:                 21508
   Free inodes:                 103413
   First block:                 0
   Block size:                  4096
   Fragment size:               4096
   Reserved GDT blocks:         24
   Blocks per group:            8320
   Fragments per group:         8320
   Inodes per group:            25856
   Inode blocks per group:      808
   ```

6. 超级块之后是一个一个的块组groups，块组内部依次为超级块（文件系统超级块的备份，只在前几个块组内有），块组描述符，GDT，block位图（用0和1记录block区域的使用情况），iNode位图（用0和1记录iNode区域的使用情况），iNode区域，block区域。

7. <img src="Linux系统编程.assets/image-20210504112913720.png" alt="image-20210504112913720" style="zoom:50%;" />

8. ![image-20210504110109409](Linux系统编程.assets/image-20210504110109409.png)

9. 文件系统屏蔽了设备的底层细节。linux在文件系统上还有一个VFS，统一了各个文件系统之间的操作，使得用户可以用同样的操作对不同文件系统的分区进行操作。

10. <img src="Linux系统编程.assets/image-20210504111017447.png" alt="image-20210504111017447" style="zoom: 67%;" />

11. mkfs：

    ```shell
    mkfs -t ext2 -b 4096 -i 1024 /dev/sdb1     #可以用mkfs.ext2替代。block大小为4k,iNode大小为1k。
    ```

12. 每个iNode块是一个结构体（通常为128B），其中stat函数获取的信息就是在这里取得的。例如有文件权限，时间戳，所有者，所属组，文件大小等，还有数据块指针（直接+1级+2级+3级），该指针指向block区域的数据块。但是不包括文件名，文件名存在于dentry结构中，文件的文件名是其所在目录的文件信息。block中有的是数据，有的是指针信息。

13. <img src="Linux系统编程.assets/image-20210504113611065.png" alt="image-20210504113611065" style="zoom:50%;" />

14. 块设备是以块为单位收发数据的，支持缓冲和随机访问。包括硬盘，CD和RAM盘等。字符设备是相对于块设备来说的，不可以寻址，只能逐字符地读写数据，包括串行端口和磁带等。

15. 由于硬盘扇区的单位是512B，较小，因此计算机读写数据是按照逻辑块block来进行的，这样可以提高I/O的效率。逻辑块的大小一般为扇区的2^n倍。文件的st_blocksize。一般设定为4KB大小。如果都是大容量的文件，例如视频，可以将block设置大一点。

16. 如果分区中的小文件太多，可能会把iNode消耗尽，但是还剩余很多的block。一个文件对应于1个iNode，最少占用1个block，即只使用了一个直接块指针。

17. 一个文件的大小指的是它所占用的data块。但是要在文件系统中存储一个文件还需要inode块，可能有间接块。

18. boot block是在分区的最开始的，存储着启动信息，文件系统不能使用。

19. ext2系统没有日志，速度特别快，CDN服务器是适合，文件丢了不怕，再从原始数据获取一份就可以了。

20. 目录也是一个文件，目录文件的block中存储着目录项，每个目录项包含iNode，目录或文件名。因此修改和删除文件名都是在操作文件所属目录的block。

21. linux文件的读取都是从根目录开始的，先找根的iNode，再从根的block找到子目录，再找子目录的iNode等等。

22. 每个文件的iNode中都存在一个属性，记录链接计数。

    1. 创建一个文件的硬链接，会新增一条目录项，iNode号为源文件的iNode，两个iNode中的硬链接计数+1，并不会创建新的iNode。由于iNode是一样的，因此硬链接是不分主从的，地位相等，权限，时间戳都一模一样。不能跨分区（iNode容易重复）或给目录建立硬链接。符号链接可以跨分区，可以给目录建立。

       ```shell
       [zj@ZJ ~]$ stat hha
         文件：hha
         大小：0               块：0          IO 块：4096   普通空文件
       设备：fd00h/64768d      Inode：201729670   硬链接：1
       权限：(0664/-rw-rw-r--)  Uid：( 1000/      zj)   Gid：( 1000/      zj)
       环境：unconfined_u:object_r:user_home_t:s0
       最近访问：2021-05-04 13:28:57.879173871 +0800
       最近更改：2021-05-04 13:28:57.879173871 +0800
       最近改动：2021-05-04 13:28:57.879173871 +0800
       创建时间：-
       [zj@ZJ ~]$ ln hha hha_hard   #创建硬链接
       [zj@ZJ ~]$ stat hha
         文件：hha
         大小：0               块：0          IO 块：4096   普通空文件
       设备：fd00h/64768d      Inode：201729670   硬链接：2
       权限：(0664/-rw-rw-r--)  Uid：( 1000/      zj)   Gid：( 1000/      zj)
       环境：unconfined_u:object_r:user_home_t:s0
       最近访问：2021-05-04 13:28:57.879173871 +0800
       最近更改：2021-05-04 13:28:57.879173871 +0800
       最近改动：2021-05-04 13:29:28.380924642 +0800
       创建时间：-
       [zj@ZJ ~]$ stat hha_hard
         文件：hha_hard
         大小：0               块：0          IO 块：4096   普通空文件
       设备：fd00h/64768d      Inode：201729670   硬链接：2
       权限：(0664/-rw-rw-r--)  Uid：( 1000/      zj)   Gid：( 1000/      zj)
       环境：unconfined_u:object_r:user_home_t:s0
       最近访问：2021-05-04 13:28:57.879173871 +0800
       最近更改：2021-05-04 13:28:57.879173871 +0800
       最近改动：2021-05-04 13:29:28.380924642 +0800
       创建时间：-
       [zj@ZJ ~]$ ln -s hha hha_sym    #创建符号链接
       [zj@ZJ ~]$ stat hha_sym
         文件：hha_sym -> hha
         大小：3               块：0          IO 块：4096   符号链接
       设备：fd00h/64768d      Inode：201873610   硬链接：1
       权限：(0777/lrwxrwxrwx)  Uid：( 1000/      zj)   Gid：( 1000/      zj)
       环境：unconfined_u:object_r:user_home_t:s0
       最近访问：2021-05-04 13:34:00.394965636 +0800
       最近更改：2021-05-04 13:33:56.925887595 +0800
       最近改动：2021-05-04 13:33:56.925887595 +0800
       创建时间：-
       ```

    2. 软连接相当于新建了一个文件，iNode号为新的，该文件的block中存放的是被连接文件的路径（因此该文件的size就是被链接文件的文件名大小，也是因为它存储的数据非常少，就不给他分配block了，而是把数据存储到iNode中了）。符号链接文件的权限，时间戳和被链接文件没有任何关系。


## 链接与重命名

1. 硬链接相关的函数：

   ```c
    #include <unistd.h>
   int link(const char *oldpath, const char *newpath);  //源文件为oldpath，新文件为newpath。如果newpath文件存在，那么不会覆盖，会返回-1，设置errno。相当于ln命令。
   int unlink(const char *pathname); //从文件系统中删除一个名称，当且仅当该名称对应的文件链接计数为0且没有进程正在打开它时，名称对应的文件才会被从硬盘上删除以腾出空间。该函数不会跟踪符号链接，而是删除符号链接本身。
   #include <stdio.h>  //标准库函数，相当于rm命令
   int remove(const char *pathname); //对于文件，会调用unlink,对于目录会调用rmdir。只能删除空目录。
   ```

2. 修改文件名或路径：

   ```c
   #include <stdio.h>  //标准库函数，相当于mv命令
   int rename(const char *oldpath, const char *newpath); //如果新旧路径名中仅文件名不同，则表示改名，否则表示移动位置并改名。打开的文件描述符不会受影响。如果newpath路径名存在，则会被原子性地替换。该函数不会跟踪符号链接。
   ```


## utime

1. ls看到的时间默认是mtime，即数据内容被修改的时间，UNIX文件系统不记录文件的创建时间。

2. 修改文件的atime和mtime

   ```c
   #include <sys/types.h>
   #include <utime.h>
   int utime(const char *filename, const struct utimbuf *times);  //接受一个结构体指针
   struct utimbuf {
       time_t actime;       /* access time */
       time_t modtime;      /* modification time */
   };
   ```


## 工作目录

1. 目录的创建和销毁，切换当前路径。

   ```c
   #include <sys/stat.h>
   #include <sys/types.h>
   int mkdir(const char *pathname, mode_t mode);
   #include <unistd.h>
   int rmdir(const char *pathname);   //只能删除空目录。由于目录没有硬链接，删除目录就是从磁盘删除了。非空目录只能递归删除，先删除目录中的所有文件，再删除目录本身。
   ```

2. 获取和更改当前的工作路径：

   ```c
   #include <unistd.h>
   int chdir(const char *path);  //改变当前进程的工作路径。该函数能够突破chroot的假根，称为chroot穿越。和cd命令的功能相同。
   int fchdir(int fd);
   #include <unistd.h>
   char *getcwd(char *buf, size_t size);  //获取当前的工作路径，和pwd命令的功能相同。
   ```

3. chroot可以修改进程的根目录，可以起到保护其他目录的作用，是一种安全机制。

## 目录解析

1. 目录的解析可以用glob函数，也可以用一系列的函数opendir closedir readdir rewinddir seekdir telldir。

2. glob函数可以找到满足pattern的多个文件名，pattern是一个带通配符的字符串，*表示任意多个字符，?表示一个字符，shell的通配符用的也是这种。该函数的模式不会去递归子目录，这点也和shell一样。

   ```c
   #include <glob.h>
   int glob(const char *pattern, int flags, int (*errfunc)(const char *epath, int errno), glob_t *pglob);  //第一个参数为一个模式字符串，第二个参数一些可以相或的选项,0表示无选项。第三个参数为一个函数指针，在解析的过程中，每次出错都会调用该函数，以保存出错的路径和原因，可以在该函数内进行错误处理，如果不需要处理，可以传入NULL。第四个参数为解析的结果。
   void globfree(glob_t *pglob);  //使用完毕后，要用该函数释放内存空间，即gl_pathv指向的空间。
   typedef struct{
       size_t gl_pathc;  //匹配pattern的路径数量
       char **gl_pathv;  //匹配的路径字符串数组，类似于main函数的输入参数管理方式。这里会申请2累内存，一个是字符指针数组，一共有gl_pathc个元素，然后是每个字符指针所指字符串的内容。这里的路径都是绝对路径。
       size_t gl_offs;   //偏移，在gl_pathv的开头中保留gl_offs个位置，用NULL填充。
   } glob_t  //gl_pathc, gl_pathv和argc, argv一样。
   //常用的flags选项：
   GLOB_DOOFFS  //根据gl_offs的值，进行偏移。
   GLOB_NOCHECK //如果pattern没有匹配到任何内容，返回pattern，即将pattern存入glob_t数据中。默认情况下，会返回GLOB_NOMATCH。
   GLOB_APPEND  //追加到现有的参数glob_t数据中，只能用于第二次或以后。可以将多次的查找合并。默认是覆盖。
   GLOB_NOSORT  //不对文件名进行排序，可以节省运行时间。默认情况下会进行排序。ls命令默认的结果就是排过序的。
   ```

3. 例子：获取所有匹配/etc/a*.conf的路径：文件和目录都会被找到。/etc/\*只能找到非隐藏的文件和目录，相当于ls /etc/\*的结果。如果要查看隐藏文件或目录，模式为/etc/.\*     可以为glob函数指定一个选项GLOB_APPEND，把两次（一次非隐藏，一次隐藏）匹配到的路径追加到一起。

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <glob.h>
   #include <string.h>
   int errfunc1(const char *epath, int errno){
       print("%s\n",epath);
       fprintf(stderr,"%s\n",strerror(errno));
   }
   int main(int argc, char** argv){
       glob_t globres;
       if (glob(argv[1],0,errfunc1,&globres) != 0) 
           fprintf(stderr,"Error");
       for(int i=0;i<globres.gl_pathc;i++){
           printf("%s\n",globres.gl_pathv[i]);
       }
       globfree(&globres);
   }
   ```

4. main的命令行参数，在shell下如果使用通配符，会被shell自动展开(不是所有的shell都会自动展开)，例如：

   ```shell
   ./main *.c    # *.c会被替换，argc不止两个。
   ```

5. 可以使用glob函数将一段命令行字符串解析为argv的样式，利用它的自动分配字符串内存的功能：

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <glob.h>
   #include <string.h>
   int main() {
       char* linebuffer = NULL;
       size_t linebuf_size = 0;
       char* tok = NULL;
       glob_t globres;
       int times = 0;
       if (getline(&linebuffer, &linebuf_size, stdin) < 0) {
           perror("getline()");
           exit(1);
       }
       while (1) {
           tok = strsep(&linebuffer, " \t\n");
           if (tok == NULL)//空指针，表示到了字符串的结尾了，此时应该退出循环。
               break;
           if (tok[0] == '\0')  //空字符串。这个和上面的并不一样。上面是判断tok是否为0，这个是判断*tok是否为0。只不过指针的0一般用NULL，字符的0一般用'\0'。
               continue;
           glob(tok, GLOB_NOCHECK | GLOB_APPEND * times, NULL, &globres); //这里需要循环第一个次不能使用GLOB_APPEND，之后才需要。GLOB_NOCHECK表示如果找不到对应的匹配，则返回pattern本身。
           times = 1; //times初始为0，后续都为1。
       }
       for (int i = 0;i < globres.gl_pathc;i++) {
           printf("[%d]:[%s]\n", i, globres.gl_pathv[i]);
       }
       globfree(&globres);
       exit(0);
   }
   ```

6. 上述函数实验：

   ```shell
   ls -l    /etc
   [0]:[ls]
   [1]:[-l]
   [2]:[/etc]
   ```

7. 目录操作函数：

   ```c
   #include <sys/types.h>
   #include <dirent.h>
   DIR *opendir(const char *name); //通过目录文件名打开一个目录
   DIR *fdopendir(int fd); //将一个open过的目录的文件描述符转化为目录流
   int closedir(DIR *dirp);  //关闭一个目录流
   struct dirent *readdir(DIR *dirp); //从一个目录流dirp中读取一条数据，每次读取都会移动目录项位置指针。类似于文件的read。
   struct dirent{   //directory entry 目录项
       ino_t             d_ino;       //inode号
       off_t             d_off;       //下一个dirent的偏移
       unsigned short    d_reclen;    //本条记录的长度    
       unsigned char     d_type;      //当前文件的类型
       char              d_name[256];  //当前文件的文件名
   }
   void rewinddir(DIR *dirp); //将目录流dirp的当前位置指针恢复到开头
   void seekdir(DIR *dirp, long loc);  //调整目录流当前位置指针的位置，下一次readdir时，就会读取这个目录项。
   long telldir(DIR *dirp);  //返回目录流dirp的目录项位置指针的当前位置。
   int scandir(const char *dirp, struct dirent ***namelist, int (*filter)(const struct dirent *), int (*compar)(const struct dirent **, const struct dirent **)); //扫描目录dirp(不包含子目录)，对每个目录项调用过滤器filter函数，如果filter为NULL，则所有目录项都被选择。filter函数有一个参数，为目录项的指针，返回值为int类型。对满足条件(返回值非0)的目录项使用compar函数进行排序，然后结果存储到目录项指针数组namelist中。namelist数组和该数组的每个指针所指的每个dirent的结构体都是由I/O库使用malloc分配管理的，使用完都应先逐个释放结构体，再释放数组。如果调用成功，函数的返回值为namelist数组的元素个数。失败返回-1，并设置errno。
   int alphasort(const struct dirent **a, const struct dirent **b); //这两个函数是glibc自带的两个函数，可以作为scandir函数的compar参数，比较的内容都是文件名，这个函数按照strcoll函数的规则比较。完全按照字母顺序来比较，例如abc就在abd之前。
   int versionsort(const struct dirent **a, const struct dirent **b); //按照strverscmp函数的规则比较。例如他会将2放在10前面，而不是按照一位一位地比较。
   ```

8. 例子，逆序打印当前目录中的文件名：

   ```c
   #define _DEFAULT_SOURCE
   #include <dirent.h>
   #include <stdio.h>
   #include <stdlib.h>
   int main(void){
       struct dirent **namelist;
       int n;
       n = scandir(".", &namelist, NULL, alphasort); //不过滤，只排序。因为要修改二级指针的值，所以用了三级指针。
       if (n == -1) {
           perror("scandir");
           exit(EXIT_FAILURE);
       }
       while (n--) {
           printf("%s\n", namelist[n]->d_name);
           free(namelist[n]);  //namelist数组的每个元素都是一个struct dirent结构体的指针。结构体的空间也是有scandir申请的，用完应该由使用者释放。
       }
       free(namelist);  //由使用者释放，最后释放数组本身的空间。
       exit(EXIT_SUCCESS);
   }
   ```

9. 例子：解析/etc下有多少文件

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <dirent.h>
   int main(){
   	DIR *dp;
       struct dirent *cur;
       if((dp = opendir("/etc")) == NULL){
           perror("opendir()");
           exit(1);
       }
       
       while((cur = readdir(dp)) != NULL){
           printf("%s\n",cur->d_name);
       }
   }
   ```

10. 如果要想获取一个目录的大小，即du命令的结果，需要进行递归解析该目录下/*和/.\*的目录和文件大小，如果遇到目录，要递归进行处理。递归的时候要注意，linux的文件系统不是树状结构，每个目录下必定有2个隐藏文件，.和.. 递归的时候需要排除掉这两个目录。排除完就可以认为是树状的了，不过还要排除硬链接和符号链接。

    ```shell
    du flen.c  #查看flen.c文件所占用的磁盘空间
    4  #结果为4，单位是KB。通过stat也可以看到该文件占用了8个block。即使该文件的内容只有432B大小。
    # 当du一个目录时，会将该目录下的所有文件和目录（包含隐藏的），除了..意外，都执行一遍du命令。例如一个目录下有1个文件test.txt和2个目录std,sys，两个目录的du结果分别为56KB和128KB。test.txt文件和.目录都占用8个block，即4KB。所以该目录的du结果为56+128+4+4=192KB。
    du #没有参数时，表示对当前目录执行du命令。
    ```

11. 例子，自定义的du命令：

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <unistd.h>
    #include <glob.h>
    #include <string.h>
    #include <libgen.h>
    #include <fcntl.h>
    
    #define PATHSIZE 256
    static long long mydu(const char* pathname) {
        static struct stat statres; //仅在递归点之前使用，所以可以放在静态区。
        static char strippath[PATHSIZE] = { 0 }; //去除完末尾/的路径
        static char conpath[PATHSIZE] = { 0 };
        glob_t globres;
        static int globret = 0;
        long long sum = 0;
        char* filename;
        strncpy(strippath, pathname, PATHSIZE);//复制一份，不直接在argv上修改
        if (strippath[strlen(strippath) - 1] == '/') {
            strippath[strlen(strippath) - 1] = '\0';  //删除路径名末尾的/
        }
        if (lstat(pathname, &statres) < 0) {
            perror("lstat");
            exit(-1);
        }
        if (!S_ISDIR(statres.st_mode)) {
            return statres.st_blocks / 2;
        } else {
            strncpy(conpath, strippath, PATHSIZE);
            strncat(conpath, "/*", 3); //非隐藏文件和目录，要求第三个参数比第二个参数的长度大，且比第一个参数的空间小。
            globret = glob(conpath, 0, NULL, &globres);
            if (globret != 0 && globret != GLOB_NOMATCH) { //无法在空目录中寻找到非隐藏文件
                perror("glob");
                exit(-1);
            }
            strncpy(conpath, strippath, PATHSIZE);
            strncat(conpath, "/.*", 4); //隐藏文件和目录
            globret = glob(conpath, GLOB_APPEND, NULL, &globres);
            if (globret != 0 && globret != GLOB_NOMATCH) {  //追加到上一次的结果中
                perror("glob()");
                exit(-1);
            }
            sum += statres.st_blocks / 2;
            for (int i = 0; i < globres.gl_pathc; i++) {
                filename = basename(globres.gl_pathv[i]);
                if (!strcmp(filename, ".") || !strcmp(filename, ".."))
                    continue;
                sum += mydu(globres.gl_pathv[i]);
            }
        }
        globfree(&globres);
        return sum;
    }
    int main(int argc, char* argv[]) {
        if (argc != 2) {
            fprintf(stderr, "%s", "Ussage:...\n");
            exit(-1);
        }
        printf("%lldK\t%s\n", mydu(argv[1]), argv[1]);
    }
    ```

12. 由于每一次递归都要将局部变量压入栈中，因此将变量尽量存储在静态区是一种比较好的节省栈的方法，这样可以使得递归的次数增加。只在递归点前使用的局部变量是可以优化为static存储的，即递归返回的时候，该变量不会被使用到。

13. 将路径名拆分为目录名和文件名，路径名使用绝对或相对路径都可以：

    ```c
    #include <libgen.h>
    char *dirname(char *path); //两个函数可能会修改path，返回值存储在函数的静态区，可能会被后续的调用覆盖掉。也有可能指向path的一部分，如果要修改返回值，应strcpy到其他地方修改。
    char *basename(char *path);
    //通常情况下用最后一个/分割。二者都不包含/。path结果如果有/，会先被去掉。
    //如果path不包含/(即只有一个文件或目录名),则dirname为.，basename为路径名本身。
    
    //特殊情况：
     1 如果path就是/，那么dirname和basename都是"/"
     2 如果path是空指针或指向一个空字符串(含有空白字符)，则dirname和basename都是"."
    //除特殊情况外，都可以将dirname和"/"还有basename拼接起来，得到path。
    ```

14. 例子：

    ```shell
    #path      dirname    basename
    /usr/lib   /usr        lib
    /usr/      /           usr
    usr        .           usr
    /          /           /
    .          .           .
    ..         .           ..
    ```

# 用户信息操作

1. 用户信息文件和操作函数：/etc/passwd /etc/group /etc/shadow这三个文件，存储着UID，GID和用户名，组名，密码的关系。不建议直接查询文件来获得相关信息，因为不是所有的UNIX系统都是使用这些文件。FreeBSD上使用一个数据库BDB来存放这些信息。HP-UNIX利用文件系统来存储这些信息。

   ```shell
   # /etc/passwd文件
   zj:x:1000:1000:Jian:/home/zj:/bin/bash #登录用的用户名:具有密码:用户ID:初始组ID:注释字段，安装Ubuntu时输入的:家目录:登录shell路径
   #会使用家目录给SHELL环境变量赋值。登录shell路径可以是任何程序。
   # /etc/group
   root:x:0: #组名:组密码:组ID:除了同ID的用户以外，组内成员ID
   adm:x:4:syslog,zj  #adm组除了还有两个成员用户syslog和zj
   # /etc/shadow
   zj:$6$SFRinE5OA7YV.tJY$kmMwKLTaGsm7Q9NkU.nms/nT2nTzfozsU0goIjwD66ll0LaP33R3Rf8i5f0KUIkIl7Wp9wLZOCJOUnaLnFkk80:19477:0:99999:7::: #用户名:加密后的密码:后续的字段都是关于密码时间的记录或设置。
   #第二个字段表示Hash后的结果，分为三段，用$分割。第一段的6表示加密方式为sha512，第二段表示做hash运算时使用的随机盐值。每个用户都不一样，这样可以保证即使密码相同，由于盐值不同，得出的hash值也不同。第三段是Hash值。
   ```

2. 若/etc/passwd中某行的密码字段为空，则该账户登录时无需密码（即便启用了shadow密码，也是如此）。

3. 如果使用了NIS（网络信息系统）或LDAP（轻型目录访问协议）在网络环境中分发密码，那么部分密码信息可能会由远端系统保存。

4. 之所以有shadow文件，是为了将用户的所有非敏感信息存放于“人人可读”的passwd文件中，而经过加密处理的密码则由shadow文件单独维护，仅供具有特权的程序读取。

5. 在passwd文件中，允许（但不常见）同一用户ID拥有多条记录（即多个名字），从而使得同一用户ID拥有多个登录名。如此一来，多个用户便能以不同密码（登录）去访问相同资源（比如，文件等，权限相同）。此外，不同的登录名还可以关联一系列不同的组ID。

6. 组密码属于非强制特性，对应于该字段。随着多属组的出现，当今的UNIX 系统已经很少使用组密码。经过加密的组密码实际上则存放于/etc/gshadow文件中。

7. 用户信息操作函数，passwd文件：

   ```c
   #include <sys/types.h>
   #include <pwd.h>
   struct passwd *getpwnam(const char *name); //通过用户名查询
   struct passwd *getpwuid(uid_t uid); //通过用户ID查询
   struct passwd *getpwent(void);//从passwd文件中逐条返回记录，当读到末尾时，返回NULL。
   void setpwent(void); //重返文件起始处
   void endpwent(void); //关闭文件。读取完毕后应该及时关闭该文件，方便后续使用。
   //针对组文件，也有3个对应的函数getgrent()，setgrent()和endgrent()。
   struct passwd {   //和passwd文件的顺序相同。
        char   *pw_name;       /* username */
        char   *pw_passwd;     /* user password */
        uid_t   pw_uid;        /* user ID */
        gid_t   pw_gid;        /* group ID */
        char   *pw_gecos;      /* user information */
        char   *pw_dir;        /* home directory */
        char   *pw_shell;      /* shell program */
   };
   //以上函数都是不可重入的，因为返回的指针是静态分配的（可以认为是glibc中定义的全局变量），也就是说两次调用返回的指针指向的位置相同，只是填充的内容不同。
   //SUSv3为该组函数定义了等价的可重入函数：getpwnam_r()、getpwuid_r()等。
   //其参数包括passwd（或group）结构，以及一个缓冲区。缓冲区专门用来保存passwd结构体中各字段所指向的其他结构。可使用系统函数sysconf(_SC_GETPW_R_SIZE_MAX)来获得此缓冲区所需的字节数。
   ```

8. SUSv3规定，如果在passwd文件中未发现匹配记录，那么 getpwnam()和getpwuid()将返回NULL，且不会改变errno。2.7 版本之前的glibc会产生ENOENT错误，而从2.7版本开始，glibc开始遵守SUSv3规范。

9. 组信息操作函数，group文件：

   ```c
   #include <sys/types.h>
   #include <grp.h>
   struct group *getgrnam(const char *name);
   struct group *getgrgid(gid_t gid);
   struct group { //和/etc/group文件中的顺序相同
       char   *gr_name;        /* group name */
       char   *gr_passwd;      /* group password */
       gid_t   gr_gid;         /* group ID */
       char  **gr_mem;         /* NULL-terminated array of pointers to names of group members 存储组成员名的字符串数组*/
   };
   ```

10. 为了防止穷举对密码进行爆破，有时会进行口令随机校验，即使用户输对了密码，也要提示错误，让其重新输入。较为重要的操作，可能会进行随机校验。

11. shadow文件的权限为000，所有者和所属组都是root，但是这并不妨碍root用户读写它，这样的权限主要是提醒root用户，尽量不要去修改它。

12. 密码信息操作函数，shadow文件：

    ```c
    #include <shadow.h>
    struct spwd *getspnam(const char *name);
    struct spwd *getspent(void); //类似于getpwent,逐条从shadow文件中读取记录。
    void setspent(void);
    void endspent(void);
    struct spwd {
         char *sp_namp;     /* Login name */
         char *sp_pwdp;     /* Encrypted password */
         long  sp_lstchg;   /* Date of last change(measured in days since 1970-01-01 00:00:00 +0000 (UTC)) */
         long  sp_min;      /* Min # of days between changes */
         long  sp_max;      /* Max # of days between changes */
         long  sp_warn;     /* # of days before password expires to warn user to change it */
         long  sp_inact;    /* # of days after password expires until account is disabled */
         long  sp_expire;   /* Date when account (measured in days since 1970-01-01 00:00:00 +0000 (UTC)) */
         unsigned long sp_flag;  /* Reserved */
    };
    #include <crypt.h> //crypt函数只推荐用来对用户的密码进行加密，不建议用于一般的加密。注意，使用crypt.h头文件中的函数，需要显式链接上libcrypt库。
    char* crypt(const char *phrase, const char *setting); //phrase是待加密的明文，setting参数是由加密方法和盐值构成的字符串。也就是/etc/shadow文件中第二个字段中第三个$及之前的字符。
    ```

13. 某些应用程序会要求用户对自身进行认证，通常会采取用户名（登录名）/密码的认证方式。出于这一目的，应用程序可能会维护其自有的用户名和密码数据库。需要登录到远程系统的网络应用程序，诸如ssh和ftp，必须按标准的login程序那样，对用户名和密码加以验证。

14. 例子，验证用户的密码，需要root执行权限：

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <shadow.h>
    #include <string.h>
    #include <crypt.h>
    int main(int argc, char* argv[]) {
        if (argc < 2) {
            fprintf(stderr, "Usage:...\n");
            exit(1);
        }
        char* input_pass;
        struct spwd* shadowline;
        char* crypted_pass;
        input_pass = getpass("input you passwd\n"); //从终端获取内容，但是不回显输入，不包含末尾的换行符。目前已经不推荐使用该函数了，可以使用termios来关闭终端的回显功能。
        shadowline = getspnam(argv[1]); //这一步会查询/etc/shadow文件，如果进程没有root权限，会失败。
        crypted_pass = crypt(input_pass, shadowline->sp_pwdp); //该函数的第二个参数只会读取前几个字符。
        if (strcmp(crypted_pass, shadowline->sp_pwdp)) {
            puts("Error");
        } else {
            puts("Ok");
        }
    }
    //读取密码的程序应立即加密密码，并尽快将密码的明文从内存中抹去。只有这样，才能基本杜绝避免恶意之徒借程序崩溃之机，读取内核转储文件以获取密码。
    //如果包含密码的虚拟内存页执行了换出操作，那么特权级程序就能从交换文件中读取密码。
    //拥有足够权限的进程可通过读取/dev/mem（虚拟设备之一，将计算机物理内存表示为有序字节流），来尝试发现密码。
    ```

# 时间操作相关函数

1. 时间操作的流程：使用time函数获取time_t的整数时间戳，然后使用localtime或gmtime构建struct tm结构体。mktime可以将结构体转化为时间戳。使用strftime将tm结构体转化为格式化的字符串。

2. <img src="Linux系统编程.assets/image-20230504200250203.png" alt="image-20230504200250203" style="zoom: 80%;" />

3. 使用stat函数获取文件的时间属性时，得到的也是time_t类型。

4. 时间操作函数：

   ```c
   #include <time.h>
   time_t time(time_t *tloc); //从内核中获取时间，以秒为单位的计数，从eopch开始，也就是1970年1月1日00:00。如果参数不是NULL，时间戳会同时存储在参数和返回值中。
   
   struct tm *gmtime(const time_t *timep);   //根据时间戳构建tm结构体，格林威治时间
   struct tm *localtime(const time_t *timep); //根据时间戳构建tm结构体，本地时间
   time_t mktime(struct tm *tm);    //将tm结构体转化为时间戳。可能会修改结构体。因为结构体中存在冗余，例如tm_wday和tm_yday都可以通过之前的字段推导出。还有就是某些字段超出取值范围的话，会被用于修改其他字段，例如1月33日，会被当作2月2日。
   struct tm {
       int tm_sec;    /* Seconds (0-60) 范围不是0-59，是因为有闰秒的存在*/
       int tm_min;    /* Minutes (0-59) */
       int tm_hour;   /* Hours (0-23) */
       int tm_mday;   /* Day of the month (1-31) */
       int tm_mon;    /* Month (0-11) 比平时说的少1*/
       int tm_year;   /* Year - 从1900开始算 */
       int tm_wday;   /* Day of the week (0-6, Sunday = 0) 周日是一周的第一天*/
       int tm_yday;   /* Day in the year (0-365, 1 Jan = 0) */
       int tm_isdst;  /* Daylight saving time 是否开启夏令时调整*/
       //夏令时调整，是一种为了节约能源而人为规定的地方时间调整，因为夏天天亮的早，所以一般将时钟调快一个小时，使得人可以早起早睡，充分利用太阳光，例如1986-1991年中国规定：每年从四月中旬第一个星期日的凌晨2时整（北京时间），将时钟拨快一小时，即将表针由2时拨至3时，夏令时开始；到九月中旬第一个星期日的凌晨2时整（北京夏令时），再将时钟拨回一小时，即将表针由2时拨至1时，夏令时结束。中国的时区跨度太大，不适合，现在能源供应比较充足，也不必这么做。另一种提高白天利用率的方法是，调整工作时间，例如可以将一天的工作时间都向前调整1个小时。
   };
   size_t strftime(char *s, size_t max, const char *format, const struct tm *tm);//将tm结构体按照format格式,输出到一个字符串s中(最多输出max的字符)。返回值为成功输出的字符串的长度。format例子："%Y-%m-%d" 可能会输出"2021-05-05"。
   ```

5. 通过tm结构体来引用具体的年月，会发现年是从1900年开始计算的，例如2010年时，tm.tm_year为110。而通过strftime格式化输出的时候就没有这种问题。

6. 比较诡异的是，time获取的时间戳是从1970年开始算的，而struct tm中的tm_year字段却是从1900年开始计算的。

7. 一般来说，返回值为指针的库函数，如果有_r版本的函数，那么普通版本的指针指向的空间都是放在静态区的，\_r版本的函数是修改后的线程安全的版本。静态区的好处是不用提供回收内存的配对函数，因为始终就只有那么一点内存被使用，而如果放在堆上，那么每次调用都会产生一块内存泄漏。静态区的缺点是，调用完该函数后，应该立即使用，再一次调用该函数，就会冲掉原来的数据。

8. 求当前时间100天以后的日期：

   ```c
   time _t t1 = time(NULL);
   struct tm *tm=localtime(&t1);
   tm->tm_mday += 100;  //tm_day合理的取值范围为1-31。
   mktime(tm);   //mktime会先判断tm结构体是否合法，如果不合法会将其纠正为合法的结构体。会自动进位。返回值没用。
   ```

# 进程环境

1. C程序总是从main函数开始执行，其原型如下。

    ```c
    int main(int argc, char* argv[]); //argc是命令行参数的个数，argv是指向各个参数的指针构成的数组。
    ```

2. 内核通过exec函数替换程序镜像来执行C程序。在调用main函数前，会先调用一个特殊的启动例程，这是因为链接器将该启动例程放置在了程序的起始地址处。启动例程从内核获得main函数的命令行参数和环境变量，然后按照main函数的定义来调用它。

    ```c
    exit(main(argc, argv)); //启动例程调用main函数的可能方式。实际上该例程通常用汇编语言编写。
    ```

3. main函数作为程序的入口是人为规定的，该函数由C启动例程来调用。可以通过设置链接器来将其他函数来代替main函数。

4. 内核栈是每个进程保留在内核内存中的区域，在执行系统调用的过程中供（内核）内部函数调用使用。由于用户栈驻留在不受保护的用户内存中，所以内核无法利用用户栈来达成这一目的。

5. argc/argv参数机制的局限在于这些变量仅对main()函数可用。要想在任意位置使用这两个参数，可以把argv以参数形式传递给这些函数，或是设置一个指向argv的全局变量。

6. Linux提供了一种特有的方法来在任意位置读取命令行参数：在专有的/proc/PID/cmdline文件种保存着任一进程的命令行参数，程序可以通过/proc/self来访问自己进程的信息。

7. GNUC提供2个全局变量，program_invocation_ name表示调用该程序的完整路径名，program_invocation_ short_name表示不含目录的程序名称，即路径名的基本名称（basename）部分。定义_GNU_SOURCE宏后即可从<errno.h>中获得对这两个全局变量的声明。

8. 命令行参数，环境变量都存在于栈之上的一个单一、连续的内存区域。SUSv3规定使用ARG_MAX常量（定义于<limits.h>）或者调用`sysconf （_SC_ARG_MAX）`函数以确定该上限值。SUSv3还要求ARG_MAX常量的下限为_POSIX_ARG_MAX（4096）个字节，而大多数UNIX 实现的限制都远高于此。

9. 自内核2.6.23 版本开始，可以通过资源限制RLIMIT_STACK来控制argv 和environ 参数所使用的空间总量上限。在这种情况下，允许argv 和environ 参数使用的空间上限要比以前大出许多，具体限额为资源软限制RLIMIT_ STACK 的四分之一，RLIMIT_STACK 在调用execve()时已经生效。

10. 

11. 

12. 

13. 

14. 

15. 

16. 

17. 


## 进程终止方式

1. 进程有8种终止的情况，其中5种为正常，3种为异常。
2. 进程的正常终止方式：
   1. 从main函数return返回。因为从main函数返回后，启动例程也会立即调用exit函数，本质上和方式2类似。
   2. 主动调用exit函数。
   3. 主动调用\_exit或\_Exit函数。
   4. 最后一个线程从其启动例程中返回。启动例程就是线程的执行序列。类似于方式1。但是该线程的返回值不用作进程的返回值。进程此时以0作为终止状态返回。
   5. 最后一个线程调用了pthread_exit函数。类似于2。和4类似，此时进程的终止状态总是0。
3. 进程的异常终止：

   1. 调用abort函数。该函数会发送一个sigabort信号给当前进程，响应时会产生一个coredump文件。它是方式2的一个特例。
   2. 被动接收到一个信号并终止，例如Ctrl+C发出的SIGINTR信号的默认行为就是终止进程。或者kill命令。信号可由自身，其他进程，内核产生。例如进程内存访问越界或除以0时，内核会发送响应的信号。
   3. 最后一个线程对取消请求并作出响应。默认情况下，“取消”以延迟方式发生：一个线程要求取消另一个线程，若干时间后，目标线程终止。
4. 不论进程如何终止，最后都会执行内核中的同一段代码。这段代码为进程关闭所有打开的文件描述符，释放它所使用的内存。
5. 正常终止时，子进程通过返回值来通知父进程其终止状态。异常终止时，内核产生一个指示其异常终止原因的终止状态。这两种情况下，父进程都可以用wait或waitpid来获得子进程的终止状态。

## exit, _exit, _Exit

1. 三个函数都用于正常终止一个程序，不同的是\_exit和\_Exit会立即进入内核，而exit会先执行一些清理处理，然后再进入内核。

2. exit()函数会执行标准I/O库的清理关闭操作。为所有打开的流调用fclose，这会导致输出缓冲区的数据被fflush。将它的子进程过继给init进程，发送SIGCHILD信号通知它的父进程。

3. return的返回值是给父进程看的，父进程可以通过wait函数来收集该返回值。shell可以通过读取$?变量来获得程序的返回值。

4. 发生以下任意一种情况，进程的终止状态是未定义的：

    1. 调用三个exit时，不带终止状态。

    2. main函数中执行了不带参数的return语句。

    3. main函数的定义中，没有声明返回值类型为整型。例如为void或没有任何类型。

5. 但是若main函数定义了返回类型为整型，并且main执行到最后一条语句时隐式返回（不出现return语句），那么进程的终止状态为0。这是C99中规定的，在以前若main函数终止时没有显式使用return语句或exit函数，则进程的终止状态是未定义的。例如：

    ```c
    #include <stdio.h>
    main(){
        printf("hello,world\n");
    } //该程序的终止码在某些平台上是随机的。具体的返回值取决于返回时栈和寄存器的内容。
    //gcc returncode.c -o returncode -std=c89   这个程序的终止状态为12，即printf输出的字符个数，因为printf的返回值会存放在eax寄存器中，其后直接从栈中返回，则相当于return 12。
    //如果修改-std=c99选项或者不指定std(因为较新的gcc默认使用的标准已经覆盖C99了)，终止码就变成了0。但是编译的时候会提示如下，也就是main函数没有显式声明返回值类型：
    returncode.c:2:1: warning: return type defaults to ‘int’ [-Wimplicit-int]
        2 | main() {
          | ^~~~
    ```

6. main函数return 一个整型值，等价于调用exit(该整型值)。为了统一管理，在main函数中推荐使用exit而不是return。普通函数的结尾可以使用return。这样通过grep命令可以统计到整个工程中所有的退出点。

    ```c
    return a; //等价于 exit(a);  但是某些编译器并不了解这种等价关系，可能会报warning，gcc不会。
    ```

7. ```c
   #include <stdlib.h>
   void exit(int status); //将status&0377的结果返回给父进程。即保留status的低8位，即从-128到127。C标准提供了两个宏可以作为status的值，EXIT_SUCCESS和EXIT_FAILURE。
   void _Exit(int status); //立刻终止调用进程
   #include <unistd.h>
   void _exit(int status); //完全等价于_Exit(),不过此函数是系统调用(POSIX.1定义)而非库函数。
   
   #include <unistd.h>
   void _exit(int status);  //exit函数所依赖的下层的系统调用。不过这两个函数不会执行钩子函数和I/O清理。
   void _Exit(int status);  //功能同上。这两个函数用在意外的分支。例如switch-case中的default分支，只有它之前的程序出错才会执行到这一步，因此一旦执行到这一步就应该尽快退出。
   ```

8. 终止处理程序，最早由C89引入，因此早于C89的系统例如SVR3、4.3BSD都不支持这一机制：

    ```c
    int atexit(void (*function)(void)); //向一个进程注册它正常终止前会调用的函数(即钩子函数，又称为终止处理函数)。返回0表示成功挂上钩子。钩子函数没有参数，没有返回值。注册过的钩子函数，只有在进程正常终止时才会被逆序调用(类似于栈)，可以认为钩子函数的入口地址被放在一个栈中。一个函数可以被注册多次，因此也会被调用多次。
    int on_exit(void (*function)(int , void *), void *arg); //被注册的函数又两个参数，第一个为exit的参数或return的返回值。第二个为注册时给on_exit提供的第二个参数arg。
    ```

9. ISO C要求，系统应该至少支持32个终止处理程序，可以更多，实际也是如此。使用sysconf函数来确定当前平台最多支持的终止处理程序上限。

    ```c
    #include <stdio.h>
    #include <unistd.h>
    #include <stdlib.h>
    int main() {
        printf("_SC_ATEXIT_MAX: %ld\n", sysconf(_SC_ATEXIT_MAX)); //Ubuntu22.04上结果为2147483647，也就是2^31个。
        exit(0);
    }
    ```

10. 从下图中可以看到C启动程序调用main函数，main函数会再调用用户自己写的程序。正常情况下，他们可以依次return。不过在任意位置都可以调用exit函数，exit函数内部会调用之前注册过的所有钩子函数最后调用标准I/O清理程序。然后自己再调用\_exit或\_Exit进入内核。当然main和用户函数也可以直接调用\_exit或\_Exit来直接进入内核，不过这样就无法调用钩子函数了。从C启动例程指向exit函数的箭头，这次调用并非用户主动调用，而是C启动例程自动调用的。

11. 下图展示了一个C程序是如何产生和消亡的。内核使得程序执行的唯一方法就是调用exec函数。进程自愿终止的唯一方法就是显式或隐式地调用\_exit或\_Exit函数。进程也可以非自愿地通过收到一个信号而终止。

12. <img src="Linux系统编程.assets/image-20230505103736237.png" alt="image-20230505103736237" style="zoom: 80%;" />

13. 从上图中可以看出exit函数会执行标准I/O清理，但是ISO C并不处理文件描述符，多进程以及作业控制，因此这一定义对UNIX系统是不完整的。

14. ISO C定义了\_Exit函数，是为了给进程提供一种无需执行终止处理程序或信号处理程序而终止的方法。对于标准I/O流是否冲洗，取决于实现，在UNIX系统中，\_Exit和\_exit是同义的，都不冲洗标准I/O流。\_exit由exit调用。

15. 通过fork创建子进程时，子进程会继承注册记录。但是通过exec函数后，会清除注册记录。

16. 例子，测试钩子函数：

       ```c
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>
       static void my_exit1(void) {
           printf("my_exit1 is done\n");
       }
       static void my_exit2(void) {
           printf("my_exit2 is done\n");
       }
       int main(void) {
           if (atexit(my_exit2) != 0) {
               perror("can’t register my_exit2");
               exit(2);
           }
           if (atexit(my_exit1) != 0) {
               perror("can’t register my_exit1");
               exit(11);
           }
           if (atexit(my_exit1) != 0) {
               perror("can’t register my_exit1");
               exit(12);
           }
           printf("main is done\n");
           return 0; //return 0和exit(0)都会导致钩子函数被调用，会依次调用my_exit1,my_exit1,my_exit2三个函数；_exit(0)和_Exit(0)都不会。
       }
       ```

17. 钩子函数的典型用法：在打开多个文件时，如果后面的文件打开失败，为了防止内存泄露，需要关闭之前打开的所有文件，再调用exit，可以使用钩子函数来完成这一操作。类似于C++中的析构函数。

      ```c
      void closefd1(void){
          close(fd1);
      }
      fd1 = open();
      if(fd1<0){
          perror();
          exit(1); //exit只会关闭标准I/O，不会管系统I/O。
      }
      atexit(closefd1);   //当fd1成功打开后，立刻注册钩子函数，这样一旦后续的文件打开失败，exit时会自动释放掉fd1的内存。
      ```

18. 如果发生了意外的不可控的错误，就应该调用\_exit或\_Exit直接退出或者调用abort()得到一个coredump，而不是调用exit()。因为后者会刷新各种流，调用钩子函数，进而会扩大错误的影响范围。


## 命令行参数分析

1. 当通过shell执行一个新的程序时，shell会收集命令行参数，然后在exec时传递过去。POSIX.1和ISO C都要求argv[argc]为NULL，这样可以不通过argc也可以获得命令行参数的个数。

   ```c
   for (int i = 0; i < argc; i++) //可以遍历命令行参数
   for (int i = 0; argv[i] != NULL; i++) //也可以
   ```

2. 可以使用echo命令来观察展开的命令行参数，但是echo不回显第0个参数（即echo本身）：

   ```shell
   zj@hit:~/linux_c/process$ echo ls *.c #这句话的输出会展示当去掉echo直接输出时，shell得到的命令行参数的样子。
   ls -l exec.c fork.c mydaemon.c mysu.c shell.c test.c uid.c wait.c
   zj@hit:~/linux_c/process$ `echo ls -l *.c`   #可以用` `或$( )将命令括起来，这样可以将一个命令的输出作为另一个命令的一部分来执行。
   -rw-rw-r-- 1 zj zj    0 May  8 00:47 exec.c
   ...
   ```

3. 命令行参数的使用方法非常灵活，需要专门的函数分析，几乎所有的程序都是使用这两个函数来解析的：

   ```c
   //常见的命令行参数的用法，有时顺序可以随意安排：
   //纯选项 -v(短) --version(长)
   //多个短选项可以连用 -abc(等价于 -a -b -c)
   //带参数的选项 -a xx
   //纯参数 xx
   
   #include <unistd.h>
   int getopt(int argc, char * const argv[], const char *optstring); //前两个参数是命令行参数，将main函数获取到的对应变量传过来即可，optstring是要分析的选项，不包括-。如果成功找到了一个选项，则返回该字符。如果没有则返回-1。
   //argv中以-开头的每个字符串("-"和"--"除外)都会被认为是一个选项。除了开头的-以外的另一个字符(因为getopt只能处理短选项)被认为是该选项的特征字符，可以放到optstring中。getopt也可以处理短选项连用的情况，-abc会自动当作三个选项 -a -b -c。
   //关联的全局变量
   extern char *optarg;
   extern int optind, opterr, optopt;
   #include <getopt.h>
   int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex);
   ```

4. 带参数的选项连写需要注意：  -my 4相当于 -m -y 4。如果要用touch创建一个名为-a的文件，不能用touch -a，因为此时-a会被认为是选项，应该用touch ./-a。或者用touch -- -a，其中--表示选项传参结束。

5. 在optstring开头加一个 - ，可以获取非选项的传参，每个非选项的传参都被认为是选项为-1的传参，例如 ls -l /etc中的/etc，其中l后面没有 : ，即表示它没有对应的选项参数，即/etc是非选项参数，此时相当于ls -l -1 /etc。

6. 全局变量optind记录着当前getopt要获取argv的下一个字符串的下标(index)，初始为1，即argv[optind - 1]为当前选项的命令行字符串。如果还想再处理一套命令行参数或者一个参数向量，可以将optind设置为1，然后执行getopt函数。

7. ```c
   int c = getopt(argc,argv,"HMSy:md"); //函数会逐个从argv中取出字符串，来比对是否等于"-H","-M"等。如果成功就返回匹配到的字符串,但不包含-。如果也需要接受选项后面的参数，可以在对应的字符后面加:。当匹配到有选项的参数时，全局变量optarg就指向该选项的参数。
   //例如:   ./myls -H -d -y abc -s   会跳过./myls这个非选项传参，当处理到-c时，optarg会指向abc字符串。
   //有些情况下参数并非是和选项相关联的，例如 ls -l /etc 其中/etc就不是-l的参数。
   ```

8. 正常的处理流程：

   ```c
   while(1){
       int c = getopt(argc,argv,"-HMSy:md");
       if (c<0)
           break;  //找不到匹配的选项
       switch(c){
           case 1:  //非选项的传参
               break;
           case H:
               break;
           case y:
               break; //待选项的传参，可以使用optarg来获取该选项对应的参数。
           ...
           default:
               exit();
       }
   }
   ```


## 环境变量

1. 较早时候，大多数的UNIX系统支持main函数带三个参数的，第三个参数就是环境变量，但是ISO C规定main函数只有两个参数，因此POSIX.1也规定使用environ来代替第三个参数。

    ```c
    int main(int argc, char* argv[], char* envp[]); //该参数随即可被视为environ变量来使用，所不同的是，该参数的作用域在main()函数内。虽然UNIX系统普遍实现了这一特性，但还是要避免使用，因为除了局限于作用域限制外，该特性也不在SUSv3的规范之列。
    ```

2. UNIX内核并不关心环境变量。它的解释完全取决于各个应用程序。例如shell使用了大量的环境变量，例如USER和PATH等，程序也使用，例如LS_COLORS。通常在一个shell的启动文件中设置环境变量，以控制shell的行为。POSIX.1定义了一些环境变量，例如LC_ALL，PATH等，而ISO C并没有定义任何环境变量。

3. 进程的环境变量是以键值对的方式存储，key="value"。等号两侧不能空格。

4. 每个程序都有一个环境表，和参数表一样，都是字符指针数组。在程序内使用全局变量environ来获取，C运行时启动代码定义了该变量并以环境列表位置为其赋值：

    ```c
    extern char **environ;  //也称为环境指针,使用方法和argv一样，不过没有argc来计数，而是用来NULL来标记字符指针数组的结束。
    for (int i =0; environ[i] != NULL;i++){
        printf("%s\n",environ[i]);
    }
    ```

5. 可以使用env命令查看当前shell的环境变量，export命令用来设置环境变量，如果不加参数表示显示当前的环境变量，它会比env少一个变量   _=/usr/bin/env   。

   ```shell
   SHELL=/bin/bash                   # env命令的输出,大多数预定义环境变量的名称为全大写字母。
   declare -x SHELL="/bin/bash"      # export命令的输出，指明了创建的方式和类型。
   ```

6. 通常通过以下环境变量相关的操作函数来使用环境变量，而不是直接使用environ变量，但若要查看整个环境变量，则必须使用environ指针：

   ```c
   #include <stdlib.h>  //getenv是ISO C定义的，其余都是POSIX.1额外定义的。
   char *getenv(const char *name);   //根据键名获取对应的值。如果不存在对应的环境变量，则返回NULL。
   int setenv(const char *name, const char *value, int overwrite); //如果name不存在，则创建；如果name存在，且overwrite非0，则先删除现有的定义，再创建一个新的，值为value。如果name存在，且overwrite为0，则什么也不做。不应在name的结尾处或者value的开始处提供一个=字符，因为setenv()会自动添加=。
   int unsetenv(const char *name);   //删除一个环境变量的定义，即使name不存在也不会报错。等价于unset命令。
   int putenv(char *string);  //string的形式为"name=value"。如果name存在，则会先删除旧的，再添加新的，string没有const修饰，也无法控制覆盖与否，修改string也会修改环境变量的值，不推荐使用。失败将返回非0 值，而非−1。该函数的glibc实现还提供了一个非标准扩展。如果string参数内容不包含一个=，那么将从环境列表中移除以string参数命名的环境变量。
   ```

7. SUSv3规定应用程序不应修改getenv()函数返回的字符串，这是由于该字符串实际上属于环境的一部分，若需要改变一个环境变量的值，可以使用setenv()函数或putenv()函数。

8. SUSv3允许getenv()函数的实现使用静态分配的缓冲区返回执行结果，这样就可以通过直接修改返回值来环境变量，但是glibc没有这么实现，

9. putenv和setenv的差异：很多实现中，putenv直接将string放入到环境表中，而string一般作为局部变量，期待putenv自己分配空间，否则函数返回后，栈上的空间就被释放了。setenv会自己分配空间来用name和value来构造环境字符串，不会出现上述情况。

10. 有时需要清除整个环境，然后以自定义值进行重建。例如为了以安全方式执行set-user-ID程序。可以通过将environ变量赋值为NULL来清除环境，或者使用clearenv函数：

    ```c
    #include <stdlib.h>
    int clearenv(void);
    //许多UNIX实现都支持clearenv()函数，但是SUSv3没有对此函数进行规范。SUSv3允许应用程序清空自身环境的唯一方法就是逐一调用unsetenv()移除每个环境变量。
    ```

11. 如果setenv()函数和putenv()函数发现environ参数为NULL，则会创建一个新的环境列表，并使environ参数指向此列表。

12. 反复调用这setenv和clearenv函数会不断产生内存泄露。因为setenv会分配的一块内存缓冲区。而调用clearenv并不会释放该缓冲区，因为它不知道该缓冲区的存在。实际上，这个问题不大，因为程序通常仅在启动时调用clearenv一次，用于移除继承自其父进程（即调用exec()函数来启动当前程序的程序）环境中的所有条目。

13. fork创建的子进程会继承父进程的环境变量，这也是一种父子进程通信的机制，但是是单向和一次性的。子进程创建后，父、子进程均可更改各自的环境变量，且这些变更对对方而言不再可见。

14. 环境变量的常见用途之一是在shell中。通过在shell的环境中放置变量值，shell就可确保把这些值传递给其所创建的进程，并以此来执行用户命令。

15. 可以通过设置环境变量来改变一些库函数的行为。正因如此，用户无需修改程序代码或者重新链接相关库，就能控制调用该函数的应用程序行为。

16. 可以看到环境表和所有环境字符串最初是存储在栈的上面。几种可能的修改：

     1. 如果删除一个环境变量，则只需在环境表中找到该指针，将后续指针都向前移动一个位置，然后将最后空出来的位置的指针置为NULL即可。

     2. 如果要增加或者修改一个环境变量，要复杂的多，因为在进程空间中，它上面是内核区域，下面是栈区域，夹在二者中间，使得环境表和环境字符串都不能原地扩展。

     3. 如果setenv修改已存在的环境变量，字符串变短的话，可以直接就地修改，如果是变长的话，则需要用malloc堆上申请一块空间用于存放新的字符串，然后将新字符串复制过去，并修改环境表中对应的指针指向新分配的内存地址。

     4. 如果新添加环境变量，首先应该malloc一个空间用来存储新的环境字符串。
         1. 如果是第一次增加环境变量，则需要malloc一块空间用来存储新的环境表。然后将旧的环境表复制过来，并将新增的环境变量地址添加到新环境表的末尾，然后在环境表的末尾添加一个NULL。最后将environ指向新的环境表。虽然新的环境表移动到了堆中，但是大多数的环境字符串还是存储在原来的栈顶以上。

         2. 如果不是第一次增加环境变量，则只需realloc原先malloc的地址块，增加一个指针的空间即可。将新的环境字符串地址添加到环境表的尾部，然后添加一个NULL。



## 内存空间分配

1. 一个C程序在内存中通常由以下几部分构成：

    1. 代码段，也称为正文段，存储着可执行的指令，通常是共享，只读的。

    2. 初始化数据段，也称为数据段，包含了程序中需明确赋予初值的变量，例如函数之外的声明：int a = 9。需要在可执行文件中占据同样大小的空间，因此载入可执行文件时，直接复制过去即可。

    3. 未初始化数据段，也成为bss段，名称来源于早期汇编程序的一个操作符，意思是由符号开始的块(block started by symbol)。在程序开始执行前，内核将此段中的数据初始化为0或空指针。例如函数外的声明：int sum[3]。不在可执行文件中占据同样大小的空间，只需一个标记即可，因为它的值都是0。

    4. 栈，自动变量以及每次函数调用时所需要保存的信息（返回地址，要保存的某些寄存器的值，要传递的参数）都存放在此段中，递归函数在栈上会产生多个栈帧，这样他们之间互不影响。

    5. 堆，动态内存分配的区域。位于未初始化数据段和栈之间，堆的顶部称为program break。

2. 上面的段（segment）不应与一些硬件体系架构，比如x86-32 中使用的硬件分段（segmentation）相混淆。相反，上面的段是对UNIX系统中进程虚拟内存的逻辑划分。有时，会使用术语区（section）来替代段，因为在ELF规范中，采用的术语区更趋一致。

3. 一个C程序可执行文件中，不包含栈和堆这2个段，但是还包含符号表的段，调试信息段，共享库信息段等。不过后面这些段都不会载入内存。size命令可以查看一个可执行文件中各个段的大小：

    ```shell
    zj@hit:~/linux_c/process$ size test
       text    data     bss     dec     hex filename
       1579     616       8    2203     89b test
    ```

4. Intel x86处理器下的Linux内存布局如下图，进程的虚拟空间是4G，0x08048000到0xc0000000(3G)是给用户使用的，3G-4G的部分是给内核使用的。64位环境下，进程的虚拟空间是128T。正文段从0x08048000开始。栈底则在0xc0000000之下开始。这种结构中，栈由高地址向低地址增长。

5. <img src="Linux系统编程.assets/image-20210506184423249.png" alt="image-20210506184423249" style="zoom:80%;" />

6. 栈不一定要向低地址生长，某些硬件并没有对栈提供特殊的支持，此时C实现可能要用链表来实现栈帧。

7. 使用pmap命令查看进程的地址空间：

   ```shell
   [zj@ZJ test]$ pmap 1550   #查看进程号为1550的进程地址空间
   1550:   -bash
   0000559894e73000   1056K r-x-- bash
   000055989517a000     16K r---- bash
   000055989517e000     36K rw--- bash
   0000559895187000     40K rw---   [ anon ]  #动态分配的空间
   ...
   00007ffe3412e000    132K rw---   [ stack ] #栈
   00007ffe34183000     12K r----   [ anon ]
   00007ffe34186000      8K r-x--   [ anon ]
   ffffffffff600000      4K r-x--   [ anon ]
    total           235468K
   ```

8. 例子，各种变量的存储空间占用：

   ```c
   #include <stdio.h>
   static int g1;
   static int g2 = 0;
   static int g3 = 3;
   int g4;
   int g5 = 0;
   int g6 = 8;
   int main() {
       static int s1;
       static int s2 = 0;
       static int s3 = 3;
       int s4;
       int s5 = 0;
       int s6 = 8;
       printf("g1: %p,g2: %p,g3: %p,g4: %p,g5: %p,g6: %p\n", &g1, &g2, &g3, &g4, &g5, &g6);
       printf("s1: %p,s2: %p,s3: %p,s4: %p,s5: %p,s6: %p\n", &s1, &s2, &s3, &s4, &s5, &s6);
       getchar();
   }
   //gcc test.c -o test -m32 。输出结果为：
   zj@hit:~/linux_c/process$ ./test 
   g1: 0x565a3020,g2: 0x565a3024,g3: 0x565a3008,g4: 0x565a3018,g5: 0x565a301c,g6: 0x565a300c
   s1: 0x565a3028,s2: 0x565a302c,s3: 0x565a3010,s4: 0xffec9810,s5: 0xffec9814,s6: 0xffec9818
   
   //pmap的结果为：
   zj@hit:~/linux_c$ pmap 4658
   4658:   ./test
   000000005659f000      4K r---- test  //由于是32位程序，所以高32位地址全部为0。
   00000000565a0000      4K r-x-- test
   00000000565a1000      4K r---- test
   00000000565a2000      4K r---- test
   00000000565a3000      4K rw--- test  //g1-g6,s1-s3都在这里。因为4K=0x1000=2^12，这段的末尾地址为565a4000。这些变量有的位于初始化数据段，有的位于未初始化数据段中，但是他们都被映射到了同一个内存页中。
   00000000565cd000    136K rw---   [ anon ]
   00000000f7ce4000    128K r---- libc.so.6
   00000000f7d04000   1528K r-x-- libc.so.6
   00000000f7e82000    532K r---- libc.so.6
   00000000f7f07000      4K ----- libc.so.6
   00000000f7f08000      8K r---- libc.so.6
   00000000f7f0a000      4K rw--- libc.so.6
   00000000f7f0b000     40K rw---   [ anon ]
   00000000f7f1c000      8K rw---   [ anon ]
   00000000f7f1e000     16K r----   [ anon ]
   00000000f7f22000      8K r-x--   [ anon ]
   00000000f7f24000      4K r---- ld-linux.so.2
   00000000f7f25000    148K r-x-- ld-linux.so.2
   00000000f7f4a000     60K r---- ld-linux.so.2
   00000000f7f59000      8K r---- ld-linux.so.2
   00000000f7f5b000      4K rw--- ld-linux.so.2
   00000000ffeab000    132K rw---   [ stack ]  // s4,s5,s6都在这里
    total             2788K
   //size的结果：
   zj@hit:~/linux_c$ size process/test
      text    data     bss     dec     hex filename
      1693     324      28    2045     7fd process/test
   ```

9. ISO C提供了3个用于动态内存分配的函数，都应使用free来释放。这三个函数返回的指针一定是适当对齐，使其可以用于存储任何数据对象。例如某些系统中要求double型变量的内存地址必须为8的倍数，此时这三个函数的返回值一定也是8的倍数。

   ```c
   #include <stdlib.h>
   void *malloc(size_t size); //分配无符号数size个字节的内存空间，其中的初始值不确定。
   void *calloc(size_t nmemb, size_t size); //为size个长度为nmemb的对象分配空间，总大小为size*nmemb个字节。其中的每个字节都被初始化为0。
   void *realloc(void *ptr, size_t size);//增加或减少以前分配的内存区域ptr的长度，使之新长度为size。当增加长度时，有可能原有的位置不够，会重新分配一块更大的内存，然后将原来的内容复制过来，并释放ptr所指的空间，新增的部分的初始值不确定。应该总是使用返回值，而不是ptr的值作为新的区域的指针。如果某些指针的值正好落在该区域内，可能在realloc后，该指针就会变为无效。
   //realloc(NULL, size); 等价于 malloc(size);
   void free(void *ptr); //ptr为NULL并不会报错，但是对一个非NULL的指针二次调用free会报错。
   ```

10. malloc相比于brk来说更易于在多线程中使用，允许分配小块内存。

11. free()函数的glibc实现会在释放内存时将相邻的空闲内存块合并为一整块更大的内存，这是为了避免在空闲内存列表（双向链表）中包含大量的小块内存碎片，这些碎片会因太小而难以满足后续的malloc()请求。

12. malloc的具体实现：首先扫描空闲内存块列表，找到尺寸≥要求的一块空闲内存（采用的扫描策有首次适配或最佳适配）。如果空闲内存块的尺寸正好与要求相当，就把它直接返回给调用者。如果是一块较大的内存，那么将对其进行分割，再将一块大小相当的内存返回给调用者的同时，把较小的那块空闲内存块保留在空闲列表中。

13. 如果在空闲内存列表中找不到足够大的空闲内存块，那么malloc()会调用sbrk()以分配更多的内存。为减少对sbrk()的调用次数，malloc()并不只是严格按所需字节数来分配内存，而是以更大幅度（以虚拟内存页大小的数倍）来增加program break，并将超出部分置于空闲内存列表。

14. 当malloc()分配内存块时，会额外分配几个字节来存放记录这块内存大小的整数值。该整数位于内存块的起始处，而实际返回给调用者的内存地址恰好位于这一长度记录字节之后。这样用户在调用free时就不用指定内存块的大小了。

15. 虽然分配内存失败的可能性很小，但所有对malloc()以及后续提及的相关函数的调用都应对返回值进行错误检查。

16. 这三个函数底层通过sbrk系统调用来实现。该系统调用用来扩充或缩小进程的堆。大多数free的实现中，释放的空间并不会用sbrk归还给内核，而是保留在空闲内存列表中以便下一次分配时更加快速。大多数实现中，malloc分配一块内存，实际占用的大小要比参数大，因为还要存储一些管理信息，例如分配块的长度，下一个分配块的指针。这样free的时候就只用给出地址块的起始地址即可。

      ```c
      #include <unistd.h> //由于内存以页为单位操作，所以分配回比实际要求的多。
      int brk(void *addr); //将program break设置为addr参数，成功返回0，失败返回-1。
      void *sbrk(intptr_t increment); //在program break原有地址上增加increment，intptr_t是一种整数类型。成功返回之前的program break，失败返回(void*)-1。在Linux中，sbrk()是在brk()基础上实现的一个库函数。
      //调用sbrk(0)将返回program break的当前位置，对其不做改变。在意图跟踪堆的大小，或是监视内存分配函数包的行为时，可能会用到这一用法。
      ```

17. 在program break的位置抬升后，程序可以访问新分配区域内的任何内存地址，但此时物理内存页尚未分配。内核会在进程首次试图访问这些虚拟内存地址时自动分配新的物理内存页。

18. 在动态分配的空间中写越界，可能会修改掉块大小记录，或其他块的内容。

19. 内存泄漏越多，可用的内存空间就越少，换页行为就越频繁，性能下降越大。

20. 当进程终止时，其占用的物理内存都会返还给操作系统，这包括malloc分配的。基于这一自动释放机制，对于那些分配了内存并在进程终止前持续使用的程序而言，通常会省略对free()的调用。这在程序中分配了多块内存的情况下可能会特别有用，因为加入多次对free()的调用不但会消耗大量的CPU 时间，而且可能会使代码趋于复杂。但是显式调用free()能使程序在未来修改时更具可读性和可维护性。如果使用malloc调试库来查找程序的内存泄漏问题，那么会将所有未经
      显式释放处理的内存报告为内存泄漏。这会使发现真正内存泄漏的工作复杂化。

21. 一些系统中支持程序使用自定义的动态内存分配和释放函数（链接时指定即可），进行附加检错。替代的库有：libmalloc，alloca(在栈上分配，这样在函数返回时，就会自动释放)，TCMalloc，jemalloc（FreeBSD8.0中默认的）等。

22. glibc提供了发现内存泄漏的工具：

     1. mtrace和muntrace函数分别在程序中打开和关闭对内存分配调用进行跟踪的功能。它们要与环境变量MALLOC_TRACE搭配使用，该变量定义了写入跟踪信息的文件名。在被调用时，mtrace()会检查是否定义了该文件，又是否可以打开文件并写入。如果一切正常，那么会在文件里跟踪和记录所有对malloc 函数包中函数的调用。由于生成文件不易于理解，还提供有一个脚本（mtrace）用于分析文件，并生成易于理解的汇总报告。出于安全原因，设置用户ID和设置组ID的程序会忽略对mtrace()的调用。

     2. mcheck()和mprobe()函数允许程序对已分配内存块进行一致性检查。当程序试图在已分配内存之外进行写操作时，它们将捕获这个错误。这些函数提供的功能和malloc调试库有重复之处。使用时，需要链接mcheck库。

     3. `MALLOC_CHECK_`环境变量提供了类似于mcheck()和mprobe()函数的功能。区别在于MALLOC_CHECK_无需对程序进行修改和重新编译。通过为此变量设置不同的整数值，可以控制程序对内存分配错误的响应方式：0忽略错误，1在标准错误输出中打印诊断错误，2调用abort()来终止程序。并非所有的内存分配和释放错误都是由`MALLOC_CHECK_`检测出的，它所发现的只是常见错误。但是，这种技术快速、易用，较之于malloc 调试库具有较低的运行时开销。出于安全原因，设置用户ID和设置组ID的程序将忽略`MALLOC_CHECK_`设置。

23. 除了使用glibc附带的malloc工具之外，还可以使用malloc调试库。它提供了和标准malloc函数包相同的API，但附加了捕获内存分配错误的功能。要使用它，需要在编译时链接调试库，而非标准C函数库的malloc函数包。由于调试库通常会降低运行速度，增加内存消耗，或是两者兼而有之，应当仅在调试时使用，而在正式发布产品时链接标准库的malloc包。常用的有：Electric Fence，dmalloc，Valgrind，Insure++。Valgrind 和Insure++能够发现许多堆内存分配之外的其他类型错误。

24. glibc中还有一些非标准函数，可用于监测和控制malloc包中函数的内存分配，但是它们不具备可移植性：

     1. mallopt()能修改各项参数，以控制malloc()所采用的算法。例如规定了从堆中分配的内存块大小的上限，超出上限的内存块则使用mmap()系统调用。

     2. mallinfo()函数返回一个结构，其中包含由malloc()分配内存的各种统计数据。

25. alloca函数可以通过移动栈顶指针来从栈上动态分配内存。因为当前函数的栈帧位于堆栈的
     顶部，故而这种方法是可行的。

     ```c
     #include <alloca.h>
     void* alloca(size_t size); //size和返回值类似于malloc。
     //不需要（实际上也绝不能）调用free()来释放由alloca()分配的内存。同样，也不可能调用realloc()来调整由alloca()分配的内存大小。虽然alloca()不是SUSv3的一部分，但大多数UNIX实现都提供了此函数，因而也具备可移植性。
     ```

26. 若调用alloca()造成堆栈溢出，则程序的行为无法预知。不能在一个函数的参数列表中调用alloca()。这会使alloca()分配的堆栈空间出现在当前函数参数的空间内（而函数参数都位于栈帧内的固定位置）

     ```c
     func(x,alloca(size)); //错误
     //修改成以下才可以
     void* y = alloca(size);
     func(x,y);
     ```

27. alloca()分配内存的速度要快于malloc()，因为编译器将alloca()作为内联代码处理，并通过直接调整堆栈指针来实现。此外，alloca()也不需要维护空闲内存块列表。

28. alloca()分配的内存随栈帧的移除而自动释放，也就是当调用alloca的函数返回时，因为函数返回时会重置栈顶指针寄存器，使其指向前一帧的末尾。这样在函数的所有返回路径中都不用去释放已分配的内存，这使得编程简化了很多。

29. 在信号处理程序中调用longjmp()或siglongjmp()以执行非局部跳转时，alloca()的作用尤其突出。此时，在起跳函数和落地函数之间的函数中，如果使用了malloc()来分配内存，要想避免内存泄漏就极其困难，甚至是不可能的。与之相反，alloca()完全可以避免这一问题，因为栈是由这些调用展开的，通过调整栈指针自然释放了栈中所分配的内存。


## 装载库

1. 动态库和静态库都是在编译时确定库的名称的，而装载库时运行时才知道要库的名称。

2. 一些无关紧要的库或插件在程序启动时如果装载失败，会先跳过，可以后续让用户手动启动。

3. 手工装载库依赖的函数：

   ```c
   #include <dlfcn.h>        //使用的时候要加上链接选项 -ldl
   void *dlopen(const char *filename, int flags);  //打开filename这个库，flags为打开方式。返回的是一个handle。filename可以是绝对或相对路径，也可以在默认路径(例如/usr/lib等)下搜寻的文件。
   int dlclose(void *handle);  //关闭这个库
   void *dlsym(void *handle, const char *symbol);   //在一个成功打开的库handle中寻找某个symbol的地址。
   char *dlerror(void); //当dlopen族的函数出错时，通过该函数可以获取到一个出错信息。如果没出错，则返回NULL。
   ```

4. 例子，手工装载math库，执行cos函数：

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <dlfcn.h>
   #include <gnu/lib-names.h>  /* Defines LIBM_SO (which will be a string such as "libm.so.6") */
   int main(void){
       void *handle;
       double (*cosine)(double); //定义一个函数指针
       char *error;
   
       handle = dlopen(LIBM_SO, RTLD_LAZY);   //RTLD_LAZY,延迟绑定，即等到使用时再装载。
       if (!handle) {
           fprintf(stderr, "%s\n", dlerror());
           exit(EXIT_FAILURE);
       }
       dlerror();    /* Clear any existing error */
       cosine = (double (*)(double)) dlsym(handle, "cos");
       // *(void **) (&cosine) = dlsym(handle, "cos"); 强转换换完就成void*赋值给void*了。由于C99标准唯独没有对void*转化为函数指针的情况进行定义，所以不能直接赋值，早期就使用这种方法，而POSIX.1-2013中对这一情况进行统一规定，因此可以使用上面的简化写法，进行强制转化了。
       error = dlerror();
       if (error != NULL) {
           fprintf(stderr, "%s\n", error);
           exit(EXIT_FAILURE);
       }
       printf("%f\n", (*cosine)(2.0));   //使用函数指针来调用对应的函数时，要加上*。
       dlclose(handle);
       exit(EXIT_SUCCESS);
   }
   ```


## setjmp longjmp

1. C语言中goto关键字不能够跨函数跳转，看上去执行路径跳转过去了，但是没有对栈进行恢复。当出现函数的嵌套调用时，例如main→A→B→C，此时如果C函数中出现了非致命错误，需要重新开始新一轮的A→B→C的调用。此时最快的方法就是从C函数直接跳转到main函数，就需要setjmp和longjmp这两个函数，否则就需要在B和A函数中进行返回值判断，决定上一次调用是否正确，特别麻烦。

   ```c
   C(){
   }
   B(){
       C();
   }
   A(){
   	B();
   }
   int main(){
       char line[1024];
       while(fgets(line,1024,stdin)){ //不断地从中断获取输入，然后调用A来处理。如果在调用链A→B→C中的某一个出问题时，最好直接返回到这里，报错，然后开始下一次的循环。
           A();
       }
   }
   ```

2. 这两个函数对于处理发生在深层嵌套调用中的出错情况非常有用。他们被称为非局部goto，会在栈上跳过若干调用帧，返回到当前调用路径上的某个函数中，相当于这些栈帧被丢弃了。

3. 在C语言中，所有函数作用域的层级相同，都是在最外层（即标准C语言不支持嵌套函数申明，尽管gcc将此功能作为其扩展功能），所以goto语句不能应用于函数间跳转。给定两个函数X和Y，编译器不知道当调用Y时，X函数的栈帧是否在栈上，所以也无法判断从Y函数跳转（goto）到X函数是否可行。

4. 支持嵌套函数声明的语言，比如Pascal语言，允许goto从一个嵌套函数跳转到其调用者，编译器可以根据函数的静态作用域来确定函数动态作用域的某些信息。因此，编译器若在词法解析时获悉函数Y嵌套于函数X 之内，也必然能够推断当调用Y时，X函数的栈帧一定已然在栈中存在（即动态作用域），并能为函数Y产生goto代码，从Y中跳转到X函数的某处。

5. 例如在进行递归查找的时候，如果查找到了某个内容，就可以通过跨函数跳转立刻返回到最高层。还有就是在内层函数中抛出异常，则也会用到跨函数跳转到异常处理程序。

   ```c
   #include <setjmp.h>
   int setjmp(jmp_buf env);   //设置跳转点，env存放着用来恢复栈状态的所有信息，同时也标识该跳转点的，longjmp的第一个参数要用到，因此一般定义为（静态）全局变量。直接执行来设置跳转点时，返回0; 从longjmp跳转回来时，返回值为longjmp的第二个参数。这种行为类似于fork，一次调用，两次返回，不过还是单一进程。
   void longjmp(jmp_buf env, int val);  //进行长跳转，跳转到使用setjmp设置env的地方，并带回非零值val。如果val被设置为了0，则会被修改为1。之所以有val，是因为一个setjmp可以对应于多个longjmp，val用来区分它们。该函数永远不会返回。
   ```

6. 一般来说，env中存放着栈指针，指令指针，一些其他寄存器的值和信号屏蔽字。

7. 例子：执行到C函数时，立刻返回到A函数的setjmp中继续执行，跳过从C函数返回到B函数和从B函数返回到A函数的过程。然后因为在第5行中ret不等于0，所以程序会执行else分支，然后从A正常结束。

   ```c
   #include <stdio.h>
   #include <unistd.h>
   #include <stdlib.h>
   #include <setjmp.h>
   static jmp_buf jmp_save;  //使用静态全局变量在不同函数共享变量。
   void C() {
       printf("C() Begin\n");
       if (1) {
           longjmp(jmp_save, 3);  //直接回到第32行的位置，返回值为3。
       }
       printf("C() End\n"); //不会被调用
   }
   void B() {
       printf("B() Begin\n");
       if (0) {
           longjmp(jmp_save, 2);
       }
       C();
       printf("B() End\n"); //不会被调用
   }
   void A() {
       printf("A() Begin\n");
       if (0) {
           longjmp(jmp_save, 1);
       }
       B();
       printf("A() End\n"); //不会被调用
   }
   int main() {
       char line[1024];
       int ret;
       ret = setjmp(jmp_save); //第一次为主动调用ret=0，后续为longjmp调用。
       if (ret == 0) {
           while (fgets(line, 1024, stdin)) { //不断地从中断获取输入，然后调用A来处理。如果在调用链A→B→C中的某一个出问题时，最好直接返回到这里，报错，然后开始下一次的循环。
               A();
           }
       } else {
           switch (ret) {  //出错分类
           case 1:
               printf("longjmp back from A()\n");
               break;
           case 2:
               printf("longjmp back from B()\n");
               break;
           case 3:
               printf("longjmp back from C()\n");
               break;
           default:
               printf("Error!");
               break;
           }
       }
   }
   //运行程序，输出为：
   zj@hit:~/linux_c/process$ ./test 
   A() Begin
   B() Begin
   C() Begin
   longjmp back from C()
   ```

8. 之所以可以进行长跳转或goto这些操作，是因为C语言可以通过内嵌汇编来打破自己构建的栈帧，直接操作栈内存结构。

9. longjmp会丢弃部分栈帧，将执行序列回到setjmp的位置。但是对于自动变量和寄存器变量并不保证恢复到第一次调用setjmp时的状态。

10. 例子：自动变量，寄存器变量，易失变量，局部静态变量，（静态）全局变量在longjmp后的变化。 

    ```c
    #include <stdio.h>
    #include <unistd.h>
    #include <stdlib.h>
    #include <setjmp.h>
    static jmp_buf jmpbuffer;
    static int globval;  //全局变量
    static void f2(void){
        longjmp(jmpbuffer,1);
    }
    static void f1(int i, int j, int k, int l){
        printf("in f1():\n");
        printf("globval = %d, autoval = %d, regival = %d, vloaval = %d, statval = %d\n", globval, i, j, k, l);
        f2();
    }
    int main(){
        globval = 1;
        int autoval = 2;
        register int regival = 3;
        volatile int volaval = 4;
        static int statval = 5;
        if(setjmp(jmpbuffer)!=0){ //longjmp之后
            printf("after longjmp:\n");
            printf("globval = %d, autoval = %d, regival = %d, vloaval = %d, statval = %d\n",globval,autoval,regival,vloaval,statval);
            exit(0);
        }
        //setjmp之后，longjmp之前
        globval = 95;
        autoval = 96;
        regival = 97;
        volaval = 98;
        statval = 99;
        f1(globval,autoval,regival,vloaval,statval);
    	exit(0);
    }
    //如果不进行优化的编译gcc test.c -o test，执行结果为：
    in f1():
    globval = 95, autoval = 96, regival = 97, vloaval = 98, statval = 99
    after longjmp:
    globval = 95, autoval = 96, regival = 3, vloaval = 98, statval = 99
    //如果进行优化的编译gcc test.c -O -o test，执行结果为：
    in f1():
    globval = 95, autoval = 96, regival = 97, vloaval = 98, statval = 99
    after longjmp:
    globval = 95, autoval = 2, regival = 3, vloaval = 98, statval = 99
    ```

11. setjmp规定了存储在存储器上的变量将具有longjmp时的值，即不会恢复。而CPU寄存器中的变量将会恢复为setjmp时的值。一般来说全局变量，静态变量，易失变量总是放在存储器上。有些编译器不优化的话，寄存器变量会存储在寄存器上，而自动变量存储在内存中，优化时，自动变量会存储在寄存器中。为避免编译器优化所引发的问题，应使用volatile修饰符声明变量。

12. 非局部跳转比goto使得程序更难阅读，因为它能在程序中任意两个函数间传递控制。在编写信号处理器时，这些函数偶尔还会派上用场，例如sigsetjmp()函数和siglongjmp()。

## 资源获取和控制

1. 每个进程都有一组资源限制，资源获取和控制函数如下：

   ```c
   #include <sys/time.h>
   #include <sys/resource.h>
   int getrlimit(int resource, struct rlimit *rlim); //获取resource资源限制，将结果存储到rlim中。resource是众多宏中的一个，例如RLIMIT_STACK，和ulimit中显示的对应。
   int setrlimit(int resource, const struct rlimit *rlim); //使用rlim设置当前resource的limit。
   struct rlimit {
       rlim_t rlim_cur;  //软限制，必须要小于等于硬限制。rlim_t是对unsigned long的封装。
       rlim_t rlim_max;  //硬限制。用RLIM_INFINITY来表示unlimited。
   };
   ```

2. 进程的资源限制通常在系统初始化时，由0号进程建立，然后由后续进程继承或修改。

3. 子进程会继承其父进程的资源限制。为了影响一个用户的所有后续进程，需要将资源限制的设置构造在shell中，例如ulimit。类似的umask，chdir也必须是shell内置的。因为修改的是当前进程，而非新产生的子进程。

4. 更改资源限制需要满足三点：

   1. 任何进程都可以将软限制修改为<或等于硬限制。
   2. 任何进程都可以降低硬限制，但必须>或=其软限制。这种降低对于普通用户是不可逆的。
   3. 只有超级用户进程可以提高硬限制。

5. 常见的资源：

   ```shell
   RLIMIT_AS     #进程总的可用存储空间的最大长度(字节)，这影响sbrk和mmap函数。
   RLIMIT_CORE   #core文件的最大字节数，若为0，则组织创建core文件。
   RLIMIT_CPU    #进程可用CPU时间的最大值，若超过此限制，该进程会收到SIGXCPU信号
   RLIMIT_DATA   #数据段的最大长度(字节)。进程的内存空间中初始化数据段，未初始化的数据段，堆的总和。
   RLIMIT_FSIZE  #可以创建的文件的最大长度(字节)，若超过此限制，该进程会收到SIGXFSZ信号。
   RLIMIT_MEMLOCK #使用mlock能够锁定在内存中的最大长度(字节)。
   RLIMIT_MSGQUEUE #进程为POSIX消息队列可分配的最大存储字节数。
   RLIMIT_NICE  #进程的调度优先级(友好值)，可以设置的最大值。
   RLIMIT_NOFILE  #进程能打开的文件数量上限，更改此限制将影响sysconf(_SC_OPEN_MAX)返回的值。
   RLIMIT_NPROC   #每个实际用户ID可拥有的最大子进程数量，更改此限制将影响sysconf(_SC_CHILD_MAX)返回的值。
   RLIMIT_NPTS   #用户可同时打开的伪终端数。
   RLIMIT_RSS    #进程最大驻留内存集长度(字节)，如果可用的内存非常少，则内核将从进程回收超过RSS的部分，发生内存交换。
   RLIMIT_SBSIZE #任意时刻，用户可以占用的套接字缓冲区(socket buffer)的最大长度(字节)
   RLIMIT_SIGPENDING #一个进程可以排队的信号最大数量。具体由sigqueue来实现这个限制。
   RLIMIT_STACK  #栈的最大长度(字节)
   RLIMIT_SWAP   #用户可使用的交换空间的最大长度(字节)
   RLIMIT_VMEM   #和RLIMIT_AS相同。
   ```

# 进程

1. 每个进程都有一个非负整数表示的唯一进程ID，它在整个系统中不重复。因此程序可以使用进程ID作为名字的一部分来创建一个唯一的文件，例如coredump文件。进程ID是可以被复用的。当进程终止后，它的ID会被回收，其他进程可以用。大多数UNIX采用的是延迟分配的算法，并不会刚回收的进程ID分配出去。这样是为了防止被认错为同ID的旧进程。

2. 进程标识符的类型为pid_t，一般为有符号的16位整型数，因此，最多同时运行32767个进程（从1开始计数），一般来说是够用了，但是虚拟机出来后，可能会不够用，如果不够用，可以typedef，然后重新编译内核来修改。ulimit中没有规定进程的最多个数，因此以这个数据类型来限制。进程号的使用顺次循环使用，不会插空，这一点和文件描述符的规则不同（优先使用可能用的最小的那个）。

   ```c
   #include <sys/types.h>
   #include <unistd.h>
   //以下两个函数总会成功
   pid_t getpid(void);    //获取当前进程的PID
   pid_t getppid(void);   //获取父进程的PID
   ```

3. Linux 内核限制进程号需小于等于32767。新进程创建时，内核会按顺序将下一个可用的进程号分配给其使用。每当进程号达到32767的限制时，内核将重置进程号计数器为300，而不是1，因为低数值的进程号为系统进程和守护进程所长期占用，在此范围内搜索尚未使用的进程号只会是浪费时间。

4. 在Linux 2.6版本中，进程号的上线可以通过Linux系统特有的/proc/sys/kernel/pid_max文件来进行调整（其值=最大进程号+1），32位平台位32768，64位平台为2^22，约420万。

5. ID为0的进程通常是调度进程，也被称为交换进程(swapper)，它是内核的一部分，但是并不执行磁盘上的任何程序。

6. ID为1的进程为init进程，是所有进程的祖先进程，PID=1，EUID=0。在自举结束后，由内核调用，文件为/sbin/init。该进程会读取系统初始化文件，例如/etc/rc*，/etc/inittab以及/etc/init.d中的文件，并将系统引导到一个适合用户使用的状态。init进程不会终止，它不是内核的一部分，只是一个普通的用户进程，但是以超级用户特权运行。不过很多新的发行版中，使用systemd来代替init的功能。

7. 超级用户也无法杀死init进程，只有关闭系统才可以终止该进程。主要作用是创建并监控系统运
   行所需的一系列进程。

8. few代指fork，exec，wait三个函数。


## fork

1. 进程的产生：

   ```c
   #include <sys/types.h>
   #include <unistd.h>
   pid_t fork(void);  //通过复制当前进程的方式来创建一个新的进程，新进程为当前进程的子进程。该函数和setjmp类似，都是执行一次，返回两次，区别是setjmp是从同一个进程的不同函数返回，fork是从不同进程的同名函数返回。如果执行成功，父进程中返回子进程的PID，子进程返回0。如果失败，父进程返回-1，不创建子进程，且会设置errno。
   //失败的情况一般为该RUID的进程总数超过了资源限制。
   ```

2. 将子进程的ID通过fork返回给父进程的原因是一个进程的子进程可以有多个，并且没有一个函数可以使一个进程获得它所有子进程的ID。之所以给子进程返回0，是因为子进程只有一个父进程，总可以用getppid获得其父进程的ID。

3. 创建子进程一般有两个目的：

   1. 复制一个自己，例如网络服务程序，每当接收到一个请求时，就会复制一个自己去响应请求，而自己继续监听请求。

   2. 执行新的程序，例如shell。

4. 通过fork出来的进程和当前进程一模一样（相当于memcpy），都是执行到fork这一行。区别只有以下几点（不同的发行版的区别不一样）：

   1. 父子进程fork函数的返回值不同，由此可以进行父子进程的区分。
   2. 父子进程的PID和PPID都不同，子进程的PPID就是父进程的PID。
   3. 子进程不继承父进程的内存锁。
   4. 子进程的未决（还未来得及响应的）信号集被初始化为空。
   5. 子进程不继承父进程设置的文件锁。
   6. 子进程不继承父进程的信号量调整。
   7. 子进程不继承父进程的计时器（闹钟）。
   8. 子进程不继承父进程的的资源利用量，归零。
   9. CPU计时器清零。tms_utime（进程的用户态执行时间），tms_stime（进程的内核态执行时间），tms_cutime（子进程的用户态执行时间），tms_cstime（子进程的内核态执行时间）的值设置为0，这四个字段为struct tms的成员，通过times函数获取。

5. 父子进程共享的内容：

    1. EUID（有效用户ID），EGID（有效组ID），RUID（真实用户ID），RGID（真实组ID）。

    2. 附属组ID

    3. PGID（进程组ID）

    4. SID（会话ID）

    5. 控制终端

    6. SUID（设置用户ID）和SGID（设置组ID）标志

    7. 当前工作目录

    8. 根目录

    9. 文件模式创建屏蔽字，即umask

    10. 信号屏蔽字

    11. 对任一打开文件描述符的close-on-exec（exec时关闭）标志。

    12. 环境变量

    13. 连接的共享存储段

    14. 内存空间

    15. 资源限制

6. 早期的fork会完全复制一份内存，费时又占用内存，因此有了vfork来使得子进程和父进程共享内存。但是现在新版的fork使用了写时复制（copy-on-write）技术，即fork后，子进程的内存并不会完全复制一份，而是和父进程共用，如果某个进程要修改对应的内存空间，才会自己复制出来一份（要修改的内容所在的页）用于修改。谁修改，谁来拷贝。这个功能需要虚拟内存功能的支持。

7. 因为某些情况下，fork后会很快调用exec，这将导致fork中复制的内容被扔掉，造成时间的浪费，因此产生了vfork，它用于创建一个新的进程，而该进程的目的就是为了执行一个新程序。shell就是典型。vfork并不将父进程的地址空间完全复制到子进程中。因此在调用exec之前，子进程会在父进程的地址空间运行，即此时子进程对变量的修改会影响到父进程。vfork的另一个特点是，它保证子进程先运行，在它调用exec或exit之后，父进程才可能会被调度。

8. 用vfork创建的进程，只能保证成功调用exit或exec族函数，其他都属于未定义行为。综上不推荐使用vfork，而是推荐使用fork，好用有没有副作用。

9. Linux支持一种新的进程创建函数clone，它是fork的增强版，允许调用者控制父进程的哪部分和子进程共享。

10. 某些系统为fork+exec提供了一个合并系统调用spawn，分开的好处是可以在fork后，exec前进行一些I/O重定向，用户ID，信号安排的工作。

11. 产生子进程后，由调度器决定哪个进程先运行，不一定哪个先运行。如果需要父子进程按照一个特定的顺序运行，需要使用锁来保证，也可以让另一个进程睡眠一会，但是不推荐，可移植行不强。

12. 例子：

      ```c
      #include <stdio.h>
      #include <stdlib.h>
      #include <unistd.h>
      int main(){
          pid_t pid1;
          printf("[%d]:Begin\n",getpid());
      //  fflush(NULL);    //推荐刷新所有的流，清空缓冲区。
          if((pid1 = fork()) < 0){
              perror("fork()");
              exit(1);
          }
          if(pid1 == 0 ){
              printf("[%d]:Child Process\n",getpid());  //子进程中会执行该句
          }else{
              printf("[%d]:Parent Process\n",getpid()); //父进程中会执行该句
          }
          printf("[%d]:End\n",getpid());                //父子进程都会执行该句
      }
      ```

13. 上述代码运行结果如下：

      ```shell
      [zj@ZJ test]$ ./test   #终端是行缓冲设备，上面的每行后面都有一个\n，所以会无延迟地输出。
      [1841]:Begin
      [1841]:Parent Process
      [1841]:End
      [zj@ZJ test]$ [1842]:Child Process #这里命令行提示符先打印出来了
      [1842]:End
      #有时候会出现程序结束时，命令行的提示符看不到了，实际上是命令行的提示符提前输出了，即shell在上述的父进程结束后就立即输出了提示符，而后续子进程又输出了一些内容，所以就把设立了的命令提示符挡住了。shell被设定为只会等待自己的子进程，但是不会等待子进程的子进程。
      [zj@ZJ test]$ ./test >/tmp/out   #文件是全缓冲设备，遇到\n不刷新，只是换行而已，必须手动fflush。否则会到进程结束时刷新。因此在fork的时候，父进程输出缓冲区内的begin字符串也被复制过来了。\n并不保证一定不缓冲，因此推荐在fork之前要加上fflush(NULL)，刷新所有的流。
      [zj@ZJ test]$ cat a
      [1843]:Begin
      [1843]:Parent Process
      [1843]:End
      [1843]:Begin  #还是父进程填入的自己的PID
      [1844]:Child Process
      [1844]:End
      ```

14. 子进程会复制父进程的所有打开的文件描述符，好像执行了dup函数。子进程和父进程的每个相同的文件描述符共享同一个文件表项。因此共享同一个文件的偏移量，这样二者对同一个文件的读写同步。因此也会将其标准输入，输出和错误关联到同一个终端上。父进程可以先打开一个文件，然后fork，这样子进程也可以通过读写这个文件来和父进程交互。

15. <img src="Linux系统编程.assets/image-20230515221900109.png" alt="image-20230515221900109" style="zoom: 80%;" />

16. 如果父进程在创建子进程后什么也不做，只是等待子进程完成。则fork前后无需对文件描述符做任何特殊操作。因为父子进程对文件的操作不会交叉。不会发生竞争的现象。

17. 如果父子进程在fork后各自执行不同的代码段，那么fork之前，父子进程都应该关闭他们不需要的文件描述符，这样不会互相干扰。

18. pstree -p 查看进程树关系。

19. ![image-20210507111305440](Linux系统编程.assets/image-20210507111305440.png)

20. 对于一个可以并行的任务，例如寻找一定范围内的质数。如果OS可用核数只有1个的话，对于计算密集型任务，也不会有加速效果。如果有多个核，创建的子进程过多，也一定不会按照子进程数量来加速。对于I/O密集型任务，多进程可以起到加速的效果。

21. 循环创建子进程需要注意的问题：

      ```c
      #include <stdio.h>
      #include <stdlib.h>
      #include <unistd.h>
      int main(){
          pid_t pid;
          for (int i=0;i<3;i++){
              fflush(NULL);
              pid = fork();
              if (pid<0){
                  perror("fork()");
                  exit(1);
              }
              if(pid ==0){  //子进程分支
                  printf("child:[%d]\n",getpid());
                  //sleep(1000);
                  exit(0); //在循环内部fork时，子进程必须要有exit，否则子进程也会继续循环，执行第6行，进而fork孙子进程。1 → 1+2 → 1+3 2+4 → 1+5 3+6 2+7 4+8
              }
          }
          //sleep(1000);
          exit(0);
      }
      ```

22. 上面程序中的两处sleep分别起作用时会出现如下状况：

      1. 仅15行起作用时，每个子进程都休眠1000s，此时父进程很快创建完所有的子进程后会先结束。此时子进程的状态都为S，即可中断的睡眠态，且他们的父进程都会变成init。因为父进程消亡后，子进程并不会被爷爷进程接管，而是直接被init接管。init也要等到这些由它接管的进程sleep都结束了才可以为其收尸，因为无法为正在运行的程序收尸。
      2. 仅19行起作用时，父进程休眠1000s，因此子进程会先结束。此时子进程的状态都为Z，僵尸态，等待父进程给他们收尸，父进程为睡眠态。而本程序中，父进程也没有为子进程收尸的语句，因此在父进程结束后，子进程会先变成孤儿，然后再被init收尸。

23. 僵尸进程偶尔出现，一闪即过，可能是他的父进程正在忙，暂时没有时间收尸。一个僵尸进程只占用一个结构体，其中包含了它的退出状态，且最宝贵的资源是PID。

24. 任何一个进程终止时，内核会逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是则该进程的父进程会被修改为1，这样确保了每个进程都有父进程。

25. 内核为每个终止的进程保留了一定量的信息，因此其父进程调用wait或waitpid时，可以得到子进程的终止状态。这些信息至少包括：子进程的进程ID，终止状态，使用的CPU时间统计。

26. 内核可以释放终止进程所使用的内存，关闭其打开的文件。

27. 如果一个要长期运行的进程，fork了很多子进程，但是都没为子进程收尸，就会产生很多僵尸进程。

28. init进程被设计为负责任的，他会在它的每个子进程终止后，调用wait获得其终止状态，这样就可以防止系统中产生大量的僵尸进程。


## wait

1. wait的含义是等待进程状态发生变化。

2. 当一个进程正常或异常终止，内核就向其父进程发送SIGCHILD信号，像子进程终止这种异步事件使用信号非常方便。对于这个信号，父进程可以选择忽略（默认），也可以为其注册一个信号处理程序。

3. 当一个父进程调用wait时：

    1. 如果其所有子进程都还在运行，则父进程阻塞。

    2. 如果一个子进程已经终止，正在等待父进程获取终止状态，则父进程取得该子进程的终止状态后立即返回。

    3. 如果它没有任何子进程，则立即出错返回。因为任何时刻，wait系列函数都只能为其子进程收尸。

4. wait的调用可以是在任意时间点调用（此时可能会阻塞），也可以是在SIGCHILD的信号处理函数中调用（此时会立即返回）。

5. wait系列函数是等待子进程的状态发生改变（正常终止，被信号终止，被信号恢复），对于正常终止的进程，wait程序会释放和它相关的资源，否则进程会变为僵尸态。

6. wait无法指定为哪个子进程收尸，哪个先结束就先为哪个收尸。调用wait后，父进程会阻塞，等待一个信号通知它子进程的状态改变了。但是如果子进程出问题了，父进程可能永远无法被唤醒。

7. 在shell中运行程序，有时候shell提示符会先跳出来，后面还会打印别的内容，这种情况一般为，运行的程序比它的子进程先结束了，同时没有wait子进程。如果在父进程的结束前加上wait函数，父进程就会阻塞，直到所有的子进程都结束，父进程为子进程收尸。然后父进程结束，shell为父进程收尸，最后shell显示出命令提示符。

8. ```c
   #include <sys/types.h>
   #include <sys/wait.h>
   pid_t wait(int *status);  //等待子进程状态发生变化，将进程的终止状态(不是exit的退出码)保存在参数status中（如果不关心，可以用NULL）。如果成功，返回终止的子进程的PID。失败返回-1。 该函数时一直等待，直到任意一个进程状态变化，阻塞式的。
   pid_t waitpid(pid_t pid, int *status, int options);//可以指定要为其收尸的pid，option可以是多个选项的或，如果包含WNOHANG，则将该阻塞操作变为非阻塞的。如果当前没有子进程退出等待收尸，则立即返回0，如果有子进程处于待收尸状态，父进程会为其收尸，并立即返回。
   
   //status是可以看做是一个位图，可以用以下宏来检测对应的位：
   WIFEXITED(status);   //该宏是用来检测进程的退出状态是否是正常退出(调用exit(), _exit()或从main函数return)。正常退出时可以执行WEXITSTATUS(status)宏来获取退出码(exit的参数或return的值)。
   WIFSIGNALED(status); //检查进程是否是由信号终止的。如果为真则可以通过WTERMSIG(status)来获取信号编号。如果为真，有些实现还可以用WCOREDUMP(status)来检查是否产生了coredump文件。
   WIFCONTINUED(status) //如果子进程是接收到了SIGCONT信号而重新运行则为真，从Linux2.6.10才有。
   //当一个进程被停止或由停止继续执行时，也会发生状态变化，此时也可以由wait获取到：
   
   ```

9. waitpid中的第一个参数pid可以有以下几种情况：

   1. = -1，等待任何一个子进程，此时和wait等价。
   2. < -1，子进程.PGID == |参数|。
   3. ==  0，子进程.PGID == 调用进程.PGID，和父进程同组的任意一个进程。
   4. \>  0，PID等于该值的子进程才会被等待。

10. wait函数在进程没有子进程或者被信号打断时，都会出错。waitpid中如果指定的PID或PGID都不存在，或pid指定的进程不是调用进程的子进程（没有权限），也会出错。

11. 进程也可以分组，便于统一管理，默认子进程是和创建它的父进程一组的。

12. 批量fork，中途出错的处理：

     ```c
      #include <stdio.h>
      #include <stdlib.h>
      #include <unistd.h>
      #include <sys/types.h>
      #include <sys/wait.h>
      int main() {
          pid_t pid;
          int status;
          for (int i = 0; i < 3; i++) {
              fflush(NULL);
              pid = fork();
              if (pid < 0) {  //只有父进程有可能到达这里
                  perror("fork()");
                  for (int j = 0; j < i; j++) { //这里没有直接exit,是考虑到前2个进程创建成功，但第3个不成功的情况，这个循环wait给前两个子进程收尸。如果不写循环，直接exit父进程的话，子进程会变成孤儿进程，然后被init接管，不推荐这样做。另一种做法是父进程kill掉所有创建成功的子进程，然后再exit。
                      wait(NULL);
                  }
                  exit(0); //从这里退出父进程，否则会运行24行，但是那是已经没有任何子进程了。
              }
              if (pid == 0) { //子进程
                  printf("child:[%d]\n", getpid());
                  exit(i);
              }
          }
          for (int i = 0;i < 3;i++) {
              pid = wait(&status);
              printf("child-terminated,pid:[%d],status:[%d],returncode:[%d]\n", \
                  pid, status, WEXITSTATUS(status));
          }
          exit(0);
      }
     ```

13. 上述程序执行的结果可能为：

      ```shell
      [zj@ZJ test]$ ./test
      child:[1896]
      child:[1898]     #子进程之间，子进程和父进程之间谁会先执行，完全取决于调度器。
      child:[1897]
      child-terminated,pid:[1897],status:[256],returncode:[1] #这里三个子进程都执行完了，父进程再为他们逐个收尸，顺序不定
      child-terminated,pid:[1898],status:[512],returncode:[2]
      child-terminated,pid:[1896],status:[0],returncode:[0]
      #另一种执行情况
      child:[1945]
      child-terminated,pid:[1945],status:[0],returncode:[0] #这里一个子进程结束后，就调度到了父进程，直接为其收尸。
      child:[1947]
      child-terminated,pid:[1947],status:[512],returncode:[2]
      child:[1946]
      child-terminated,pid:[1946],status:[256],returncode:[1]
      ```

14. 如果有一个父进程不想wait其子进程，也不想让子进程变成僵尸一直等待父进程终止，然后被init接管并收尸。这个目的可以用两次fork实现：

      ```c
      #include <stdio.h>
      #include <stdlib.h>
      #include <sys/wait.h>
      #include <unistd.h>
      int main() {
          pid_t pid;
          if ((pid = fork()) < 0) { //主进程首先fork了一次，然后就去21行wait自己的子进程了。
              perror("first fork()");
              exit(1);
          } else if (pid == 0) { 
              if ((pid = fork()) < 0) {//子进程又fork了一次
                  perror("second fork()");
                  exit(1);
              } else if (pid > 0) { //主进程的子进程退出了，这样21行就能返回。
                  exit(0);
              }
              sleep(2);//这里是主进程的孙子进程，它的父进程消亡了，因此它被init接管。
              printf("second child, parent pid = %ld\n", (long)getppid());//上面之所以要让孙子进程睡眠2秒，是为了让printf执行时，其父进程结束，这样此时getppid的结果就一定是1。
              exit(0);
          }
          if (waitpid(pid, NULL, 0) != pid) {
              perror("waitpid");
              exit(1);
          }
          exit(0);
      }
      //这里进程A fork一次，产生了进程A和B，然后进程B再fork一次，产生了B和C，此时进程B exit了，进程A也wait进程B，这样进程B就完美退出了，此时就只剩进程C了，他被init接管了。
      //这个方法可以最终产生一个被init接管的进程，对进程A来说，不用阻塞很久，好像啥也没发生一样，进程C跟它始终没啥关系。
      ```

15. 如果有一系列类似任务要分配给多个进程，不推荐一个任务分配给一个进程：

      1. 有些任务适合于均匀分配给多个进程；有分块和交叉分配两种算法，例如1-100分给三个进程：
         1. 分块，1-33分给1进程，34-67分给2进程，67-100分给3进程。
         2. 交叉分配，1，4，...分给1进程；2，5，...分给2进程；3，6，...分给3进程。
      2. 一般情况下优先选择交叉分配，也有例外，例如查找质数的任务，交叉分配可能导致某个进程始终分配到的数都是某个很小的数的倍数，因而该进程很快就完成了任务。
      3. 有些任务需要非均匀的分配，各个进程才能一样忙才是最优的状态。例如查找质数的任务，由于质数的分布密度不均匀，在较小的数附近分布较密。
      4. 池类算法：可以创建一个任务池，进程逐个从池中取任务，如果先结束，就先取任务，能者多劳。上游将任务逐个投递到任务池内，然后唤醒下游从任务池内取任务去计算，然后这个下游再唤醒上有投递任务，周而复始。类似于生产者和消费者，会产生竞争和冲突。可以用进程池或线程池完成。


## exec

1. 如果没有exec函数族，那就无法通过shell运行程序。因为fork只能复制一个shell。

2. exec函数族用来执行一个文件，会用一个新的进程镜像(来自新的可执行文件)替换掉当前进程的镜像，但是PID不会变化，其中有汇编级别的操作来操作内存和IP。替换的内容有：正文段，数据段，堆段，栈段：

   ```c
   #include <unistd.h>
   extern char **environ;  //环境变量，和argv的存储一样
   int execl(const char *path, const char *arg, .../* (char  *) NULL */); //path为路径名，可以有多个命令行参数，最后以NULL结尾。
   int execlp(const char *file, const char *arg, .../* (char  *) NULL */); //和上一个不同的是，file为文件名，如果文件名中含有/，就将其视为路径名;否则就在环境变量PATH的各个目录中寻找该可执行文件。
   int execle(const char *path, const char *arg, .../*, (char *) NULL, char * const envp[] */);//和第一个比，允许使用自定义的环境变量envp，替换environ。命令行参数和环境变量中间需要间隔一个NULL的参数。
   int execv(const char *path, char *const argv[]);  //命令行参数由一个字符指针数组当做一个参数传入。一般用于函数之间相互调用的情况，因为无法实现确定有多少个参数，因而无法使用execl函数。
   int execvp(const char *file, char *const argv[]); //类似于execlp
   int execvpe(const char *file, char *const argv[], char *const envp[]); //类似于execle
   ```

3. 环境变量PATH包含了一个目录列表（路径前缀），目录之间用冒号分割，例如：

    ```shell
    PATH=/bin:/usr/bin:/usr/local/bin:.  #最后的.表示当前路径。一个零长度的前缀也表示当前目录，例如开头的单个:，中间的两个连续的::，和末尾的:。
    #不过处于安全考虑，不推荐将.加入到PATH中。
    ```

4. exec函数族中的命令行参数是从argv[0]开始传入的。argv[0]对可执行程序本身没用，但是在该程序内部可能会使用到，该名称也被称作进程名，ps命令中会从argv[0]开始显示整个argv来作为进程的详细信息。一般的命令只会从argv[1]开始处理命令行参数。

5. 如果此类函数产生返回，说明exec失败，因为原来的进程执行环境已经被破坏了，正常情况下该函数是不会返回的。

   ```c
   //exec前也应fflush刷新所有的流。和fork不同的是，fork会复制缓冲到子进程中。而exec会直接覆盖掉缓冲，而导致输出丢失。
   execl("\bin\date","date","+%s",NULL);  //如果该函数执行成功，其后的代码就被替换，因而不会再被执行了。
   perror("execl()");  //此处不用再判断返回值，因为只要该函数返回，就表示执行失败。直接打印错误信息，然后退出进程即可。
   exit(1);
   ```

6. 例子fork+exec+wait操作：

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <sys/types.h>
   #include <unistd.h>
   int main(){
       pid_t pid;
       printf("Begin!\n");
       fflush(NULL);
       pid = fork();
       if(pid <0){
           perror("fork()");
           exit(1);
       }
       if(pid == 0){ //子进程
           execl("/bin/date","date","+%s",NULL);
           perror("execl()");
           exit(1);
       }
       wait(NULL); //父进程等待子进程
       printf("End!\n");
       exit(0);
   }
   ```

7. 在Shell环境下执行命令的过程：shell先fork一个子进程（和shell一样），然后在子进程中exec对应的命令，父进程中wait对应的子进程，子进程执行完毕后，shell为其收尸，最后显示命令提示符。

8. 自定义shell，还有很多地方待完善，可以将此shell作为某个用户的登录shell：

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <glob.h>
   #include <string.h>
   #include <unistd.h>
   #include <sys/types.h>
   #include <sys/wait.h>
   #define DELIMS " \t\n"
   
   static void parse(char* linebuffer, glob_t* globres);
   
   int main() {
       char* linebuffer = NULL; //用于接收getline内部创建的内存的地址
       size_t linebuf_size = 0;
       char* tok = NULL;
       glob_t globres;
       int times = 0;
       pid_t pid;
       while (1) {
           printf("zj@hit:$ ");
           fflush(stdout);
           if (getline(&linebuffer, &linebuf_size, stdin) < 0) {
               perror("getline()");
               exit(1);
           }
           parse(linebuffer, &globres);
           if (!strcmp(globres.gl_pathv[0], "-1"))
               exit(0);
           pid = fork();
           if (pid < 0) {
               perror("fork()");
               exit(1);
           }
           if (pid == 0) {
               execvp(globres.gl_pathv[0], globres.gl_pathv);
               perror("execvp()");
               exit(1);
           }
           wait(NULL);
           globfree(&globres);
       }
       exit(0);
   }
   static void parse(char* linebuffer, glob_t* globres) {
       char* tok = NULL;
       int times = 0;
       while (1) {
           tok = strsep(&linebuffer, DELIMS); //使用分隔符字符串DELIMS中的任意一个来逐个分隔字符串linebuffer，strtok也可以完成该功能。
           if (tok == NULL)
               break;
           if (tok[0] == '\0') //当多个分隔符连续出现时，会解析出空串。
               continue;
           glob(tok, GLOB_NOCHECK | GLOB_APPEND * times, NULL, globres); //将被分隔出来的字符串存储起来。NOCHECK表示如果没有匹配，则返回原始的字符串保存起来。GLOB_APPEND表示追加到之前的内容中，不过应该只有第一次不追加（因为globres中默认可能有数据），后面每次都追加。
           times = 1;
       }
   }
   //另一种思路是，考虑到parse函数可能会在解析时发现是内部命令，此时应该顺道输出一个标志。可以选择增加一个参数flag，或者定义一个结构体类型，此时在glob函数的最后一个参数就变成&(cmd->globres)了，第二种方式的扩展性更强。
   struct cmd{
       glob_t globres;
       int flag;
   }
   ```


## u+s，g+s

1. 普通用户对/etc/shadow文件是没有读写权限的，但是却可以通过passwd命令来修改密码，而改密码就是修改该文件。用shell执行任何命令，都会附带着一个用户ID的信息，这样才可以执行文件的权限检查和资源利用限制。

2. 进程的PCB中除了存储着运行该进程的用户的UID和GID(也称为real)，还存储着effective，save的UID和GID，一共6个。suid，sgid不一定有，而real和effective是必须有的。鉴定权限时看的是effective。

   ```c
   struct task_struct{
       ...
       uid_t uid,euid,suid,fsuid;
       gid_t gid,egid,sgid,fsgid;
       int ngroups;                  //记录进程在多少个用户组中
       gid_t groups[NGROUPS];      //记录进程所在的组
       ...
   }
   ```

3. 有些可执行文件（实际上任何文件都是如此，但此处只关注可执行文件的这两个权限位）还具有特殊权限，即所有者或所属组的执行权限变为s，s是包含x的。u+s的操作是other在执行该程序时，会暂时将EUID转变为文件的所有者的ID。这样可以将root的部分权限下放，给与普通用户一些暂时提权的固定行为。 在没有u+s权限的时代，普通用户都不可以修改自己的密码。例如：

   ```shell
   [zj@ZJ ~]$ ll /bin/passwd /usr/bin/su /usr/bin/sudo
   -rwsr-xr-x. 1 root root 33K 4月   7 2020 /bin/passwd
   -rwsr-xr-x. 1 root root 50K 7月  22 2020 /usr/bin/su
   ---s--x--x. 1 root root 162K 1月  27 05:58 /usr/bin/sudo
   ```

4. u+s，g+s被称为setuid或setgid。

   ```shell
   chmod u+s a.out    #为可执行文件设置u+s权限。只有该文件的所有者和root可以执行此命令
   ```

5. exec函数会检查可执行文件是否具备u+s或g+s权限，如果具备，则会将当前子进程的EUID修改为可执行文件的所有者的UID或GID（这一步没必要使用setuid等函数修改的，因为exec是系统调用，它可以直接在内核态修改PCB中对应变量的值）。而RUID和RGID不变，内核总是通过有效UID和GID来判断权限的。RUID和RGID一般是用来做资源利用统计的。可以看到，u+s和root没有关系，可以用来切换到任意用户。

6. exec切换EUID或EGID后，一般不需要再切换回去，因为可执行文件结束后，就被父进程或init收尸了。

7. u+s或g+s的权限设置要慎重，因为这样可能会使得一个普通用户没有输入root的密码也以root的身份来运行一个程序。如果权限是rwsrwxrwx，那么可以直接修改具有u+s权限的二进制文件来更改其功能，这样比较危险，所以一般不会开放给other写可执行文件的权限。

8. 获取和修改real和effective ID：

   ```c
   #include <unistd.h>
   #include <sys/types.h>
   uid_t getuid(void);   //返回当前进程的real UID。uid_t在64位Ubuntu上为unsigned int
   uid_t geteuid(void);  //返回当前进程的effective UID。
   gid_t getgid(void);   //返回当前进程的real GID。gid_t在64位Ubuntu上为unsigned int
   gid_t getegid(void);  //返回当前进程的effective GID。
   
   int setuid(uid_t uid); //设置当前进程的effective UID。如果当前进程是有特权的(EUID为0)，那么RUID和SUID也会被设置。
   int setgid(gid_t gid); //设置当前进程的effective GID。同上
   int seteuid(uid_t euid); //设置当前进程的effective UID。非特权进程只能将EUID设置为RUID,EUID或SUID。
   int setegid(gid_t egid); //设置当前进程的effective GID。同上
   
   int setreuid(uid_t ruid, uid_t euid);  //同时设置当前进程的real和effective UID，原子化的操作，有一个设置失败，则整个操作不会执行。如果有一个不想修改，可以用-1来代替。非特权进程只能将EUID设置为RUID,EUID,SUID中的一个。非特权进程只能将RUID设置为RUID或EUID。这个函数可以用来互换当前进程的EUID和RUID。
   int setregid(gid_t rgid, gid_t egid);  //同时设置当前进程的real和effective GID，原子化的操作。
   ```

9. 特权进程就是EUID为0的进程，有2种方法创建特权进程：由某一特权进程产生子进程；使用可执行文件的u+s权限。

10. u+s权限和setuid的例子：

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <sys/types.h>
    void getID() {
        printf("UID: %d\t", getuid());
        printf("EUID: %d\t", geteuid());
        printf("GID: %d\t", getgid());
        printf("EGID: %d\n", getegid());
    }
    int main(int argc, char* argv[]) {
        pid_t pid;
        printf("Before\n");
        if (argc != 2) {
            fprintf(stderr, "Usage:...\n");
            exit(1);
        }
        getID();
        if (setuid(atoi(argv[1])) < 0) {
            perror("setuid");
            exit(1);
        }
        printf("After\n");
        getID();
        exit(0);
    }
    //由root用户运行时，结果如下：
    root@hit:/home/zj/linux_c/process# ./uid 1000 //setuid的参数为1000
    Before
    UID: 0  EUID: 0 GID: 0  EGID: 0
    After
    UID: 1000       EUID: 1000      GID: 0  EGID: 0
    //如果通过chmod赋予该程序u+s权限，但是不修改所有者和所属组，由root执行同样的命令，结果如下：
    root@hit:/home/zj/linux_c/process# ./uid 0
    Before
    UID: 0  EUID: 1000      GID: 0  EGID: 0  //可以看到执行u+s权限的程序只会改变EUID
    After
    UID: 0  EUID: 0 GID: 0  EGID: 0  //而调用setuid函数后，会改变UID和EUID
    //如果EUID为0的进程通过setuid函数修改了自己的UID和EUID为1000后，此时它无法再通过setuid将EUID修改回0。
    ```

11. 例子，root用户修改自己的EUID，然后又修改回来：

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <sys/types.h>
    void getID() {
        printf("UID: %d\t", getuid());
        printf("EUID: %d\t", geteuid());
        printf("GID: %d\t", getgid());
        printf("EGID: %d\n", getegid());
    }
    int main(int argc, char* argv[]) {
        pid_t pid;
        if (argc != 2) {
            fprintf(stderr, "Usage:...\n");
            exit(1);
        }
        if (setreuid(-1, atoi(argv[1])) < 0) {
            perror("setuid");
            exit(1);
        }
        printf("Before\n");
        getID();
        if (setreuid(atoi(argv[1]), 0) < 0) {
            perror("setuid");
            exit(1);
        }
        printf("After\n");
        getID();
        printf("Back\n");
        if (setuid(0) < 0) {
            perror("setuid");
            exit(1);
        }
        getID();
        exit(0);
    }
    //由root用户来执行命令 ./uid 1000 结果为:
    root@hit:/home/zj/linux_c/process# ./uid 1000
    Before
    UID: 0  EUID: 1000      GID: 0  EGID: 0 //首先仅设置了自己的EUID
    After
    UID: 1000       EUID: 0 GID: 0  EGID: 0//然后将EUID修改为了RUID
    Back
    UID: 0  EUID: 0 GID: 0  EGID: 0 //最后将EUID和RUID还原为一开始的0
    ```

12. Linux 系统中经常使用的set-UID程序有：passwd，用于更改用户密码；mount和umount，用于加载和卸载文件系统；su，允许用户以另一用户的身份运行shell。set-GID的例子有wall，用来向tty组下辖的所有终端（通常情况下，所有终端都属于该组）写入一条消息。


## sudo

1. 用户执行sudo命令时，因为sudo命令设置了是u+s权限的，因此exec函数会将子进程的EUID更改为root。sudo命令内部会再根据第一个参数再exec一次（此时EUID已经是root了，一般并不会修改EUID），传入后续对应的参数。这样sudo后面的命令就可以用root用户的身份执行了。

2. sudo命令中并没有设置EUID的操作，因为它被设置了u+s权限，fork出的shell子进程在exec时就会修改EUID。

3. sudo并不要求其后的命令具有u+s或g+s权限。而sudo程序本身具有u+s权限。

4. 一般来说others用户执行u+s的程序并不需要任何验证信息。而sudo程序比较特殊，因为它的所有者是root，还有就是它再提权后，会再执行用户指示的程序。因而需要验证当前用户是否有资格来执行sudo提权。

5. 利用sudo来提升权限需要满足以下要求：当前用户符合在sudoers文件中某一项的设置（推荐使用visudo命令来修改该文件，因为修改该文件需要root权限，如果修改不当，可能导致当前用户没有了root权限，无法再次修改）。

   ```shell
   #/etc/sudoers文件
   # User privilege specification
   root    ALL=(ALL:ALL) ALL
   # Members of the admin group may gain root privileges
   %admin ALL=(ALL) ALL
   # Allow members of group sudo to execute any command
   %sudo   ALL=(ALL:ALL) ALL  #表明允许sudo组的所有用户执行任何命令。第二部分是扩展巴科斯范式EBNF。格式为  本条规则使用的用户或组 限制用户从哪些主机登录时才可以使用=(允许变身为的身份，冒号分割用户或组，ALL:ALL则表示任意组内的任意用户) 可执行命令的列表。
   #例子A B=(C:D) E     对于用户A来说，当他从主机B登录时允许它变身为用户C或用户组D的成员来执行命令E。
   
   #/etc/groups
   sudo:x:27:zj  #zj用户是在sudo组内的，因此它具备执行任何命令
   ```

6. 例子，写一个自定义的扩展功能的sudo，可以以指定的任意用户来执行某个命令：

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <unistd.h>
   #include <sys/wait.h>
   int main(int argc, char* argv[]){ //因为当前程序是u+s，所以此时EUID就是0了，但是RUID还是执行它的shell的。
       pid_t pid;
       if(argc < 3){
           fprintf(stderr, "Usage:...\n");
           exit(1);
       }
       pid = fork();
       if(pid < 0){
           perror("fork()");
           exit(1);
       }
       if (pid == 0){
           if (setuid(atoi(argv[1])) < 0){ //因为EUID是0，所以可以设置为将EUID任意，同时也会修改RUID。
               perror("setuid");
               exit(1);
           }
           execvp(argv[2],argv+2);
           perror("exec()");
           exit(1);
       }
       wait(NULL);
       exit(0);
   }
   //执行命令 ./mysu 0 cat /etc/shadow  希望该程序会使用root用户的权限来执行cat /etc/shadow文件。但是setuid函数会报错，Operation not permitted。因为普通用户无法修改自己的EUID为root。
   //还需要root用户执行以下两步才可以达到目标：
   chown root mysu
   chmod u+s mysu
   ```

7. 可以用id命令来获取某个用户的RUID，RGID，EUID，EGID，还可以列出所在的组：

   ```shell
   zj@hit:~$ id -un   #-u表示列出当前用户的有效用户ID,-n表示列出名称,而不是ID。配合-r使用可以获得真实用户ID。whoami等价于id -un
   zj
   zj@hit:~$ id -Gn   #-G表示列出当前用户所在的组。
   zj adm cdrom sudo dip plugdev lxd
   zj@hit:~$ id -gn   #-g表示列出当前用户有效组ID，只有一个。配合-r使用可以获得真实组ID。
   zj
   # id并不是shell的内置命令，可以配合管道符，附加在其他进程的后面，来输出该进程的信息。
   ./mysu 0 id -un  #结果为root
   ./mysu 0 id -run #结果为root，可见setuid把RUID也改了。实际上u+s的程序在exec时并不会修改RUID，这里是因为setuid函数修改的。
   ./mysu 0 id -gn  #结果为zj
   ./mysu 0 id -rgn #结果为zj
   ./mysu 0 id -Gn  #结果为zj adm cdrom sudo dip plugdev lxd。虽然UID和EUID都变为0了，仍然能输出zj的组信息，即使将GID和EGID都修改为0，结果也不便。这可能是因为id命令并没有根据这些值来确定组信息。
   ```

   

## 登录过程

1. 登录和用户身份切换过程：

   1. init进程（此时还是root用户）产生（fork + exec）一个getty进程，提示输入用户名，保存用户名。
   2. 然后getty进程再exec(login)，变身为login进程，提示输入密码，保存密码。
   3. 将输入的密码和shadow文件中对应的行的盐值组合，计算摘要是否等于之前设置的。到此，都是root用户的身份。
   4. 如果相等，则认证成功。然后fork+exec一个用户对应的shell程序。再切换用户的身份。root用户可以设置当前进程的所有用户和组ID。但是设置完成后，就无法再修改回来了。
   5. 如果不相等，则exec一个getty进程。
2. 和一般的用法不同的是，getty进程不fork，直接exec。

## 解释器

1. 解释器文件就是脚本文件。

   ```shell
   #!/bin/bash
   ls
   cat /etc/shadow #一行一行地执行，中间的某一行出错，不会影响下一行。
   ps
   ```

2. exec函数会先判断文件的前两个字符是否是#!，如果是则为脚本文件，则不会直接将当前进程镜像替换为脚本文件，需要特殊处理：exec载入对应的解释器（路径存储在第一行的#!后面），其中包含一个命令行参数为脚本文件名。这样解释器就会解释执行整个当前文件（相当于执行命令bash a.sh或python a.py），包括第一行。由于exec根据开头的两个字符是否是#!来判断是不是脚本文件。所以一般解释器(bash，python)也顺便将#作为脚本文件的注释行，这样解释器就会跳过第一行。

3. 实际上#!后面可以不是解释器文件，任意的可执行文件都行，例如脚本文件abc为：

   ```shell
   #!/usr/bin/cat
   hah
   hoho
   ```

4. chmod a+x abc，然后执行./abc结果如下：

   ```shell
   [zj@manjaro linux]$ ./abc  #相当于/bin/cat ./abc,由于cat命令不会将#当做注释,因而会输出该解释器文件的每一行。
   #!/usr/bin/cat
   hah
   hoho
   ```

5. 有时候需要限制某些用户的操作（安全性较高的场景），可以为其定制shell，需要修改/etc/passwd文件中的该用户的登录shell。

6. system函数执行shell命令：

   ```c
   #include <stdlib.h>
   int system(const char *command);//相当于调用/bin/sh -c command，可以看做是fork+exec+wait的简单封装。
   ```

## 进程会计

1. acct函数打开或关闭进程会计：

   ```c
   #include <unistd.h>
   int acct(const char *filename); //当有进程消亡时，会将相关信息写入到filename文件中。不过这个函数只是BSD的方言，不再POSIX中。
   ```

## 竞争条件

1. 当多个进程都试图对共享数据进行处理，且最后的结果又取决于进程运行的顺序时，认为发生了竞争条件。
2. 如果fork之后，某种逻辑显式或隐式地依赖于父进程或子进程的先后执行顺序，那么认为fork处发生了竞争，因为无法保证fork后子进程和父进程哪个先执行。
3. 竞争导致的错误很难调试，因为它时而出现，时而不出现。

## 计时

1. clock_t在64位linux下就是long类型，在C标准头文件time.h中定义。该头文件中还定义了CLOCKS_PER_SEC宏，表示一秒内的时钟滴答数，一般是100万。

2. C标准的时间函数clock：

   ```c
   #include <time.h>
   clock_t t = clock();
   printf ("Calculating...\n");
   ...
   t = clock() - t; //结果是时间差对应的滴答数
   printf ("It took me %d clicks (%f seconds).\n",t,((float)t)/CLOCKS_PER_SEC);
   ```

3. 进程时间，time命令的基础times函数：

   ```c
   #include <sys/times.h>
   clock_t times(struct tms *buf);   //buf是该函数存储时间的结构体指针。返回值为墙上时钟的滴答数。这个函数和C标准库的time函数要区分开，time是获取从1970年到现在的时间戳。如果不想要详细的时间，参数可以传入NULL。
   struct tms {
       clock_t tms_utime;  /* user time */
       clock_t tms_stime;  /* system time */
       clock_t tms_cutime; /* user time of children */
       clock_t tms_cstime; /* system time of children */
   };    //用户时间+子进程的用户时间=最终的用户时间。
   
   //通过系统的times函数获取到的clock_t类型的滴答数，和时间的对应关系为1秒钟=sysconf(_SC_CLK_TCK)个滴答。一般是1秒钟=100滴答。而通过C标准头文件clock获取到的，1秒钟=100万滴答。因此clock函数更容易溢出，大约半个小时就会溢出。
   ```

4. 常见的计时方式有：

   1. 通过时钟中断进行间隔计时，每隔一定时间（一般为10ms），时钟中断就会传入CPU中，CPU会执行中断服务程序，减少当前进程的时间片，将当前进程PCB中的时间属性加1，如果中断时在用户态就增加用户时间，反之增加系统时间。这种方法不太精确，只有当程序运行时间在秒级别才有意义。

5. 使用time命令为进程计时，其中父进程会等待子进程，因此进程的时间会包含父进程自己的时间和子进程的运行时间，还有父进程等待子进程的时间，当然这三个时间有可能重叠。

6. time命令可以计算后面的命令执行消耗的时间：

   ```shell
   [zj@ZJ test]$ time cp /etc/services aa
   real    0m0.003s  #实际运行的时间=user+sys+调度消耗，也称为墙上时间
   user    0m0.000s  #在用户态运行的时间
   sys     0m0.003s  #在内核态运行的时间
   [zj@ZJ test]$ time ./test > /dev/null #重定向不会作用在time的输出上，只会重定向./test程序的输出。
   ```

7. CPU时间可分为系统CPU时间和用户CPU时间。前者是指在内核模式中，执行代码所花费的时间（比如执行系统调用，或代表进程执行其他的内核服务）。后者是指在用户模式中，执行代码所花费的时间（比如，执行常规的程序代码）。


## 软件时钟（jiffies）

1. 时间相关的各种系统调用的精度是受限于系统软件时钟（software clock)的分辨率，它的度量单位被称为jiffies。jiffies的大小是定义在内核源代码的常量HZ。这是内核按照round-robin（轮询调度）的分时调度算法分配CPU进程的单位。
2. 在2.4或以上版本的Linux/x86-32内核中，软件时钟速度是100赫兹，即一个jiffy是10毫秒。
3. 自Linux面世以来，由于CPU的速度已大大增加，Linux/x86-32 2.6.0内核的软件时钟速度已经提高到1000HZ。更高的软件时钟速率意味着定时器可以有更高的操作精度和时间可以拥有更高的测量精度，也会导致有效时间缩短。因为每个时钟中断会消耗少量的CPU 时间，这部分时间CPU无法执行任何操作。
4. 现在软件时钟频率成为一个可配置的内核的选项（包括处理器类型和特性，定时器的频率）。自2.6.13内核，时钟频率可以设置到100、250（默认）或1000 赫兹，对应的jiffy值分别为10、4、1 毫秒。自内核2.6.20，增加了一个频率：300赫兹，它可以被两种常见的视频帧速率25帧每秒（PAL）和30帧每秒（NTSC）整除，方便视频播放。

## 会话和进程组

1. 真正的终端是在早期，多人共同使用一台计算机的情况，只有基本的输入输出，类似于网吧的无盘系统。现在使用的都是终端模拟器。

2. 一个终端的登录就产生一个会话session，当然也可以主动产生会话(创建守护进程时需要)。一个session可以容纳多个进程组，一个进程组内可以有多个进程。进程组分为前后台，任何时刻最多只有一个前台进程组，其余的都是后台进程组。之所以要区分前后台，主要是为了确定终端的输入和输出关联到哪个进程组。

3. 进程组也有ID，称为PGID。实际上并不存在一个进程组这样的实体，他只是一个将进程分类的属性，PGID属性相同的进程属于同一个进程组，PID=PGID的进程是该进程组的leader。一般情况下父进程是它和他的子进程所在组的leader。

4. 会话也有ID，称为SID，会话的leader，满足PID=SID。

5. 刚登录时，只有一个进程组，该进程组内只有一个进程，就是该用户的登录shell。如果此时执行top命令则会创建一个新的进程组，组内只有一个进程top，该进程组为前台进程组，占据着终端。如果从top退出，则shell进程组又回到了前台。

6. 设计session和进程组的目的是为了支持shell的job管理。一个进程组通常称为一个job。使用管道符连接起来的多个进程属于同一个进程组，例如`ls|wc`。同一个进程组的所有进程隶属于一个session，同一个session共享一个控制终端。可以都是后台进程

7. 除Bourne shell以外，几乎所有的主流shell都支持任务控制，它允许用户同时执行并操纵多条命令或管道，会将管道内的所有进程置于一个新进程组或任务中。

8. 使用会话最多的是支持任务控制的shell，由shell创建的所有进程组与shell自身隶属于同一会话，shell是此会话的会话首进程。通常，会话都会与某个控制终端相关，对于由交互式shell所创建的会话，这就是用户的登录终端。

9. 一个终端至多只能成为一个会话的控制终端。打开控制终端会致使会话首进程成为终端的控制进程。一旦断开了与终端的连接（比如，关闭了终端窗口），控制进程将会收到SIGHUP信号。

10. 在任一时点，会话中总有一个前台进程组（前台任务），可以从终端中读取输入，向终端发送输出。

11. 一个会话可以拥有任意数量的后台进程组（后台任务），由以“&”字符结尾的行命令来创建。

12. 内核可对进程组中的所有成员执行各种动作。

13. 使用ps命令可以查看，PPID为父进程的ID，PGID为所属进程组的ID，SID为会话ID，TTY为关联的终端，？表示没有关联控制终端：

    ```shell
    [zj@manjaro ~]$ ps ajx
       PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND
          0       1       1       1 ?             -1 Ss       0   0:01 /sbin/init
          1     372     372     372 ?             -1 Ss      81   0:00 /usr/bin/dbus-daemon 
    ```

14. 进程组中leader退出并不会终止该进程组中的其他进程。只有进程组的所有进程都退出后，进程组才会消亡。

15. 一个进程的PID不会变，PPID一般也不会变（如果父进程提前结束，子进程的PPID会变为父进程的父进程，有可能是1号的init进程），而PGID和SID是可以改变的。通过fork创建子进程时，子进程会继承父进程的PGID和SID。

16. 设置或获取进程相关的ID：

   ```c
   #include <unistd.h>
   pid_t getpid(void);  //获取当前进程的PID,没有对应的setpid，因为进程的pid是在fork时由内核从可用的pid中找出来的。
   pid_t getppid(void);  //获取当前进程父进程的PID，即PPID。同样也没有对应的setppid函数。
   
   pid_t getpgrp(void);  //获取当前进程所在的进程组ID，即PGID。
   pid_t getpgid(pid_t pid);  //获取参数pid进程的PGID，如果pid=0,那么表示获取当前进程的PGID,等价于getpgrp()。
   
   pid_t setpgrp(void);  //如果当前进程不是session的leader，会将当前进程的组ID修改为和当前进程的ID相同，也就是将当前进程单独成组。否则什么也不做。
   int setpgid(pid_t pid, pid_t pgid);  //修改pid进程的PGID为pgid。一个进程只能修改自己和它的同一个session中的子进程的组ID，否则会报错。如果pid=0,则表示修改当前进程的组ID。
   
   pid_t getsid(pid_t pid);  //获取进程pid所在的session ID。如果pid为0，表示获取当前进程所在的session ID。
   pid_t setsid(void); //如果当前进程不是一个进程组的leader，则会创建一个session，并且在新会话中创建一个新的进程组，然后把该进程放到新的进程组中。当前进程会变为新session和新group的leader，PGID=SID=PID，且新的session默认没有控制终端。如果调用成功，返回新的session ID，否则返回-1。如果当前进程是组leader，则什么也不做。
   ```

11. 一般来说父进程fork出子进程，父进程是进程组的leader，而子进程不是，子进程可以通过调用这个函数，来变成一个新的进程组和session的leader，并且脱离控制终端，这也会将该子进程变为守护进程。

12. 例子：

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    int main() {
        pid_t pid;
        if ((pid=fork())<0) {
            fprintf(stderr, "fork error!\n");
            exit(1);
        }else if (pid==0) {   //进入子进程
            printf("The child process PID is %d.\n",getpid());
            printf("The Group ID is %d.\n",getpgrp());
            printf("The Group ID is %d.\n",getpgid(0));
            printf("The Group ID is %d.\n",getpgid(getpid()));
            printf("The Session ID is %d.\n",getsid(0));
            printf("The Session ID is %d.\n",getsid(getpid()));
            exit(0);
        }
        wait(NULL);
        printf("The parent process PID is %d.\n",getpid());
        printf("The PPID of parent process %d.\n",getppid());
        printf("The Group ID is %d.\n",getpgrp());
        printf("The Session ID is %d.\n",getsid(0));
        return 0;
    }
    //程序的输出：
    The child process PID is 1529.
    The Group ID is 1528.
    The Group ID is 1528.
    The Group ID is 1528.
    The Session ID is 1159.
    The Session ID is 1159.
    The parent process PID is 1528.
    The PPID of parent process 1159.
    The Group ID is 1528.
    The Session ID is 1159.
    //ps命令的结果
       PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND
       1156    1158    1156    1156 ?             -1 R     1000   0:01 sshd: zj@pts/0
       1158    1159    1159    1159 pts/0       1538 Ss    1000   0:00 -bash
    ```

13. 可以发现bash进程(PPID=1158)是sshd进程(PID=1158)的子进程，但是两个进程不属于同一个session，是bash进程通过调用setsid实现的。bash进程是他所在的session和进程组的leader。他创建了程序中的父进程1528，后者又创建了它的子进程1529，这两个进程和bash同属于一个session 1159，但是这两个进程单独属于一个进程组1528，可见bash运行程序时会单独为其创建一个进程组，该程序就是该进程组的leader。


## 守护进程

1. 守护进程daemon（又称为精灵进程，因为daemon为古希腊神话中的半神半人精灵），类似于Windows上的服务，一般会开机自动在后台运行。
2. 守护进程的特点，前两条正好可以用setsid来实现：

   1. 守护进程一般是会话和进程组的leader。

   2. 守护进程一般都是脱离控制终端的，所以控制终端的输入输出会对他有影响，且会通过终端发送信号来影响守护进程。

   3. PPID=1，因为在创建守护进程时，他的父进程一般会直接退出，而不是等待为其收尸，因为守护进程可能要运行很久都不会退出。这样守护进程的父进程就变为init进程。
3. 一般会对守护进程的标准输入，标准输出和标准错误进行重定向，否则会报错。其父进程在fork前就先修改自己的标准输入，标准输出和标准错误，fork完再修改回来。
4. 创建守护进程的步骤，例子见下一节：

   1. 父进程fork()创建子进程，然后父进程执行exit()，使得子进程被init接管。
   2. 子进程将自己的0，1，2三个文件描述符不关联设备，重映射到`/dev/null`空设备。
   3. 子进程setsid()创建新会话，`chdir("/")`修改工作目录，这样可以防止占用某个挂载的设备，使得该设备无法卸载。
   4. 如果确定程序不会再创建文件，则可以调用umask(0)重新设置umask。
   5. close() 关闭所有打开的文件描述符，因为子进程会继承父进程的所有打开的文件描述符。

      ```c
      for(i=0;i<getdtablesize();i++)  //getdtablesize返回当前进程文件描述符表的项数
          close(i);
      ```
   6. 执行守护进程的任务，顺便打开一个日志文件，记录日志。

5. 守护进程一般要求是单实例的，即重复启动会失败。一般通过在/var/run目录下的*.pid锁文件来实现。每次启动时，都会去检验该目录下是否存在同名的.pid文件，如果有则表示已经存在一个实例了，启动失败。锁文件内保存着该守护进程的PID。

6. 因为没有控制终端，因此无法使用Ctrl+C来杀死它，可以使用kill函数或命令给守护进程发送信号来杀死它。


## 日志

1. 守护进程脱离了控制终端，因此需要通过写日志来反应自己的运行状况。实际上所有的程序都应该写日志来记录自己的运行状况。可以写入到系统日志中，也可以写入到程序自己的日志中。系统日志需要通过系统的服务来写入。

2. 系统日志，在/var/log目录下。其下的messages文件为主日志文件。不能允许所有的程序任意修改日志文件，因此出现了rsyslogd服务（配置文件为/etc/rsyslog.conf），进程将要写的日志交给该服务，由该服务写日志，属于权限分离。日志文件的所有者和用户组一般都是root。

3. ```c
   #include <syslog.h>
   void openlog(const char *ident, int option, int facility); //打开一个到系统日志器的连接。如果没调用openlog也可以直接使用syslog写日志，后者会自动调用openlog，不过此时ident为NULL。
   //ident为标识，例如进程名，会添加到每条日志的开头，如果为NULL，则使用程序名。如果在写日志的过程中ident的内容发生了变化，会反映在日志内容中，因此建议提供一个字符串常量。
   //option控制日志打开和后续写入的行为，常用的为LOG_PID，即在每条日志中包含进程的PID；LOG_NODELAY表示立即打开连接，默认会在第一条日志写入时才打开连接，即LOG_ODELAY。
   //facility用来指明写日志的程序的类型，常用的有LOG_FTP,LOG_MAIL,LOG_LPR,LOG_CRON等，默认为LOG_USER。
   void syslog(int priority, const char *format, ...);  //产生一条日志，分发给syslogd服务。priority是由自定义的facility（取值依据上面的参数）和level按位或得到的，如果没有按位或facility，则会使用openlog指定的facility，如果之前没有调用过openlog，则facility为LOG_USER。其中level确定了日志的等级，常用的为LOG_ERR, LOG_WARNING, LOG_INFO, LOG_DEBUG。format及后面的参数可以当作和printf一样使用，不同的是%m会被strerror(errno)替换，syslog会自动为每一条日志换行，因此没必要手动添加。
   void closelog(void);  //关闭日志，可选。
   int setlogmask(int mask); //设置日志优先级的mask，默认所有level的日志都可以写入，mask=0xFF，这个可以在服务的配置文件中设置。函数返回之前的mask。mask = LOG_MASK(LOG_DEBUG) | LOG_MASK(LOG_INFO) 表示仅打开这两个级别的日志输出。LOG_DEBUG为7，LOG_MASK(p)为(1 << (p))。
   #include <stdarg.h>
   void vsyslog(int priority, const char *format, va_list ap); //和syslog类似，就是接收可变参数。
   ```

4. 守护进程和系统日志综合例子：

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <unistd.h>
   #include <sys/types.h>
   #include <sys/stat.h>
   #include <fcntl.h>
   #include <syslog.h>
   #include <errno.h>
   #include <string.h>
   #define FNAME "/tmp/out1"
   int main() {
       FILE* fp = NULL;
       pid_t pid = 0;
       int fd = 0;
       int i = 0; //打印计数器
       openlog("mydaemon", LOG_PID, LOG_DAEMON);
       pid = fork();
       if (pid < 0) {
           syslog(LOG_ERR, "fork() failed %s", strerror(errno)); //不能使用perror报错。
           exit(1);
       }
       if (pid > 0) {
           exit(0);
       }
       //子进程代码
       fd = open("/dev/null", O_RDWR); //打开一个孔设备
       if (fd < 0) {
           syslog(LOG_ERR, "open(\"/dev/null\") failed %s", strerror(errno));
           exit(1);
       }
       dup2(fd, 0);
       dup2(fd, 1);
       dup2(fd, 2);
       if (fd > 2) {
           close(fd); //只保留012三个文件描述符。
       }
       chdir("/");
       umask(0);
       if (setsid() < 0) {
           syslog(LOG_ERR, "setsid() failed %s", strerror(errno));
           exit(1);
       } else {
           syslog(LOG_INFO, "setsid() success");
       }
       fp = fopen(FNAME, "w"); //打开一个文件
       if (fp == NULL) {
           syslog(LOG_ERR, "fopen(%s) failed %s", FNAME, strerror(errno));
           exit(1);
       }
       syslog(LOG_INFO, "%s was opend", FNAME);
       while (1) {
           fprintf(fp, "%d\n", i);
           fflush(fp);
           sleep(1);
           i++;
       }
       fclose(fp);
       closelog();
       exit(0);
   }
   //实测Ubuntu22.04会将日志写入到/var/log/syslog文件中。
   ```

# 并发

1. 信号和多线程是实现并发的两大类方法。
2. 多进程的并发是先有具体实现，然后标准化的，多线程与之相反，因此后者跟规范些，处理的分歧情况更少。一般来说一个库发布时默认应该支持多线程并发，如果不支持，会在名字上体现出来。
3. 事件可以分为同步和异步。异步的意思是事件何时到来不确定。钓鱼中的鱼上钩，俄罗斯方块中按键的到来，网络编程中监听外部连接的到来就可以看做是一个异步事件。
4. 异步事件的处理方法：
   1. 查询法：适用于事件发生频率较高的情况。主动。
   2. 通知法：适用于事件发生频率较低的情况。被动。本质上也是查询，可以看做间接查询。让别人主动查询，然后通知自己。

5. 信号属于初步异步，线程属于强烈异步。二者混合使用的比较少，一般以一个为主。多线程并发比信号并发要简单些。

6. 因为信号是进程层面，而非线程层面的。

7. 线程安全：如果一个函数可以被多个线程同时调用，而结果不会变化，此时认为它是线程安全的。POSIX.1要求标准内的所有函数都是线程安全的，除了部分函数外。这些非线程安全的函数，大多有线程安全的版本，例如rand和rand_r。

8. 异步取消安全：如果一个函数在开启异步取消的环境中，可以安全地被取消，此时认为它是异步取消安全的。POSIX标准中只有pthread_cancel，pthread_setcancelstate，pthread_setcanceltype是线程安全的。


# 信号

1. 信号是软件层面的中断，和系统调用中的int 0x80还不一样。信号的响应依赖于中断机制。信号是进程层面的。

2. 内核，其他进程（当有权利时）和自身都可以向进程发送信号。

3. 信号是经典的异步实例，进程不能通过测试某个变量来判断是否发生了信号，只能告诉内核，当某个信号发生时，应该如何响应。

4. ```shell
   [zj@manjaro ~]$ kill -l #列出所有信号,信号的名字都是以SIG开头的。
    1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
    6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
   11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
   16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
   21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
   26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
   31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
   38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
   43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
   48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
   53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
   58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
   63) SIGRTMAX-1  64) SIGRTMAX
   ```

5. 信号1-31称为标准信号，34-64称为实时信号，RT为RealTime。标准信号可能会丢失，而实时信号不会。

6. 信号的不可靠指的是信号的行为不可靠，而不是标准信号会丢失。因为程序中没有显式书写调用信号处理程序的语句，信号处理程序的执行现场是内核布置的。在处理一个信号的同时，如果又来了一个相同的信号，第二次的执行现场就可能把第一次的覆盖掉。早期的UNIX为了规避这种问题，就规定信号处理程序在被响应一次后，信号的行为变成默认的，这样不太好。

7. 发生下列情况时，内核会向进程发送信号：

   1. 用户键入中断字符，通常是Ctrl+C。

   2. 进程的某个子进程已经终止。

   3. 由进程设定的定时器已经到期。

   4. 进程尝试访问无效的内存地址。

8. 产生信号的方法：

   1. 用户在终端上的按键，例如Ctrl+C会产生一个SIGINT信号，Ctrl+\会产生一个SIGQUIT信号，这些信号都会发送给终端的前台进程组。
   2. 硬件异常产生信号，例如除数为0，无效的内存引用，这些异常由硬件产生，通知内核，内核为进程产生一个信号。例如访问0地址会受到SIGSEGV。
   3. kill函数或命令可以发送任意信号给一个进程或进程组。有权限要求，普通用户的进程只能发送给自己的其他进程，root用户的进程可以发送给任意用户的进程。
   4. 当检测到某些条件满足，会发送信号，这里的条件是软件层面的，例如定时器到时，会发送SIGALRM信号。

9. 对于信号的处理：

   1. 忽略此信号，大多数信号都可以这样处理，SIGKILL和SIGSTOP除外，否则进程不能被内核或root终止。如果忽略某些硬件产生的信号，例如除0，进程的行为将是不确定，因此不推荐忽略这些信号。
   2. 捕捉信号，对信号进行处理。不能捕捉SIGKILL和SIGSTOP信号。
   3. 执行系统的默认动作，大多数信号的默认动作都是终止该进程或终止+产生core文件。
   4. 先挂起，之后再被专用信号唤醒。

10. 大部分的系统都支持31个信号，Solaris支持40个信号。标准C中规定的信号特别少。

11. ![image-20210620105646237](Linux系统编程.assets/image-20210620105646237.png)

12. signal函数，为一个信号注册处理函数：

    ```c
     #include <signal.h>
    typedef void (*sighandle_t)(int);  //定义了一个函数指针类型。多个信号可以共用一个信号处理函数，因此信号处理函数的参数int为此次触发该函数的信号编号。
    sighandle_t signal(int signum, sighandle_t handler); //signum为要注册的信号，返回值为信号之前的处理函数指针
    //展开如下：
    void (*signal(int sig, void (*func)(int)))(int);  //建议使用这种，因为可以少定义一个类型，避免命名冲突。标准C中并没有定义sighandle_t这个类型。
    ```

13. signal函数的第二个参数可以是SIG_IGN(忽略信号)，SIG_DFL(系统默认行为，这样做相当于恢复默认)或用户自定义的函数。

14. 例子：

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <signal.h>
    static void siginthandler(int){
        write(stdout, "!", 1);
    }
    int main(){
        void (*oldsiginthandler)(int); //定义一个函数指针变量
        oldsiginthandler = signal(SIGINT, siginthandler);
        for (int i = 0; i < 10; i++){
            write(stdout, "*", 1);
            sleep(1);
        }
        exit(0);
    }
    //执行程序，在中途按下Ctrl+c键，结果如下：
    *****^C!*****      //其中^C是功能键的回显，可以关闭。
    ```

15. 阻塞的系统调用会被信号打断而提前返回，例如sleep（规定的时间走完之前会阻塞），write（在写入任何数据之前会阻塞），read（在读到任何数据之前会阻塞）等，此时会在返回值报错，且设置errno为EINTR。因此如果上面的程序按住Ctrl+C不松的话，程序会很快执行完。

16. 用信号改写之前的程序，例如文件的打开：

    ```c
    do{
        fd = open("/tmp/out", O_RDWR);
        if(fd < 0 && errno != EINTR){  //如果出错且不是因为中断，那表示是真错误，可以退出。
            perror("open()\n");
            exit(1);
        }
    }while(fd < 0)
    ```

17. 可重入（reentry）函数是为了解决信号的不可靠而产生的。信号处理函数应该为可重入的。其特点是，上一次调用还没结束，下一次调用就发生了，但是二者不会相互影响。不可重入函数大多是包含全局或局部静态变量，用来记录多次调用的上下文。通过将全局或局部静态变量变成函数的参数，也就是将其放在栈上，这样就变成可重入的函数了。

18. 所有的系统调用都是可重入的，一部分库函数也是可重入的，例如memcpy。不可重入的库函数一般都会有\_r版本，例如rand和rand\_r。rand产生的随机值是伪随机序列，每次产生的随机值是在上一次的基础上产生的。

    ```c
    #include <stdlib.h>
    int rand(void);
    int rand_r(unsigned int *seedp); //多了一个参数，seedp用来标识不同的调用状态。
    
    char *ctime(const time_t *timep);
    char *ctime_r(const time_t *restrict timep, char buf[restrict 26]); //多了一个参数，原来返回的字符串，现在由调用者来给出，这样重入时，就不会混淆了。
    ```

19. 是否可重入在man手册中有个表格会标识出来：

20. ![image-20230509211103651](Linux系统编程.assets/image-20230509211103651.png)

21. 标准信号的响应过程：

    1. 内核为每个进程维护了至少2个位图，mask和pending，二者都是32位的，分别对应于32个UNIX标准信号。mask是信号屏蔽字，用来标识当前进程的状态，默认为全1，表示不屏蔽任何信号。pending用来记录当前进程收到了哪些信号，初始为全0，进程收到信号时，内核会将其pending位图的对应位置为1。

    2. 进程在重新获得CPU使用权，从Kernel态转化到User态时，内核会计算`mask & pending`，如果结果为0，表示该进程没有收到任何信号。如果有多个位不为0，内核会将其中一个（先响应哪个是没有严格的顺序）信号的mask和pending的位都置为0，再去调用（将函数的返回值从原来主函数中的某个位置修改为信号处理函数的头）对应信号的处理函数。pending置为0表示处理了这个信号，mask置为0是防止重入现象。

    3. 该信号处理函数执行完后，再进入内核，将上一次的信号的mask位置为1，pending位不处理，此时才算完成了一个信号的处理。然后从内核态回到用户态前，重复第2步的操作，继续做`mask & pending`的按位与。

22. 如果接收进程正在运行，则可以立即进行信号处理。

23. 通过将signal的第二个参数即信号处理函数设置为SIG_IGN来忽略一个信号。这个函数实际是将mask位图的指定信号的位设置为0，这样在按位与时，即使pending位为1，结果也为0。

24. 信号从收到到响应有不可避免的延迟，因为进程只有在（通过中断）陷入内核，然后重新获得CPU使用权时才会处理信号。如果进程当前正在使用CPU或正在排队等待，是无法对信号立刻响应的，收到的信号只能由内核存储在对应进程的pending位图中。用信号来计时的话可能会带来10ms左右的误差。

25. 信号的响应是可以嵌套的，一个信号处理函数没执行完被调度出让CPU，再次获取CPU前，会处理新的信号（其它类型的信号，因为此时之前信号的mask位还为0），可以执行新的信号处理函数。

26. 如果在短时间内收到了相同的多个信号，只会当作一次，因为位图只有0和1两种情况。

    1. 一种是进程在运行或排队等待CPU时收到了多个相同信号，内核会重复地将对应的pending位设置为1。
    2. 另一种是进程在执行信号处理函数时，收到了多个相同的信号，内核也会重复地将对应的pending位设置为1。

27. 常用函数：

    ```c
    #include <sys/types.h>
    #include <signal.h>
    int kill(pid_t pid, int sig); //给进程或进程组发送信号sig，kill并非是用来杀死进程，主要是由于大部分的信号的功能是用来杀死进程的。如果pid>0，则是对应的进程。如果pid=0，则发给和当前进程同组的每个进程，一般称为组内广播。如果pid=-1，给当前进程有权发送信号的每个进程发送，除了1号进程init以外，称为全局广播，例如即将解除设备挂载时，init进程可以对所有进程发送信号，要求他们解除对该设备的使用。如果pid<-1，将信号发送给进程组ID为-pid内的每个进程。如果sig=0，则不发送信号，但是会执行判断进程是否存在和是否有权对该进程发送信号的检查，这个功能一般用来检查某个进程或进程组是否存在。成功发送至少一个信号则返回0，否则返回-1，并设置errno。(-1,EPERM)表示权限不够，(-1,ESRCH)表示进程或进程组不存在。
    #include <signal.h>
    int raise(int sig); //给调用进程或线程发送一个信号。在单线程进程中，等价于kill(getpid(), sig)，在多线程进程中，等价于pthread_kill(pthread_self(), sig)。如果这个信号导致一个信号处理函数被调用，则该处理函数返回后，raise才会返回。若成功返回0，失败返回非0。
    #include <unistd.h>
    unsigned int alarm(unsigned int seconds); //在倒计时seconds秒后，给当前进程发送一个SIGALRM信号，该信号的默认行为会杀死当前进程并在终端输出“闹钟”二字。如果seconds=0，则不会产生新的倒计时，同时会取消已有的倒计时。新的alarm设置会覆盖掉旧的。例如alarm(10);alarm(5)，大约会在5s后收到信号。
    #include <unistd.h>
    int pause(void);  //使得调用进程或线程睡眠，以等待任意一个信号（该信号要么注册了处理函数，要么会杀死进程）的到达。当信号到达，且其信号处理函数执行完毕后，pause才会返回。
    ```

28. 某些实现中，sleep是用alarm和pause来封装的，这时不推荐使用sleep，因为其内部的alarm和外部其他的alarm会冲突。考虑到移植的问题，因此不推荐使用sleep。一般系统中sleep是用nanosleep封装的，所以不会有事。

    ```c
    #include <unistd.h>
    int usleep(useconds_t usec); //usec不能超过1000000,否则会报错EINVAL，微秒单位，实际时间可能由于系统繁忙，处理调用或系统定时器的粒度而被轻微地拉长。成功时返回0。
    //和sleep，usleep相比，nanosleep可以在被信号打断后，继续休眠。
    #include <time.h> //也可能会被信号打断，此时会将剩余的为sleep的时间写入到rem参数中，这样可以继续调用该函数来sleep。
    int nanosleep(const struct timespec *duration, struct timespec *_Nullable rem);
    struct timespec { //
        time_t     tv_sec;   /* 秒 非负整数 */
        /* ... */  tv_nsec;  /* 纳秒 [0, 999999999] */
        }; //tv_nsec的类型不定，但是一定能存放上述范围。32位glibc下，通常是long或long long。
    ```

29. 例子，让程序对一个变量持续累加5s，然后打印结果：

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <time.h>
    int main() {
        time_t end;
        long long count = 0;
        end = time(NULL) + 5;
        while (time(NULL) <= end) {
            count++;
        }
        printf("%lld\n", count);
        exit(0);
    }
    //用time命令来对进程进行计时，三次结果如下，可以发现时间相差较大，这取决于进程开始执行的时间是处在一秒钟的开头部分还是结尾部分，因为在一秒内的任意时刻获取time都是相同的，假设开始时间为2.1s，结束时间为8.0s，则一共经历5.9s；若开始时间为2.9s，结束时间相同，则一共经历5.1s，二者都被认为是5s。time获取的时间是真实的时刻，并非开启了一个新的计时器。这个问题中，结束时刻都是统一的，但是起始时刻不同。
    zj@hit:~/linux_c/parallel$ time ./5sec 
    2614308708
    real    0m5.392s
    user    0m5.389s
    sys     0m0.000s
    zj@hit:~/linux_c/parallel$ time ./5sec 
    2567372156
    real    0m5.289s
    user    0m5.287s
    sys     0m0.001s
    zj@hit:~/linux_c/parallel$ time ./5sec 
    2489735892
    real    0m5.138s
    user    0m5.136s
    sys     0m0.001s
    ```

30. 使用信号来优化上一个程序：

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <time.h>
    #include <signal.h>
    #include <unistd.h>
    static volatile int flag = 1;
    static void alrm_handler(int) {
        flag = 0;
    }
    int main() {
        time_t end;
        long long count = 0;
        signal(SIGALRM, alrm_handler); //要求必须先注册信号处理函数，然后再计时。
        alarm(5);
        while (flag) { //这个程序如果使用gcc -O1优化可能会产生一个bug，就是gcc认为循环体内没有改变flag，因此在每次测试flag时，都是直接从寄存器中读取来提高效率，而非每次从内存中读取。这样会导致及时信号处理函数已经在内存中修改了flag的值，由于while不会从内存中读取，因而程序会进入死循环。因此推荐在flag的定义中加上volatile关键字，使得每次遇到该变量时，都去内存中读取它的值，而非使用寄存器中的值。在嵌入式编程中常用。
            count++;
        }
        printf("%lld\n", count);
        exit(0);
    }
    //用time命令来对进程进行计时，两次结果如下，可以发现时间相差不大，而且虽然修改的程序运行时间断了，但是计数的值却比修改前的大，这是因为修改前的程序每步循环都要取时间戳，会浪费CPU。可以发现alarm的精度比time更高，且更节省CPU。
    zj@hit:~/linux_c/parallel$ time ./5sec_sig
    2723499745
    
    real    0m5.003s
    user    0m4.997s
    sys     0m0.004s
    zj@hit:~/linux_c/parallel$ time ./5sec_sig
    2738516149
    
    real    0m5.003s
    user    0m4.982s
    sys     0m0.012s
    ```

31. 在一些需要定速输出的程序（播放视频，网络发送数据）中，可以使用alarm和pause的组合。例子：每秒从文件中读取10个字符，同时输出到终端。

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <sys/types.h>
    #include <fcntl.h>
    #include <sys/stat.h>
    #include <errno.h>
    #include <signal.h>
    #define CPS 10
    #define BUFFERSIZE CPS
    static volatile int loop = 0;
    void alrm_handler(int) {
        alarm(1); //每次响应alarm信号时，再设置一个alarm信号，这样就可以每秒收到一个alarm信号了
        loop = 1;
    }
    int main(int argc, char* argv[]) {
        int sfd, dfd = 1;  //目标流为标准输出
        char buf[BUFFERSIZE] = { 0 };
        int len, ret, pos;
        if (argc < 2) {
            fprintf(stderr, "Usage:...\n");
            exit(1);
        }
        do {
            sfd = open(argv[1], O_RDONLY);
            if (sfd < 0) {
                if (errno != EINTR) {
                    perror("open");
                    exit(1);
                }
            }
        } while (sfd < 0);
        signal(SIGALRM, alrm_handler);
        alarm(1);
        while (1) {
            while (!loop)
                pause();
            loop = 0; //从pause恢复后，立刻为下一次等待设置条件
            len = read(sfd, buf, BUFFERSIZE);
            if (len < 0) {  //读和写的重要区别，如果read的返回值小于目标读取量，不推荐反复读，因为
                if (errno == EINTR) {
                    continue; //读取失败时，会回到35行，然后又会在37行等待。主要是因为38行中已经将loop设置为0了，有两种方案，第一种是将loop=0移动到46行或62行之后。第二种是为了这个read在添加一层while循环。这样continue才会回到read处。
                }
                perror("read()");
                break;
            }
    /* 第二种方案例子
    		while((len = read(sfd, buf, BUFFSIZE)) < 0){
                if (errno == EINTR) {
                    continue;
                perror("read()");
                break;
            }
    */
            if (len == 0) {
                break;
            }
            pos = 0;
            while (len > 0) {
                ret = write(dfd, buf + pos, len);
                if (ret < 0) {
                    if (errno == EINTR) {
                        continue;
                    }
                    perror("write()");
                    exit(1);
                }
                pos += ret;
                len -= ret;
            }
          //loop = 0;
        }
        close(sfd);
        exit(0);
    }
    //从/etc/services中读取，并每秒输出10个字符
    ./slowcat /etc/services
    ```

32. 假设要读取的内容来自一个慢速的设备，例如打印机，若此时设备上没有数据，程序会阻塞在39行，然后等时钟信号到来后，阻塞被打断，经过42行的跳转，又会阻塞在39行。如果到来的数据量非常大，也无能为力，因为只能一秒读取一次，一次读取10个字符。这是典型的漏桶的实现。

33. 令牌桶是漏桶的改进，当读不到数据时，会积攒读取的权限，下次如果能读取多个，就会尽可能消耗掉权限。这样能应对波动的数据输入。一般数据的到来都是突发的，短时间会到来大量的数据，其他时间都在静默。令牌桶的实现如下，数据突然涌入时，也会突然消耗掉之前积攒的权限，读写多次：

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <sys/types.h>
    #include <fcntl.h>
    #include <sys/stat.h>
    #include <errno.h>
    #include <signal.h>
    #define CPS 10
    #define BUFFERSIZE CPS
    #define BURST 100 //token的上限
    static volatile int token = 0; //用来标记积攒的读取权限
    void alrm_handler(int) {
        alarm(1);
        token++;
        if (token > BURST){
            token = BURST;
        }
    }
    int main(int argc, char* argv[]) {
        int sfd, dfd = 1;
        char buf[BUFFERSIZE] = { 0 };
        int len, ret, pos;
        if (argc < 2) {
            fprintf(stderr, "Usage:...\n");
            exit(1);
        }
        do {
            sfd = open(argv[1], O_RDONLY);
            if (sfd < 0) {
                if (errno != EINTR) {
                    perror("open");
                    exit(1);
                }
            }
        } while (sfd < 0);
        signal(SIGALRM, alrm_handler);
        alarm(1);
        while (1) {
            while (token <= 0) //只要token>0，就会不暂停，直接读写
                pause();
            len = read(sfd, buf, BUFFERSIZE); //如果读取不到任何内容，则会阻塞在此处，等到下一次时钟信号到来被打断，在45行continue，又会等待在42行上，但是此时token已经完成了自增1，积累了一次权限。
            if (len < 0) {
                if (errno == EINTR) {
                    continue;
                }
                perror("read()");
                break;
            }
            if (len == 0) {
                break;
            }
            pos = 0;
            while (len > 0) {
                ret = write(dfd, buf + pos, len);
                if (ret < 0) {
                    if (errno == EINTR) {
                        continue;
                    }
                    perror("write()");
                    exit(1);
                }
                pos += ret;
                len -= ret;
            }
            token--;//完成一次输出，消耗掉一个token。这里存在一个可能出错的问题，就是信号处理函数15行也会对全局变量token进行处理，一般来说这里和15行不大可能时间上冲突。还有就是在某些精简指令集系统中，token--可能会被翻译成多条指令，非原子。可以将token声明为sig_atomic_t类型。这样对于该变量的使用和赋值都会是原子的。
        }
        close(sfd);
        exit(0);
    }
    ```

34. 实际上程序只要求匀速输出，至于读取的频率有多快，每次读取多少并不关心。例如用户只关心视频能否流畅播放，不关心缓冲的速度和进度。这种最好用多线程，生产者消费者模型来实现。

35. 为了方便后续的使用，可以将令牌桶封装成库，供其他程序调用。考虑到程序中可能需要多个令牌桶，该库中也应该维护一个令牌桶的数组或链表。

36. 结构体指针数组中，可以让结构体来自述下标。也就是说如果接收到了一个结构体指针，要释放它，此时不用去数组内循环查找它的位置来将其设置为NULL。可以在结构体的设计中包含一个pos变量，生成该结构体的时候，就存储上它在数组中的位置。这样在释放它时，可以直接通过pos变量来获取它的位置，直接对数组的对应元素赋值NULL。

37. 用单一计时器alarm来实现多任务计时器，效果如下：

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    void f1(char* s){
        printf("f1(): %s", s);
    }
    void f2(char* s){
        printf("f2(): %s", s);
    }
    int main(){
        int job1, job2, job3;
        puts("Begin!");
        if ((job1 = anytimer_addjob(5,f1,"aaa")) < 0){ //用一个结构体将等待时间，注册待调用的函数和参数保存起来。
            fprintf(stderr, "anytimer_addjob(): %s\n", strerr(-job1)); //校验返回值，后面调用两个也应该有。
            exit(1);
        }
        anytimer_addjob(2,f2,"bbb"); //用一个结构体指针数组来管理所有的计时器。每过一秒钟，将所有的有效计时器的等待时间都-1。如果在某一秒中，某个计时器的等待时间变为了0。则调用注册的函数，完事释放该结构体，并将对应的数组元素置为NULL。
        anytimer_addjob(7,f1,"ccc");
        puts("End!");
        while(1){ //不能立刻结束，需要等待时钟到来
            write(stdout, "*", 1); //每秒向控制台输出一个*
            sleep(1);
        }
    }
    //程序的预期结果为 先输出2个*，13行的信号到来输出，然后输出3个*，12行的信号到来，然后输出2个*，最后14行的信号到来，然后一直输出*。即**f2(): bbb***f1(): aaa**f1(): ccc*******
    ```

38. anytimer.h：

    ```c
    #ifndef ANYTIMER_H__
    #define ANYTIMER_H__
    
    #define JOB_MAX 1024
    typedef void(*anytimer_jobfunc_t)(void);
    /*
     *返回值  >=0    成功，返回计时任务ID
     *        == -EINVAL    失败，参数非法     //这里用系统自带的errno来返回出错的结果，调用者可以用strerr(返回值)来获取详细的出错信息。
     *        == -ENOSPC    失败，数组满
     *        == -ENOMEM    失败，内存空间不足
     */
    int anytimer_addjob(int sec, anytimer_jobfunc_t job, void* arg); //传给用户一个类似于文件描述符的整数，实际上就是结构体指针所在数组的下标。
    /*
     *返回值 == 0 成功，指定任务已经取消
     *      == -EINVAL 失败，参数非法
     *      == -EBUSY  失败，指定任务已完成
     *      == ECANCELED 失败，指定任务重复cancel
     */
    int anytimer_canceljob(int id);//取消一个job
    
    /*
     *返回值 == 0 成功，指定任务的结构体已经成功释放
     *      == -EINVAL 失败，参数非法
    */
    int anytimer_waitjob(int id);
    
    #endif
    ```

39. setitimer和getitimer，中间的i表示interval，即时间间隔。不同于时刻定时器，后者在某一时刻到达时才会触发。系统为每个进程提供了三种时钟，一个进程每种计时器最多只能有一个。setitimer的好处是，长期运行误差不累计，适合服务器环境。

    ```c
    //当时间间隔定时器(it_value)到时后，内核会发送一个信号给调用进程。然后计时器会重置为it_interval，如果时间间隔非零的话。
    #include <sys/time.h>
    int getitimer(int which, struct itimerval *curr_value);//which为时钟类型，取值可以为ITIMER_REAL，ITIMER_VIRTUAL，ITIMER_PROF，时钟信息存储在curr_value中。
    int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value);//用新的new_value设置，如果要保存旧的，可以提供old_value，否则可以用NULL代替。
    struct itimerval {
        struct timeval it_interval; //后续时间间隔，每次it_value到期后，都会原子化地将it_interval赋值给it_value。
        struct timeval it_value;    //初始时间间隔，每次都会将这个值递减。
    };
    struct timeval {
        time_t      tv_sec;  //秒
        suseconds_t tv_usec; //微秒
    };
    //若成功，返回0，否则返回-1，并设置errno。
    //如果it_value的2个字段都为0，则表示关闭这个定时器。如果it_interval的2个字段都为0，则表示这个定时器仅生效一次，否则为循环定时器。
    //当it_interval为3.5s，it_value为1.5s，则定时后1.5s会收到一个信号，然后每3.5s收到一个信号，一直持续下去。
    ```

40. 三种时钟到时后，发出的信号不同。

    1. ITIMER_REAL 用墙上时间计时，每次到时后发出SIGALRM信号。和alarm函数类似。
    2. ITIMER_VIRTUAL 用进程在用户态消耗的CPU时间来计时，计算该进程下所有线程的和。每次到时后发送SIGVTALRM信号。只有在进程执行时，该计时器才递减。
    3. ITIMER_PROF 用进程消耗的总CPU时间(用户态和内核态之和)来计时，计算该进程下所有线程的和。每次到时后发出SIGPROF信号。联合ITIMER_VIRTUAL可以用来度量进程的用户和内核态的CPU用时。

41. 通过fork产生的子进程不继承父进程的时间间隔定时器。时间间隔定时器在execve时保留。

42. 在使用system函数来执行命令期间，内核会自动屏蔽SIGCHILD，忽略SIGINT和SIGQUIT信号。

43. 信号集操作函数：

    ```c
    #include <signal.h>
    //sigset_t是信号集类型，由一个整型实现的位图，一定能够包含标准信号的个数。
    int sigemptyset(sigset_t *set);//使信号集排除所有信号，位图置为全0。
    int sigfillset(sigset_t *set); //使信号集包含所有的信号，位图置为全1。
    //信号集必须先使用empty或fill初始化，然后才可以调用下面的函数。
    int sigaddset(sigset_t *set, int signum); //向信号集中添加某个信号。
    int sigdelset(sigset_t *set, int signum); //从信号集中删除某个信号。
    
    int sigismember(const sigset_t *set, int signum); //判断信号是否存在于信号集中，在返回1，不在返回0，出错返回-1。
    ```

44. 用sigprocmask函数block的信号，在被屏蔽期间，终端的按键会回显也会发出信号，设置pending中的位图，但是却无法打断阻塞的系统调用，例如sleep。

    ```c
    #include <signal.h> //读写调用线程的信号屏蔽字
    int sigprocmask(int how, const sigset_t *_Nullable restrict set, sigset_t *_Nullable restrict oldset); 
    //how取值可以为SIG_BLOCK(向当前屏蔽集中添加set参数),SIG_UNBLOCK(从当前屏蔽集中删除set参数，允许尝试解锁未被屏蔽的信号),SIG_SETMASK(将当前屏蔽集设定为set参数)
    //如果oldset非NULL，则之前的屏蔽集会赋值给它。
    //如果set为NULL，则屏蔽集没有变化，但是还是会将当前屏蔽集赋值给oldset。保存现场，用于后面的恢复。
    //该函数在多线程进程中的行为未定义，可以使用pthread_sigmask代替。
    ```

45. sigpending的作用不大，它会去内核中获取pending集，即到来的信号的状态。但是该函数从内核中返回时，就会响应一个信号，返回后的pending集就跟原来不同了。

    ```c
    #include <signal.h>
    int sigpending(sigset_t *set);
    ```

46. 不能从信号处理函数随意跳转到其他位置，例如使用longjmp。因为信号处理函数结束后，还要把之前的设置过的mask位恢复，若longjmp，就没有机会做这件事，会导致该进程永远无法收到该信号了。不同UNIX的行为不一样，BSD上在setjmp时，就可以设置保存mask。然后再longjmp时，会自动恢复。POSIX提供了两个函数用来完成这样的工作：sigsetjmp和siglongjmp，配套使用，这样就可以从信号处理函数往外跳了。

    ```c
    #include <setjmp.h>
    void sigsetjmp(sigjmp_buf env, int savesigs);//savesigs表示是否要保存mask，如果为true，则siglongjmp时，就会自动恢复mask，和BSD的行为相同。
    void siglongjmp(sigjmp_buf env, int val);
    ```

47. 信号驱动程序：也就是执行一段程序（期间不会响应驱动信号），然后暂停，等待驱动信号，然后继续循环执行。这个功能可以用sigprocmask和pause完成，但是如果要求将屏蔽期间收到的信号也作为一个驱动信号来驱动，则无法完成（类似于令牌桶，可以积攒权限），可以使用sigsuspend来实现。

    ```c
    sigprocmask(SIG_BLOCK, &set,&oldset); //set中包含想要屏蔽的信号，即驱动信号，oldset为空。
    /* 执行程序 */
    sigprocmask(SIG_SETMASK, &oldset, NULL);//在这两句中间发送的驱动信号都不会被响应，而是暂存起来。而在这个函数从内核回来时，就会处理掉驱动信号，因为此时已经解除屏蔽了。因此会暂停在下面的pause上。发生这种情况的主要原因是，这两句不是原子操作，无法在接触屏蔽的同时暂停。
    pause();
    
    #include <signal.h>
    int sigsuspend(const sigset_t *mask); //临时用mask替换调用线程的信号屏蔽字，然后马上进入阻塞状态，等待一个信号信号（该信号要么注册了处理函数，要么会杀死进程），信号响应完毕后，恢复信号屏蔽字。该函数中间不会响应任何信号。如果该信号的行为杀死了进程，则sigsuspend函数不会返回；如果调用了信号处理函数，则sigsuspend函数会再信号处理函数返回后再返回，然后恢复信号屏蔽字。mask中不能包含SIGKILL或SIGSTOP，会没有效果。
    //总是返回-1，并设置errno为EINTR，即被信号打断。
    ```

48. 用signal为多个信号注册同一个处理函数时可能会出现信号处理函数被重入的风险。例如信号A，B都注册了处理函数C，当进程在执行处理函数C来响应信号A期间，可能会进入内核，在从内核返回时，又回去响应刚刚到来的信号B，因此又会去调用C。这样C函数将会被调用两次。另外一种情况就是从内核返回时，也可能。如果使用signal函数，要避免这种情况，就只能在信号处理函数一开始就先屏蔽掉其他注册了此处理函数的其他信号，然后在信号处理函数结束时，再恢复。

49. 例如，使用多个信号（SIGINT，SIGQUIT，SIGTERM）来进行程序收尾，将他们注册了同一个处理函数。收尾程序中的某些命令只能被执行一次，例如使用信号来申请释放内存，或者打开关闭文件，一旦被重入则有可能出错。

50. sigaction可以完整地替换signal函数，并解决上面的问题。

    ```c
    #include <signal.h>
    int sigaction(int signum, const struct sigaction *_Nullable restrict act, struct sigaction *_Nullable restrict oldact); //signum为除了SIGKILL和SIGSTOP的任何信号，act为新的处理函数，oldact会保存旧的。
    
    struct sigaction {
        void     (*sa_handler)(int); //某些架构中，sa_handler和sa_sigaction是一个union，不能同时赋值。
        void     (*sa_sigaction)(int, siginfo_t *, void *); //响应信号时，会将信号相关的信息填入第二个参数中。
        sigset_t   sa_mask; //响应当前信号时，还想要block的信号，可以放在sa_mask中。
        int        sa_flags; //如果值包含SA_SIGINFO，则会使用sa_sigaction函数，而非sa_handler。
        void     (*sa_restorer)(void);
    };
    //如果要给三个信号设置sigacton，不需要分别设置sa_mask来屏蔽另外2个，可以使用同一个屏蔽这三个信号的mask。因为无论如何都会屏蔽自己。
    ```

51. signal并不区分信号的来源，而是将所有信号都认为一样。可以使用sigaction来设置只响应从内核传来的信号，而对于用户使用kill发送的信号不予响应。或者只响应从某个进程发来的信号。

    ```c
    siginfo_t {
        int      si_signo;     /* Signal number */
        int      si_errno;     /* An errno value */
        int      si_code;      /* Signal code 记录了信号从何而来，例如USER或KERNEL*/
        int      si_trapno;    /* Trap number that caused hardware-generated signal (unused on most architectures) */
        pid_t    si_pid;       /* Sending process ID */
        uid_t    si_uid;       /* Real user ID of sending process */
        int      si_status;    /* Exit value or signal */
        clock_t  si_utime;     /* User time consumed */
        clock_t  si_stime;     /* System time consumed */
        union sigval si_value; /* Signal value */
        int      si_int;       /* POSIX.1b signal */
        void    *si_ptr;       /* POSIX.1b signal */
        int      si_overrun;   /* Timer overrun count; POSIX.1b timers */
        int      si_timerid;   /* Timer ID; POSIX.1b timers */
        void    *si_addr;      /* Memory location which caused fault */
        long     si_band;      /* Band event (was int in glibc 2.3.2 and earlier) */
        int      si_fd;        /* File descriptor */
        short    si_addr_lsb;  /* Least significant bit of address (since Linux 2.6.32) */
        void    *si_lower;     /* Lower bound when address violation occurred (since Linux 3.19) */
        void    *si_upper;     /* Upper bound when address violation occurred (since Linux 3.19) */
        int      si_pkey;      /* Protection key on PTE that caused fault (since Linux 4.6) */
        void    *si_call_addr; /* Address of system call instruction (since Linux 3.5) */
        int      si_syscall;   /* Number of attempted system call (since Linux 3.5) */
        unsigned int si_arch;  /* Architecture of attempted system call (since Linux 3.5) */
    }
    ```

52. 海量的假信号可能会淹没掉真信号。

53. 在进程的多个线程之间进行用户级的上下文切换：

    ```c
    #include <ucontext.h> //上下文就是可还原的执行现场，使用这两个函数就可以在用户态搭建一个多线程框架。
    int getcontext(ucontext_t *ucp); //将获取到的上下文保存在ucp中，上下文包括信号屏蔽字，执行栈，机器寄存器。
    int setcontext(const ucontext_t *ucp); //ucp参数要么是用getcontext获得的，要么是通过sigaction的三参信号处理函数的最后一个参数传递的。
    ```

54. 实时信号不会丢失，会记录下相同信号的数量，依次响应。不同的信号也会按照收到的顺序来依次响应。如果同时受到标准信号和实时信号，则会先响应标准信号。

55. 实时信号都没有默认动作，标准信号除了SIGUSR1和SIGUSR2都由默认动作。

56. 使用ulimit设置实时信号可以排队的上限：pending signals，一般为7k多个。


# 线程

1. 线程就是一个正在运行的函数。线程之间没有主次之分，main函数也不应称之为主线程。

2. 线程之间共享代码段，全局数据段，堆。但是每个线程都有自己的栈，信号屏蔽字，errno变量，实时调度策略和优先级。

3. 线程之间通信比进程之间简单，可以使用全局变量，因为共享同一块地址空间。

4. 就某些算法而论，用多线程来实现比之以多进程实现要更加自然。

5. 线程有多个标准，最常用的是POSIX标准，还有OpenMP标准。POSIX线程只是标准，没有实现，各家系统的实现可以不一样。例如线程标识是pthread_t类型，但是可能是整数或结构体或指针。Linux环境下使用整数实现。

6. 使用POSIX线程，需要在gcc编译和链接时加入-pthread选项。makefile中使用`CFLAGS+=-pthread`和`LDFLAGS+=-pthread`。

7. `ps ax -L`可以查看进程中包含的线程。-L表示以Linux的模式查看。

   ```shell
   zj@zj-hit:~$ ps ax -L  #LWP是轻量级进程，是Linux下的线程。
       PID     LWP TTY      STAT   TIME COMMAND
       869     869 ?        Ssl    0:00 /usr/sbin/rsyslogd -n -iNONE
       869     879 ?        Ssl    0:00 /usr/sbin/rsyslogd -n -iNONE
       869     880 ?        Ssl    0:00 /usr/sbin/rsyslogd -n -iNONE
       869     881 ?        Ssl    0:00 /usr/sbin/rsyslogd -n -iNONE
   ```

8. Linux下进程的第一个线程（一般是main线程）的线程号和进程号相同，线程号会挤占进程号的空间。

9. Linux下存在2个Pthread的实现：

   1. LinuxThreads，最原始的pthread实现，在glibc2.4后，就不再维护。
   2. NPTL（Native POSIX Thread Library），现代实现，更符合标准，对于创建大量线程更优化。在glibc2.3.2，Linux2.6内核之后可用。没有管理线程，所有的线程在同一个线程组内。使用了前两个实时信号，因此这些信号不能在程序中使用。

10. 这两者都是1:1实现，每个线程都对应于一个内核调度实体。都使用了clone的系统调用。在NPTL中，进程同步原语（互斥量，线程join）通过futex系统调用实现。从glibc2.3.2开始，可以使用`getconf GNU_LIBPTHREAD_VERSION`来确定pthread是哪个实现。

11. Pthreads定义了一套C语言的类型、函数与常量，它以pthread.h头文件和一个线程库实现。

12. Pthreads API中大致共有100个函数调用，全都以"pthread_"开头，并可以分为四类：

    1. 线程管理，例如创建线程，等待(join)线程，查询线程状态等。

    2. 互斥锁（Mutex）：创建、摧毁、锁定、解锁、设置属性等操作。

    3. 条件变量（Condition Variable）：创建、摧毁、等待、通知、设置与查询属性等操作。

    4. 使用了互斥锁的线程间的同步管理。

13. POSIX的Semaphore API可以和Pthreads协同工作，但这并不是Pthreads的标准。因而这部分API是以`sem_`打头，而非`pthread_`。一般来说信号量是应在进程间通信的。

14. pthread的函数成功时，返回0，失败则返回error number，并不会设置errno，这个和系统调用的规定不一样，后者都是返回-1，并设置errno，这样可能会导致多个出错覆盖的问题。此时不能用perror报错，只能用strerror报错。

15. 线程标识符（号）：

    ```c
    #include <pthread.h>
    int pthread_equal(pthread_t t1, pthread_t t2); //比较两个线程的标识符，因为pthread_t的类型不定，因此不能使用==比较。相同时，返回非0，否则为0。
    pthread_t pthread_self(void); //返回调用线程的线程标识符。类似于进程的getpid
    ```

16. 线程的创建：

    ```c
    int pthread_create(pthread_t *restrict thread, const pthread_attr_t *restrict attr, void *(*start_routine)(void *), void *restrict arg); //在调用进程中产生一个新的线程。新线程的入口地址是start_routine，也成为启动例程。arg是传递给它的单个参数。attr指向一个确定线程属性的pthread_attr_t类型结构体。该结构体使用pthread_attr_init来初始化。如果为attr为NULL，则使用默认属性创建线程。
    //如果调用成功，则返回前会将新线程的标识符存放在thread参数内。出错时thread参数的内容不定。
    //新线程继承调用线程的信号屏蔽字，不继承信号栈上下文。新线程的pending集为空。
    //新线程继承调用线程的浮点环境。
    //在Linux下，还有如下特性，新线程会继承调用线程的能力集(capability sets)和CPU亲和屏蔽字(affinity mask)。
    //大部分情况下不需要设置线程的属性，使用默认的即可。
    ```

17. 线程终止的情况：

    1. 主动调用了`void pthread_exit(void *retval)`，retval为退出状态，可以通过兄弟线程调用`int pthread_join(pthread_t thread, void **retval)`来接收。

       ```c
       #include <pthread.h>
       [[noreturn]] void pthread_exit(void *retval); //推荐使用pthread_exit，而非return，它会执行线程栈的清理。类似于进程的exit会调用钩子函数一样。这个函数不会返回到调用者。
       ```

    2. 从入口函数处正常返回，等价于调用pthread_exit，其中retcval就是return的值。

    3. 被`int pthread_cancel(pthread_t thread)`取消了。

    4. 任何一个兄弟线程调用了exit，或者main线程从main()函数return了。这都会终止进程的所有线程。

18. 线程终止时，进程级别的共享资源必会释放，例如互斥量，条件变量，信号量，文件描述符等。使用atexit注册的钩子函数也不会调用。只有进程的最后一个线程终止时，才会执行上述动作。

19. 等待一个线程终止：

    ```c
    #include <pthread.h>
    int pthread_join(pthread_t thread, void **retval); //thread参数指定要等待的线程，如果线程已经终止，则立即返回，否则阻塞。该thread必须是可等待的(joinable)。
    //如果retval非空，则会将目标线程的退出状态(就是pthread_exit的参数)赋值给retval指向的空间，也就是需要传入一个一级指针的地址。如果目标线程是通过pthread_cancel终止的，则会将PTHREAD_CANCELED赋值。
    //如果多个线程同时终止，尝试去join同一个线程，那么行为未定义。如果调用pthread_join的线程被取消了，那么目标线程仍然是可等待的。
    //成功返回0，否则返回错误代码。
    ```

20. 例子：

    ```c
    #include <stdio.h>
    #include <unistd.h>
    #include <pthread.h>
    #include <string.h>
    #include <stdlib.h>
    static void* func (void* p){
        puts("Thread is working!\n");
        return NULL;
    }
    int main(){
        pthread_t tid;
        int err;
        puts("Begin!\n");
        err = pthread_create(&tid, NULL, func, NULL);
        if(err){
            fprintf(stderr, "pthread_create():%s\n", strerror(err));
            exit(1);
        }
    //  pthread_join(tid,NULL);
        puts("End!\n");
        exit(0);
    }
    //理想的执行顺序是main线程打印Begin!，然后另一个线程打印Thread is working!，然后main线程打印End!。不过线程的执行顺序取决于调度器，不能事先假定其顺序。
    //新创建的线程有可能在main线程执行到exit时，都没有调度到，此时进程结束，它永远也不会被执行了。
    ```

21. 线程的取消：

    ```c
    //例如将一个查找的任务交给多个线程，当其中一个线程找到后，应该取消其他所有的线程。
    #include <pthread.h>
    int pthread_cancel(pthread_t thread); //给thread线程发送取消请求，目标线程的是否和何时响应，取决于它的取消状态和类型。
    //线程的取消状态可以通过pthread_setcancelstate设置为enable或disable。
    int pthread_setcancelstate(int state, int *oldstate); //设定线程的取消状态。如果线程关闭了取消状态(PTHREAD_CANCEL_DISABLE)，则该取消请求会排队等待线程打开取消状态(PTHREAD_CANCEL_ENABLE)。默认所有线程都打开取消状态。
    int pthread_setcanceltype(int type, int *oldtype); //设定线程的取消类型。分为推迟取消和异步取消。默认状态下，取消请求会被推迟到取消点前再响应(PTHREAD_CANCEL_DEFERRED)；或者线程可以在任何时间被取消(PTHREAD_CANCEL_ASYNCHRONOUS)，通常会在收到请求时立刻响应，但是系统并不保证这一点。
    void pthread_testcancel(void); //调用这个函数就会创建一个取消点。适用于纯科学计算的线程，因为他可能会运行很长时间而不阻塞，因此需要认为制造一个取消点。
    //POSIX.1中定义一些函数必须是cancel点（都是可能引发阻塞的系统调用），一些可以是cancel点。这可以在man pthreads中找到。
    
    //例子
    fd1=open();
    pthread_cleanup_push(); //为了防止打开fd1后立刻被取消，导致没法释放文件，可以将close函数添加到清理栈中。有一种极端情况，也就是在fd1打开后，清理函数入栈前，收到了cancel请求，不过此时也不用害怕被直接取消，因为默认情况下，cancel请求会被推迟响应。程序继续执行，将要阻塞在open时才会响应取消请求，从而调用清理函数。
    fd2=open();
    pthread_cleanup_push();
    pthread_cleanup_pop();
    pthread_cleanup_pop();
    ```

22. 栈的清理，操作调用线程的取消清理栈，其中存放的都是线程取消时会被调用的钩子函数。可以用于解锁互斥量，使之可以被其他线程使用：

    ```c
    #include <pthread.h> //类似于atexit记录钩子函数，不过POSIX.1允许下面的函数用宏实现，展开后各自缺一个大括号，所以要成对使用，且出现在同一个语法区域内。
    void pthread_cleanup_push(void (*routine)(void *), void *arg); //将一个函数压入栈中，函数为routine，参数为arg。
    void pthread_cleanup_pop(int execute); //从栈上弹出一个函数，若execute非0，则会调用该函数，否则不会。
    //有如下三种情况会将函数弹出栈：1.线程被取消时，所有函数依次弹出栈并执行。2.线程调用pthread_exit终止时，所有函数依次弹出栈并执行，return时不会调用。3.线程调用pthread_cleanup_pop时，最顶部的函数弹出栈，是否执行看参数execute。
    //例子
    static void* func(void*p){
        pthread_cleanup_push(cleanfunc,"1"); //逐个将三个钩子函数入栈
        pthread_cleanup_push(cleanfunc,"2");
        pthread_cleanup_push(cleanfunc,"3");
        pthread_cleanup_pop(1); //逐个将他们逆序弹出
        pthread_cleanup_pop(0); //第二个函数不会被执行
        pthread_cleanup_pop(1);
        pthread_exit(NULL);
    //pthread_cleanup_pop一定要配套出现，否则会报语法错误。即使在exit之后也可以，此时会将参数execute都当作是1。
    //  pthread_cleanup_pop(1);
    //  pthread_cleanup_pop(0);
    //  pthread_cleanup_pop(1);
    }
    ```

23. 线程分离，表示不关心这个线程的生死存亡：

    ```c
    #include <pthread.h>
    int pthread_detach(pthread_t thread); //将thread线程标记为分离的。当一个分离的线程终止时，它的资源会自动释放给系统，而不需要其他线程来join它。尝试去join一个分离的线程会产生未定义的行为。
    ```

24. 线程出现竞争的明显现象是，程序的结果有时和设想的不同，而且每次都可能不一样。可以增加sleep语句来复现竞争的结果，类似于没有红绿灯的十字路口，如果车辆较长（sleep），则可能会碰撞，反之碰撞几率则较小。

25. 例如将查找20个数中的质数的任务分配给20个线程，在main线程中使用for循环创建20个线程，i不断递增的同时也将他传递给每个线程的入口函数。因此对于变量i来说，有20个线程要读它，而main线程还在同时改变他。因此调度顺序的不同，会使得每个线程读到的i可能不同。改进方法是：将这20个数放在一个数组中，每次创建线程时，分别传入不同位置的数即可。

26. 一个进程中可以包含的线程数量，取决于进程的可用地址空间和每个线程的栈大小（ulimit可以查看，默认为10MB）。对于64位系统，最先消耗完的可能是PID号。

27. 例子，20个线程，每个线程都从文件读取一个数，然后加1，写回文件，不竞争的情况下，文件中的数会增加20：

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <pthread.h>
    #include <unistd.h>
    
    static void* thr_add (void* p){
        char linebuf[1024];
        FILE *fp;
        fp=fopen("/tmp/out","r+");
        if(fp == NULL){
            perror("fopen()");
            exit(1);
        }
        fgets(linebuf,1024,fp);
        fseek(fp,0,SEEK_SET);
     // sleep(1); //这段程序如果在单核机器上运行，由于每个线程都比较短，因此有可能不会出现竞争，此时可以让程序sleep一下，这样就更容易产生竞争了，有时会仅使数据增加1。
        fprintf(fp,"%d\n",atoi(linebuf)+1);
        fclose(fp);
        pthread_exit(NULL);
    }
    int main(){
        int i, err;
        pthread_t tid[20];
        for(i=0; i<20; i++){
            err = pthread_create(tid+i, NULL, thr_add, NULL);
            if(err){
                fprintf(stderr, "pthread_create():%s\n", strerror(err));
                exit(1);
            }
        }
        for(i=0; i<20; i++){
            pthread_join(tid[i], NULL);
        }
        exit(0);
    }
    ```

28. 互斥量是线程同步的一种机制。为资源加锁，保证同时只能由一个人占有该资源。

29. 创建和销毁互斥量。

    ```c
    #include <pthread.h>
    int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr); //动态初始化互斥量mutex，可以在attr参数中设置其属性。刚初始化的互斥量是未加锁的。重复初始化一个互斥量，会造成未定义的行为。
    pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; //静态初始化，使用默认参数，编译时常量表达式。
    int pthread_mutex_destroy(pthread_mutex_t *mutex); //销毁互斥量。
    //被销毁后的互斥量还可以重新初始化，对被销毁的互斥量加锁的行为是未定义的。
    //销毁未解锁的互斥量，或者正在被其他线程尝试加锁的互斥量，或者被其他线程调用pthread_cond_timedwait或pthread_cond_wait等待的互斥量，此时行为未定义。
    ```

30. 给互斥量上锁，解锁：

    ```c
    #include <pthread.h>
    int pthread_mutex_lock(pthread_mutex_t *mutex);
    int pthread_mutex_trylock(pthread_mutex_t *mutex); //非阻塞的lock，
    int pthread_mutex_unlock(pthread_mutex_t *mutex);
    ```

31. 多个人同时对一个资源只读是没有竞争的。一旦有一个人要写，那么就需要考虑竞争，因为写之前和写之后读到的结果是不同的。

32. 代码临界区：同一时刻只能有一个线程在其中执行代码。任何一个线程在进入之前，都需要获取锁，退出时释放锁。

33. 互斥量其实是限制某段代码能否运行，而非某个变量或资源能否使用。

34. 互斥锁链，可以让多个线程有序执行：

    ```c
    #include <pthread.h>
    #include <signal.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <unistd.h>
    
    static pthread_mutex_t mut[4]; // 4个互斥量构成了一个循环链
    static pthread_t tid[4];
    
    static void *thr_func(void *p) { // p分别为0，1，2，3
      int c = 'a' + (int)p;
      while (1) {
        pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
        //为了避免没有解锁而直接退出线程，先不对cancel响应。
        pthread_mutex_lock(mut + (int)p);
        //每个线程对自己的互斥量加锁，因为在创建线程时都加锁了，所以这里都会阻塞，但是由于在第28行解锁了第0个互斥量，所以只有它不阻塞在此。
        write(1, &c, 1);
        pthread_mutex_unlock(mut + ((int)p + 1) % 4); //解锁下一个互斥量。
        pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
        //解锁后，才可以响应cancel。
        pthread_testcancel(); //如果没有这个调用，就不会响应cancel，为pthread_setcancelstate不是一个取消点。这样会造成始终不响应cancel请求，从而一直运行不停止。
      }
      pthread_exit(NULL);
    }
    
    static void mutex_destroy(int sig) {
      int i;
      for (i = 0; i < 4; i++) {
        pthread_cancel(tid[i]);
      }
    }
    
    int main() {
      int i, err;
      void *return_msg;
      signal(SIGALRM, mutex_destroy); //注册信号，响应闹钟的到来
      for (i = 0; i < 4; i++) {
        pthread_mutex_init(mut + i, NULL);
        //初始化并对各自的互斥量加锁，此时可以顺利加锁。
        pthread_mutex_lock(mut + i);
        err = pthread_create(tid + i, NULL, thr_func, (void *)i);
        if (err) {
          fprintf(stderr, "pthread_create():%s\n", strerror(err));
          exit(1);
        }
      }
      pthread_mutex_unlock(mut+0); //解锁第一个互斥量，可以将0修改为1，2，3来从b，c，d开始输出
      alarm(1); //因为4个线程都是死循环，所以设定1秒后停止
      for (i = 0; i < 4; i++) {
        pthread_join(tid[i], &return_msg);
        //结果为PTHREAD_CANCELED宏，即((void *) -1)
        printf("%d\n", (int)return_msg);
      }
      for (i = 0; i < 4; i++) {
        pthread_mutex_destroy(mut + i);
      }
      exit(0);
    }
    ```

35. 使用任务池来计算质数：

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <pthread.h>
    #include <string.h>
    #define LEFT 30000000
    #define RIGHT 30000200
    #define THRNUM 4
    static int num = 0; //用来存储待计算的数，全局变量可以方便各个线程读写。
    static pthread_mutex_t mut_num = PTHREAD_MUTEX_INITIALIZER;
    void* thr_prime(void* p){
        int i,j,mark;
        while(1){
            pthread_mutex_lock(&mut_num);
            while(num == 0){
                pthread_mutex_unlock(&mut_num);
                sched_yield();
                pthread_mutex_lock(&mut_num);
            }
            if(num == -1){
                pthread_mutex_unlock(&mut_num);
                break;
            }
            i = num; //这里使用一个局部变量将num保存起来，可以尽可能缩短临界区的代码范围
            num = 0;
            pthread_mutex_unlock(&mut_num);
            mark = 1;
            for(j=2; j<i/2; j++){
                if(i%j == 0){
                    mark = 0;
                    break;
                }
            }
            if(mark){
                printf("[%d]:%d is a primer\n", (int)p, i);
            }
        }
        pthread_exit(NULL);
    }
    int main(){
        int i, err;
        pthread_t tid[THRNUM];
        for(i=0; i<THRNUM; i++){
            err = pthread_create(tid+i, NULL, thr_prime, (void*)i);
            if(err){
                fprintf(stderr, "pthread_create():%s\n", strerror(err));
                exit(1);
            }
        }
        for(i=LEFT; i<RIGHT; i++){//下发任务
            pthread_mutex_lock(&mut_num);
            while(num != 0){ //如果num不为0，表示已经下发了任务还没有线程接收该任务。
                pthread_mutex_unlock(&mut_num);
                sched_yield(); //调用线程主动让出CPU。可以认为是任意短的sleep。如果使用sleep会造成进程调度颠簸。
                pthread_mutex_lock(&mut_num);
            }
            num = i;
            pthread_mutex_unlock(&mut_num);
        }
        pthread_mutex_lock(&mut_num);
        while(num != 0){ //如果num不为0，表示最后一个任务还没有被取走。
            pthread_mutex_unlock(&mut_num);
            sched_yield();
            pthread_mutex_lock(&mut_num);
        }
        num = -1; //这样任务线程再取到-1后，会自动退出，然后被main线程join。
        pthread_mutex_unlock(&mut_num);
        for(i=0; i<THRNUM; i++){
            pthread_join(tid[i], NULL);
        }
        pthread_mutex_destroy(&mut_num); //销毁互斥量
        exit(0);
    }
    ```

36. 如果在临界区内要进行跳转（例如break或continue等），如果目的地还在临界区内，则可以不用解锁，否则需要先解锁，再跳转。否则会产生死锁状态。

37. 上面的方法有一个问题，任务线程在让出CPU后，可能会调度另一个任务线程抢到锁，这样它还得继续让出CPU。主要原因是main线程和任务线程的地位并不相同，而且任务线程数量多，更容易抢到锁。可以采用通知法，main线程等待取走任务的哪个任务线程唤醒它，任务线程等待main线程唤醒它们中的一个。

38. 主动让出CPU：

    ```c
    #include <sched.h>
    int sched_yield(void); //使调用线程让出CPU，移动到它的静态优先级的调度队列的末尾。如果当前线程是最高优先级队列中的唯一一个线程，那么它会继续运行。
    ```

39. 从Linux2.6.23开始，默认的调度器就是CFS(Completely Fair Scheduler)，替代了早先的O(1)调度器。调度器是内核的一部分，每个线程都有关联的调度策略和一个静态的调度优先级。调度器会根据所有线程的这2个属性来决定现在调度哪个程序。

40. 条件变量和互斥量不同的是，一个线程释放了互斥量后，不会去唤醒另一个阻塞在该互斥量上的线程，而条件变量会：

    ```c
    #include <pthread.h> //初始化和销毁一个条件变量，类似于互斥量的用法
    int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); //动态初始化
    pthread_cond_t cond = PTHREAD_COND_INITIALIZER; //静态初始化
    int pthread_cond_destroy(pthread_cond_t *cond);
    ```

41. 广播或发送信号：

    ```c
    #include <pthread.h>
    int pthread_cond_broadcast(pthread_cond_t *cond); //唤醒所有阻塞在条件变量cond上的线程。
    int pthread_cond_signal(pthread_cond_t *cond); //至少唤醒一个线程。
    //如果有多个线程阻塞在同一个条件变量上，调度策略会决定唤醒的顺序。
    //如果没有线程阻塞在条件变量上，那么这两个函数没有任何效果。
    ```

42. 等待一个条件，会用到条件变量和互斥量：

    ```c
    #include <pthread.h> //解锁互斥量，然后阻塞在条件变量上，此时在临界区外，线程会让出CPU。应确保调用时，当前线程已经锁住了互斥量，否则会报错或产生未定义行为。成功返回时表示，当前线程已经锁住了互斥量，
    int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); //等待abstime时间
    int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); //死等
    //应确保在调用线程锁定互斥量的情况下调用这些函数。
    ```

43. 仅使用互斥量的程序本是上是查询法，效率不如通知法高。例子：

    ```c
    pthread_mutex_lock(&mut);
    while(num == 0){ //本质上是查询法
        pthread_mutex_unlock(&mut);
        sched_yield();
        pthread_mutex_lock(&mut);
    }
    ... //临界区操作
    pthread_mutex_unlock(&mut);
    //更改为如下：
    pthread_mutex_lock(&mut);
    while(num == 0){
        pthread_cond_wait(&cond,&mut); //cond为条件变量，此时或解锁mut，然后在cond上等待。当其他线程对该条件变量调用signal或broadcast时，会唤醒此线程。当此线程被唤醒后，会尝试锁定互斥量mut。如果成功则继续向下执行，否则会阻塞在抢锁阶段。
    }
    i = num; //读取非零的num
    num = 0;
    pthread_cond_broadcast(&cond); //唤醒main线程来继续填入新的数据
    pthread_mutex_unlock(&mut);
    
    //下发任务的
    pthread_mutex_lock(&mut);
    while(num != 0){
        pthread_cond_wait(&cond,&mut);
    }
    num = i;
    pthread_cond_broadcast(&cond);
    pthread_mutex_unlock(&mut); //唤醒等待的线程和解锁这两句的顺序并没有严格的顺序。不过推荐先唤醒，再解锁，这样可以让被唤醒的线程随后立即抢锁。
    ```

44. 使用条件变量的通知法来改写筛选质数：

    ```c
    #include <pthread.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <unistd.h>
    #define LEFT 30000000
    #define RIGHT 30000200
    #define THRNUM 4
    static int num = 0; //用来存储待计算的数，全局变量可以方便各个线程读写。
    static pthread_mutex_t mut_num = PTHREAD_MUTEX_INITIALIZER;
    static pthread_cond_t cond_num = PTHREAD_COND_INITIALIZER;
    void *thr_prime(void *p) {
      int i, j, mark;
      while (1) {
        pthread_mutex_lock(&mut_num);
        while (num == 0) {
          pthread_cond_wait(&cond_num, &mut_num);
          // cond为条件变量，此时或解锁mut，然后在cond上等待。当其他线程对该条件变量调用signal或broadcast时，会唤醒此线程。当此线程被唤醒后，会尝试锁定互斥量mut。如果成功则继续向下执行，否则会阻塞在抢锁阶段。
        }
        if (num == -1) {
          pthread_mutex_unlock(&mut_num);
          break;
        }
        i = num;
        num = 0;
        pthread_cond_broadcast(&cond_num);
        //不能使用signal，因为可能会唤醒另一个任务线程
        pthread_mutex_unlock(&mut_num);
        mark = 1;
        for (j = 2; j < i / 2; j++) {
          if (i % j == 0) {
            mark = 0;
            break;
          }
        }
        if (mark) {
          printf("[%d]:%d is a primer\n", (int)p, i);
        }
      }
      pthread_exit(NULL);
    }
    int main() {
      int i, err;
      pthread_t tid[THRNUM];
      for (i = 0; i < THRNUM; i++) {
        err = pthread_create(tid + i, NULL, thr_prime, (void *)i);
        if (err) {
          fprintf(stderr, "pthread_create():%s\n", strerror(err));
          exit(1);
        }
      }
      for (i = LEFT; i < RIGHT; i++) { //下发任务
        pthread_mutex_lock(&mut_num);
        while (num != 0) {
          pthread_cond_wait(&cond_num, &mut_num);
        }
        num = i;
        pthread_cond_signal(&cond_num); //这里只要唤醒一个工作线程即可
        pthread_mutex_unlock(&mut_num);
        //唤醒等待的线程和解锁这两句的顺序并没有严格的顺序。不过推荐先唤醒，再解锁，这样可以让被唤醒的线程随后立即抢锁。
      }
      pthread_mutex_lock(&mut_num);
      while (num != 0) {
        pthread_cond_wait(&cond_num, &mut_num);
      }
      num = -1;
      pthread_cond_broadcast(&cond_num); //需要唤醒所有的工作线程。
      pthread_mutex_unlock(&mut_num);
      for (i = 0; i < THRNUM; i++) {
        pthread_join(tid[i], NULL);
      }
      pthread_mutex_destroy(&mut_num); //销毁互斥量
      pthread_cond_destroy(&cond_num); //销毁条件变量
      exit(0);
    }
    ```

45. 使用time命令来对通知法和查询法进行度量，可以看到通知法的时间更短：

    ```shell
    zj@zj-hit:~/test/C$ time ./main #查询法
    real    0m0.281s
    user    0m0.733s
    sys     0m0.049s
    zj@zj-hit:~/test/C$ time ./main #通知法
    real    0m0.247s
    user    0m0.643s
    sys     0m0.037s
    ```

46. 如果不确定是唤醒任意一个，还是唤醒所有，则可以都唤醒。

47. 使用条件变量来改进逐个打印abcd的问题。

    ```c
    #include <pthread.h>
    #include <signal.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <sys/time.h>
    #include <unistd.h>
    
    static pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;
    static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
    static pthread_t tid[4];
    static int num = 0; //令牌，用来记录当前允许哪个线程打印。只有num和自己的线程编号(int)p相同时，线程才会打印，否则wait在一个条件变量上，每次取得权力后，将令牌移动一位，叫醒所有等待令牌的线程。
    
    static void *thr_func(void *p) {
      int c = 'a' + (int)p;
      while (1) {
        pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
        pthread_mutex_lock(&mut);
        while (num != (int)p) {
          pthread_cond_wait(&cond, &mut);
        }
        write(1, &c, 1);
        num = (num + 1) % 4; //令牌移动一位
        pthread_cond_broadcast(&cond); //此时无法定向唤醒，只能唤醒所有
        pthread_mutex_unlock(&mut);
        pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
        pthread_testcancel();
      }
      pthread_exit(NULL);
    }
    
    static void mutex_destroy(int sig) {
      int i;
      for (i = 0; i < 4; i++) {
        pthread_cancel(tid[i]);
      }
    }
    
    int main() {
      int i, err;
      void *return_msg;
      struct itimerval it;
      signal(SIGALRM, mutex_destroy);
      for (i = 0; i < 4; i++) {
        pthread_mutex_init(&mut, NULL);
        pthread_mutex_lock(&mut);
        err = pthread_create(tid + i, NULL, thr_func, (void *)i);
        if (err) {
          fprintf(stderr, "pthread_create():%s\n", strerror(err));
          exit(1);
        }
      }
      pthread_mutex_unlock(&mut); //解锁互斥量，
      it.it_interval.tv_sec = 0;
      it.it_interval.tv_usec = 0;
      it.it_value.tv_sec = 0;
      it.it_value.tv_usec = 20000;
      setitimer(ITIMER_REAL, &it, NULL);
      // alarm(1); //因为4个线程都是死循环，所以设定1秒后停止
      for (i = 0; i < 4; i++) {
        pthread_join(tid[i], &return_msg);
        //结果为PTHREAD_CANCELED宏，即((void *) -1)
        printf("%d\n", (int)return_msg);
      }
      for (i = 0; i < 4; i++) {
        pthread_mutex_destroy(&mut);
      }
      exit(0);
    }
    ```

48. 读写锁，分为读锁和写锁。允许多个同时读，但是只有一个能同时写，分别相当于信号量和互斥量。读锁可以施加在读锁上，但不能施加在写锁上，因为不知道会读到写之前还是之后的内容。写锁不能加在任何锁上。这可能会发生写者饿死的情况，例如源源不断地有读者来加锁，导致写着无法加锁。可以通过如下方式来解决：当新的读者看到有写者阻塞时，就不会加读锁，而是排队在写锁后面。

49. 使用方法：

    ```c
    int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
    int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,const pthread_rwlockattr_t *restrict attr);
    pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;
    ```

50. 自旋锁：

    ```c
    int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
    int pthread_spin_destroy(pthread_spinlock_t *lock);
    ```

51. 屏障：

    ```c
    int pthread_barrier_wait(pthread_barrier_t *barrier);
    ```

52. 线程私有数据：

    ```c
    int pthread_key_create(pthread_key_t *key, void (*destructor)(void*));
    ```


# 进程间通信

1. 进程或线程间通信的主要目的是通信和同步操作。
2. 通信工具分为2大类：
   1. 数据传输：为了进行通信，一个进程将数据写入到IPC 工具中，另一个进程从中读取数据。它要求在用户内存和内核内存之间进行两次数据传输。写入的时候从用户内存到内核内存，另一次传输是在读取的时候从内核内存到用户内存。数据传输还可以分为3种：
      1. 字节流：通过管道，FIFO，以及流socket交换的数据是无分隔符的数据流。每个读取操作可能会从IPC 工具中读取任意数量的字节，不管写者写入的块的大小是什么。这和UNIX的一切都是文件的思想重合。
      2. 消息：通过消息队列，以及数据包socket交换的数据是以分隔符分隔的消息。只能读写整条消息，无法只读取部分消息，而把剩余部分留在IPC工具中，也无法在一个读取操作中读取多条消息。
      3. 伪终端：一种在特殊情况下使用的通信工具。

   2. 共享内存：允许进程通过将数据放到由进程间共享的一块内存中以完成信息的交换。内核通过将待通信进程中的页表条目指向同一个RAM分页来实现这一功能。由于通信无需系统调用以及用户内存和内核内存之间的数据传输，因此共享内存的速度非常快。进程可以像访问自己的虚拟地址空间中的内存那样访问共享内存中的数据。同步处理（可能还会有流控）会增加共享内存设计的复杂性。

3. 数据传输和共享内存的区别：
   1. 尽管一个数据传输工具可以有多个读取者，但其读取操作会消耗数据，其他进程将无法获取所消耗的数据。在socket中可以使用MSG_PEEK标记来执行非破坏性读取。UDP socket允许将一条消息广播或组播到多个接收者处。
   2. 数据传输工具提供了读写操作，传输的数据只供一个读进程消耗。内核会自动处理读写者之间的流控以及同步（这样当读者试图从当前为空的工具中读取数据时将会阻塞，直至一些进程向该工具写入了数据）。

4. 共享内存的特点：
   1. 尽管共享内存的通信速度更快，但速度上的优势是用来弥补需要对在共享内存上发生的
      操作进行同步的不足的。因此，也需要进行同步。在共享内存中，信号量通常用来作为同步方法。
   2. 放入共享内存中的数据对所有共享这块内存的进程可见。

5. 同步的目的是为了协调进程的操作，分为4种：
   1. 信号量，其含义由应用程序来确定的，一个由内核维护的整数，其值永远都不会小于0。一个进程减小一个信号量是为了预约对某些共享资源的独占访问，完成之后可以增加信号量来释放共享资源以供其他进程使用。最常用的信号量是二元信号量（值只能是0或1），但处理一类共享资源拥有多个实例的应用程序需要使用最大值等于共享资源数量的信号量。POSIX信号量不能一次增加或减少多个。
   2. 文件锁，协调操作同一文件的多个进程的动作，也可以用来协调对其他共享资源的访问。分为两类：读（共享）锁和写（互斥）锁。
   3. 互斥量和条件变量，常用于posix线程。

6. 最原始的进程间通信（IPC）可以是读写同一个文件。但是效率低，缺乏灵活性。以下方式可以作为IPC的方法：
   1. 信号，用来表示事件的发生。
   2. 管道（即|符号），和FIFO，用于在进程间传递数据。
   3. 套接字，供同一台主机或不同主机上的进程之间传递数据。
   4. 文件锁定，为了防止其他进程读写文件内容，允许某进程对文件的部分区域加以锁定。
   5. 消息队列，用于在进程间交换数据包。
   6. 信号量，用于同步进程的动作而非数据。
   7. 共享内存，允许多个进程共享同一块物理内存，当某个进程改变了该区域的值，其他进程可以立即感知。
7. 之所以有这么多的IPC机制，是因为它们来源一不同的UNIX实现，遵循的标准也不同，例如FIFO来源自System V，套接字来源于BSD。
8. POSIX IPC工具（消息队列、信号量以及共享内存）是对较早的System V IPC工具的改进。
9. IPC对象在进程终止或执行exec()时会自动被关闭。
10. 在Linux 上，POSIX IPC对象位于挂载在设置了粘滞位的目录下的虚拟文件系统中，这个位是一个受限的删除标记，设置该位表示非特权进程只能够断开它自己拥有的POSIX IPC对象的链接。可以使用标准的ls，rm命令来列出和删除IPC对象。
11. socket可以用来在网络上通信，而FIFO则只能用来在同一机器上的进程间进行通信。
12. Linux通过flock()和fcntl()来提供文件加锁工具。flock()提供了一种简单的加锁机制，允许进程将一个共享或互斥锁加到整个文件上。由于功能有限，现在已经很少使用了。fcntl()提供了记录加锁，允许进程在同一文件的不同区域上加上多个读锁和写锁。
13. 一些 UNIX实现，包括安装了能提供NPTL线程实现的glibc的Linux 系统，允许在进程间共享互斥体和条件变量。
14. 当协调对文件的访问时文件记录加锁通常是最佳的选择，而对于协调对其他共享资源的访问来讲，信号量通常是更佳的选择。
15. 通信工具也可以用来进行同步，所有数据传输工具都可以用来同步，只是同步操作是通过在工具中交换消息来完成的。
16. 要访问一个IPC 对象，进程必须要通过某种方式来标识出该对象，一旦将对象打开之后，进程必须要使用某种句柄来引用该打开着的对象。

    ```shell
    工具类型             用于识别对象的名称         标识对象的句柄
    管道                     没有名称               文件描述符
    FIFO                     路径名                 文件描述符
    UNIX 域socket            路径名                 文件描述符
    Internet 域socket        IP+端口号              文件描述符
    POSIX 消息队列            POSIX IPC路径名       mqd_t(消息队列描述符)
    POSIX 命名信号量          POSIX IPC路径名       sem_t*(信号量指针)
    POSIX 匿名信号量          没有名称              sem_t*(信号量指针)
    POSIX 共享内存            POSIX IPC路径名       文件描述符
    匿名映射                  没有名称               无
    内存映射文件              路径名                文件描述符
    flock()文件锁             路径名                文件描述符
    fcntl()文件锁             路径名                文件描述符
    ```
17. 应用程序也可以在一个字节流工具上应用面向消息的模型，这可以通过使用分隔字符、固定长度的消息，或对整条消息长度进行编码的消息头来实现。
18. 消息队列有一个特性就是，它们可以为消息赋予一个优先级。这样发送消息的顺序就可以与接收消息的顺序不同了。
19. 消息队列可以用来在进程间传递消息。消息边界被保留了下来，这样读者和写者就以消息为单位（与管道提供的无分隔符的字节流是不同的）进行通信了。
20. 使用描述符来通信的工具（管道，FIFO以及socket），都支持高级I/O特性：I/O 多路复用（select()和poll()系统调用）、信号驱动的I/O、以及Linux特有的epoll API。它们允许应用程序同时监控多个文件描述符以判断是否可以在某些文件描述符上执行I/O 操作。与之相比，System V消息队列没有使用文件描述符，使用的是System V IPC 标识符，因此并不支持这些技术。
21. 在 Linux上，POSIX消息队列也是使用文件描述符来实现的，因此也支持上面介绍的各种I/O技术。
22. POSIX消息队列提供了一个通知工具，当一条消息进入了一个之前为空的队列中时可以使用它来向进程发送信号或实例化一个新线程。
23. UNIX 域socket允许在进程间传递文件描述符。这样一个进程就能够打开一个文件并使它被另一个本来无法访问该文件的进程可用。
24. UDP socket 允许一个发送者向多个接收者广播或组播一条消息。
25. 使用fcntl()加上的记录锁由加锁的进程拥有。内核使用这种所有权属性来检测死锁。如果发生了死锁，那么内核会拒绝其中一个进程的加锁请求，因此会在fcntl()调用中返回一个错误，表示死
    锁的发生。System V和POSIX信号量并没有所有权属性，因此内核不会为信号量进行死锁检测。当使用fcntl()获得记录锁的进程终止之后会自动释放该记录锁。
26. 在上述所有IPC方法中，只有socket允许进程通过网络来通信。socket 一般用于两个域中：一个是UNIX domain，它允许位于同一系统上的进程进行通信；另一个是Internet domain，它允许位于通过TCP/IP 网络进行连接的不同主机上的进程进行通信。
27. 通常，将一个使用UNIX domain socket 进行通信的程序转换成一个使用Internet domain socket 进行通信的程序只需要做出微小的改动即可将它应用于网络场景。

28. 从可移植性的角度来看，System V IPC要优于POSIX IPC。因为只有2.6.x的Linux 内核系列才提供了一个POSIX 消息队列的实现以及对POSIX 信号量的完全支持。System V IPC在SUSv3中进行了规定，并且几乎所有的UNIX实现都支持System V IPC。POSIX IPC 机制在SUSv3中则是一个可选的组件。POSIX IPC的各种细节并没有在SUSv3中进行规定。特别是没有规定使用哪些命令来显示和删除系统上的IPC对象。
29. System V IPC工具被设计成独立于传统的UNIX I/O模型，使得其中一些特性使得它的编程接口的用法更加复杂。这些都在POSIX IPC工具中得到了改变。

    1. 无连接的，内核不会记录进程已经打开了该对象（与其他IPC 对象不同）。这意味着内核无法维护当前使用该对象的进程的引用计数，其结果是应用程序需要使用额外的代码来知道何时可以安全地删除一个对象。
    2. 编程接口与传统的UNIX I/O模型是不一致的（它们使用整数键值和IPC 标识符，而不是路径名和文件描述符。而且这个接口也过于复杂了。

30. 对于FIFO和socket来说，其IPC对象名位于文件系统中，可访问性是根据相关的文件权限掩码（指定了所有者、组和其他用户的权限）来确定的。
31. 管道、匿名内存映射被标记成只允许相关进程访问。这里的相关是指通过fork()关联的。为了使两个进程能够访问同一个对象，其中一个必须要创建该对象，然后调用fork()。而fork()调用的结果就是子进程会继承引用该对象的一个句柄，这样两个进程就能够共享对象了。
32. POSIX未命名信号量的可访问性是通过包含该信号量的共享内存区域的可访问性来确定的。
33. 命名信号量与其他POSIX IPC类似：它们通过一个名字来标识，并且所有具备在该对象上合适权限的进程都能够访问该对象。未命名信号量没有关联的标识符，而是会被放置在由一组进程或单个进程中的多个线程共享的内存区域中。
34. 为了给一个文件加锁，进程必须要拥有一个引用该文件的文件描述符（即它必须要拥有打开文件的权限）。
35. 对 Internet domain socket 的访问（即连接或发送数据报）没有限制。如果有需要的话，可以在应用程序中实现访问控制。
36. 持久性是指一个IPC 工具的生命周期，分为3种：

    1. 进程持久性，只要存在一个进程持有进程持久的IPC 对象，那么该对象的生命周期就不会终止。管道、FIFO 以及socket都是这种。
    2. 内核持久性，只有当显式地删除内核持久的IPC对象或系统关闭时，该对象才会销毁。对象的生命周期与是否有进程打开该对象无关。这意味着一个进程可以创建一个对象，向其中写入数据，然后关闭该对象（或终止）。在后面某个时刻，另一个进程可以打开该对象，然后从中读取数据。
    3. 文件系统持久性：会在系统重启的时候保持其中的信息，对象会一直存在直到被显式地删除。唯一一种这种对象是基于内存映射文件的共享内存。

37. FIFO的数据持久性与其名称的持久性是不同的。FIFO 在文件系统中拥有一个名称，
    当所有引用FIFO 的文件描述符都被关闭之后该名称也是持久的
38. 在一些场景中，不同IPC工具的性能可能存在显著的差异。但是一般不太会关心这个，因为：

    1. 在应用程序的整体性能中，IPC工具的性能的影响因素可能不是很大，并且确定选择何种IPC 工具可能并不仅仅需要考虑其性能因素。
    2. 各种 IPC 工具在不同UNIX 实现或Linux 的不同内核中的性能可能是不同的。
    3. IPC 工具的性能可能会受到使用方式和环境的影响。相关的因素包括每个IPC 操作交换的数据单元的大小、IPC 工具中未读数据量可能很大、每个数据单元的交换是否需要进行进程上下文切换、以及系统上的其他负载。

39. POSIX.1b的目标是设计出一组能弥补System V IPC 工具的不足之处的IPC机制。


# POSIX消息队列

1. POSIX消息队列在Linux2.6.6中才被加入，还需要glibc 2.3.4 或之后的版本。

2. 打开或创建一个消息队列：

   ```c
   #include <fcntl.h>
   #include <sys/stat.h>
   #include <mqueue.h>
   mqd_t mq_open(const char*name, int oflag, .../* mode_t mode, struct mq_attr* attr */); //创建一个名为name的消息队列，成功时返回消息队列描述符，失败返回(mqd_t)-1。
   //oflag如果不包含O_CREAT，则打开一个既有队列，如果包含了O_CREAT，并且给定的name不存在，则会创建一个空队列。如果同时包含O_CREAT和O_EXCL，并且给定的name已经存在，此时会报错。EXCL是exclusive排他的意思。还能够通过包含O_RDONLY、O_WRONLY以及O_RDWR中的一个来指定访问方式。默认是以阻塞方式打开，O_NONBLOCK将会导致以非阻塞的模式打开队列。
   //如果此次操作是打开一个已有的队列，那么mode和attr参数会被忽略，否则需要提供。
   //mode指定了施加于新消息队列之上的权限，可取的值与文件上的掩码值一样，并且会与进程的umask取掩码。具备读或写的权限后，才可以读写消息队列。
   //attr如果是NULL，那么将使用实现定义的默认特性创建队列。
   //返回值类型为mqd_t，SUSv3要求它不能是一个数组，需要确保这个类型是一个能在赋值语句中使用或能作为函数参数传递的类型。在Linux上，是一个int。
   ```

3. 在fork()中子进程会接收其父进程的消息队列描述符的副本，并且这些描述符会引用同样的打开着的消息队列。子进程不会继承其父进程的任何消息通知注册。

4. 当一个进程执行了一个exec()或终止时，所有其打开的消息队列描述符会被关闭。关闭消息队列描述符的结果是进程在相应队列上的消息通知注册会被注销。

5. 关闭一个消息队列：

   ```c
   #include <mqueue.h>
   int mq_close(mqd_t mqdes); //如果调用进程已经通过mqdes在队列上注册了消息通知，那么通知注册会自动被删除，并且另一个进程可以随后向该队列注册消息通知
   ```

6. 当进程终止或调用exec()时，消息队列描述符会被自动关闭。应用程序应该在不用消息队列描述符的时候显式地关闭消息队列描述符，以防止出现进程耗尽消息队列描述符的情况。

7. 关闭一个消息队列并不会删除该队列。要删除队列则需要使用mq_unlink()。

   ```c
   #include <mqueue.h>
   int mq_unlink(const char* name); //删除标识为name的消息队列，并将队列标记为在所有进程使用完该队列之后销毁该队列。如果所有打开该队列的进程已经关闭了该队列，则会立即删除。
   ```

8. 在Linux上，POSIX消息队列被实现成了虚拟文件系统VFS的i-node，并且消息队列描述符和打开着的消息队列分别被实现成了文件描述符和打开着的文件。SUSv3没有对实现细节进行规定。

9. 不同进程能够持有引用同一个打开的消息队列的消息队列描述符。这些描述符会共享O_NONBLOCK标记的状态。

10. 消息队列属性：

    ```c
    #include <mqueue.h>
    struct mq_attr{
        long mq_flags; //标记是否是O_NONBLOCK，根据mq_open()的oflag参数来初始化的，并且使用mq_setattr()可以修改这个标记。
        long mq_maxmsg;//使用mq_send()向消息队列添加消息的数量上限，默认是10个。
        long mq_msgsize; //每条消息的最大大小，默认为8192字节。
        long mq_curmsgs; //当前位于队列中的消息个数。如果有其他进程在读写消息队列，这个值在mq_getattr()返回时可能已经发生了改变。
    } //只有第一个是消息队列描述符的属性，后3个都是消息对立的属性。
    //内核根据mq_maxmsg和mq_msgsize来确定消息队列所需的最大内存量。他俩是在是在消息队列被创建时就确定下来的，并且之后也无法修改这两个特性。
    int mq_getattr(mqd_t mqdes, struct mq_attr *addr);//返回一个消息队列描述符mqdes相关联的消息队列属性的mq_attr结构体。
    int mq_setattr(mqd_t mqdes, const struct mq_attr *newattr, const struct mq_attr *oldattr); //设置新属性，保存旧属性。SUSv3规定唯一能修改的特性是O_NONBLOCK标记的状态。
    ```

11. 发送消息：

    ```c
    #include <mqueue.h>
    int mq_sent(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned int msg_prio); //将长度为msg_len的消息msg_ptr添加到描述符mqdes所引用的消息队列中，优先级为非负整数msg_prio。msg_len必须≤消息队列的mq_msgsize属性，否则mq_send就会返回EMSGSIZE错误。长度为零的消息是允许的。
    //0表示优先级最低，当一条消息被添加到队列中时，它会被放置同优先级的所有消息之后。如果一个应用程序无需使用消息优先级，那么只需要将msg_prio都指定为0即可。SUSv3允许实现为消息优先级规定一个上限，可以通过定义常量MQ_PRIO_MAX或通过设置sysconf(_SC_MQ_PRIO_MAX)的返回值来完成。SUSv3要求这个上限至少是32（_POSIX_MQ_PRIO_MAX），即0到31。在Linux 上，这个常量值为32768。
    ```

12. 如果消息队列已经满了（即已经达到了队列的mq_maxmsg限制），那么后续的mq_send()会阻塞直到队列中存在可用空间为止。如果设置了O_NONBLOCK则会立即失败并返回EAGAIN错误。

13. 接收消息：

    ```c
    #include <mqueue.h>
    ssize_t mq_receive(mqd_t mqdes, char* msg_ptr, size_t msg_len, unsigned int *msg_prio); //从mqdes引用的消息队列中取出一条优先级最高，存在时间最长的消息放置到msg_ptr指向的缓冲区，msg_len是缓冲区可用空间大小，必须要≥队列的mq_msgsize属性，否则就会失败并返回EMSGSIZE错误。消息的优先级会被保存到msg_prio中。
    //成功时返回消息的大小，失败是返回-1，ssize_t是有符号整数类型。
    //如果消息队列当前为空，那么会阻塞直到存在可用的消息，如果设置了O_NONBLOCK则会立即失败并返回EAGAIN错误。
    ```

14. 消息可以在队列中存储很久，不用着急去取消息。

15. 延时非阻塞收发消息：

    ```c
    #include <mqueue.h> //如果操作无法立即被执行，那么阻塞到一个特定的时刻。如果标记了O_NONBLOCK，则会立即返回。
    #include <time.h> //timespec设定的从EPOCH到过期时刻的时间差，其单位为秒数和纳秒数。要指定从当前时间开始多长时间过期，则可以使用clock_gettime()来获取CLOCK_REALTIME时钟的当前值，并在该值上加上所需等待的时间量来生成一个timespec结构。
    int mq_timesent(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned int msg_prio, const struct timespec *abs_timeout);
    ssize_t mq_timereceive(mqd_t mqdes, char* msg_ptr, size_t msg_len, unsigned int *msg_prio, const struct timespec *abs_timeout);
    //如果因为超时而无法完成操作，那么调用就会失败并返回ETIMEDOUT错误。
    //在Linux上将abs_timeout指定为NULL表示永远不会超时，但这种行为并没有在SUSv3中得到规定。所有UNIX实现都没有提供这两个函数。
    ```

16. POSIX消息队列区别于System V的一个特性是，前者能够接收之前为空的队列上有可用消息的异步通知（即队列从空变成了非空）。

17. 这个特性意味着无需执行一个阻塞的调用或将消息队列描述符标记为非阻塞并在队列上定期执行mq_receive()调用了。因为进程可以设定当消息到达时通知它，然后继续执行其他任务直到收到通知为止，这才是真正的异步。进程可以选择通过信号或在一个单独的线程中调用一个函数的形式来接收通知。

    ```c
    //为调用进程注册在一条消息进入描述符mqdes引用的空队列时接收通知。只有非空→空时，才会发送通知。
    #include <mqueue.h>
    int mq_notify(mqd_t mqdes, const struct sigevent *notification); //notification 参数指定了进程接收通知的机制。
    
    union sigval{
        int sival_int; //附带的整数数据
        void *sival_ptr; //附带数据的指针
    }
    struct sigevent{
        int sigev_notify; //设定通知方法
        int sigev_signo;  //设定发送通知时，要使用的信号编号
        union sigval sigev_value; //要传递给信号处理函数或线程函数的参数。
        void (*sigev_notify_function)(union sigval); //线程通知时要执行的函数
        void *sigev_notify_attributes; //就是pthread_attr_t
    }
    //sigev_notify可以为：
    //SIGEV_NONE，注册这个进程接收通知，但当一条消息进入之前为空的队列时不通知该进程。当新消息进入空队列之后注册信息会被删除。
    //SIGEV_SIGNAL，通过生成一个sigev_signo信号来通知进程。如果sigev_signo是一个实时信号，那么sigev_value 字段将会指定信号都带的数据。通过传入信号处理器的siginfo_t结构中的si_value字段或通过调用sigwaitinfo()或sigtimedwait()返回值能够取得这部分数据。
    //SIGEV_THREAD，通过调用在sigev_notify_function中指定的函数来通知进程，就像是在一个新线程中启动该函数一样。sigev_notify_attributes为线程的特性,和pthread_attr_t一样。sigev_value中指定的联合sigval值将会作为参数传入这个函数。
    ```

18. 消息通知的特点：

    1. 在任何一个时刻都一个消息队列上只能有一个进程注册。后续在该队列上的注册请求将会失败，返回EBUSY错误。
    2. 如果在注册的时候队列中已经包含消息，那么只有当队列被清空之后，又有一条新消息达到之时才会发出通知。
    3. 当向注册进程发送了一个通知之后就会删除注册信息，之后任何进程就能够向队列注册接收通知了。如果一个进程想要持续地接收通知，那么它就必须要在每次接收到通知之后再次注册。
    4. 如果有其他进程阻塞在消息队列上等待读取，那么该进程会读取消息，注册进程会保持注册状态，注册进程不会收到通知。
    5. 可以将notification参数设置为NULL，来撤销自己在特定消息队列上的注册信息。

19. mq_close()函数关闭进程之前打开的一个消息队列。

28. mq_unlink()函数删除一个消息队列名并当所有进程关闭该队列时对队列进行标记以
    便删除。

29. mq_notify()函数允许一个进程向一个队列注册接收消息通知。在注册完之后，当一条消息可用时会通过发送一个信号或在一个单独的线程中调用一个函数来通知进程。


# POSIX信号量

1. 信号量就是一个非负整数，可以认为是非独占的互斥量。互斥量可以认为是布尔类型，信号量是非负整型。其上可以进行2个主要操作，+1和-1。如果信号量当前值为0，则-1操作会阻塞。

2. 当有多个资源可以供同时使用时，可以使用信号量。例如桌子上有6根筷子，每个人吃饭需要拿2根，如果使用互斥量的话，同一时刻只能有1个人吃饭，但是桌子上的筷子是能满足3个人同时吃饭的，这就造成了资源的浪费。

3. 哲学家就餐问题，圆桌就坐，目标就是不要有人饿死。有两种版本：

   1. 每两个人之间放着一个叉子，一个人只要拿到一个叉子就可以吃饭。

   2. 每两个人之间放着一根筷子，每个人需要同时拿到自己两侧的筷子才可以吃饭。

4. 信号量可以使用互斥量+条件变量的方式模拟出来。

   ```c
   
   ```

5. 信号量操作函数：

   ```c
   #include <semaphore.h>
   int sem_init(sem_t *sem, int pshared, unsigned int value); //初始化一个匿名信号量value为其初始值。pshared表示该信号量是在同进程的线程之间共享（取0，应该为全局变量或者堆中分配的内存）还是在不同进程之间共享（取非0，应该在共享内存区域，使用shm_open，mmap，shmget。或者通过fork产生的父子进程之间）。任何可以访问共享内存区域的进程，都可以操作其中的信号量。重复初始化一个信号量会产生未定义行为。
   sem_t *sem_open(const char *name, int oflag);//创建一个新的或打开一个已有的信号量，其名称为name。oflag是打开标记，定义在fcntl.h中。如果为O_CREAT，则当信号量不存在时会创建，其用户和组ID为调用进程的EUID，EGID。如果为O_CREAT|O_EXCL，当信号量已经存在时会报错。如果成功，则返回信号量的地址，这个地址可以用于其他信号量相关的操作函数。
   sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value);//如果oflag为O_CREAT，则需要提供mode和value两个参数。mode为新信号量的权限，权限会和进程的umask相互作用，类似于open函数，权限的符号形式的定义在<sys/stat.h>中。value为其初始值。如果oflag为O_CREAT，且信号量已经存在，则mode和value参数会被忽略。
   int sem_post(sem_t *sem);//给信号量sem+1，如果导致信号量大于0，则另一个阻塞在信号量上的线程会被唤醒，从而来给信号量-1。
   int sem_wait(sem_t *sem); //给信号量-1，如果信号量之前大于0，则当前线程会继续，如果之前等于0，则当前线程会阻塞在该信号量上。
   int sem_trywait(sem_t *sem); //非阻塞版本，失败返回EAGAIN。
   int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); //有截止时间的阻塞版本，abs_timeout表示从EPOCH(1970年初)以来的时间。失败返回ETIMEDOUT。如果可以立即给信号量-1，那么无论abs_timeout的值是多少，此函数都不会失败，此时甚至都不会检查abs_timeout的有效性。
   int sem_getvalue(sem_t *sem, int *sval); //获得信号量sem的值，存放在sval中。当有多个线程使用sem_wait尝试锁住该信号量而阻塞时，POSIX.1支持sem_getvalue的两种返回值，要么是0，要么是一个负数，它的绝对值表示当前阻塞在该信号量上的线程数目。Linux使用前一种方式。
   int sem_close(sem_t *sem); //关闭sem信号量，使得所有与之关联的资源被释放。
   int sem_destroy(sem_t *sem); //销毁匿名信号量sem，只有被初始化后的信号量才可以被销毁。如果其他线程正阻塞在该信号量上，此时销毁会造成未定义行为。使用已销毁的信号量的行为时未定义的，可以重新初始化已经销毁的信号量。匿名信号量应该在和他关联的内存被释放前销毁。
   int sem_unlink(const char *name); //删除命名信号量，一旦打开信号量的所有其他进程关闭信号量，它就会被销毁。
   ```

6. POSIX信号量有两种形式：

   1. 命名，名称类似于`/somename`，以/开头，有且只有一个/，空字符结尾的字符串，最多包含`NAME_MAX-4`个字符，一般为251。不同进程之间可以通过指定同一个名称给`sem_open()`来操作同一个命名信号量。当一个进程不再使用该信号量时，可以使用`sem_close()`来关闭，当所有进程都不再使用该信号量时，可以使用`sem_unlink()`来从系统中删除。

   2. 匿名，也成为基于内存的信号量。只能通过变量名或内存地址来引用。进程之间共享的信号量需要通过共享内存来实现。System V共享内存段使用shmget创建，POSIX共享内存对象使用shm_open创建。必须使用`sem_init()`来初始化。当不用时，应该在对应内存区域释放前，使用`sem_destroy()`销毁。使用共享内存，应该链接上rt实时库，`-lrt`。

7. 以上两种信号量都可以在线程之间或进程之间共享。对命名信号量来说，这两种方式没有区别；对匿名信号量来说，信号量存放的位置不一样。

8. 在Linux2.6之前，只支持匿名的，线程共享的信号量。命名信号量具有内核持续性，如果不适用`sem_unlink()`销毁，则会一直持续到关机。

9. 在Linux中，命名信号量会在虚拟文件系统中创建一个对应的文件，通常为`/dev/shm/sem.somename`，这也是为什么要求somename要小于`NAME_MAX-4`，因为sem.占据了4个字符。从Linux2.6.19以后，可以为该目录下的文件添加ACL，控制对象的用户和组权限。

10. POSIX信号机制比System V信号机制（semop，semget）更简单易用，因此不推荐使用后者。



# 管道

1. 管道是UNIX系统上最古老的IPC方法，它在20世纪70年代早期UNIX的第三个版本上就出现了。

2. 其主要功能是：给定两个运行不同程序（命令）的进程，在shell中让一个进程的输出作为另一个进程的输入。允许数据从一个进程流向另一个进程。两个进程并不知道管道的存在，它们只是从标准文件描述符中读取数据和写入数据，shell必须要完成相关的工作。

3. FIFO是管道的一个变体，它们之间的一个重要差别在于管道只能在在相关进程之间传递数据，FIFO可以用于任意进程间的通信。

4. 管道是一个字节流，不存在消息或消息边界的概念。读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是什么。从管道中读取出来的字节的顺序与它们被写入管道的顺序是完全一样的。在管道中无法使用lseek()来随机地访问数据。

5. 如果需要在管道中实现离散消息的概念，那么就必须要在应用程序中完成这些工作。虽然这是可行的，但如果碰到这种需求的话最好使用其他IPC机制，如消息队列和数据报socket。

6. 试图从一个当前为空的管道中读取数据将会被阻塞直到至少有一个字节被写入到管道中为止。

7. 如果管道的写入端被关闭了，那么从管道中读取数据的进程在读完管道中剩余的所有数据之后将会看到文件结束。

8. 在管道中数据的传递方向是单向的。在一些UNIX实现上，管道是双向的（所谓的流管道）。并没有在任何UNIX 标准中进行规定，应该避免使用，作为替代，可以使用UNIX domain 流socket 对，它提供了一种标准的双向通信机制，并且其语义与流管道是等价的。

9. 如果多个进程写入同一个管道，那么如果它们在一个时刻写入的数据量不超过`PIPE_BUF`字节，那么就可以确保写入的数据不会发生相互混合的情况。SUSv3 要求`PIPE_BUF`至少为`POSIX_PIPE_BUF（512）`，它定义在<limits.h>中，也可以调用`fpathconf(fd,_PC_PIPE_BUF)`来返回原子写入操作的实际上限。在Linux 上，PIPE_BUF 的值为4096。

10. 当写入管道的数据块的大小超过了PIPE_BUF字节，内核可能会将数据分割成几个较小的片段来传输，读者从管道中读取数据时会附加上后续的数据。write()调用会阻塞，直到所有数据都被写入到管道为止。如果同时只有一个进程向管道写入数据，则不用考虑PIPE_BUF的大小。如果有多个进程同时写入，则有可能将大数据分割后，出现数据交叉。在Linux 2.4及后续的版本上，写入数据量大于PIPE_BUF字节的所有操作都可能会与其他进程的写入操作发生交叉。

11. 只有在数据被写入到管道时，PIPE_BUF限制才会起作用。当写入的数据达到PIPE_BUF字节时，write()会在必要的时候阻塞，直到管道中的可用空间足以原子地完成操作。

12. 如果待写入的数据大于PIPE_BUF字节，那么write()会尽可能地多写入数据以充满整个管道，然后会阻塞，直到一些读取进程从管道中移除了数据。如果此类阻塞的write()被一个信号中断了，那么这个调用会被解除阻塞并返回成功传输到管道中的字节数，这个字节数会少于请求写入的字节数，这也就是部分写入。

13. 管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的。一旦管道被填满后，后续向该管道的写入操作就会被阻塞直到读者从管道中移除了一些数据为止。SUSv3并没有规定管道的存储能力。从Linux 2.6.11起，管道的存储能力是64KB。

14. 一般来讲，一个应用程序无需知道管道的实际存储能力。如果需要防止写者进程阻塞，那么从管道中读取数据的进程应该被设计成以尽可能快的速度从管道中读取数据。即使缓冲区只有1个字节，管道也能工作。使用较大的缓冲器是为了提高效率：每当写者充满管道时，内核必须要执行一个上下文切换以允许读者被调度来消耗管道中的一些数据。使用较大的缓冲器意味着需执行的上下文切换次数更少。

15. 从Linux 2.6.35开始就可以修改一个管道的存储能力了。Linux特有的`fcntl(fd, F_SETPIPE_SZ, size)`函数可以将fd引用的管道的存储能力修改为至少size字节。

16. 非特权进程可以将管道的存储能力修改为系统的页面大小到/proc/sys/fs/pipe-max-size（默认为1048576字节）之间的任何一个值。特权进程可以无视此限制。

17. 在为管道分配空间时，内核可能会将size 提升为对实现来讲更加便捷的某个值。`fcntl(fd, F_GETPIPE_SZ)`会返回为管道分配的实际大小。

18. 创建一个管道：

    ```c
    #include <unistd.h>
    int pipe(int pipefd[2]); //成功调用时，会在数组file中返回两个打开的文件描述符，分别表示管道的读取端pipefd[0]和写入端pipefd[1]。可以使用read()和write()系统调用来在管道上执行I/O。成功调用返回0，失败返回-1。
    ioctl(fd, FIONREAD, &cnt) //可以返回文件描述符fd所引用的管道或FIFO中未读取的字节数
    ```

19. 一旦向管道写入数据之后立即就能从管道读取数据。read()会读取的数据量为所请求的字节数与管道中当前存在的字节数两者之间较小的那个，但当管道为空时阻塞。

20. 也可以在管道上使用标准I/O函数，例如printf()，scanf()，只需要使用fdopen()获取一个与该描述符对应的文件流即可。不过需要考虑标准I/O的缓冲问题。

21. 在单个进程中管道的用途不多，一般来讲都是使用管道让两个进程进行通信。为了让两个进程通过管道进行连接，在调用完pipe()之后可以调用fork()。在fork()时，子进程会继承父进程的文件描述符的副本。虽然父进程和子进程都可以从管道中读写数据，但这种做法并不常见。因此，在fork()之后，其中一个进程应该立即关闭管道的写入端的描述符，另一个则应该关闭读取
    端的描述符。

22. ![image-20240521193304027](Linux系统编程.assets/image-20240521193304027.png)

23. 例子：

    ```c
    int pipefd[2];
    if (pipe(pipefd) == -1){
        perror("pipe");
    }
    switch(fork()){
        case -1:
            perror("fork");
        case 0: //子进程关闭写文件描述符
            if(close(pipefd[1]) == -1){
                perror("child close");
            }
            //子进程读取
            break;
        default: //父进程关闭读文件描述符
            if (close(pipefd[0]) == -1){
                perror("parent close");
            }
            //父进程写入
            break;
    }
    ```

24. 如果父子进程想要双向通信，一般不会使用1个双向管道，因为在同时写入时会有竞争问题，要防止这种竞争情况的出现就需要使用某种同步机制。一般会用2个单向的管道，如果使用这种技术，那么就需要考虑死锁的问题了，因为如果两个进程都试图从空管道中读取数据或尝试向已满的管道中写入数据就可能会发生死锁。

25. 从2.6.27内核开始，Linux支持一个全新的非标准系统调用pipe2()。它和pipe()一样，但支持额外的参数flags，这个参数可以用来修改系统调用的行为。支持两个标记，一个是O_CLOEXEC，它会导致内核为两个新的文件描述符启用close-on-exec标记（FD_CLOEXEC）。另一个是O_NONBLOCK 标记，它会导致内核将底层的打开的文件描述符标记为非阻塞，这样后续的I/O操作会是非阻塞的。这样就能够在不调用fcntl()的情况下达到同样的效果了。

26. 管道除了可以在父子进程之间使用，还可以用于任意多个相关进程之间的通信，只要在创建子进程的系列fork()调用之前通过一个共同的祖先进程创建管道即可。

27. 管道可用于一个进程和其孙子进程之间的通信，第一个进程创建管道，然后创建子进程，接着子进程再创建第一个进程的孙子进程。通常用于两个兄弟进程之间的通信，它们的父进程创建了管道，然后创建两个子进程。这就是在构建管道线时shell所做的工作。

28. 通过UNIX domain socket 传递一个文件描述符使得将管道的一个文件描述符传递给一个非相关进程成为可能。


# 内存映射

1. 内存映射分为两类：
   1. 文件映射，将文件的部分区域映射到调用进程的虚拟内存。一旦完成映射，对文件映射内容的访问则转化为对相应内存区域的字节操作。映射页面会按需自动从文件中加载。也称为基于文件的映射或内存映射文件。
   2. 匿名映射，没有对应的文件，其映射页面的内容会被初始化为0。
2. 功能可以有：用可执行文件的相应段来初始化进程的代码段、内存（内容填充为0）分配、文件I/O（即映射内存I/O）以及进程间通信（通过共享映射）。
3. 由某一进程所映射的内存可以与其他进程的映射共享，即各个进程的页表条目指向RAM中相同分页。有两种方法：
   1. 两个进程都针对同一个文件的相同区域进行了映射，它们会共享物理内存的相同分页，不过在各自的虚拟内存的位置可能不同。
   2. 子进程自父进程处继承映射，这些映射所引用的物理内存分页与父进程中相应映射所引用的分页相同，虚拟内存的位置也相同。
4. 当多个进程共享的页面相同时，一个进程对页面的改动是否为其他进程所见，这取决于创建映射时传入的标志参数。
   1. 私有映射（MAP_PRIVATE），在映射内容上发生的变更对其他进程不可见，对于文件映射来讲，变更将不会在底层文件上进行。本来是同一个物理内存分页，一个进程写入后，会复制一份出来，也就是copy on write，因此也被称为私有、写时复制映射。
   2. 共享映射（MAP_SHARED），在映射内容上发生的变更对所有共享同一个映射的其他进程都可见，对于文件映射来讲，变更将会发生在底层的文件上。

5. 若传入标志为私有，则某进程对映射内容的修改对于其他进程是不可见的，而且这些改动也不会真地落实到文件上；若传入标志为共享，对映射内容的修改就会为其他进程所见，并且这些修改也会造成对文件的改动。
6. 文件和匿名，私有和共享，两种属性一共可以产生4种。
   1. 私有文件映射，主要用途是使用一个文件的内容来初始化一块内存区域。常见的例子包括根据二进制可执行文件或共享库文件的相应部分来初始化一个进程的文本和数据段。
   2. 私有匿名映射，每次创建时都会产生一个新的、不与任何其他映射共享分页的映射。主要用途是为一个进程分配新（用零填充）内存（如在分配大块内存时，malloc()会为调用mmap()）。父子进程之间不会看到互相对映射所做出的变更。
   3. 共享文件映射，主要用于两个用途：第一，它允许内存映射I/O，对该块内存内容的变更会自动被写入到这个文件中。为使用read()和write()来执行文件I/O这种做法提供了一种替代方
      案。第二是允许无关进程共享一块内容以便以一种类似于System V共享内存段的方式来执行（快速）IPC。
   4. 共享匿名映射，每次创建时都会产生一个新的、不与任何其他映射共享分页的映射。父子进程之间会看到互相对映射所做出的变更。

7. 进程在执行exec()时映射会丢失，但通过fork()创建的子进程会继承映射，映射类型也会被继承。
8. 通过Linux特有的/proc/PID/maps文件能够查看与一个进程的映射有关的所有信息。
9. mmap()的另一个用途是与POSIX共享内存对象一起使用，它允许无关进程在不创建关联磁盘文件（共享文件映射需要这样的文件）的情况下共享一块内存区域。
10. 创建内存映射：

    ```c
    #include <sys/mman.h> //首先通过open获取文件的描述符fd，然后调用mmap创建文件映射，此时就能够关闭文件描述符了，而不会对映射产生任何影响。
    void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);//在调用进程的虚拟地址空间中创建一个新映射。成功时返回映射的首地址，失败返回MAP_FAILED，Linux上为((void *)–1)。
    //addr参数指定了映射被放置的虚拟地址。如果为NULL，那么内核会为映射选择一个合适的地址，这是推荐的做法。如果非NULL，内核会将参数值作为一个提示信息来处理，在实践中，内核至少会将指定的地址舍入到最近的一个分页边界处。无论如何，内核会选择一个不与任何既有映射冲突的地址。如果在flags包含了MAP_FIXED，那么addr必须是分页对齐的。
    //length参数指定了映射的字节数。不用是一个系统分页大小（sysconf(_SC_PAGESIZE)返回值）的倍数，但内核会以分页大小为单位来创建映射。
    //prot参数是设置保护信息的位掩码，其取值要么是PROT_NONE（无法访问），如下其他三个标记的组合：PROT_READ，PROT_WRITE，PROT_EXEC。
    //flags参数是控制映射操作选项的位掩码。只能取MAP_PRIVATE或MAP_SHARED。
    //参数fd和offset用于文件映射，匿名映射将忽略它们。fd是一个标识被映射的文件的文件描述符。offset指定了映射在文件中的起点，它必须是系统分页大小的倍数。要映射整个文件就需要将offset指定为0并且将length指定为文件大小。
    ```
11. 对于共享文件映射，对文件的更新将无法确保立即生效，可以参看msync()。
12. 如果一个进程在访问一个内存区域时违反了该区域上的保护位，那么内核会向该进程发送一个SIGSEGV信号。
13. 标记为PROT_NONE的分页内存的一个用途是作为一个进程分配的内存区域的起始位置或结束位置的守护分页，防止进程意外访问。
14. 内存保护信息驻留在进程私有的虚拟内存表中。因此，不同的进程可以用不同的保护位来映射同一个内存区域，使用mprotect()能够修改内存保护位。
15. 由于底层硬件在保护粒度上的限制（如老式的x86-32 架构），很多UNIX实现上PROT_READ 会隐含PROT_EXEC，反之亦然，并且在一些实现上指定PROT_WRITE会隐含PROT_READ。现代的x86-32架构不会出现这种问题。
16. SUSv3规定了offset参数必须要与分页对齐，而addr参数在指定了MAP_FIXED的情况下也必须要与分页对齐。SUSv4规定如果指定了MAP_FIXED并且addr为非零值，那么addr和offset除以系统分页大小所得的余数应该相等。
17. SUSv3 规定这些参数必须是分页对齐的。SUSv4 表示一个实现可以要求这个参数是分页对齐的。mprotect()、msync()以及munmap()中的addr 参数也存在类似的情况。
18. 解除映射区域：

    ```c
    #include <sys/mman.h>
    int munmap(void* addr, size_t length); //从调用进程的虚拟地址空间中删除一个映射。
    //addr参数是待解除映射的地址范围的起始地址，它必须与一个分页边界对齐。
    //length参数是一个非负整数，指定了待解除映射区域的大小（字节数）。会多解除，直到遇到一个分页边界。
    //如果指定的范围内不存在映射，则函数不起任何作用并返回0，表示成功。
    ```
19. 一般来讲通常会解除整个映射。因此可以将addr指定为mmap()返回的地址，并且length指定为mmap()中使用的length。
20. 也可以解除一个映射中的一部分，原来的映射要么会收缩，要么会被分成两个，这取决于在何处开始解除映射。还可以指定跨越多个映射的地址范围，这样所有在范围内的映射都会被解除。
21. 在解除映射时，内核会删除进程持有的在指定地址范围内的所有内存锁。（内存锁是通过mlock()或mlockall()来建立的）。
22. 当一个进程终止或执行了一个 exec()之后进程中所有的映射会自动被解除。
23. 为确保一个共享文件映射的内容会被实际写入到底层文件中，在解除前需要调用msync()。
24. 除了普通的磁盘文件，使用mmap()还能够映射各种真实和虚拟设备的内容，如硬盘、光盘以及/dev/mem。
25. 在打开描述符fd引用的文件时，prot和flags参数值必须要和文件的权限的相匹配。
26. 文件必须允许读取打开的，并且如果在prot和flags中指定了PROT_WRITE 和MAP_SHARED，那么文件必须是允许读写打开的。
27. 在Linux上，一个文件映射的分页会在首次被访问时映射进内存。这意味着如果在映射之后修改了文件内容，但映射的分页还没有被访问过，那么如果相应分页还没有被加载进内存的话，变更对这个进程可能是可见的。这个行为是依赖于实现的，可移植的应用程序应该避免依赖某个特定内核在这种场景中的行为。
28. 私有文件映射的应用：

    1. 允许多个进程共享同样的（只读的）代码段，它是从可执行文件或库文件的相应部分映射而来的。
    2. 映射一个可执行文件或共享库的初始化数据段，它会被处理成私有，使得对映射数据段内容的变更不会发生在底层文件上。
    3. 简化程序的文件输入逻辑，这与使用共享文件映射来完成内存映射I/O类似，但它只允许文件输入。

29. 这两种用法通常对程序是不可见的，因为这些映射是由程序加载器和动态链接器创建的。
30. 可执行文件的文本段通常是只读和可执行（PROT_READ |PROT_EXEC），但在被映射时仍然使用了MAP_PRIVATE而不是MAP_SHARED，这是因为调试器或自修改的程序会修改程序文本（在修改了内存上的保护信息之后），而这样的变更是不应该发生在底层文件上或影响到其他进程的。也就是不应将修改写回到文件。
31. 共享文件映射的应用：

    1. 内存映射I/O，程序会定义一个结构化数据类型来与磁盘文件中的内容对应起来，然后使用该数据类型来转换映射的内容。）这项技术被称为数据持久化或序列化。对于输出来讲，用户进程仅仅需要修改内存中的内容，然后可以依靠内核内存管理器来自动更新底层的文件。
    2. IPC，它和共享内存对象类似，但是它会将变更会反应到文件上。这对于需要共享内存内容能够持久化的应用程序来讲是非常有用的。

32. 内存映射I/O，在一些情况下，它能够比使用传统的I/O系统调用执行文件I/O这种做法提供更好的性能。原因如下：

    1. 正常的read()或write()需要两次数据传输：一次是在磁盘文件和内核高速缓冲区之间，另一次是在内核高速缓冲区和用户空间缓冲区之间。
    2. 还能够通过减少所需使用的内存来提升性能。只有内核缓冲区，而不用用户缓冲区。

33. 这个性能优势在在大型文件中执行重复随机访问时最有可能体现出来。如果顺序地访问一个文件，并假设执行I/O时使用的缓冲区大小足够大以至于能够避免执行大量的I/O系统调用，那么与read()和write()相比，mmap()带来的性能上的提升就非常有限或者说根本就没有带来性能上的提升。效率的提高主要得益于减少了用户空间和内核空间之间的一次数据传输，但是这个和磁盘I/O所需的时间相比，内存使用量的降低通常是可以忽略的。
34. 缺点如下：对于小数据量I/O 来讲，内存映射I/O 的开销（即映射、分页故障、解除映射以及更新硬件内存管理单元的超前转换缓冲器）实际上要比简单的read()或write()大。此外，有些时候内核难以高效地处理可写入映射的回写（在这种情况下，使用msync()或sync_file_range()有助于提高效率）。

35. 要映射2个页面，但是文件只有不到1个页面，因此会产生3个区域，0-2199，2200-4095，4096-8192，8192-。第一个区域可以自由访问，写入也会及时反应到文件中。第二个区域会被初始化为0，也是可以自由访问的，但是写入不会反映到文件中。第三个区域访问会产生SIGBUS信号。第四个区域访问会产生SIGSEGV信号。
36. ![image-20240522110054890](Linux系统编程.assets/image-20240522110054890.png)
37. 创建一个大小超过文件范围的映射可能是无意义的。但通过扩展文件的大小（如使用ftruncate()或write()），可以使得这种映射中之前不可访问的部分变得可用。
38. mmap()的prot参数指定的内存保护与映射文件被打开的模式之间的交互：一般来说，PROT_READ和PROT_EXEC要求被映射的文件使用O_RDONLY或O_RDWR打开，而PROT_WRITE要求被映射的文件使用O_WRONLY 或O_RDWR 打开。
39. 内核会自动将发生在共享文件映射的变更写入到文件中，但在默认情况下，内核不保证这种同步操作会在何时发生。

    ```c
    #include <sys/mman.h>
    int msync(void* addr, size_t length, int flags); //让应用程序能够显式地控制何时完成共享映射与映射文件之间的同步。能够确保在可写入映射上发生的更新会对在该文件上执行read()的其他进程可见。addr和length指定了需同步的内存区域的起始地址和大小，不用指定对应的文件。flags可以取如下值：
    //MS_SYNC,执行一个同步写入，这个调用会阻塞，直到所有被修改过的分页被写入到底盘为止。
    //MS_ASYNC,执行一个异步写入，被修改过的分页会在后面某个时刻被写入磁盘，并立即对在相应文件区域中执行read()的其他进程可见，即使还没写入时。
    ```
40. 在MS_SYNC操作之后，内存区域会与磁盘同步，而在MS_ASYNC 操作之后，内存区域仅仅是与内核高速缓冲区同步。
41. 如果在MS_ASYNC操作之后不采取进一步的动作，那么被修改过的分页最终会作为由pdflush 内核线程执行的自动缓冲区刷新的一部分被写入到磁盘。在msync()调用之后可以在映射对应的文件描述符上调用一个fsync()（或fdatasync()）。这个调用会阻塞直到快速缓冲区与磁盘同步为止。
42. Linux提供了一个的统一虚拟内存系统。这表示内存映射和高速缓冲区块会尽可能地共享同样的物理内存分页。因此通过映射获取的文件视图与通过I/O 系统调用（read()、write()等）获得的文件视图总是一致的，不msync的话也不会影响从文件中读取的数据，而msync()的唯一用途就是强制将一个映射区域中的内容写入到磁盘。
43. 创建匿名映射的2种方法：

    1. 在flags中指定MAP_ANONYMOUS 并将fd 指定为−1，在Linux 上，当指定了MAP_ANONYMOUS 之后会忽略fd的值。但一些UNIX实现要求在使用MAP_ANONYMOUS时将fd指定为−1。
    2. 打开/dev/zero设备文件，并将得到的文件描述符传递给mmap()。

44. 要从<sys/mman.h>中获得`MAP_ANONYMOUS`的定义必须要定义`_BSD_SOURCE`特性测试宏或`_SVID_SOURCE`特性测试宏。Linux提供了常量MAP_ANON作为MAP_ANONYMOUS的同义词。
45. /dev/zero是一个虚拟设备，从中读取数据时它总是会返回0，而写入到这个设备中的数据总会被丢弃。一个常见用途是使用0来组装一个文件，如使用dd命令。
46. 以上2种方法得到的映射中的字节都会被初始化为0。offset参数都会被忽略，因为没有底层文件，所以也无从指定偏移量。
47. glibc中的malloc()实现，使用私有匿名映射来分配大于MMAP_THRESHOLD字节的内存块。这样在后面要free()时，就能通过munmap()高效地释放这些块。它还降低了重复分配和释放大内存块而导致内存分片的可能性。MMAP_THRESHOLD在默认情况下是128kB，但可以通过mallopt()库函数来调整这个参数。
48. 共享匿名映射只在Linux 2.4 以及之后的版本上可用。允许相关进程（如父进程和子进程）共享一块内存区域而无需一个对应的映射文件。
49. 在大多数UNIX实现上一旦映射被创建，其位置和大小就无法改变了。但Linux提供了（不可移植的）mremap()系统调用来执行此类变更。
50. 虚拟内存操作：

    ```c
    //其中一些系统调用只有与共享内存区域结合起来之后才能够发挥特别的作用,但它们可以被应用于一个进程的虚拟内存中的任何区域。
    #include <sys/mman.h>
    int mprotect(void* addr, size_t length, int prot); //设定一块虚拟内存区域上的保护信息为prot。保护是设置在整个分页上的，因此实际上length会被向上舍入到下一个分页。prot的取值和mmap的prot参数相同。
    int mlock(void* addr, size_t length); //加锁，成功返回0，失败返回-1。这里的addr无需是分页对齐的，内核会从addr下面的下一个分页边界开始锁住分页。加锁操作的单位是分页，在一个分页大小为4096字节的系统上，mlock(2000, 4000)调用会将0到8191之间的字节都锁住。
    int munlock(void* addr, size_t length); //删除之前由调用进程创建的内存锁。给一组分页解锁并不能确保它们就不会驻留在内存中了，只有在其他进程请求内存的时候才可能从RAM中删除分页。
    int mlockall(int flags); //给调用进程特定时期占据的所有内存加锁,flags可以取MCL_CURRENT(当前所有，包括代码段、数据段、内存映射以及栈)的或组合MCL_FUTURE(将来所有，可能是通过mmap()或shmat()映射的一个共享内存区域的一部分，或增长的堆或栈的一部分)。
    int munlockall(void); //将调用进程的所有分页解锁并撤销之前的mlockall(MCL_FUTURE)调用所产生的结果。
    int mincore(void* addr, size_t length, unsigned char* vec);//报告在一个虚拟地址范围中哪些分页当前驻留在RAM中，因此在访问这些分页时也不会导致分页故障。addr必须是分页对齐的，length会被向上舍入到分页边界。驻留信息会保存在vec数组中，包含(length+PAGE_SIZE–1)/PAGE_SIZE个元素。每个字节的最低有效位在相应分页驻留在内存中时会被设置，而其他位的设置在一些UNIX实现上是未定义的，因此可移植的应用程序应该只测试最低有效位。
    //mincore()返回的信息在执行调用的时刻与检查vec中的元素的时刻期间可能会发生变化。唯一能够确保保持驻留在内存中的分页是那些通过mlock()或mlockall()锁住的分页。
    int madvise(void* addr, size_t length, int advice); //通过通知内核调用进程对起始地址为addr长度为length字节的范围之内分页的可能的使用情况来提升应用程序的性能。内核可能会使用这种信息来提升文件映射上执行的I/O的效率。addr必须是分页对齐的，length会被向上舍入到分页边界。advice取值：
    //MADV_NORMAL，默认行为，分页是以簇的形式（较小的一个系统分页大小的整数倍）传输的。会导致一些预先读和事后读。
    //MADV_RANDOM，区域内的分页会被随机访问，这样预先读将不会带来任何好处，因此内核在每次读取时所取出的数据量应该尽可能少。
    //MADV_SEQUENTIAL，区域内的分页只会被访问一次，并且是顺序访问，因此内核可以激进地预先读，并且分页在被访问之后就可以将其释放了。
    //MADV_WILLNEED，预先读取这个区域中的分页以备将来的访问之需。MADV_WILLNEED 操作的效果与Linux特有的readahead()系统调用和posix_fadvise() POSIX_FADV_WILLNEED操作的效果类似。
    //MADV_DONTNEED，不再要求这个区域中的分页驻留在内存中，对于MAP_PRIVATE区域来讲，分页会显式地被丢弃，这意味着其上的变更会丢失，虚拟内存地址范围仍然可访问。对于MAP_SHARED 区域来讲，内核在一些情况下可能会丢弃修改过的分页，这取决于运行系统的架构（在x86上不会发生这种行为）。
    ```
51. mlock()和mlockall()系统调用将一块虚拟内存区域锁进物理内存，从而防止它被交换
    出去。
52. 在一些应用程序中将一个进程的虚拟内存的部分或全部锁进住，确保它们总是位于物理内存中是非常有用的。有2个原因：

    1. 它可以提高性能。对被锁住的分页的访问可以确保永远不会因为分页故障而发生延迟。这对于那些需要确保快速响应时间的应用程序来讲是很有用的。
    2. 安全，如果包含敏感数据的分页被写入到了磁盘，那么从理论上来讲就可以在后面某个时刻直接从磁盘中读取该分页。（攻击者可能会通过运行一个消耗大量内存的程序来强制其他进程占据的内存被交换到磁盘上。）由于内核不保证会清除交换空间中保存的数据，因此即使在进程终止之后也可能从交换空间中读取信息。一般来讲，只有特权进程才能够从交换设备上读取数据。

53. 笔记本电脑和一些桌面系统上的挂起模式会将系统的RAM副本保存到磁盘上，不管是否存在内存锁。
54. RLIMIT_MEMLOCK限制了一个进程能够锁进内存的字节数。在2.6.9之前的Linux内核中，只有特权进程（CAP_IPC_LOCK）才能给内存加锁。
55. 从Linux 2.6.9开始，允许非特权进程给一小段内存进行加锁。这对于那些需要将一小部分敏感信息锁进内存以确保这些信息永远不会被写入到磁盘上的交换空间的应用程序来讲是非常有用的，如gpg是通过密码短语来完成这件事情的。这会导致：特权进程能够锁住的内存数量是没有限制的，非特权进程能够锁住的内存数量上限由软限制RLIMIT_MEMLOCK定义。软和硬RLIMIT_MEMLOCK限制的默认值都是8 个分页。
56. Linux特有的/proc/PID/status文件中的VmLck条目能够找出一个进程当前已经锁住的内存数量。
57. 当没有足够的物理内存来锁住所请求的分页或请求违背RLIMIT_MEMLOCK软资源限制时mlock()调用就会失败。
58. 除了显式地使用munlock()之外，内存锁在下列情况下会被自动删除。

    1. 进程终止时。
    2. 当被锁住的分页通过munmap()被解除映射时。
    3. 当被锁住的分页被使用mmap() MAP_FIXED标记的映射覆盖时。

59. 内存锁不会被通过fork()创建的子进程继承，也不会在exec()执行期间被保留。
60. 当多个进程共享一组分页时，只要还存在一个进程锁着这些分页，那么这些分页就会保持被锁进内存的状态。内存锁不在单个进程上叠加，实际只会建立一个锁，并且只需要通过一个munlock()调用就能够删除这个锁。例如：

    ```c
    //如假设在同一个虚拟内存分页中存在两个数据结构，指针p1 和p2 分别指向了这两个结构。
    mlock(*p1, len1);
    mlock(*p2, len2); //没有效果
    munlock(*p1, len1); //会将p1和p2所在的同一个分页都解锁。
    ```
61. 
65. 
66. 
67. 
68. 
69. 
70. 
71. 
72. 
73. 

# 伪终端

1. 伪终端是一对相互连接的虚拟设备，也称为主从设备。他们之间设有一条IPC信道，可供数据进行双向传递。
2. 从设备（slave device）所提供的接口，其行为方式与终端相类似，基于这一特点，可以将某个为终端编写的程序与从设备连接起来，然后，再利用连接到主设备的另一程序来驱动这一“面向终端”的程序，这是伪终端的一个关键用途。由“驱动程序”所产生的输出，在经由终端驱动程序的常规输入处理（例如，默认情况下，会把回车符映射为换行符）后，会作为输入传递给与从设备相连的面向终端的程序。而由面向终端的程序向从设备写入的任何数据又作为“驱动程序”的输入来传递（在执行完所有常规的终端输入处理后）。换句话说，“驱动程序”所履行的功能，在效果上等同于用户通常在传统终端上所执行的操作。
3. 伪终端的应用：telnet 和ssh之类提供网络登录服务，以及X Window系统所提供的终端窗口实现。

# 网络

1. 在网络中，客户端和服务器应用所运行的硬件平台和操作系统可以不同。



# 库的使用

1. 在程序开发时，通常把公用的自定义功能从主程序中分离开来，函数和类的生命在头文件中，其实现在源文件中，主程序包含头文件，链接包含库文件即可使用该库的功能。

2. 在Linux上应该总是通过gcc间接地调用链接器，因为gcc能够确保使用正确的选项来调用ld并将程序与正确的库文件链接起来。

3. 在x86-32，gcc不应该指定`–fomit–frame–pointer`选项，因为这会使得无法调试。在一些架构上，如x86-64，这个选项是默认启用的，因为它不会防止调试。可以使用strip删除可执行文件和库的调试信息。

4. 共享库使得可执行文件中不必包含公用的库函数代码。只需要在所有进程都可以引用的内存区域载入一份该共享库即可。共享库的一个优点是：用库函数的新版本替代老版本而无需对使用该库的程序重新编译链接（假定参数的数目和类型都没变）。

5. 使用gcc -static可以阻止gcc使用共享库，也就是都用静态链接，这样程序的各个段和总体积会变大很多。

6. 虽然一个静态库可以包含很多目标模块，但链接器只会包含那些程序需要的模块。

7. 虽然共享库的代码是由多个进程共享的，但其中的变量却不是的。每个使用库的进程会拥有自己的在库中定义的全局和静态变量的副本。

8. 第一个加载共享库的程序实际上在启动时会花费更长的时间。

9. 编译成库文件可以隐藏具体代码实现。动态库文件还可以随时更换，更新方便，动态加载，用完卸载，节省内存。

10. 一般的头文件都有条件编译的宏定义，为了防止重复包含。头文件public.h：

   ```c
   /*
    * 程序名：public.h，公共功能函数声明的头文件，用于测试静态和动态链接
    * 作者：xxxxx 日期：xxxxxx
   */
   #ifndef PUBLIC_H
   #define PUBLIC_H
   void func();     // 自定义函数的声明
   
   #endif
   ```

11. 源文件public.cpp：

    ```c
    /*
     * 程序名：public.cpp，公共功能函数定义的程序文件，用于测试静态和动态链接
     * 作者：xxxxxx 日期：xxxxxxxx
    */
    #include "public.h"  // 包含自定义函数声明的头文件
     
    void func()   // 自定义函数的实现
    {
      printf("我心匪石，不可转也。我心匪席，不可卷也。威仪棣棣，不可选也。\n");
    }
    ```

12. 如果库是以源代码的形式给出的，则可以编译的时候，加上库的源文件即可。例如：

    ```shell
    g++ -o book265 book265.cpp public.cpp
    ```

13. 不包含头文件，编译不通过；不链接库，不能运行成功。

14. 动态库是在程序执行的开始进行判断寻找对应的文件是否存在，在需要的时候才会载入，占用运行时。静态库占用程序体积，但是不会占用运行时。

15. 静态库：一般取名为libxxx.a，其中xxx为库名。

    ```shell
    ar -cr libxxx.a xxx.o yyy.o        #把目标代码打包成一个静态库。
    ```

16. 静态，动态库必须要手动链接才可以，在编译时，都要指明路径和库名（如果不是在默认的位置）。

    ```shell
    gcc -L/usr/local/lib -o main main.o -lxxx     #-L后面表示搜索库的路径，一般默认的路径不用包含。-l参数必须在最后。  从-lxxx看不出要链接动态还是静态库，如果出现重名，优先选择动态库。
    ```

17. 动态库：一般取名为libxxx.so.y    xxx为库名，y为版本号。

    ```shell
    gcc -shared -fPIC -o libxxx.so xxx.c     #-shared表示生成动态库。-fPIC表示位置无关代码，也可以是-fpic，
    ```

18. 动态库在编译时必须要使用位置独立的代码，这在大多数架构上都会带来性能开销，因为它需要使用额外的一个寄存器。这使得代码可以在运行时被放置在任意一个虚拟地址处。这一点对于共享库来讲是必需的，因为在链接的时候是无法知道共享库代码位于内存的何处的。

19. 在运行时必须要执行符号重定位。即需要将对共享库中每个符号（变量或函数）的引用修改成符号在虚拟内存中的实际运行时位置（因为同一个动态库在不同进程中可能位于不同的虚拟内存位置）。因此会比静态库多花费一些时间。

20. 在Linux/x86-32上，可以使用不加-fPIC选项编译的模块来创建共享库。但这样做的话会丢失共享库的一些优点，包含依赖于位置的内存引用的程序文本页面不会在进程间共享。在一些架构上是无法在不加-fPIC选项的情况下构建共享库的。

21. 可以使用如下方法来判断一个目标文件在编译时，是否开启了-fPIC选项：

    ```shell
    #以下两种方法均可，核心原理是检查目标文件符号表中是否存在名称_GLOBAL_OFFSET_TABLE_
    nm main.o |grep _GLOBAL_OFFSET_TABLE_ #如果产生了输出，则表示指定了-fPIC
    readelf -s main.o |grep _GLOBAL_OFFSET_TABLE_
    ```

22. 可以使用如下方法判断一个共享库中的所有目标文件在编译时是否都指定了-fPIC选项：

    ```shell
    #如果产生了输出则表示至少一个目标文件没有指定-fPIC
    objdump --all-headers /lib/x86_64-linux-gnu/libc.so.6 |grep TEXTREL #TEXTREL表示存在一个目标模块，其文本段中包含需要运行时重定位的引用
    readelf -d /lib/x86_64-linux-gnu/libc.so.6 |grep TEXTREL
    ```

23. 在ELF中，库依赖性是记录在可执行文件的DT_NEEDED标签中的。

24. 动态链接器会检查程序的共享库清单并使用一组预先定义好的规则来在文件系统上找出相关的库文件，如果库不在内存中的话就将库加载进内存。动态链接器既是一个可执行文件，又是一个动态库。而动态链接器本身是静态链接的。

25. 一些架构如x86-64同时支持执行32和64位的程序。在此类系统上，32位的库位于`*/lib`子目录中，64位的库位于`*/lib64`子目录中。

26. 共享库的另一种用法是作为Java NativeInterface (JNI)中的一个构建块，它允许Java代码通过调用共享库中的C函数直接访问底层操作系统的特性。

27. 一般来说动态库libxxx.so都是一个软连接，指向libxxx.so.y之类的具体版本的库。

28. 如果发布的位置不是在标准的位置，还要在/etc/ld.so.conf配置文件中添加该位置。然后使/sbin/ldconfig重新读入该配置文件。其实在标准或非标准位置新增库文件，都应该执行该程序一下，它的作用是将文件/etc/ld.so.conf列出的路径下的库文件缓存到/etc/ld.so.cache以供使用。配置文件如下：

    ```shell
    include ld.so.conf.d/*.conf   #会读入该目录下的所有配置文件。
    /x/lib           #用户新添加的路径
    ```

29. 如果一个程序依赖多个库，且这些库之间也存在依赖关系，那么在-l时，被依赖的库要放在后面。

30. 还可以在程序执行的过程中手动装载和卸载，这样可以使程序启动速度加快，节约内存开销。

31. 静态，动态库的发布：

    1. 将头文件xxx.h存放到/usr/local/include中。
    2. 将编译好的静态库libxxx.a或libxxx.so放在/usr/local/lib中。

32. ldd工具，查看当前可执行文件依赖的动态库：

    ```shell
    [zj@ZJ ~] ldd ./llist #搜索方式与动态链接器一样
    	linux-vdso.so.1 => (0x00007fff3b35f000)
    	libllist.so => /usr/local/lib/libllist.so (0x00007f1c761b2000)
    	libc.so.6 =>/lib64/libc.so.6 (0x0000003fdfe00000)
    	/lib64/ld-linux-x86-64.so.2 (0x0000003fdf600000)
    ```

## 静态库

1. linux下静态库文件名为libxxx.a，其中xxx为库的名称，lib和.a不可省略。规范命名可以方便链接程序寻找到该库。

2. Ubuntu22.04系统中，glibc静态库的位置在：

   ```shell
   sudo find / -name 'libc.a' #查询libc.a文件。libc.so,libm.a,libm.so文件在下面三个位置也存在。
   /usr/lib32/libc.a #32位
   /usr/lib/x86_64-linux-gnu/libc.a #64位
   /usr/libx32/libc.a
   ldd --version #查看glibc的版本
   ldd (Ubuntu GLIBC 2.35-0ubuntu3.5) 2.35
   #一般会自动安装，如果没有得话，可以手动安装
   sudo yum install glibc-static  #redhat系列
   sudo apt-get install libc6-dev #debian系列
   sudo apt-get install libc6-dev-x32  #X32 ABI Development Libraries for AMD64
   sudo apt-get install libc6-dev-i386 #32-bit development libraries for AMD64
   ```

3. 静态库是一个独立的文件，又称为归档文件，里面包含了按照特定的结构组织起来的其它的一些文件。保存了原始文件的内容，访问模式，时间戳等信息。

4. ar命令是GNU Binutils的一部分，可以用来创建，修改静态库，也可以从静态库中提取单个模块。

   ```shell
   ar [--plugin <name>] [-X32_64] [-]<d|m|p|q|r|s|t|x>[abcDfilNoPsSTuUvV [relpos] [count]] [--target <bfdname>] [archive] [member...] #archive为静态库，member是模块名称
   
   --plugin #使ar加载指定的插件，这增加了对更多文件格式的支持。只有工具链构建时开启了插件支持的情况下，此选项才可用。
   -X32_64 #此选项是GNU ar的默认选项(表示处理32和64位目标文件)，原生的AR不支持任何其他-X选项，比如-X32，此选项是AIX ar的默认选项。
   --target #当库成员的目标文件格式与系统的默认格式不同时，指定具体的格式，用于交叉编译。
   
   #选项分为操作选项<d|m|p|q|r|s|t|x>和修饰选项[abcDfilNoPsSTuUvV]。操作选项只能有一个，修饰选项可以有任意多个,与操作选项配合使用时，二者的顺序可以任意。
   #选项前的-可以省略，这是区别于其他命令行程序的明显特点。
   
   #操作选项：
   d #Delete，从库中删除由[member...]指定的模块。
   m #Move，在库中移动成员。当库中有若干模块对于同一个符号都有定义时，模块之间的顺序很重要。如果没有特别指定，新添加的模块将处于库的末尾。也可以使用修饰选项a，b或i指定移动到的位置。
   p #Print，打印库中指定的成员，如果没有指定member，则输出全部成员。如果指定修饰选项v，则在输出成员的内容前，将显示成员的名字。
   q #Quick append，将新模块快速追加到库的结尾处，并不检查是否需要替换。修饰选项a，b或i对此操作没有影响，因为模块总是追加到库的结尾处。
   r #Replacement，以替换模式向库中插入成员。当插入的模块名已经在库中存在，则替换同名的模块。默认的情况下，新的成员增加在库的结尾处，而非在原来模块的位置。
   s #写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。甚至对于没有任何变化的库也作该动作。对一个库做ar s等同于对该库做ranlib。注意，s可以同时当作操作或修饰选项。
   t #Table，显示库的模块表清单。如果指定文件名称，则仅显示指定的那些文件。如果不指定任何文件，则列出库中的所有文件。一般只显示模块名，如果结合选项v可显示文件的访问权限、时间戳、属主和组等信息。类似于ls -l。
   x #Extract，从库中提取一个成员。如果不指定模块名，则提取库中所有的模块，类似于tar -x。
   #修饰选项：
   a #After，在库中一个已经存在的成员(relpos参数指定)后面增加一个新的模块。
   b #Before，在库中一个已经存在的成员(relpos参数指定)前面增加一个新的模块。
   c #Create，创建一个库。不管库是否存在，都将创建。如果库已经存在，是否会覆盖？如果没有模块，是否创建空库？
   D #Deterministic，以确定性模式操作。添加文件和存档索引时，对uid、gid、时间戳使用0，对所有文件使用一致的文件模式。使用此选项时，如果ar与相同的选项和相同的输入文件一起使用，则多次运行将创建相同的输出文件，而不考虑输入文件的所有者、组和文件。模式或修改时间。如果binutils配置为-- enabledeterministic archives，那么默认情况下，此模式为on。可以使用U修饰符禁用它。
   f #在库中截断指定的名字。默认情况下，模块名的长度是不受限制的，可以使用此参数将模块名截短，以保证与其它系统的兼容。
   i #Insert，类似选项b。
   l #暂未使用
   N #与[count]参数一起使用，在库中有多个相同的文件名时指定提取或删除的个数
   o #Original，当提取成员时，保留成员的原始数据。如果不指定该选项，则提取出的模块的时间将标为提取出的时间。
   P #进行文件名匹配时使用全路径名。ar在创建库时不能使用全路径名（这样的库文件不符合POSIX标准），但是有些工具可以。此选项将导致GNU AR使用完整的路径名匹配文件名，这在从另一个工具创建的存档中提取单个文件时非常方便。
   s #等同于操作选项s。
   S #不创建目标文件索引，这在创建较大的库时能加快时间。不过需要在归档完毕后，再运行一下ranlib，才可以被链接器使用。
   T #Thin，将指定的存档设为精简存档。如果库已经存在并且是常规库，则现有成员必须与存档位于同一目录中。此时库文件并不真正包含成员的内容，而是通过符号链接包含？
   u #Update.一般说来，命令ar r member... 会替换所有member模块到库中。如果你只想替换那些比库中同名文件新的文件，即更新，可以使用该选项。该选项只与操作选项r一起使用。
   U #Undeterministic，不要在确定性模式下操作。这与上面的D选项相反。被添加的文件和存档索引将获得它们的实际uid、gid、时间戳和文件访问权限模式值。
   v #Verbose，显示执行操作选项的详细信息。
   ```

5. 静态库文件中存在一个名为.SYMDEF的成员。它包含了静态库中所有成员所定义的有效符号（函数名、 变量名）。因此，当为库增加了一个成员时，相应的就需要更新该成员，否则新所增加的模块中定义的所有的符号将无法被链接程序定位。链接时就会报找不到符号的错误。使用ranlib libxxx.a即可更新静态库。不过如果使用的是GNU的ar，则不用再使用ranlib，因为它会自动更新（ar s是默认的选项）。

6. 这是因为早期的ar做的工作就只是tar的工作，即将多个目标文件打个包。然后需要使用ranlib来生成索引，才能被链接器使用。后来开发人员发现可以将ranlib的功能集成到ar中。

7. ar常用操作：

   ```shell
   ar crv libtest.a add.o sub.o #创建一个静态库libtest.a，包含2个模块add.o和sub.o。
   ar x /usr/lib64/libc.a errno.o #从/usr/lib64/libc.a中提取errno.o模块，当前目录会生成一个对应的文件。
   zj@zj-hit:~$ ar tv /usr/lib/x86_64-linux-gnu/libc.a errno.o #查看静态库中指定模块的详细信息。0/0是uid/gid，960为大小，单位为字节。Jan  1 08:00 1970为时间
   rw-r--r-- 0/0    960 Jan  1 08:00 1970 errno.o
   ```

8. 可以使用`nm -s`查看静态库中的符号。

9. 静态库的生成方法：

   ```shell
   g++ -c -o libpublic.a public.cpp          # -c表示只进行预处理，编译，汇编，不链接，生成.o的目标文件。
   ```

10. 使用方法有两种：

    1. 直接把调用者的源代码和库文件一起编译：

       ```shell
       g++ -o book265 book265.cpp libpublic.a   #实际就是分步编译，这里要使用库的文件名
       ```

    2. 采用L参数指定静态库文件的目录，-l参数指定静态库名。

       ```shell
       g++ -o book265 book265.cpp -L/home/wucz/demo -lpublic   #-l的参数为库名，而不是库的文件名。如果要制定多个库和库的目录，则可以使用多次-L,-l。
       ```

11. 在chroot监狱中无法使用动态库，因此必须使用静态链接。

12. 静态链接的应用程序能确保系统上共享库的变动不会影响到它，因为它已经拥有了运行所需的全局代码。

13. 在默认情况下，当链接器能够选择名称一样的共享库和静态库时（如在链接时使用`-Lsomedir -ldemo`，并且libdemo.so 和libdemo.a 都存在），会优先使用共享库。可以使用如下方法来强制使用静态库：

    1. 在gcc命令行中指定静态库的路径名（包括.a扩展名）。
    2. 在gcc命令行中指定-static 选项。
    3. 使用gcc的`-Wl,-Bstatic`和`-Wl,-Bdynamic`选项来显式地指定链接器选择共享库还是静态
       库，每个库可以单独使用该选项设置。


## 动态库

1. 动态库的命名libpublic.so，和静态库相比，就是后缀名不同。动态库是运行时动态加载，因此需要制定动态库的目录。

2. 动态库的生成方法：

   ```shell
   gcc -g -c fPIC -Wall public.c mod1.c #编译产生使用位置无关代码的目标文件
   gcc -g -shared -o libpublic.so public.o mod1.o #将目标文件链接成动态库
   ```

3. 文件属性：

   ```shell
   zj@zj-hit:~$ file libpublic.a
   libpublic.a: ELF 64-bit LSB relocatable, x86-64, version 1(SYSV), not stripped
   zj@zj-hit:~$ file libpublic.so
   libpublic.so: ELF 64-bit LSB shared object, x86-64, version 1(SYSV),dynamically linked, BuildID[sha1]=e096e8c680dd5dcd40c2a7a10cdefd7b18df513d, not stripped
   ```

4. 在同一个目录下，如果既有静态库又有动态库，那么优先使用动态库。如果非要使用静态库，则应该使用静态库的第一种编译方法。

5. 动态库的使用方法：

   ```shell
   g++ -o book265 book265.cpp -L/home/wucz/demo -lpublic #方法和静态库的相同。
   ```

6. 如果在运行时出现如下异常，则应该指定动态库的位置。

   ```shell
   export LD_LIBRARY_PATH=/home/wucz/demo:.:$LD_LIBRARY_PATH #添加/home/wucz/demo和当前目录为动态库的搜索路径。
   #如果定义了LD_LIBRARY_PATH，那么动态链接器在查找标准库目录之前会先查找该环境变量列出的目录中的共享库。
   ```

7. 动态库在编译时，只做语法检查，并没有被编译进程序中。当程序执行到动态库中的函数时，才会动态加载该函数。

8. 默认嵌入到可执行文件以及动态链接器在运行时搜索的名称都是共享库文件的实际名称，这被称为库的真实名称。但是一般推荐使用别名来创建共享库，这种别名称为soname（ELF中的DT_SONAME标签）。

9. 如果共享库拥有一个soname，那么在链接阶段会将soname嵌入到可执行文件中，而不会使用真实名称，同时后面的动态链接器在运行时也会使用这个soname来搜索库。引入soname 的目的是为了提供一层间接，使得可执行程序能够在运行时使用与链接时使用的库不同的（但兼容的）共享库。

   ```shell
   gcc -g -shared -Wl,-soname,libpublic.so.2 -o libpublic.so.2.1 mod1.o mod2.o #创建动态库时，为其添加soname。
   gcc -o prog prog.c libpublic.so.2.1 #链接时需要指定真实名称。
   objdump -p libpublic.so.2 |grep SONAME #查询一个共享库的soname
   SONAME        libpublic.so
   readelf -d libpublic.so.2 |grep SONAME
   0x0000000e (SONAME)   Library soname: [libpublic.so]
   ```

10. 除了给共享库增加一个soname外，还需要创建一个符号链接将soname指向库的真实名称，并且必须要将这个符号链接放在动态链接器搜索的其中一个目录中。

11. 一般来讲，一个共享库相互连续的两个版本是相互兼容的，这意味着每个模块中的函数的调用接口是一致的，并且函数的语义是等价的（即它们能取得同样的结果）。这种版本号不同但相互兼容的版本被称为共享库的次要版本。但有时候需要创建创建一个库的新主版本，即与上一个版本不兼容的版本。同时，必须要确保使用老版本的库的程序仍然能够运行。

12. 为了满足这些版本化的要求，共享库的真实名称和soname必须要使用一种标准的命名规范。

    ```shell
    #真实名称
    libname.so.major-id.minor-id #主版本不同的话，库互相不兼容。此版本可以是任意字符，一般是一个数字，也可以是两个由点分隔的数字，一个是此版本号，一个是补丁号或修订号。
    libdemo.so.1.0.0
    libdemo.so.1.0.4 #和上一个版本兼容
    libdemo.so.2.0.1 #和上两个版本都不兼容
    #soname
    #共享库的soname包括相应的真实名称中的主要版本标识符，但不包含次要版本标识符。因此soname的形式为libname.so.major-id。通常会将soname创建为包含真实名称的目录中的一个相对符号链接。
    libdemo.so.1 -> libdemo.so.1.0.4 #通常每个库的主要版本的soname链接会指向在主要版本中最新的次要版本
    libdemo.so.2 -> libdemo.so.2.0.1
    libread.so.5 -> libread.so.5.0
    ```

13. 对于每个共享库还可以定义链接器名称，将可执行文件与共享库链接起来时会用到这个名称。链接器名称是一个只包含库名但不包含任何版本标识的符号链接，形式为libname.so。这样就可以构建独立于库版本的链接命令了，即不用在链接命令中指定版本号了。一般来讲，链接器名称与它所引用的文件位于同一个目录中，它既可以链接到真实名称，也可以连接到库的最新主要版本的soname。通常，最好使用指向soname的链接，因此对soname所做的变更会自动反应到链接器名称上。

    ```shell
    #ldconfig程序将保持soname最新的任务自动化了，因此如果使用了上面的约定的话就是隐式地维护链接器名称
    #如果需要将一个程序与共享库的一个较老的主要版本链接起来，就不能使用链接器名称。相反，在链接命令中需要通过制定具体的真实名称或soname 来标示出所需要的版本（主要版本）。例如
    libvulkan.so -> libvulkan.so.1
    libvulkan.so.1 -> libvulkan.so.1.3.204
    ```

14. 因此综上，创建和使用共享库的步骤如下：

    ```shell
    gcc -g -c fPIC mod1.c mod2.c mod3.c #编译，创建位置无关的目标文件
    gcc -g -shared -Wl,-soname,libdemo.so.1 -o libdemo.so.1.0.1 mod1.o mod2.o mod3.o #创建共享库，设置soname
    ln -s libdemo.so.1.0.1 libdemo.so.1 #创建soname文件
    ln -s libdemo.so.1 libdemo.so  #创建链接器文件
    #使用共享库来完成链接
    gcc -g -o prog prog.c -L. -ldemo #链接当前目录下的libdemo.so
    export LD_LIBRARY_PATH =$LD_LIBRARY_PATH:. #将当前目录添加到链接器搜寻目录中，方便运行时链接。
    ```

15. 一般来讲，在生产应用程序中不应该修改LD_LIBRARY_PATH。共享库及其关联的符号链接会被安装在其中一个标准库目录中，例如：

    ```shell
    /usr/lib #大多数标准库安装的目录
    /lib #应该将系统启动时需要用到的库放在这里，因为启动时可能还没挂在/usr/lib
    /usr/local/lib #非标准或实验性的库安装到这里，/usr/lib一般是一个由多个系统共享的网络挂载，需要只在本机安装一个库的情况则可以将库放在这个目录中。
    /etc/ld.so.conf #在这个文件中列出的所有目录，其中路径名之间用换行、空格、制表符、逗号或冒号分隔。其中一般会包含一句include /etc/ld.so.conf.d/*.conf   也就是这个目录下所有以.conf结尾的文件中的目录
    #在大多数情况下，将文件复制到这些目录中需要具备超级用户的权限。
    ```

16. 搜索顺序为：LD_LIBRARY_PATH路径列表，/etc/ld.so.cache文件，/lib和/usr/lib目录。

17. 安装完之后就必须要创建soname和链接器名称的符号链接了，通常它们是作为相对符号链接与库文件位于同一个目录中。

18. ldconfig解决了共享库的2个潜在的问题：

    1. 共享库可以位于各种目录中，如果动态链接器需要通过搜索所有这些目录来找出一个库并加载这个库，那么整个过程将非常慢。

    2. 当安装了新版本的库或者删除了旧版本的库，那么soname符号链接就不是最新的。

19. 它搜索一组标准的目录并创建或更新缓存文件/etc/ld.so.cache，使之包含在所有这些目录中的主要库版本（每个库的主要版本的最新的次要版本）列表。动态链接器在运行时解析库名称时会轮流使用这个缓存文件。`ldconfig –p`会显示/etc/ld.so.cache 的当前内容。

20. 它检查每个库的各个主要版本的最新次要版本，以找出嵌入的soname，然后在同一目录中为每个soname 创建（或更新）相对符号链接。为了能够正确执行这些动作，ldconfig要求库的名称要根据前面介绍的规范来命名。

21. 每当安装了一个新的库，更新或删除了一个既有库，以及/etc/ld.so.conf中的目录列表被修改之后，都应该运行ldconfig，需要管理员权限才可以。

22. ldconfig的2个功能，生成ld.so.cache必须用它，而更新文件链接可以手动进行。

23. ABI兼容的含义：

    1. 库中所有公共方法和变量的语义保持不变。每个函数的参数列表不变并且对全局变量和返回参数产生的影响不变，同时返回同样的结果值。因此提升性能或修复Bug（导致更加行为更加符合规定）的变更可以认为是兼容的变更。
    2. 没有删除库的公共API中的函数和变量，但向公共API中添加新函数和变量不会影响兼容性。
    3. 在每个函数中分配的结构以及每个函数返回的结构保持不变。类似的，由库导出的公共结构保持不变。例外情况是在特定情况下，可能会向既有结构的结尾处添加新的字段，但当调用程序在分配这个结构类型的数组时会产生问题。有时候，库的设计人员会通过将导出结构的大小定义为比库的首个发行版所需的大小更大来解决这个问题，即增加一些填充字段以备将来之需。

24. 当一个运行着的程序正在使用共享库的一个既有版本时也能够安装库的新主要版本或次要版本。已经运行着的程序会继续使用共享库的上一个次要版本，只有当它们终止或重启之后才会使用共享库的新次要版本。


## 优缺点

1. 静态库优点：
   1. 静态链接相当于复制一份库文件到可执行程序中，不需要像动态库那样有动态加载和识别函数地址的开销，也就是说采用静态链接编译的可执行程序运行更快。
2. 静态库缺点：
   1. 静态链接生成的可执行程序比动态链接生成的大很多，运行时占用的内存也更多。对磁盘和内存有都浪费。
   2. 库文件的更新不会反映到可执行程序中，可执行程序需要重新编译。
3. 动态库优点：
   1. 相对于静态库，动态库在时候更新（修复bug，增加新的功能）不需要重新编译。
   2. 全部的可执行程序共享动态库的代码，运行时占用的内存空间更少。
4. 动态库缺点：
   1. 使可执行程序在不同平台上移植变得更复杂，因为它需要为每每个不同的平台提供相应平台的共享库。
   2. 增加可执行程序运行时的时间和空间开销，因为应用程序需要在运行过程中查找依赖的库函数，并加载到内存中。
5. 动态库的不足相对于它带来的好处在现今硬件下简直是微不足道的，所以链接程序在链接时一般是优先链接动态库的。

## 高级API

1. 默认情况下，可执行文件运行时，动态链接器就会加载动态依赖列表中的所有共享库，但有些时候延迟加载库是比较有用的，如只在需要的时候再加载一个插件。dlopen API就能提供这个功能，它源自Solaris，现在其中大部分内容都在SUSv3中进行了规定。

2. 如果想要使用dlopen加载一个共享库，则不能在构建可执行文件时链接该库。

3. dlopen API 使得程序能够在运行时打开一个共享库，根据名字在库中搜索一个函数，然后调用这个函数。在运行时采用这种方式加载的共享库通常称为动态加载的库，它的创建方式与其他共享库的创建方式完全一样。

   ```c
   #include <dlfcn.h> //链接时要加上 -ldl选项
   void *dlopen(const char *filename, int flags); //打开一个共享库，加载到进调用进程的虚拟地址空间并增加该库的打开引用计数，返回一个供后续调用使用的句柄。filename表示绝对或将对路径。失败时返回NULL。
   int dlclose(void *handle); //关闭之前由dlopen()打开的库。当进程终止时会隐式地对所有库执行dlclose()。
   void *dlsym(void *handle, const char *symbol); //在handle 指向的库以及该库的依赖树中的库中搜索一个符号symbol（一个包含函数或变量的字符串）并返回其地址。找不到时，返回NULL。
   char *dlerror(void); //如果在dlopen API的函数调用中得到了一个错误，那么可以使用dlerror()来获取一个指向表明错误原因的字符串的指针。如果从上一次调用dlerror()到现在没有发生错误，那么dlerror()函数返回NULL。
   //dlsym()返回的符号值可能会是NULL，这与找不到符号的返回是无法区分的。为了弄清楚具体是哪种情况就必须要先调用dlerror()（确保之前的错误字符串已经被清除了），然后再调用dlsym()，最后调用dlerror()，如果此时返回了一个非NULL值，那么就可以认为发生错误了。
   ```

4. 如果filename指定的共享库依赖于其他共享库，那么dlopen()会自动加载那些库。这一过程会递归进行，这种被加载进来的库被称为这个库的依赖树。

5. 在同一个库文件中可以多次调用dlopen()，但只会在第一次调用时将库加载进内存，所有的调用都返回同样的句柄值。但dlopen API会为每个库句柄维护一个引用计数，每次调用dlopen()时都会增加引用计数，每次调用dlclose()都会减小引用计数，只有当计数为0 时dlclose()才会从内存中删除这个库。

6. flags参数是一个位掩码，可以是以下两个之一：

   1. RTLD_LAZY：只有当代码被执行的时候才解析库中未定义的函数符号。如果某个特定符号的代码没有被执行到，那么永远都不会解析该符号。延迟解析只适用于函数引用，对变量的引用会被立即解析。
   2. RTLD_NOW：在dlopen()结束之前立即加载库中所有的未定义符号，不管是否需要用到这些符号，这种做法的结果是打开库变得更慢了，但能够立即检测到任何潜在的未定义函数符号错误。这在调试应用程序时这种做法是比较有用的，因为它能够确保应用程序在碰到未解析的符号时立即发生错误，而不是在执行了很长一段时间之后才发生错误。

7. 通过将环境变量LD_BIND_NOW设置为一个非空字符串能够强制动态链接器在加载可执行文件共享库时立即解析所有符号（即类似于RTLD_NOW）。glibc2.1.1及以后续是有效的。设置LD_BIND_NOW会覆盖RTLD_LAZY标记的效果。

8. 如果symbol是一个变量，可以将返回的指针赋予给对应类型的变量：

   ```c
   int* p;
   p = (int*)dlsym(handle, "myvar"); // 也可以不
   if (p == NULL){
       perror("cannot find myvar");
   }
   ```

9. 如果symbol是一个函数，可以使用dlsym()返回的指针来调用该函数。

   ```c
   int (*funcp)(int); //定义一个函数指针
   funcp = dlsym(handle, "myfunc"); //错误，因为C99标准禁止函数指针和void *之间的赋值操作。
   *(void**)&funcp = dlsym(handle, "myfunc"); //使用C99标准推荐的二级指针法。这段代码看似和 (void*)funcp = dlsym(handle, "myfunc");类似，但是在gcc开启–pedantic选项时会发出 ANSI C forbids the use of cast expressions as lvalues的警告信息。而二级指针法就不会提示警告。
   //另一种可能的方法是将返回值强制转换为函数指针类型
   funcp = (int (*)(int))dlsym(handle, "myfunc"); //C99标准仍然要求编译器对此类转换生成警告信息并列举了上面的*(void **)语法。
   //使用函数指针来调用函数
   funcp(2); //或者(*funcp)(2)也可以。
   ```

10. 从glibc 2.2.3开始，共享库中的函数可以使用atexit()（或on_exit()）来设置一个在库被卸载时自动调用的函数。

11. 设计良好的共享库应该只公开那些构成其声明的应用程序二进制接口（ABI）的符号（函数和变量），原因为：

    1. 如果共享库的设计人员不小心导出了未详细说明的接口，那么库的使用者可能会使用这些接口。这样在将来升级共享库时可能会带来兼容性问题。库的开发人员认为可以修改或删除那些不属于文档中记录的ABI中的接口，而库的用户则希望继续使用原来的接口。
    2. 在运行时符号解析阶段，由共享库导出的所有符号可能会优先于其他共享库提供的相关定义。
    3. 导出非必需的符号会增加在运行时需加载的动态符号表的大小。

12. 在C程序中可以使用static关键词使得一个符号私有于一个源代码模块，从而使得它无法被其他目标文件绑定。

13. 除了使一个符号局限于源代码模块之外，static还有一个副作用，如果一个符号被标记为static，那么在同一源文件中对该符号的所有引用会被绑定到该符号的定义上，也就是这些引用在运行时不会被关联到其他共享库中的相应定义上。

14. gcc提供了一个特有的特性声明，它执行与static关键词类似的任务。

    ```c
    void __attribute__ ((visibility("hidden"))) func(void){} //这么做有一个副作用，即防止在运行时发生符号插入。
    ```

15. static将一个符号的可见性限制在单个源代码文件中，而hidden使得一个符号对构成共享库的所有源代码文件都可见，但对库之外的文件不可见。

16. 版本脚本可以用来精确控制符号的可见性以及选择将一个引用绑定到符号的哪个版本。

17. 版本脚本是一个包含链接器ld执行的指令的文本文件。要使用版本脚本必须要指定`--version-script`链接器选项。版本脚本的后缀通常（但不统一）是.map。

18. 符号版本化允许一个共享库提供同一个函数的多个版本。每个可执行文件程序会使用生成它时使用的共享库函数的版本。这使得可以对共享库进行不兼容的改动而无需提升库的主要版本号。

19. 从极端的角度来讲，符号版本化可以取代传统的共享库主要和次要版本化模型。

20. glibc从2.1开始使用了这种符号版本化技术，因此glibc 2.0及以前的所有版本都是通过单个主要库版本（libc.so.6）来支持的。

21. 可以定义一个或多个在共享库被加载和卸载时自动执行的钩子函数，这样在使用共享库时就能够完成一些初始化和终止工作了。不管库是自动被加载还是使用dlopen加载的，初始化函数和终止函数都会被执行。

22. 初始化和终止函数是使用gcc 的constructor和destructor特性来定义的。在库被加载时需要执行的所有函数都应该定义成下面的形式。

    ```c
    void __attritube__ ((constructor)) some_load(void){}
    void __attritube__ ((destructor)) some_unload(void){}
    //一项较早的技术是在库中创建两个函数_init()和_fini()，目前已经不推荐了。
    //使用gcc的constructor和destructor特性还能创建主程序的初始化函数和终止函数。
    ```

23. 出于测试的目的，有些时候可以有选择地覆盖一些正常情况下会被动态链接器找出的符号。可以通过设置环境变量LD_PRELOAD（由共享库名称组成，共享库名称之间用空格或冒号分隔）来使得某些共享库预先加载，这样可执行文件自动会使用这些库中定义的函数，从而覆盖那些动态链接器在其他情况下会搜索的同名函数。

24. 也可以使用/etc/ld.so.preload文件来在系统层面完成同样的任务，该文件列出了以空格分隔的库列表，LD_PRELOAD的优先级更高。

25. 出于安全原因，set-user-ID和set-group-ID程序忽略了LD_PRELOAD。

26. 可以通过设置LD_DEBUG环境变量来监控动态链接器的操作以弄清楚它在搜索哪些库。可以设置为一个或多个标准关键词可以从动态链接器中得到各种跟踪信息。

    ```shell
    #如果将help赋给LD_DEBUG，那么动态链接器会输出有关LD_DEBUG 的帮助信息，而指定的命令不会被执行。可以赋多个选项，各个选项之间用逗号分隔。
    zj@zj-hit:~$ LD_DEBUG=help ls #ls不会被执行
      libs        display library search paths
      reloc       display relocation processing
      files       display progress for input file
      symbols     display symbol table processing
      bindings    display information about symbol binding
      versions    display version dependencies
      scopes      display scope information
      all         all previous options combined
      statistics  display relocation statistics
      unused      determined unused DSOs
      help        display this help message and exit
    ```

27. LD_DEBUG 对于由动态链接器隐式加载的库和使用dlopen()动态加载的库都有效。出于安全的原因，在set-user-ID 和set-setgroup-ID 程序中将会忽略LD_DEBUG。

28. 在默认情况下，LD_DEBUG 的输出会被写到标准错误上，可以使用LD_DEBUG_OUTPUT环境变量指定一个文件名。
