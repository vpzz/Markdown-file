# 绪论

1. 算法+数据结构=程序设计。pascal语言的发明人，图灵奖获得者wirth。

2. 数值计算（例如求解方程组）和非数值计算（例如求解一组数中的最大值，计算机对弈，数据库管理程序）。

3. 非数值计算问题中，描述现实世界的实体模型和在计算机中表示的方法是数据结构要讨论的问题。

4. 数据元素是数据中的一个一个的个体，是数据结构中讨论的基本单位。

5. 数据结构是带结构的数据元素的集合。

6. 数据元素之间可以存在以下几关系：

   1. 序列关系，构成了线性结构。
   2. 树形关系，构成了树。
   3. 网状关系，构成了图。
   4. 集合关系，集合中的元素不存在任何关系，不过他们都属于同一个集合。

7. 数据结构可以描述为一个二元组：Data_Structures=(D,S)  其中D表示数据元素的有限集合，S是D上关系的有限集合。

8. 数据元素在计算机中使用二进制位串来表示。关系可以用有序对来表示，例如树形结构，可以用<A,B>来表示B是A的后继。

9. 关系的表示可以使用顺序映像（在存储器中的位置和逻辑顺序一致）或链式映像（每个元素都有个附加指针，指向它的后继或者前驱）。

10. 抽象数据类型ADT是数据结构和定义在它上面的一组操作。可以由一个三元组表示：（D,S,P）  DSP分别为数据对象，D上的关系，和对D的基本操作。

11. 算法是为了解决某些问题而规定的一个有限长的操作序列，必须满足一下五个特性：有穷性，确定性（同一输入，输出应该相同），可行性，有输入，有输出。

12. 设计算法应该考虑到：正确性（对任意输入都能得到正确的输出，实际较为难确定），可读性，健壮性，高效率和低存储需求。

13. 衡量算法的时间效率通常有两种方法：

    1. 事后统计法，编制程序，多次运行，然后进行统计。可能会有一些其他的因素掩盖了算法的本质。
    2. 事前分析估算法。

14. 和算法执行时间相关的因素：算法选用的策略，问题的规模，所用的编程语言，编译程序产生的代码质量，计算机的指令执行速度。其中和设计算法相关的是前两条。

15. 一个特定算法的运行工作量大小，只依赖于问题的规模，通常用n表示。

16. 研发新的算法的目的是在问题规模很大时，也能高效率的运行。

17. 如果随着问题规模n的增大，算法执行时间的增长率和函数f(n)的增长率相同，则可以记作T(n)=O(f(n))，称T(n)为算法的（渐进）时间复杂度。

18. 算法都是有控制结构+若干的原操作构成的。此处的原操作指的是对固有数据类型的操作。

19. 算法的总的执行时间可以看做是：∑原操作的执行次数*每个原操作的执行时间。        而原操作的执行时间对于不同的算法来说，一般都是定值。所以可以用原操作的执行次数来估算算法的执行时间。

20. 因为考虑的是当问题规模较大时的情况，所以只选取在算法中**重复执行次数较多的原操作**（基本操作）作为算法执行时间的衡量标准。

21. 因此算法的执行时间可以看做是和基本操作的执行次数成正比的。

22. 可以看出算法的基本操作都是在循环语句中的。

23. 上面的两个算法的效率和具体的输入数据无关，只和输入的规模有关，即使要排序的数据已经是有序的数据，也要把循环都运行一遍。

24. 冒泡排序，每一次循环都将最大的数或者最小的数放到序列的一端，然后问题的规模就变为n-1了。

25. 最好情况下时间复杂度为O(n)，最坏情况下时间复杂度为O(n^2)。一般将最坏情况下的时间复杂度作为算法的时间复杂度。

26. 同理也存在空间复杂度，需要的存储量包含三方面的内容：输入的数据占用（一般来说是固定的），程序本身的占用（一般来说较小，算法之间的差异也不大），辅助变量的占用。

27. 之前的排序算法中，对于任意问题规模，所需要的辅助变量都是固定的，因此该算法的空间复杂度为O(1)。这种的算法成为原地工作。

28. 算法设计的三个步骤，前两个步骤可以用递归的方法简便的给出，第三步往往要通过动态规划将递归转化为迭代：

    1. 第一步，先保证程序可以运行。
    2. 第二步，使得程序输出正确的结果。
    3. 第三部，使得程序处理更快。

29. 算法是指在特定的计算模型下，旨在解决特定问题的指令序列。算法应具有：

    1. 正确性，可以解决特定的问题。
    2. 确定性，非模糊的，语义明确的。
    3. 可行性，每一个基本操作都是可以在常数时间内完成的，避免把大象装冰箱。
    4. 有穷性，对于任何输入，经过有穷次的计算，都可以得到输出。

30. 有穷性举例，Hailstone序列：

    ```c++
    Hailstone(42) = {42,21,64,32,16,8,4,2,1}    //由于3*奇数+1是偶数，因此该序列不会出现连续的上升。
    Hailstone(7) = {7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1} //序列的长度未必和输入的大小成正相关。
    //目前来看，还未证明对于任意的n，Hailstone序列都是有限长度的，同时也未找出一个n，使得Hailsotne是无限长度的。
    ```

31. $$
    Hailstone(n)=\left \{\begin{array}{ccc}\{1\} \quad n\le1\\\{n\}\cup Hailstone(n/2)\quad n偶\\\{n\}\cup Hailstone(3n+1) \quad n奇\end{array}\right.
    $$

32. 一个好的算法需要满足以下标准：

    1. 能够正确处理简单的输入，大规模的输入，一般性的输入，退化的输入，任意合法输入。
    2. 要有足够的健壮性，能够辨别不合法的输入，而不导致非正常的退出。
    3. 可读性，结构化+准确命名+注释。程序除了是人和计算机交流的语言，还是人和人交流的语言。
    4. 效率，时间尽可能短，空间尽可能少。

33. 一般来说规模近似的问题，同一种算法所需的时间也近似。但是相同规模的问题，也有极端情况，例如从一个序列中查找元素，可能在最开始就查找到，可能到最后一个才能查找到。

34. 算法是独立于编程语言存在的，但是同一个算法使用不同的编程语言，编译器，硬件系统得出的性能又有区别。因此对于算法的分析主要基于理论。

35. 图灵机就是一个经典的模型。由纸带，读写头组成。图灵机是一个状态机，任意时刻都处在有限状态中的一个，这个状态也可以说是读写头的状态。初始时刻，纸带上的单元格内都是'#'。任何时刻读写头都对准纸带上的一个单元格。图灵机是按照固定节拍运动的，每次运动前都会寻找对应的转换函数(有很多个，这就是运行在图灵机上的指令)，决定下一步是如何运动，状态如何改变。转换函数为：

    ```c++
    (q, c; d, L/R, p)  //若当前状态为q,且当前状态为c; 则将当前字符改写为d,然后向左/右移动一格,并转入p状态。一旦进入h状态(事先约定的)，则停机。
    ```

36. RAM(Random Acess Machine)在可计算的意义上是和图灵机对等的。由无限多个寄存器组成，每个寄存器都有一个顺序编号，R[0]，R[1]，…。可以进行的基本操作有：

    ```c
    /*直接赋值*/
    R[i] <- c //将一个常数赋值给编号为i的寄存器。
    R[i] <- R[j]
    /*间接赋值*/
    R[i] <-R[R[j]] //间接赋值，将编号为j的寄存器当做一个新的编号，将该寄存器中的值赋值给编号为i的寄存器。
    R[R[i]] <- R[j]
    /*基本运算*/
    R[i] <- R[j] + R[k]	
    R[i] <- R[j] - R[k]	
    /*条件语句*/
    IF R[i]=0 GOTO l //条件跳转
    IF R[i]>0 GOTO l
    GOTO l  //无条件跳转
    STOP  //停机
    ```

37. 使用理论模型来评价算法的效率进行评判，可以认为算法运行的时间∝算法所需要执行的基本操作的次数。

38. T(n)=算法为求解规模为n的问题，所需执行的基本操作次数。

39. 使用大O记号来对算法的效率进行分析，这个是在定量和定性之间的折中。

40. 如果存在c>0，当n>>2时，有T(n) <c*f(n)，那么可以将T(n)简化为O(f(n))，一种渐进分析的思想，偏向于悲观。和T(n)相比，f(n)更为简洁，但依然反应前者的增长趋势。

41. <img src="数据结构.assets/image-20210823192741579.png" alt="image-20210823192741579" />

42. <img src="数据结构.assets/image-20210823192921489.png" alt="image-20210823192921489" />

43. 常见的算法时间复杂度：

    1. 常数复杂度，记作O(1)。如果一段代码中不含显式或隐式的循环，分支转向，递归，那么他就是常数复杂度。
    2. 对数复杂度，和底数无关，因此都不写底数，直接记作log(n)。这类算法是相当优秀的。
    3. 多项式复杂度，记作O(n^c)，和常数c无关。这类算法被认为是可以处理的。
    4. 指数复杂度，记作O(2^n)。这类算法通常被认为是不可处理的。

44. 很多问题的指数复杂度算法往往显而易见，而设计出多项式复杂度算法却极其困难，有时候甚至不可能的。

45. 常见级数的求和：

    ```c++
    //等差级数的和:与末项的平方同阶。
    T(n) = 1+2+...+n =n(n+1)/2 = O(n^2)
    //等比级数级数的和:与末项同阶。
    T(n) = 2^0+2^1+2^2+...2^n = (2^(n+1)-1)/(2-1) = O(2^n)
    //幂方级数的和:比幂次高出一阶。
    T(n) = 1^2+2^2+3^2+...+n^2 = n(n+1)(2n+1)/6 = O(n^3)
    T(n) = 1^3+2^3+3^3+...+n^3 = n^2(n+1)^2/4 = O(n^4)
    ```

46. <img src="数据结构.assets/image-20210823202925391.png" alt="image-20210823202925391" />

47. 嵌套循环的例子：

    ```c++
    /*n^2复杂度*/
    for (int i=0; i<n;i++){
        for (int j=0;j<n;j++){
            O1operation(i,j);
        }
    }
    /*同样是n^2*/
    for (int i=0; i<n;i++){
        for (int j=0;j<i;j++){
            O1operation(i,j);
        }
    }
    /*n*/
    for (int i=0; i<n;i<<=1){   //外层是跳跃的，内层是连续的。总共进行的操作有1+2+4+8+...+2^[logn],等比数列，总和与最后一项同阶,即O(n)。
        for (int j=0;j<i;j++){
            O1operation(i,j);
        }
    }
    /*nlogn*/
    for (int i=0; i<n;i++){  //外层是连续的，内层是跳跃的，总共执行的操作有log1+log2+log3..+logn= O(nlogn)。
        for (int j=1;j<i;j<<=1){
            O1operation(i,j);
        }
    }
    ```

48. 常数复杂度的例子：

    ```c++
    //问题：给定一个整数子集S, |S| = n>=3，找出其中任意一个非极端的元素，即不是最大，也不是最小。
    //算法：从S中任意取3个元素，例如前三个，找出这三个数中中间的那个数，这个数就是S的非极端元素。该算法和问题的规模n无关。
    ```

49. 空间复杂度一般不计入输入的空间，只考虑为了处理输入，而需要的新的空间多少。

50. 冒泡排序，给定n个数，将他们按序(升降序都可以)排列。通过观察，可以发现，对于无序序列，总是存在一堆相邻的元素师逆序的。该算法的思路是，多次扫描，遇到逆序的对，就交换两个数。每一次扫描都会将最大的一个数放到末尾，这种序列是从后往前排好的。该算法的复杂度是O(n^2)。例如：

    ```c++
    253684971→23564871 9→2354671 89→234561 789→23451 6789→2341 56789→231 456789→21 3456789→1 23456789
    //上面用空格分隔开已经归位的数字。经过k轮扫描后，最大的k个数必然归位，同时问题的规模缩减值n-k。
    void bublesort(int a[], int n) {  //给出数组的地址和个数。
    	for (int i = 0;i < n;i++) {
    		for (int j = 0;j < n - i - 1;j++) {
    			if (a[j] > a[j + 1]) {
    				int temp = a[j];
    				a[j] = a[j + 1];
    				a[j + 1] = temp;
    			}
    		}
    	}
    }
    /*另一种冒泡排序，不推荐这么写，逻辑复杂*/
    void bublesort1(int array[], int n) {
    	for (bool sorted = false;sorted = !sorted; n--) {  //首先执行表达式1和2，此时sorted为true，表达式2为真，进入循环。如果在循环中出现了逆序，那么sorted就变成了false，一轮循环结束n--，然后执行表达式2，结果为真，继续循环，如果在某一轮循环中没有发现逆序，那么执行表达式2，结果为false，退出循环。
    		for (int i = 1;i < n;i++) {
    			if (array[i-1] > array[i]) {
    				int temp = array[i-1];
    				array[i-1] = array[i];
    				array[i] = temp;
    				sorted = false;  //如果出现逆序，就将全局标志设置为无序。
    			}
    		}
    	}
    }
    /*使用*/
    int a[] = { 2,5,3,6,8,4,9,7,1 };
    bublesort(a, sizeof(a)/sizeof(a[0]));
    ```

# 迭代与递归

1. 从程序语言的角度讲，递归更简洁，但是他的效率一般是不如迭代的。

2. Decrease and Conquer，减而治之就是将一个大规模的问题划分为两个子问题，其中一个是平凡的，可以直接求解，类似于递归基，另一个规模比原有的问题缩减了一些。分别求解两个问题，然后由子问题的解，得到原问题的解。

3. 求解数组求和问题：

   ```c++
   /*递归*/
   int sum(int A[], int n ){
       return (n == 0) ? 0 : sum(A, n-1)+A[n-1];  //n=0是递归基。
   }
   /*迭代*/
   int sumI(int a[],int n){
       int sum =0;
       for (int i =0;i<n;i++){
           sum +=a[i];
       }
       return sum;
   }
   ```

4. 递归算法的时间复杂度分析可以有两种方法：

   1. 递归跟踪的方法：检查每个递归实例(也就是自身调用)，累计所需要的时间，每个递归实例中，不考虑自身调用语句，而将其计入对应的子实例中。因此上面的问题，每个递归实例中，时间复杂度就是O(1)，有n+1个递归实例，从sum(A,n)到sum(A,0)，因此总的时间复杂度为O(n)，称之为线性递归。

   2. 递推方程分析：列出递推方程组，然后求解。

      ```c++
      //递推方程组如下：
      T(n) = T(n-1) +O(1)
      T(0) = O(1)
      //将上述第一个式子改写为：
      T(n) - n = T(n-1) - (n-1) = T(n-2) - (n-2)=...=T(0) - 0 = O(1)
      //从而T(n) = O(n)
      ```

5. 将给定数组的子区间倒置：

   ```c++
   /*递归版本1*/
   void reverse(int a[], int lo, int hi){  //这里考虑左右都是闭区间。
       int temp = a[lo];
       reverse(a, lo+1, hi);
       for(int i =lo; i<hi; i++){
           a[i] = a[i+1];
       }
       a[hi] = temp;
   }
   /*递归版本2*/
   void reverse(int a[], int lo, int hi){
       if(lo<hi){
           int temp = a[lo];
           a[lo] = a[hi];
           a[hi] = temp;
           reverse(a, lo+1, hi-1);  //这个递归算法有两个递归基，即lo=hi和lo=hi+1，因为同时将问题的规模-2，因此不改变奇偶性。这两种情况是可以合并处理，因为都不需要做任何操作。
       }
   }
   /*迭代版本*/
   void reverse(int a[], int lo, int hi){
       while(lo<hi){
           int temp = a[lo];
           a[lo] = a[hi];
           a[hi] = temp;
           lo++;
           hi--;
       }
   }
   ```

6. Dvide and Conquer 分而治之，将一个大规模的问题分解为两个子问题，这两个子问题的规模相当。分别求解子问题，然后合并得到原问题的解。

7. 数组元素求和的二分递归：

   ```c++
   int sum(int a[], int lo, int hi){
       if(lo == hi){   //由于lo <= mi <=hi,因此递归基只有一种情况，就是lo=hi，此时求和的结果就是它自己。
           return a[lo];
       }
       int mi = (lo+hi)>>1;  //除以2，向下取整的操作。
       return sum(lo, mi)+sum(mi+1, hi);
   }
   ```

8. 寻找一个数组(左闭右开)中最大的两个元素，MAX2：

   ```c++
   //两趟循环，第一趟找出最大的元素，第二趟找出次大的。
   void max2(int a[], int lo, int hi, int& x1, int& x2){  //下标x1存储最大的，下标x2存储次大的。
   	x1 = lo;
       for (int i =lo, i<hi,i++){
           if(a[i] > a[x1]){   //经过第一轮循环，找到了最大值所在的位置，为x1。
               x1 = i;
           }
       }
       x2 = lo;
       for (int i = lo, i<=x1; i++){  //在第一段中寻找出最大值。
           if(a[i]>a[x2]){
               x2 = i;
           }
       }
       for (int i = x1+1, i<hi; i++){ //用第二段中的值和第一段中的最大值比较，找出次大值。
           if(a[i]>a[x2]){
               x2 = i;
           }
       }
   }
   //一趟循环，每次都和当前已知的最大和次大值比较。
   void max2(int a[], int lo, int hi, int& x1, int& x2){
       x1 = lo;
       x2 = lo;
       for (int i=lo; i<hi; i++){
           if(a[i]>x[x1]){
               x2 = x1;
               x1 = i;
           }else if(a[i]>a[x2]){
               x2 = i;
           }
       }
   }
   //递归+迭代
   void max2(int a[], int lo, int hi, int& x1, int& x2) {
   	int mi = (lo + hi) >> 1;
   	int x1L = lo;
   	int x2L = lo;
   	int x1R = mi;
   	int x2R = mi;
   	if (lo + 3 == hi) {  //第一个递归基
   		if (a[lo] > a[lo + 1]) {   //找出三个元素中较大的两个。
   			if (a[lo + 1] > a[lo + 2]) {
   				x1 = lo;
   				x2 = lo + 1;
   			}
   			else if (a[lo] > a[lo + 2]) {
   				x1 = lo;
   				x2 = lo + 2;
   			}
   			else {
   				x1 = lo + 2;
   				x2 = lo;
   			}
   		}
   		else {
   			if (a[lo] > a[lo + 2]) { //轮换
   				x1 = lo + 1;
   				x2 = lo;
   			}
   			else if (a[lo + 1] > a[lo + 2]) {
   				x1 = lo + 1;
   				x2 = lo + 2;
   			}
   			else {
   				x1 = lo + 2;
   				x2 = lo + 1;
   			}
   		}
   		return;
   	}
   	if (lo + 2 == hi) {  //第二个递归基
   		a[lo] > a[hi - 1] ? (x1 = lo, x2 = hi - 1) : (x1 = hi - 1, x2 = lo);
   		return;
   	}
   	max2(a, lo, mi, x1L, x2L);
   	max2(a, mi, hi, x1R, x2R);
   	if (a[x1L] > a[x1R]) {
   		x1 = x1L;
   		x2 = (a[x2L] > a[x1R]) ? x2L : x1R;
   	}
   	else {
   		x1 = x1R;
   		x2 = (a[x1L] > a[x2R]) ? x1L : x2R;
   	}
   	return;
   }
   /*使用*/
   int a[] = { 2,5,3,6,8,4,9,7,1 };
   int x1 = 0, x2 = 0;
   max2(a, 0, sizeof(a)/sizeof(a[0]), x1, x2);
   ```

9. 演示例子：int a[9] = { 2,5,3,6,8,4,9,7,1 }。lo=0，hi=9，x1=0，x2=0；

   1. 第一次调用mi=4，计算max2(a,0,4,0,0)进入新的递归。

   2. 得出新得mi=2，计算max(a,0,2,0,0)，进入新的递归。

   3. 得出新的mi=1，此次递归满足第二个递归基。比较a[0]和a[1]，得出x1L=1,x2L=0。递归返回，执行max2(a,2,4,2,2)。也是第二个递归基，比较a[2]和a[3]，得出x1R=3,x2R=2。

   4. max2(a,0,4,0,0)的两个子递归都返回了，开始执行后面的比较。得出x1 = 3，x2 =1 。递归返回，x1L=3，x2L=1。

   5. 计算max2(a,4,9,4,4)，得出新的mi=6，计算max2(a,4,6,4,4)，进入新的递归。满足第二个递归基，比较a[4]和a[5]，得出x1L=4，x2L=5。递归返回，计算max2(a,6,9,6,6)，满足第一个递归基，x1R=6，x2R=7。max2(a,4,9,4,4)返回，比较得出x1R=6,x2R=4。max2(a,0,9,0,0)返回，比较得出x1=6，x2=4。

   6. 相当于下面的这个树进行了左序遍历。实际上第一个递归基不能是lo+1=hi，这样有效的元素有1个，这样如果该节点的值大于相邻节点的两个值，那么最大和次大的都是这一个了，发生错误。

   7. ```c++
         253684971
          /     \
       2536    84971
       /  \    /   \
      25  36  84  971
      ```

10. 动态规划：通过递归找出了算法的本质，给出一个初步的解，再将其等效地转化为迭代的形式。

11. 斐波那契数列：

    ```c++
    // fib(n)=fib(n-1)+fib(n-2)    n从0开始,前两项分别为0和1，后续依次为1,2,3,5,8,...
    //递归算法
    int fib(int n){
        if(n<2){
            return n;
        }
        return fib(n-1)+fib(n-2);
    }
    ```

12. 复杂度分析，通过fib(n+1)导出T(n)。

13. <img src="数据结构.assets/image-20210826011020839.png" alt="image-20210826011020839" />

14. 这种算法之所以效率低下是因为进行了很多重复的的计算，例如下图，在计算fib(5)会做分支会计算fib(3)，右分支也会计算一遍。

15. <img src="数据结构.assets/image-20210826011520455.png" alt="image-20210826011520455" />

16. 有两种优化的方法：

    1. 记忆法：为了避免重复计算，可以将已经计算过的斐波那契数，存储起来，之后再要计算时，先查表，如果没有计算过，再执行计算。

       ```c++
       int arr[45];  //全局数组，用来存储已经计算过的fib数。
       int fib(int n) {
       	if (n < 2) {
       		arr[n] = n;
       		return arr[n];
       	}
       	if (arr[n - 1] == -1)  //每次计算前都要查表。
       	{
       		arr[n - 1] = fib(n - 1);  //虽然是自己调用自己，但是省去了很多递归实例的创建。
       	}
       	if (arr[n - 2] == -1) {  //这段代码，几乎不创建新的递归实例。
       		arr[n - 2] = fib(n - 2);
       	}
       	return arr[n - 1] + arr[n - 2];
       }
       int main() {
       	for (int i = 0;i < 45;i++) {
       		arr[i] = -1;
       	}
       	for (int i = 0;i < 45;i++) {
       		cout << "fib(" << i << ") = " << fib(i) << endl;
       	}
       }
       ```

    2. 还可以进行动态规划，颠倒计算方向。上面的递归是自顶向下，这里的动态规划是自底向上，进行迭代。

       ```c++
       int fib(int n) {
       	int f = 0, g = 1;
       	for (int i = 0;i < n;i++) {
       		g = g + f;
       		f = g - f;
       	}
       	return f;
       }
       ```

17. 最长公共子序列：一系列字符按照顺序排列构成一个序列，一个序列的若干个字符按照原来的顺序重新组合到一起，构成该序列的子序列。最长公共子序列是指两个序列的公共子序列中最长的那个。不过最长公共子序列可能不唯一。例如下面的左图，data和dana都是LCS。同时LCS的位置可能不唯一，例如下面右图，LCS是data，但是第一个元素d并不唯一。不过最开始分析的时候，可以先不考虑这些问题，只考虑最简单的版本。

18. <img src="数据结构.assets/image-20210826122925395.png" alt="image-20210826122925395" />

19. 递归算法，通过分而治之，将一个规模为n+m的问题分解为2个n+m-1的问题。如果末尾元素相同，则可以通过减而治之，转化为1个m+m-2的问题。分而治之的子问题规模不一定是原问题的一半，只要比原问题小即可。

20. <img src="数据结构.assets/image-20210826154035758.png" alt="image-20210826154035758" />

21. ```c++
    int LCS(char A[], int la, char B[], int lb) {
    	if (la < 1 || lb < 1) {
    		return 0;
    	}
    	if (A[la - 1] == B[lb - 1]) {              //减而治之
    		return LCS(A, la - 1, B, lb - 1) + 1;
    	}
    	else {                                     //分而治之
    		int a = LCS(A, la, B, lb - 1);
    		int b = LCS(A, la - 1, B, lb);
    		return a > b ? a : b;
    	}
    }
    
    /*使用*/
    char A[]="education";
    char B[]="advantage";
    LCS(A,sizeof(A)/sizeof(A[0]),B,sizeof(B)/sizeof(B[0]));
    ```

22. 上面这种算法的复杂度是指数的。可以发现，中间有些递归实例被重复地创建(实际上的递归实例总共也不过就n*m个)。因此可以使用动态规划，将该算法转化为自底向上的迭代。

23. 先列出下面的表的左边2列和上面2行，填写上0，然后逐行逐列填写，每个单元格的数值计算方法如下：

    1. 如果该单元格对应的上边和左边的元素相同，则该单元格的值=其左上角单元格的值+1。
    2. 如果该单元格对应的上边和左边的元素不同，则该单元格的值=max(上面单元格的值，左边单元格的值)。

24. <img src="数据结构.assets/image-20210826155131389.png" alt="image-20210826155131389" />

# 向量

1. 使用抽象数据类型vector时，一般不要在外部保留指向元素的指针（记住编号，使用的时候重新索引即可），因为随着扩容，元素的地址会发生变化，这样会使得该指针变为野指针。

2. 等差数列扩容的效率低于等比数列扩容。插入相同量的数据，等差数列扩容需要的扩容次数更多，每次扩容都要复制已有的内容，每次扩容的分摊成本为O(n)。等比数列扩容次数更少，每次扩容的分摊成本为O(1)。这是用空间换时间，等比数列扩容的空间使用率一般只有50%。

3. 顺序查找是输入敏感的，最好的情况可能一开始就找到，时间复杂度为O(1)，最坏的情况可能是到最后也没有找到，时间复杂度为O(n)。

4. 向量类的定义：

   ```c++
   #define DEFAULT_CAPACITY 128
   template<typename T>
   class vector{
   private:
       int _size,_capacity;   //大小，容量。
       T* _elem;  //数据区。
   public:    
       //构造函数
       vector(int c = DEFAULT_CAPACITY){
           _elem = new T[_capacity = c];
           _size = 0;
       }
       //析构函数
       ~vector(){
           delete [] _elem;
       }
       //只读接口
       
       //可写接口
       int remove(int lo, int hi);
   };
   ```

5. 序列的删除操作：

   ```c++
   template<typename T>
   int vector<T>::remove(int lo, int hi){   //区间删除
       if(lo >= hi){
           return 0;
       }
   	while(hi < _size){
           _elem[lo++] = _elem[hi++];  //逐个复制元素。从前往后，顺序不能反了。
       }
       _size = _size-(hi-lo);  //调整元素个数属性。
       return hi-lo;
   }
   template<typename T>
   T vecrot<T>::remove(int r){  //单个元素的删除
       T e = _elem[r];
       remove(r,r+1);
       return e;
   }
   ```

6. 无序序列的唯一化操作，每次都要将当前元素和它之前的所有元素比较，如果存在相同，则删除当前元素（需要移动后续的所有元素），如果不存在，则比较下一个元素：

   ```c++
   Template<typename T>
   int vector<T>::deduplicate(){
       int i=1,oldsize=_size;
       while(i < _size){
           find(_elem[i],0,i)? remove(i): i++;
       }
       return oldsize-_size;  //返回值为删除了的元素个数。
   }
   ```

7. 有序序列的唯一化(去重)操作，在有序序列中，重复元素总是相邻出现的，每个区间只保留一个元素即可：

   ```c++
   Template<typename T>
   int vector<T>::uniquify(){   //低效版本，如果出现了连续的重复元素，就要不断地移动其后的所有元素。时间复杂度为O(n^2)。
       int i =0, oldsize = _size;
       while(i < _size-1){
   	    (_elem[i] ==_elem[i+1]) ? remove(i+1): i++;
       }
       return oldsize - _size;
   }
   Template<typename T>     //高效版本
   int vector<T>::uniquify(){
       int i =0,j=1, oldsize = _size;
   	while(j < _size){
           if(_elem[i] !=_elem[j]){
               _elem[++i] = _elem[j];
           }
           j++;
       }
       _size = i+1;
       return oldsize - _size;
   }
   ```

8. 有序序列的查找可以使用二分查找或斐波那契查找。有序向量的从插入依赖于查找，因为要保证，插入后序列仍然有序。即V.insert(V.search(e)+1,e)；为了应对可能出现的查找不到，出现重复的情况，约定返回值为不大于该元素的最后一个元素的下标。

9. 有序向量的二分查找或斐波那契查找都是减而治之，每一次通过判断将原来问题的规模减小一半左右。虽然看上去像是分而治之，但是分开的两部分只用求解一部分，另一部分直接就排除了。

   ```c++
   template<typename T>
   int vector<T>::search(const T& e, int lo, int hi){
       while(lo<hi){   //隐式递归，没有直接调用自己，但是通过循环实际是在重复自己。
           int mi =(lo+hi)>>1;
           if(e < _elem[mi]){   //分而治之，因为下面的分支只能执行一个。
               hi = mi;
           }else if(_elem[mi < e]){
               lo = mi+1;
           }else{
               return mi;
           }
       }
   }
   ```

10. 二分查找的递归深度为logn，每个递归实例的时间复杂度为O(1)，因此该算法的时间复杂度为O(logn)。更细微的，二分查找成功和失败的时间复杂度均为O(1.5logn)。将关键码的比较次数(if语句的次数)定义为查找长度。

11. 一般的比较中，建议都是用<，因为小于号和通常的排序（升序）规则是吻合的。

12. 如下一个由7个元素构成的有序数列，对于其中的每个元素都有1次成功的情况，假设他们出现的概率相同。同时有8种（最底层的元素个数*2）失败的情况。如果成功在元素\[3\]，需要经过2次比较，如果成功在元素\[5\]，需要经过5次比较。可以发现，向左转向和向右转向的几率相同，但是需要进行的比较次数却不相同，一个是1，一个是2。所有的失败情况都发生在最底层。如果将这棵树向左偏移一下，即左侧的递归深度加深，这样可以对原先的不平衡进行补偿，使得平均查找长度进一步缩短。

13. ![image-20210826221429534](数据结构.assets/image-20210826221429534.png)

14. 斐波那契查找：假设序列长度n=fib(k)-1。则可取mi=fib(k-1)-1，这样左右两段的长度分别为fib(k-1)-1，fib(k-2)-1。即每次不去中点，而是去靠近右侧的斐波那契点，使得左侧大，右侧小，当n足够大时，大致是黄金分割点。

15. ![image-20210827103126336](数据结构.assets/image-20210827103126336.png)

16. fib-1序列：1-,0,0,1,2,4,7,...。7种成功的情况，平均查找长度为（2+3+4+4+5+5+4）/7=4。8种失败的情况，平均查找长度为（4+5+4+4+5+4+5+4）/8=4.38。通过比较发现，都比二分查找低一点。

17. ![image-20210827123622440](数据结构.assets/image-20210827123622440.png)

18. 通过分析可以得出，当分段点为黄金分割点时，时间复杂度的系数最小，为O(1.44logn)。

19. 另一种优化思路时，将分支的情况从3个缩减为2个，这样只用进行1次比较就可以缩小问题的规模。这样做可以使得左右转向的成本是一样的，但是也会引入新的问题，就是所有的命中都到了整个树的最底层。最好的情况变得坏了，最坏的情况变得好了，整体性能更稳定了。

    ```c++
    template<typename T>
    int vector<T>::binSearch(const T& A, int lo ,int hi){
        while(lo<hi-1){  //当区间内只有1个元素时退出循环。
            int mi  = (lo+hi)>>1;
            if(e < _elem[mi]){
                hi = mi;
            }else{
                lo = mi;
            }
        }
        return (_elem[lo] ==e)? lo: -1;
    }
    ```

20. 为了使得查找算法可以为插入算法提供可靠地接口，可以使用：

    ```c++
    template<typename T>
    int vector<T>::binSearch(const T& e, int lo, int hi){
        while(lo < hi){  //退出条件改变了
            int mi = (lo+hi)>>1;
            (e<_elem[mi])? hi=mi: lo=mi+1;   //[lo,mi)和(mi,hi)，漏掉了mi。
        }
    	return --lo;     //这个问题从循环中退出前，lo=hi+1,此时mi=lo,如果e<_elem[mi]，hi向lo靠拢，此时不大于e的最后一个元素下标为mi-1,也就是lo-1。反之lo向hi靠拢,不大于e的最后一个元素就是mi，也是lo-1。
    }
    /*
    设初始时lo=0,hi=n，在[0,n)的区间上搜寻e。则任意时刻_elem[0,lo)<=e<_elem[hi,n)。可以用数学归纳法证明，首先初始时刻[0,0)和[n,n)都是空集合，自然满足。假设在某一时刻满足，推算该时刻减而治之的两种情况都是满足的。
    */
    ```

21. <img src="数据结构.assets/image-20210827192242685.png" alt="image-20210827192242685" style="zoom: 67%;" />


# 排序算法

1. 冒泡排序的改进，原来的算法，即使前缀已经完全有序，也依然会进行扫描。这里用一个标志记录已经扫描过的部分是否是有序的，如果是就直接退出扫描了，对于已经有序的序列，只要一边扫描就可以，一般序列也可以将三角形的扫描变成梯形，如果对于完全逆序的序列，则和没有改进的算法效率相同：

   ```c++
   template<typename T>
   void Vector::bubbleSort(int lo, int hi){
       while(!buble(lo,hi--));  //当某一次扫描中没有发现逆序对时，就退出整个扫描，认为已经有序了。
   }
   template<typename T>
   bool Vector::bubble(int lo, int hi){
       bool sorted = true;  //用于记录每一趟扫描汇总，是否发现了逆序。
       while(++lo<hi){
           if (_elem[lo-1]>_elem[lo]){
               sorted = false;  //发现了逆序。
               swap(_elem[lo-1],_elem[lo]); //交换两个数。
           }
       }
       return sorted;
   }
   ```

2. 有可能出现这么一种情况，就是前缀不是完全就位的，而是靠后的部分元素已经就位。例如序列一开始为 894321567，经过两次扫描后为432156789。，已知9和8已经归位，这个时候前缀的部分元素567也已经归位，但是原来的算法还会继续执行扫描，不过执行4-1次即可。这三次扫描会分别将432归位。这里可以改进的部分是这三次扫描实际上只用扫描前缀中没有归位的部分，后面的567可以不参与扫描。

3. 进一步改进的思路：在每次扫描中记录下最后一个逆序对右边元素下标，下一次直接将hi移动到这里。这样扫描形状就由1个梯形变成了多个梯形，不过在最坏的情况下，效率依然和原始版本一样。

   ```c++
   //894321567→84321567 9→4321567 89→321456 789→213 456789→123456789。发生了一次跳跃。
   //这种作法并不会减少扫描的次数，只不过是将每次扫描的元素个数降低了。
   template<typename T>
   void Vector::bubbleSort(int lo, int hi){
       while(lo<(hi = buble(lo,hi)));  //hi会跳跃地移动。
   }
   template<typename T>
   int Vector::buble(int lo, int hi){
       int last = lo;
       while(++lo<hi){
           if(_elem[lo-1]>_elem[lo]){
               last = lo;
               swap(_elem[lo-1],_elem[lo]);
           }
       }
       return last;
   }
   ```

4. <img src="数据结构.assets/image-20210830125708041.png" alt="image-20210830125708041" style="zoom:67%;" />

5. 排序算法的稳定性，输入的重复元素在输出中已然保持原先的顺序，例如：

   ```c++
   /*
     输入    :6,7a,3,2,7b,1,5,8,7c,4
    稳定输出 :1,2,3,4,5,6,7a,7b,7c,8    三个重复元素已然保持着abc的顺序。
   非稳定输出:1,2,3,4,5,6,7a,7c,7b,8
   */
   ```

6. 这里的冒泡排序算法都是稳定的，因为在该算法中，任意两个元素的顺序如果要交换，就必须直接交换，即元素不能跳跃，必须一个一个地交换。要交换顺序的两个元素会逐渐靠近，然后再某一趟扫描中交换顺序。不过由于冒泡排序中交换顺序的条件是严格>，所以该算法是稳定的。

7. 冒泡排序的上述各种改进算法，最坏情况下都是O(n^2)。

8. 所有基于比较的排序算法，时间复杂度的极限是O(nlogn)。

9. 归并排序，最早是由冯诺依曼实现的，利用了分而治之的策略，而且是列表和向量通用的。将待排序的序列一分为二，然后递归地调用排序算法，到了递归基后(一个元素的序列是有序的)，再依次合并有序序列。两大步骤，无序向量的递归分解+有序向量的逐层合并。

   ```c++
   template<typename T>
   void Vector<T>::mergeSort(int lo, int hi){
       if(lo+1 = hi) return;
       int mi = (lo+hi)>>1;
       mergeSort(lo,mi);
       mergeSort(mi,hi);
       merge(lo, mi, hi);
   }
   ```

10. <img src="数据结构.assets/image-20210831011738311.png" alt="image-20210831011738311" style="zoom:50%;" />

11. 两个有序序列的合并：

    ```c++
    /*
    序列1:135     序列2:24689
    两个光标，分别指向两个序列头部，有一个新的向量用于存放合并后的序列。依次比较连个序列的光标下的元素，并将较小的放入合并后的序列，然后移动其中一个的光标，直到有一个光标到底，此时直接复制另一个序列剩余的元素即可。
    合并后的序列:1→2→3→4→5→689
    */
    ```

12. 时间复杂度：T(n) = 2*T(n/2)+O(n)，结果为O(nlogn)。


# 线性表

19. 线性结构是一个数据元素的有序集。这里的有序指的是次序上的，而不是数值上的。

2. 满足4条性质：
   1. 集合中必存在唯一的第一个元素。
   2. 集合中必存在唯一的最后一个元素。
   3. 除最后一个元素外，均有唯一的后继。
   4. 除第一个元素外，均有唯一的前驱。

3. 线性表可以有两种实现方式：顺序映像（顺序表）和链式映像（链式表）。每个元素都存在一个位序。

4. 基本操作有四类：
   1. 初始化为空表。
   2. 销毁线性表。
   3. 引用型操作（不改变线性表本身），判断是否为空，求表长，求元素的前驱或后继，获取第i位置上的元素，遍历操作（对所有元素都执行一遍某个函数），定位操作（将表中的每一个元素都和所给数据进行比较，将满足条件的第一个元素的位序返回）。
   4. 加工型操作，清空表中的数据（并不销毁该表，只是变为空表），修改第i位序的元素的值，在第i个元素处插入新元素，删除第i个元素。

5. 对于有序结构进行比较的算法比对无序结构比较的要快，一维有序结构的比较，可能只用比较开头或末尾。但是对无序表进行排序也要花费一定的时间。实际上排序算法可以做到很好的优化。

6. 合并两个有序序列时，可以每次比较两个序列的开头，逐次向新序列的末尾添加。

7. 将一个多重循环拆成多个低重循环，可以大大提高效率。

8. **顺序映像**：用一组地址连续的存储单元，依次存放线性表中的元素，元素之间的关系隐含在存储结构中。

9. 将第一个元素的存储地址作为线性表的起始地址，基地址。相邻元素的地址之间相差一个常量。因此有了基地址和相邻元素地址差值，就可以得到每一个元素的地址。

10. 每次进行插入或删除元素时，大约要移动表中一半的元素。

11. **链式映像**：用一组地址任意的存储单元存放线性表中的元素。链式表是以“结点”为基本单元的，每个节点等于元素+指向后继元素的指针。每个结点包含一个数据域和指针域。只有一个后继指针的链表也叫作单链表。

12. 线性表存在一个头指针，指向第一个结点。

13. 数据域的大小/结点的大小=存储密度

14. 通常在线性表的第一个元素之前加入一个头结点，该结点没有元素，只有一个指向真正第一个元素结点的指针。头指针指向该头结点。如果是空表，则头结点的指针域为空。

15. 链表的查找比较慢，需要从头开始，依次查找。链表的插入删除需要先查找对应位序的元素的地址，然后修改相关的指针域即可。比顺序表高效一些。

16. 链表的生成和顺序表不同，顺序表的生成，会先生成一个预定长度的表，而链表是逐个插入的。链表的生成有两种方式，一种是每次把新的元素插入到最后一个，一种是每次都插入到当前的开头，也就是头结点的后面。

17. 目前的单链表存在如下问题：表长是一个隐含的值，使用不便，顺序表在定义时就确定了这个表长。在最后插入结点时，需要遍历整个表。位序概念被淡化，节点的相对关系被强化。

18. 可以通过在以下方法来解决上述问题：在链表中增加一个表长域，表尾结点的指针，当前结点的指针。将在某一个位序处的插入删除操作变为在当前结点前插入和删除当前结点。（可能需要移动当前指针）

19. 线性表的链式映像还有双向链表（每个节点有两个指针域，前驱和后继节点的地址，可以较好地解决单链表寻找前驱的困难），循环链表（没有头尾节点，把单链表的尾节点的指针指向头结点）

20. 一元多项式可以用一个顺序表来存储它的系数，如果有很多项的系数为0，可以将系数和对应项的指数一同存储起来。

21. 例如$p(x)=7x^3-2x^{12}-8x^{999}$可以存储为$((7,3),(-2,12),(-8,999))$。按照指数从小到大的来排列。顺序表中的每个元素都是一个二元数。

# 栈和队列

1. 栈也是一系列有序元素$a_i$的集合，约定$a_n$为栈顶，$a_1$为栈底。和线性相比主要是操作不同。一个入栈一个出栈。插入和删除都只能在栈顶进行。栈可以看做是特殊的顺序表。
2. 队列和栈不同的是删除只在第一个元素处进行。队列是开放的（单通道），栈是封闭的。
3. Push和Pop分别为入栈和出栈操作，均在栈顶操作。
4. 栈的应用举例：
5. **数制转换**：将一个10进制数转化为2进制时，每次得到的余数都入栈，最后逐个出栈，得到的就是二进制表示。同样的工作也可以使用顺序表来实现，不过可读性要差很多。
6. **括号匹配检验**，检查左右括弧是不是成对出现：([]())这样的是对的。可以用期待的急迫程度来描述。每出现一个左括弧，就期待一个右括弧的出现。从左往右依次读取括弧，遇到左括弧入栈，遇到右括弧观察栈顶的括弧是否和他匹配，如果匹配则栈顶弹出，继续向右扫描。后出现的左括弧，先和下一个右括弧进行匹配。每次和栈顶元素进行比较的时候，都要先检查栈是否为空。
7. **行编辑程序问题**：早期的编辑程序是一行一行编辑的，没有光标可以使用。需要使用一个缓冲区，带用户确认输入后，再将缓冲区的内容写入到文件中，而不是立即将用户的输入写入到文件中。约定#符号表示退格作用，@表示删除该行的内容，从头输入。
8. <img src="数据结构.assets/image-20200906175351608.png" alt="image-20200906175351608" style="zoom:50%;" />
9. **迷宫求解**：通常使用穷举求解方法。在每个节点都有3种方向可以走，上下左右除了来的方向。按照某一个顺序进行走，如果有路就一直往下走，如果到了一个点没路了，那就只能回到上一个节点，继续探索刚才没有探索过的路线。每一个点都有几种尝试的可能。这样得到的路径不一定是最短路径。
10. **表达式（只限于二元运算符）求值**，表达式的定义：
11. <img src="数据结构.assets/image-20200906232601788.png" alt="image-20200906232601788" style="zoom: 50%;" />
12. 在计算机中，表达式的表示可以有3种方法：①前缀表示法例如x 3 5②中缀表示法3 x 5③后缀表示法3 5 x。这三种表示方法都没有括号。操作数的相对顺序没有改变。中缀式丢失了括弧的信息致使运算的次序不明确。
13. <img src="数据结构.assets/image-20200906232909370.png" alt="image-20200906232909370" style="zoom:50%;" />
14. 对于前缀式来说，如果出现连个连续的操作数，这表示一个最小表达式，他们的运算符是紧挨着前面的那个运算符。
15. 后缀式中运算符的次序正好是运算的顺序，所以一般会先将表达式转换为后缀式，然后求值。后缀式也叫逆波兰式。
16. 后缀式需要先保留操作数，遇到运算符时，去除最近的两个操作数，进行计算，并把计算的结果保存起来。和栈的结构完美契合。
17. 如何由原表达式求得后缀式，因为后缀式是有运算顺序意义的，所有需要根据原表达式来确定运算顺序。例如：原表达式：$a+b\times c-d/e\times f$。后缀式：$abc\times+de/f\times-$。
18. 这样一个表达式，在从左到右扫描运算符的时候，先遇到+号，但是不知道是不是能够优先计算，需要继续向后扫描，此时遇到x号，可知，之前的+号应该在x号后进行。继续向右扫描运算符，遇到了-号，可知x号是在-号之前进行，因此将x号写到操作数后面，然后比较+和-号，同级遵循从左到右的顺序，因此+号写入到x后面，此时-号的运算顺序还要继续向右扫描运算符来确定。
19. 每一个运算符的顺序都需要由它后面的运算符来确定。
20. 需要维护两个栈，一个是最终生成后缀式的栈，一个是存放中间的运算符的栈。左括号都入栈，遇到右括号，则将期间的栈内元素依次弹出运算符栈，压入后缀式栈，同时消掉两个括号。同时为了比较的方便，在表达式两端先加上一个#，代表优先级最低的运算符。（对它前后的运算符起到一个隔离的作用，总是入栈。右括弧总是将对应的左括弧之上的运算符转移到后缀式栈中。
22. **实现递归**：递归算法的可读性好，容易证明正确性。当一个函数在运行期间要调用另一个函数前，需要完成3件事：
    1. 将所有的实参，返回地址等信息传递给被调用函数保存。    这个返回地址和函数的返回值无关，而是在被调用函数结束后，需要通过返回地址找到在调用函数中应该执行的下一个语句。
    2. 为被调用函数的局部变量分配存储空间。
    3. 将控制转移到被调用函数的入口。
23. 当被调用函数完成后，要返回时，应执行的操作有：
    1. 保存被调用函数的计算结果，也就是函数的返回值。
    2. 释放被调用函数的数据区。
    3. 依照被调用函数的保存的返回地址将控制转移到调用函数。
23. 如果存在多个函数嵌套调用的话，需要先调用，后返回，此时需要用到栈的结构。
24. 高级语言中对于简单的函数可以用内联来避免入栈和出栈的操作，提高效率。
25. 类似于线性表，栈的实现也有两种映像，顺序栈和链栈。
26. 顺序栈需要知道栈顶的位置和栈的大小。栈顶指针一直在移动。入栈和出栈的同时都要移动栈顶指针。
27. 用链式映像来实现，不能充分发挥链式映像的优势，因为栈的操作一般都是在栈顶进行的，链式映像的优点在于在中间插入删除元素时，较为简单。
28. 队列需要两个移动的指针来分别表示队头和队尾，而栈只需要一个移动的指针来表示栈顶。
29. 队列也可以有两种映像，顺序队列和链队列。链队列的缺点和链栈一样。
30. 顺序队列中，如果队尾元素要超出分配的空间时，则应重新分配空间，并将现存的队列拷贝到新空间。也可以考虑循环利用数组形成循环队列，不过容易首尾撞车。
31. 在高级语言中，可以用数组来模拟栈和队列。在数组外定义两个指针即可。
32. 对于有序表的各种算法，时间复杂度应该都是线性的。
34. 判断输入的字符是否是“回文”，例如abcdedcba。因为没有明确的中间元素标记，所以单靠一个栈无法完成，还需要一个队列，首先把输入的元素分别存入栈和队列，然后依次比较栈顶和队头元素。

# 串

1. 串就是字符序列。可以理解为数据元素限定为字符的线性表。但是二者的操作有很大的差别，线性表的操作大多以单个元素为主，而串的操作对象为整个串，而且子串非常重要。
2. 这里的串是当做变量来看的，也就是字符数组，而不是计算机程序中的常量字符串。
3. 两个串比较大小指的是按照逐个字符字典顺序（ASCII码）比较。
4. 串常量用“”来括住，不计入长度。是给编译器识别用的。
5. 串可有顺序和链式两种存储映像，顺序映像有两种：定长存储（串的实际长度可以变化，超出预定义长度的会被截断）和堆分配存储（用字符指针和串长度来实现，需要手动分配和释放内存）。
6. 串的链式映像中，结点一般存储的是一个子串，而不是一个字符，因为这样的存储密度太低了。例如一个多行文本可以由多个行结点组成。方便进行行间和行内的操作。
7. 子串定位函数也称为串的模式匹配，文本编辑软件中的查找功能就需要这种算法。常见的有三种算法：
   1. 简单算法，逐个取出长度相同的子串进行比较。子串进行比较时，是逐个比较字符。这种算法对于一般的字符匹配还可以，对于二进制位的匹配较差，时间复杂度是两个串长度的乘积数量级的。也称为Brute Force（暴力算法）
   2. 首位匹配算法，首先也是先取子串，然后比较，比较的方法和简单算法不同，先比较第一个字符，然后比较最后一个，最后比较第2到倒数第2个（按顺序）。尽量避免出现之前的都相等，到最后不等的情况。只能解决部分情况。时间复杂度和简单算法一样。
   3. KMP算法，复杂度可以是O(两个串长度之和)，解决了之前两个算法中指针回溯的问题。需要对模式串B先进行分析，例如知道模式串的第一个和第二个字符不相等B[1]≠B[2]，模式串B和原字符串A的前n(n>2)个都相同（A[1]=B[1],A[5]=B[2]……），则指针不用回溯到第二个进行比较，因为由上可以判定A[2]≠B[1]。
8. <img src="数据结构.assets/image-20200908135532707.png" alt="image-20200908135532707" style="zoom:33%;" />
9. 观察下图，A和B串的指针都为7时，出现了对应字符不等，由于模式串中B[1-6]≠B[2-7]，后6个和前6个不等，所以指针可以跳过A[2]这个起始点。又由于B[1-5]≠B[3-7]，即前5个和后5个不等。依次分析，经过分析模式串的子串B[1-7]的前2个和后2个相等，因此将模式串向右移动7-2=5个单位。变成了下下图。关键就是通过分析子串，来获得移动的量。这个移动的量取决于比较停止的位置和子串的特征。
10. <img src="数据结构.assets/image-20200908140822932.png" alt="image-20200908140822932" style="zoom: 33%;" />
11. <img src="数据结构.assets/image-20200908141206239.png" alt="image-20200908141206239" style="zoom:33%;" />
12. 对于模式串，需要使用一个next函数，它的输入是模式串的当前指针j，输出的新的j。k从大到小寻找模式串的相似子串。修改j的值，实际上就是移动模式串的位置，因为模式串的j和原串的i始终是对齐的。
13. next()函数的作用是求模式串的子串的最长公共前后缀。然后移动模式串，使得前缀来到对应的后缀的位置（前后缀的长度小于子串的长度）。如果模式串在移动后，超出了原串的范围了，那么判定匹配失败。
14. 当A[i]≠B[j]时，运行next[j]函数，在比较A[i]和B[j]，相等的话就都+1，遇到不等再次运行next[j]函数。如果出现next[j]=0时，则此时，ij都应+1。
15. <img src="数据结构.assets/image-20200908144308394.png" alt="image-20200908144308394" style="zoom:50%;" />
16. 当要查找的串较长时，指针回溯问题就更为严重了。
17. 对于模式串中的每一个位序上的字符，都可以计算出一个k。在模式串中该字符前面的字符构成的子序列中，前k-1个字符=后k-1个字符。
18. 模式串分析:
19. <img src="数据结构.assets/image-20200908150242510.png" alt="image-20200908150242510" style="zoom:50%;" />
20. 指针不回溯还有个好处是，如果原串比较长，可以分批次读入内存，不用重复读取。
21. 求next函数值的过程是递推的(要求得当前的next值，需要获得之前的字符的next值)。若已知前4个字符的next值，现在要求第5个字符的next值：
    1. 首先，因为next[4]=2，可得B[1] = B[3]，然后判断B[4]==B[2]。如果相等，则可以发现B[1-2]=B[3-4]，因此next[5] = 3。
    2. 如果不等，例如B[5]≠B[3]，表明这个串不能在原来的基础上增长了。应该将B[5]和B[next[3]]，即B[1]去比较。也不等，再比较B[5]和B[next[1]]，即B[0]。所以此时，next从头开始计数，next[6]=1。
22. 上边第2步中，之所以要找B[next[3]]是因为想找出模式串的子串B[1-2]的最长的k。
23. 还可以进一步简化问题：next(j)=k，这里边存在一种特殊情况可以简化next(j)，即如果B[j]=B[k]，则next(j)= next(k)。如果再判定B[j] = B[next(k)]的话，则next[j] = next(next(k))，例如：
24. <img src="数据结构.assets/image-20200908172312156.png" alt="image-20200908172312156" style="zoom: 33%;" />
25. 上图，从左向右依次比较时，第一次停在i=j=4时，此时需要求next(4) ，得到3，比较T[4] = T[3]，则继续计算next(3) ，得到2，比较T(4) = T(2)，则继续计算next(2)，得到1，比较T[4] = T[1] ，则继续计算next(1)，得到0，此时i和j都+1，比较S[5]和T[1]。
26. 所以可以对next数组进行修正简化。00004
27. <img src="数据结构.assets/image-20200908173348062.png" alt="image-20200908173348062" style="zoom: 50%;" />

# 数组和广义表

1. 数组也是线性结构，多维数组有多个关系，每一个关系都是线性的。
2. 下表从0开始。以二维数组为例：每个数据元素在同一行上存在一个前驱和后继（首尾的不存在）。对列也是一样的，这两个关系构成了二维数组的两个线性关系。数组可以看做是下表和元素的对应关系。数组要注意下标越界问题。
3. 数组没有插入和删除操作，只有取值和赋值的操作。即它的结构是不变的，只有数据的改变。
4. 数组只有顺序表示，因为他只有引用性操作，没有加工性操作，不需要链式映像。数组是多维的，而存储空间是一维的，因此有两种映像方法，以一个2x3x2的数组为例，三个下标的变化分别为     0，1                 0，1，2                    0，1：
   1. 以行序为主序（低下标优先） (0,0,0)→(0,0,1)→(0,1,0)→(0,1,1)→     从后往前变
   2. 以列序为主序（高下标优先）(0,0,0)→(1,0,0)→(0,1,0)→(1,1,0)→(0,2,0)→(1,2,0)     从前往后变。
5. 大多数高级语言是按照以行序为主序的原则排列的，除Fortran以外。对于二维数组来说，就是一列一列存储。数组的首个元素的地址称为数组的基地址。
6. 数组的元素的存储位置是其下标的一个（多元）线性函数。索引是常数时间复杂度。
7. **三元组顺序表结构**，类似于多项式的简化存储：标记行列值和元素的值。还有记录矩阵的总行列数，非零元的个数。为了寻找同一行的非零元的便利，顺序表中的元素按照行值为主序，从小到大进行排列。一行一行扫描。
8. 求转置矩阵的操作，常规的二维数组表示方法，时间复杂度为矩阵大小（mxn），使用三元组顺序表结构时，需要满足生成的新的转置矩阵的顺序表也要是按照行序排列的。需要转置过后，直接放到对应的位置，一步到位。
9. 这需要对转置前的数据进行分析，获得一个表格，标识了如何根据原来数据的列值来找到转置后的位置。
10. 对原矩阵的三元组顺序表从前往后扫描，根绝列值的出现，依次记录，出现一次记录+1。得到下表的第二行。然后cPot表示转置后的表中对应行的第一个非零元的位置。第一个一定是1，然后第二个是1+2，即转置后的表中，第一行有2个元素，所以第二行的第一个非零元要从1+2=3的位置放置。
11. <img src="数据结构.assets/image-20200911204032068.png" alt="image-20200911204032068" style="zoom:50%;" />
12. 制作出位置记录表后，依次进行转置，取出第一个元素，观察他的列值=2，那么查表可得，应该放在第3行，对它的行列调换，放入第3行，然后修改位置记录表，第二列对应的CPot值+1=4。
13. 这样一来转置操作就变成了线性复杂度。取决于矩阵的非零元的个数。
14. 三元组顺序表的缺点是当要随机寻找某一行的非零元时，需要从头索引，不方便。
15. **行逻辑连接的顺序表**：在稀疏矩阵的结构中增加一个记录每一行的第一个非零元的位置的数据成员。
16. 用稀疏矩阵乘法为例，常规方法计算矩阵乘法需要三重循环。
17. Q=MxN。根据两个表，得出Q的顺序表。
18. <img src="数据结构.assets/image-20200913181918747.png" alt="image-20200913181918747" style="zoom:50%;" />
19. <img src="数据结构.assets/image-20200913181643933.png" alt="image-20200913181643933" style="zoom:50%;" />
20. Q矩阵的第一行的非零元和M矩阵的第一行的非零元运算得到。M矩阵的第一行的零元不参与运算。
21. 需要一个缓存器，初始都是0，来累加，直到一行计算完成。累加器的大小为Q也就是N的列数。
    1. 取出M的第一个非零元，（1，2，2）找N中第2行的所有非零元与之相乘（通过N的每行第一个非零元的位置数组可以快速获得，该行有2个非零元），得到（1，1，4）和（1，2，8）这两个元素的列值是N中非零元的列值。此时缓存器为(0+4,0+8)。
    2. 取出M的第二个非零元（通过M的 每行第一个非零元位置数组，可知道该行有2个非零元），（1，5，3）找N中第5行的所有非零元与之相乘（通过N的每行第一个非零元的位置数组可以快速获得，该行有1个非零元），得到（1，2，-6）这两个元素的列值是N中非零元的列值。此时缓存器为(0+4,0+8-6)。
    3. 此时处理完M的第一行所有非零元，得到了Q的第一行所有元素（这里不一定是非零元）。然后将缓存器中的非零元放到顺序表中。依次为（1,1,4）（1,2,2）。
    4. 累加器清零，从第二行开始重复第一行的，最后将缓冲器的非零元填入顺序表中，注意此时的元素的行号都是2。
    5. 在生成Q的过程中，也就顺便得到了Q的每行第一个非零元的位置数组。
22. 其时间复杂度相当于M的行数xN的列数。不过这个方法也可以用于非稀疏矩阵，这样的话复杂度就和常规方法一样了。
23. 用数组来表示稀疏矩阵会引起一种问题，如果稀疏矩阵中的非零元数量变化（矩阵的加减），那么数组的维度就要跟着变化，这是顺序结构的缺点。
24. **十字链表**：每个节点有5个域，除了之前的2个行列位置和数据，还增加了行列后继元素的指针。因此一共产生了矩阵的行+列这么多的链表。
25. <img src="数据结构.assets/image-20200913185204891.png" alt="image-20200913185204891" style="zoom:50%;" />
26. 如上图，如果此时要给第1行第3列的元素+5，则应该修改代表第1行和第3列的两个链表。每一个元素既处在一个行的链表上，又处在一个列的链表上。

# 树和二叉树

1. 树是递归定义的，树可以看做是一个集合，空集表示空树，存在唯一的一个称为根的数据元素root。当元素数量>1时，其余结点可以分为m的互不相交的有限集，T1,T2，……Tm。其中每一个子集本身又是一颗符合本定义的树，称为root的子树。
2. 子树的根节点和母树根节点存在一个前驱和后继关系。一般讨论的树为有向树，但是不画箭头。
3. 树中的基本元素是节点，由数据元素+若干指向子树的分支组成。结点得分支的个数称为节点的度。树中所有节点的度的最大值为树的度。度=0的节点为叶子节点。度>0的是分支节点。
4. 从根到任一节点的路径由根到该节点的所经过的分支和节点组成，唯一存在的。父节点，子节点，兄弟节点，祖先节点，子孙节点。一个节点有且只有一个父节点（根节点除外）。
5. 树是层次结构的，根节点为第一层，第L层节点的子节点为L+1层。叶子节点所在的最大的层数称为树的深度。
6. 森林是由m棵互不相交的树的集合。一棵树可以看做是根节点+子树组成的森林构成。
7. 如果一个节点的子节点之间是有顺序的，则成为有序树。这个和有向树不同，后者是指父子节点之间的关系，前者是指兄弟节点之间的关系。通常讨论的都是无序树。
8. 线性结构可以看做是一种特殊的树结构，即每个节点只有1个子树。
9. **二叉树**：或为空树，或是由一个根节点+两棵分别称为左子树和右子树的互不相交的二叉树组成。左右子树本身可以是空树。
10. <img src="数据结构.assets/image-20200913201109201.png" alt="image-20200913201109201" style="zoom:50%;" />
11. 二叉树的5种基本形态：
12. <img src="数据结构.assets/image-20200913201428780.png" alt="image-20200913201428780" style="zoom:50%;" />
13. 二叉树的左右子树不能交换，但是这个概念和有序树还不一样。例如如果一个节点只有一个子节点，有序树就无意义，但是对于二叉树来说，必须说明该子节点是在左边还有右边（两棵不同的树）。
14. 对于树的删除，一般都是删除整个子树，而没有只删除节点的操作。
15. 二叉树的第i层上，至多有$2^{i-1}$个节点。深度为h的二叉树，最多有$2^h-1$个节点。
16. 两类特殊的二叉树：
    1. 满二叉树，深度为k，并且含有$2^{k}-1$个节点的二叉树。只有最后一层是叶子节点，不存在度为1的节点。满二叉树可以按照从上到下，从左到右的顺序进行编号。
    2. 完全二叉树。取自满二叉树的前N的连续的节点构成的二叉树。只有最后一层不是满的，且最后一层一定是从左向右排列。
17. 具有n个节点的完全二叉树的深度为[$log_2^n$]+1。向下取整。
18. 完全二叉树的任意一个节点i和它的父节点的编号之间存在如下关系：
    1. 若i=1，则没有父节点，否则，编号为[i/2]的节点是其父节点。
    2. 若2i>n，说明该节点没有左子节点。否则编号为2i的节点是其左子节点。
    3. 若2i+1>n，说明该节点没有右子节点。否则编号为2i+1的节点是其右子节点。
19. 上面的规律可以用数学归纳法证明。需要注意的是，它适用于从1开始编号的二叉树。
20. 二叉树的顺序存储：将空的地方填上，构成完全二叉树来存储。不过要浪费一些空间。
21. <img src="数据结构.assets/image-20200914224828584.png" alt="image-20200914224828584" style="zoom:50%;" />
22. 二叉树的链式存储
    1. 二叉链表：每个节点含有一个数据域和两个指针域（分别指向左右子节点）。整个二叉树由指向根节点的指针构成。
    2. 三叉链表：在二叉链表的基础上加上一个指示父节点的指针域。
    3. 双亲链表：每个节点含有一个数据域和一个指针域（分别指向父节点），还有一个指示他是父节点的左/右节点的标识。所有节点可以放到一维数组中。相当于反着索引。
    4. 线索链表
23. 二叉树的遍历：顺着某一个搜索路径寻访二叉树中的节点，使得每一个节点都能被访问到，且只被访问一次。
24. 线性结构的遍历只有一条搜索路径，因为每个节点都只有一个后继。
25. 对于二叉树，可以有三条搜索路径：
    1. 先上后下的按层次遍历：
    2. 先做后右的遍历，可以看做是递归定义。
    3. 先右后左。
26. 每个节点都会被经过三次，第一次是当做根，第二次是从左子树回来到根，第三次是从右子树回来到根。需要约定在那一次执行访问操作。按照访问发生的时刻分为三种：
    1. 先序遍历又叫先根遍历，前序遍历，按照下图中的顺序为ABCDEFGHK。
    2. 中序遍历，从左子树回来的时候访问根节点，按照下图中的顺序为BDCAEHGKF。
    3. 后序遍历，从右子树回来的时候访问根节点，按照下图中的顺序为DCBHKGFEA。
27. 三种遍历方法和三种访问方法是不冲突的，每一种遍历都可以选择在那一时刻访问根节点。先遍历子树还是先访问根节点。
28. <img src="数据结构.assets/image-20200914230651080.png" alt="image-20200914230651080" style="zoom:67%;" />
29. 选择不同的遍历方法，就是将根节点和它的左右子树的节点放置到不同的位置。例如中序遍历的话，即A始终在BCD和EFGH的中间，把二者分开。

# 树

1. 向量和链表的查找和插入删除性能都各有优缺点。树是综合了二者优点的结构，不是线性结构，但是又带有了线性的特征，可以称之为半线性的，而图是非线性的。可以认为是链表的链表List\<List\>，或者说二维链表。

2. 树是按照层次关系来组织数据的。树结构是一种特殊的图T=(V,E)，节点数|V|=n，边数|E|=e。定义在一组元素之间的二元关系。元素之间有关系可以用连接两个元素的一条边来代表。树中的点称为顶点vertex，而图中的点称为节点node。

3. 指定任意一个节点$r\in V$作为顶点后，这个树$T$就成为了有根树。多个有根树$T_i$加上一个新的顶点$r$可以构成一个新的规模更大的树，参与组成该树的每个树$T_i$都称为它的以ri作为顶点的子树$T_i=subtree(r_i)$。ri称为r的孩子，ri之间互称兄弟sibling。r拥有的孩子的数目，称为该节点的(出)度$=degree(r)$。

4. ![image-20210827201546996](数据结构.assets/image-20210827201546996.png)

5. 关于边，顶点，顶点的度之间存在如下公式，边数=所有顶点的度数之和=顶点数-1，所以在讨论时间复杂度时，都是以树的顶点数n作为问题规模参考的：
   $$
   e=\sum_{r\in V}degree(r)=n-1
   $$

6. 计算机科学中讨论的树，每个顶点的孩子之间应是有序的，而数学上讨论的树不太在意这个。若指定$T_i$为T的第i棵子树，$r_i$作为r的第i个孩子，那么称T为有序树。

7. 图G=(V,E)中，如果V中k+1个节点，通过E中的k条边依次相连，那么称构成了一条路径path（也称为通路）。路径是由一些首尾相连的边构成的。路径$\pi$的长度$|\pi|$定义为他的边数。如果路径的首尾节点相同$v_0=v_k$，那么称之为环路。

8. 如果任何两个点之间都可以通过某条路径相连，那么这个图称为连通图connected。这一条件要求边数不能太少。

9. 如果一个图中不包含任何环路，那么称之为无环图。这一条件要求边数不能太多。

10. 对于树来说，任何一个节点v到根节点r都存在唯一的一条路径path(v,r)=path(v)。将这条路径的长度称为该节点的深度depth(v) = |path(v)|。根节点的深度为0。如果树的根发生了转换，每个节点的深度可能会发生变化。

11. 在不引起歧义的情况下，可以将路径，节点，子树之间可以互相替代。path(v)\~v\~subtree(v)。

12. path(v)上的节点都成为v的祖先ancestor，默认是包含顶点自身的。排除掉自身的祖先称为真proper祖先。v是它祖先的后代descendent。没有后代的节点称为叶子leaf。

13. 所有叶子节点深度的最大值称为该树的高度。任何一个子树也可以定义高度，就是一该节点作为根节点的树的深度。只有一个根节点的树的高度为0，空树（一个节点都没有）的高度为-1。高度的定义依赖于深度，一个节点的高度也就是以它为根的子树的高度。也就是max{所有孩子的高度}+1。

14. 任何一个节点的高度+该节点的深度<=整个树的高度height(T)。

15. <img src="数据结构.assets/image-20210827210218962.png" alt="image-20210827210218962" style="zoom:50%;" />

16. 树的半线性特征体现在，任何一个节点总有惟一的祖先，而它的后代却不一定唯一。

17. 根据上面的特征，显而易见，树的每个节点只要维护一个父节点的编号即可。这样一个树可以用下面的一张表来表示，每个节点有一个编号，也记录这它的父节点的编号，还有该节点的内容。不过这样有一个问题，从任意节点找到它的子节点或兄弟节点都需要从上往下遍历，时间复杂度为O(n)。

18. <img src="数据结构.assets/image-20210827211719146.png" alt="image-20210827211719146" style="zoom:50%;" />

19. 另一种思路是，每个节点维护一个储存有它所有孩子的向量或链表的指针，不过这样又会使得由子节点找父节点变得复杂。

20. <img src="数据结构.assets/image-20210827212208712.png" alt="image-20210827212208712" style="zoom:50%;" />

21. 综合上面两种思路，可以有如下的表示方法。不过这样会造成数据冗余，例如在删除节点D时，除了删除D所在的那一行，还应在他的父节点行内删除它。这个方法还有一个问题，就是所有节点的孩子加起来也就O(n)级别，但是需要为每个节点都留存O(n)的空间，存储空间效率低。

22. <img src="数据结构.assets/image-20210827212525879.png" alt="image-20210827212525879" style="zoom:50%;" />

23. 长子+兄弟表示方法是对树的本质的深刻理解。每个节点都保存两个指针，一个指向自己的长子，另一个指向自己的下一个兄弟。二者是一纵一横的关系。通过R找B时，需要先执行R.firstchild()获得A，然后再通过A.nextsibling()获得B。

24. <img src="数据结构.assets/image-20210827213425933.png" alt="image-20210827213425933" style="zoom:50%;" />

# 二叉树

1. 每个节点的度数不超过2的树，称为二叉树binary tree。每个节点的两个孩子和子树可以以左或右区分。

2. 二叉树中，深度为k的节点最多有2^k个。

3. 含有n个节点，高度为h的二叉树中， h<n<2^(h+1)。
   1. 当n=h+1时，该二叉树退化为单链条。
   2. 当n=2\^(h+1)-1时，该二叉树称为满二叉树。即每个深度的节点数都达到最大，即2\^k个。深度相同的二叉树中，满二叉树的节点数最多。
   
4. 二叉树的宽度和高度成指数关系。二叉树变宽的速度比变高的速度快很多。

5. 如果每个节点的出度都是0或2，那么称这个二叉树为真二叉树。

6. 通过二叉树来描述多叉树，要求多叉树有根且有序，在之前的长子+兄弟表示法中，多叉树的每个节点也只有两个引用，可以将这两个引用当做二叉树的两个叉，左子节点表示当前节点的长子，右子节点表示当前节点的下一个兄弟，将原来的树顺时针旋转45度即可。本来不同级的两个节点变得同级了。

7. <img src="数据结构.assets/image-20210827220021608.png" alt="image-20210827220021608" style="zoom:50%;" />

8. 二叉树节点类的代码：

   ```c++
   template<typename T>
   class BinNode{
   private:
       BinNode<T>* parent,lChild,rChild;
       T data;
       int height;  //当前节点的高度，这里使用高度而不是深度，是因为高度是节点更本质的属性，当将该节点的子树独立出来时，高度信息不变，而深度会变为0。
   public:
       int size() const {  //子树的规模，也就是包括当前节点在内，所有后代节点的个数。
           int s = 1;
           if(lChild){   //分而治之,时间复杂度O(n)。
               s+=lChild->size();
           }
           if(rChild){
               s+=rChild->size();
           }
           return s;
       }
       BinNode(const T& e, const BinNode& father){
           T=e;
           parent = &father;lChild=NULL;rChild=NULL;
       }
       BinNode<T>& insertAsLC(const T& e){  //插入一个新的节点，作为当前节点的左孩子，返回值为左孩子。
       	return *(lChild = new BinNode(e,this));  //这里完成了两个绑定，将this绑定为左子节点的父节点，又将当前节点的LChild指向新生成的节点。
       }
       BinNode<T>& insertAsRC(const T& e);
       BinNode<T>* succ();  //(中序遍历下)当前节点的直接后继。
       template<typename VST> void travLevel(VST&)  //子树层次遍历。这里的VST接受的是仿函数类型。
   };
   ```

9. 二叉树类的代码：

   ```c++
   #define stature(p) ((p)?(p->height):-1)
   template<typename T>
   class BinTree{
   protected:
       int _size;  //二叉树的规模，即节点总数。
       BinNode<T>* _root;  //指向根节点的指针。
       virtual int updateHeight(BinNode<T>& x){ //更新节点x的高度并返回，由于每种二叉树的更新策略不同，因此此处为虚方法。
           return x.height = max(stature(x.lChild, x.rChild))+1;
       }
       void updateHeightAbove(BinNode<T>& x){ //更新节点x及它的祖先的高度。当插入或删除一个节点时，它的祖先节点的高度属性可能会因此改变，因此应该在插入或删除完成后调用当前函数，使得各个节点的数据合理。
           while(x){
               updateHeight(x);   //先更新当前的，然后再切换到父节点。
               if(x.parent){
                   x = *(x.parent);  //切换前要判断是否还有父节点。
               }else{
                   return;
               }
           }
       }
   public:
       int size() const {return _size;}
       bool empty() const {return !_root;} //判断当前树是否为空树，即没有根节点。
       BinNode<T>& root(){return *_root;}
       BinNode<T>& insertAsRC(BinNode<T>& x, const T& e){  //将元素e作为节点x的右节点插入。
           _size++;
           x.insertAsRC(e);  //通过调用节点的插入来实现，各自分工。
           updateHeightAbove(x);
           return x.rChild;
       }
       BinNode<T>& insertAsLC(BinNode<T>& x, const T& e);
       template<typename VST> void traverse(BinNode<T>& x,VST& visit){ //遍历
           if(!x){
               return ;
           }
           visit(x.data);  //先序遍历。
           if(x.lChild){    //分而治之
               traverse(*(x.lChild), visit);  //尾递归
           }
           if(x.rChild){
               traverse(*(x.lChild), visit);  //尾递归
           }
       }
   };
   ```

10. 之前的节点类中有插入孩子节点的代码，这里的树的类中也有插入孩子节点的代码。不过只能通过树来给指定节点上插入左右孩子节点。因为只有这样，整个树，即该节点的祖先节点的高度才会都更新。

11. 上面的updateHeightAbove函数不能写成下面这样：

    ```c++
    void updateHeightAbove(BinNode<T>& x){
    	do{
            updateHeight(x);
        }while(x = *(x.parent))   //当x.parent=NULL时，就会发生运行时错误。
    }
    ```

12. 二叉树的组织和链表类似，节点和整体是分离开的。整体只保留一个指向头的指针，二者不同的是，树节点有多个子节点的指针，链表节点只有一个。

13. 树的遍历是按照某种次序访问树中的各个节点，每个节点恰好被访问一次，相当于将半线性的树转化为线性的序列。常见的遍历策略有：先序preorder，中序inorder，后序遍历postorder，这里的先后是指根节点的遍历相对于左右子树遍历的位置。这三种遍历都是递归定义的。

14. ![image-20210828094032996](数据结构.assets/image-20210828094032996.png)

15. 递归形式的遍历算法，时间复杂度是O(n)，虽然这已经是最好的了，但是在递归栈中，每个递归实例都对应于一帧，每次函数调用都会引入额外的开销，因此可以替换为迭代。由于上面的递归实例都是在最末尾创建的，称为尾递归，它是比较容易改写为迭代的。

    ```c++
    template<typename VST> void traverse(BinNode<T>& x,VST& visit){ //遍历
        stack<BinNode*> S;
        if(x){
            S.push(&x);
        }
        while(!S.empty()){  //当栈不空时继续循环。
            x = *(S.pop());
            visit(x.data);  //先序遍历。
            if(x.rChild){   //右孩子先进后出。
                S.push(x.rChild);
            }
            if(x.lChild){   //左孩子后进先出。
                S.push(x.lChild);
            }
        }
    }
    ```

16. <img src="数据结构.assets/image-20210830000305721.png" alt="image-20210830000305721" style="zoom: 67%;" />

17. 这种算法虽然间接，但是不容易推广到后续的中序，后序遍历。仔细观察访问节点的顺序。会一直往左下方向走，直到没有左孩子，此时会访问右孩子，然后继续左下行走，如果到了叶子节点，那么会转移到下一个兄弟节点。如果没有兄弟节点，就找父节点的兄弟节点。

18. 将任何一棵树中，起始于树根，沿着左孩子一直到底的路径称为左侧链。

19. ![image-20210830000446685](数据结构.assets/image-20210830000446685.png)

20. 在从L0到Ld的过程中，就将对应的右孩子压入栈中，当左侧链到底后，开始从栈中取出节点，继续重复上面的步骤进行先序遍历，当栈空时，遍历完成。

    ```c++
    template<typename T, typename VST>
    static void visitAlongLeftBranch(BinNode* x,VST& visit, Stack<BinNode*>& S){  //沿一棵树的左侧链下行访问，并将右侧的节点入栈。
        while(x){
            visit(x->data);
            S.push(x->rChild);  //即使rChild为NULL也入栈。
            x = x->lChild;
        }
    }
    template<typename T, typename VST>
    void travPre_I2(BinNode* x, VST& visit){
        Stack<BinNode*> S;
        while(1){
            visitAlongLeftBranch(x,visit,S);
            if(!x->empty()){
    			x = S.pop();  //可以改写为while(x=S.pop()); 由于S中可能存在NULL,当出现NULL时，visitAlongLeftBranch会徒劳调用一次，不如在调用前就检测，这里的while循环，可以一直弹栈，知道弹出的非空。
            }else{
                return;
            }
        }
    }
    ```

21. 任何一棵二叉树都可以表示成下图的样子，左侧链+对应的右子树。

22. <img src="数据结构.assets/image-20210830001400087.png" alt="image-20210830001400087" style="zoom: 50%;" />

23. 示例：首先访问a，将c入栈，然后访问b，将b的右孩子(NULL)入栈。此时由于b的左孩子为NULL，所以返回，从栈中弹出NULL，赋值给x，又进入visitAlongLeftBranch函数，while判断失败，退出，再从栈中弹出c，进入visitAlongLeftBranch函数，访问c，入栈f，访问d，入栈e。此时d的左孩子为NULL，退出循环，然后将e出栈，访问e，入栈NULL，此时e的左孩子为NULL，退出循环，出栈NULL，退出循环，继续出栈f，访问f，入栈NULL，访问g，入栈NULL，g的左孩子为NULL，退出循环，出栈NULL，后续。。。

24. ![image-20210830002836701](数据结构.assets/image-20210830002836701.png)

25. 中序遍历和之前的先序遍历不同，先序遍历中最后两个递归都是尾递归，而中序遍历中，访问左子树的那个递归不是尾递归。观察访问顺序，可以发现，当一个节点拿到访问控制权后，会先转移给它的左孩子；当一个节点的左孩子被访问后，接下来就是它的左孩子的右孩子遍历，最后是自己。

26. ![image-20210830004323516](数据结构.assets/image-20210830004323516.png)

27. ```c++
    //函数执行流程：visit(L_k)→Inorder(T_k)→visit(L_(k-1))
    template<typename T>
    static void goAlongLeftBranch(BinNode* x, Stack<BinNode*>& S){  //沿一棵树的左侧链下行依次入栈。
        while(x){
            S.push(x);  //将当前节点入栈也入栈。这个栈不会出现NULL。
            x = x->lChild;
        }
    }
    template<typename T, typename VST>
    void travPre_I2(BinNode* x, VST& visit){
        Stack<BinNode*> S;
        while(1){
            goAlongLeftBranch(x,S);
            if(!x->empty()){
                x = S.pop();  //这里不会pop出界的，因为有树根节点。
    	        visit(s->data);
        	    x = x->rChild;
            }else{
                return;
            }
        }
    }
    ```

28. ![image-20210830004744642](数据结构.assets/image-20210830004744642.png)

29. 树的遍历本质上是访问控制权的转移。以上遍历的迭代版本算法也是O(n)复杂度。

30. 层次遍历：由上到下，由左到右。之前的三种遍历，都有后代先于祖先被访问的情况，也就是逆序。层次遍历严格按照节点的深度来访问，会使用到队列。

    ```c++
    template<typename T, typename VST>
    void travel(BinNode* x, VST& visit){
        Queue<BinNode*>  Q;
        Q.enqueue(x); //先将根节点入队。
        while(!(Q.empty)){
            x = Q.dequeue();
            visit(x->data); //访问当前节点。
            if(HasLChild(*x)) Q.enqueue(x->lChild); //左孩子入队。
            if(HasRChild(*x)) Q.enqueue(x->rChild); //右孩子入队。
        }
        return;
    }
    ```

31. 二叉树的重构，就是通过遍历序列来反向构造出对应的二叉树。中序遍历加上先序/后序中的一个即可。通过先/后序遍历序列，可以获得当前子树的根节点，然后再中序遍历序列中寻找对应的节点，就可以将序列切分开，进而知道左右子树分别对应于那一部分。

32. ![image-20210830110936603](数据结构.assets/image-20210830110936603.png)

33. 对于真二叉树（每个节点的度都是偶数），可以只用先序+后序遍历序列进行重构。L和R要么都存在要么都不存在。

34. ![image-20210830115435604](数据结构.assets/image-20210830115435604.png)
