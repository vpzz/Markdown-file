# 基础

1. 变量的分类，数字常量默认都是double类型，即使看上去是个整数，例如`A=10`。可以使用`class(obj)`或`whos obj`来获取变量的类型。

2. ![image-20220502210213475](Matlab.assets/image-20220502210213475.png)

3. 逻辑类型的变量只有2个取值，true或false，数值表示分别为1和0。

4. 可以保存工作区，以便后续使用，格式可以是.mat（二进制数据）或.m（命令格式的文本）。

   ```matlab
   %也可以使用save指令来完成该操作
   save xx.mat  %默认为二进制格式
   save xx.mat --ascii  %保存为文本格式，此时就无法再导入进matlab了，因为文本中只有值，而没有数据的结构了。
   load('xx.mat')  %从.mat文件导入变量到工作空间，相当于在matlab中右键→加载。而在matlab中右键→导入可以选择导入一部分变量。
   ```

5. 可以使用xlsread和xlswrite来读写excel文件。可以使用writematrix将矩阵写入到csv格式的文件。可以使用导入工具来将外部数据导入到matlab中，可以将该导入动作保存为函数，脚本等，方便后续调用。默认导入为表格，可以变为数值矩阵。

6. matlab界面左侧是当前目录，其中亮色的目录是指该目录包含在软件的path中。右键可以将一个目录或其所有子目录都包含到path中。

7. log是自然对数函数，log10是以10为底，log2是以2为底。

8. matlab是弱类型的语言，使用变量前不需要声明类型。变量名区分大小写，变量名不能以数字开头。

9. 特殊的变量和常量：

   1. ans：answer的缩写，如果计算结果没有显式指定给某个变量的话，默认会存储到这里。
   2. i，j：虚数单位。
   3. inf或Inf：无穷大，例如`x=1/0`，`inf*-1`结果为`-inf`。可以使用`isinf`判断。
   4. eps：2.2204e-16，一般用来作为浮点数相等的界限。
   5. NaN或nan：not a number，例如`x=inf/inf`，`inf-inf`，值不确定。可以使用`isnan`判断。
   6. pi：圆周率的精确值。如果要输入$\pi$，则可以使用`\pi`。例如`xlabel('xx \pi')`。

10. 名称的优先级从高到低分别为：变量，内置函数，子函数，私有函数（MEX文件，P文件，M文件）。

11. 输入iskeyword命令来查看所有的关键字，变量名要避开这些关键字。matlab的函数调用和数字索引都是使用`()`。使用clear x将变量x从工作空间删除，不加变量名会清空整个工作空间。

    ```matlab
    >> cos(8)
    ans = -0.1455
    cos = 'This string'  %会覆盖内置的cos函数。
    >> cos(8)    %表示获取字符串的第8个字符,下标从1开始。
    ans = r
    >> clear cos  %清理用户定义的名字，恢复系统默认的
    >> cos(8)
    ans = -0.1455
    ```

12. 数据类型转换，并不会改变原来变量的类型：

    ```matlab
    double()  %转化为double类型
    single()  %单精度，也就是float
    int8()
    int16()
    int32()
    int64()
    uint8()
    uint16()
    uint32()
    uint64()
    ```

13. matlab有两种字符串类型，一个是由char拼成的字符数组（用单引号包裹起来），一个是字符串string类型（用双引号包裹起来）。前者可以像数组一样进行自由拼接，后者不可以，因此推荐使用前者。

    ```matlab
    >> a = 'a';  %1x1的char类型，一共2个字节。
    >> str1 = 'abc'; %1x3的char类型，一共6个字节。
    >> str2 = "bcd";  %1x1的string类型，150个字节，这并不是表示每个字符占用50个字节，而是默认申请150个字节的长度。
    >> whos
      Name      Size            Bytes  Class     Attributes
      a         1x1                 2  char                
      str1      1x3                 6  char                
      str2      1x1               150  string
    %转化为数字
    >> uint8("def");  %会报错，无法从string转换为uint8或16。
    >> uint8('abc');  %结果为1x3的uint8类型，[97 98 99]。
    %字符数组拼接
    >> ['as' 'de'] %水平拼接，结果为1x4的char类型，'asde'。
    >> "as"+"de" %水平拼接，结果为1x1的string类型，"asde"。
    >> ["as" "de"]  %矩阵形式的水平拼接,结果为1x2的string类型，即字符串构成的矩阵。此时ans(1)为"as"，ans(2)为"de"。
    >> ['asf';'dem']  %竖向拼接，结果为的2x3char类型。要进行竖向拼接的2个数组的维度必须一致，否则会报错。
    >> ["as";"de"]  %竖向拼接,结果为2x1的string类型，字符串矩阵。
    %字符数组索引
    >> x="abcd";x(2);  %不可以将string字符串当作字符向量来看到，用索引来取元素，会报错。
    >> y='abcd';y(2);  %结果为'b'。
    %字符数组比较
    >> 'a' == 'abada';  %相当于用'a'和字符串的每个字符去比较，结果为逻辑数组[1 0 1 0 1]。
    >> x='abada';x(x == 'a') = 't';  %会将x中的'a'替换为't'
    >> "ab" == "abada"; %会报错，提示数组的大小不兼容。
    >> strcmp("ab","bc");  %结果为false，比较两个字符串是否完全相等。
    ```

14. 字符串和字符数组相互转化：

    ```matlab
    >> char("abc")   %结果为'abc'
    >> string('ab')  %结果为"ab"
    ```

15. 字符串和数字的转换函数：

    ```matlab
    >> num2str(1.5)    %将数字转换为字符数组，结果为'1.5'
    >> str2num("2.5")  %将字符数组转换为数字，结果为2.500000000000000
    ```

16. 结构体struct类型。

    ```matlab
    %student是一个1x1的struct，也就是结构体数组，包含3个字段。
    student.name = 'john joe';
    student.id = 2;
    student.grade = [80,68,90];
    >> student
    student = 
      包含以下字段的 struct:
         name: 'john joe'
           id: 2
        grade: [80 68 90]
    %向结构体数组中添加结构体
    student(2).name = "zj"; %没有提供的字段会为默认值
    ```

17. 也可以使用struct函数来创建结构体：

    ```matlab
    >> a = struct('f1','a','f2',[]) %键值对形式
    a = 
      包含以下字段的 struct:
        f1: 'a'
        f2: []
    ```

18. 结构体可以嵌套存在：

    ```matlab
    student.name = 'zj';
    student.grade = struct('math',80,'englist',75);
    ```

19. 结构体字段相关的函数：

    ```matlab
    cell2struct %将cell数组转化为struct数组
    struct2cell %将struct数组转化为cell数组
    fieldnames  %获取结构体的字段名
    getfield(S,field) %返回结构体S的指定字段中的值。如果S.a=1，则getfield(S,'a')返回1。
    isfield(S,field)  %如果field是结构体S的一个字段的名称，则返回1。否则将返回0。
    isstruct(A) %如果A为结构体，则返回逻辑值1，否则返回逻辑值0。
    orderfields(S) %按名称对S中的字段排序，然后输出。
    rmfield(s,field) %从结构体数组s中删除指定的一个或多个字段。
    setfield(S,field,value) %为结构体S的指定字段赋值。setfield(S,'a',1)相当于S.a = 1。
    structfun(func,S) %将函数func应用于标量结构体S的每个字段，每次一个字段。然后将func的输出串联成列向量。
    ```

20. cell array（元胞数组），类似于矩阵，但是每个元素的类型可以不同，定义时它的元素都要使用`{ }`包括起来，或者将索引用`{ }`包括起来，此时等号右侧就不用`{ }`包括了，推荐使用后者。matlab内部是存储每个元素的指针，因此cell可以看作是指针数组。

    ```matlab
    >> A(1,1) = {[1 2 3]};
    >> A(1,2) = {3+5i};
    A =
      1×2 cell 数组
        {[1 2 3]}    {[3.000000000000000 + 5.000000000000000i]}
    >> A{2,1} = 'abc';
    A =
      2×2 cell 数组
        {[1 2 3]}    {[3.000000000000000 + 5.000000000000000i]}
        {'abc'  }    {0×0 double                              }
    ```

21. 获取元素时，也有两种方式，`( )`和`{ }`，前者结果是1x1的cell，后者结果就是cell内的数据类型，也推荐使用后者。

    ```matlab
    >> A(1,1)  %结果为1×1的cell数组，{[1 2 3]}。
    >> A{1,1}  %结果为1x3的double数组，[1 2 3]。
    ```

22. 创建元胞数组的其他方式：

    ```matlab
    >> C = {1 2 3;'text' rand(5,10,2) {11; 22; 33}}; %只是将数组的[]变成了{}
    C =
      2×3 cell 数组
        {[   1]}    {[          2]}    {[     3]}
        {'text'}    {5×10×2 double}    {3×1 cell}
    ```

23. 矩阵分块的方法：

    ```matlab
    A = magic(3); %A是一个3x3的矩阵
    C = mat2cell(A,[1 1 1],[1 2]); %行按照1 1 1分开，列按照1 2分开。
    C =
      3×2 cell 数组
        {[8]}    {[1 6]}
        {[3]}    {[5 7]}
        {[4]}    {[9 2]}
    ```

24. 高维数组：

    ```matlab
    >> A = rand(2,2,2); %三个维度分别为row,column,page（类似于书籍中的书页一样堆叠）。
    >> A
    A(:,:,1) =  %第1页
       0.644318130193692   0.811580458282477
       0.378609382660268   0.532825588799455
    A(:,:,2) =  %第2页
       0.350727103576883   0.875942811492984
       0.939001561999887   0.550156342898422
    ```

25. 可以沿不同的维度对矩阵进行拼接（concatenation）：

    ```matlab
    A = [1 2;3 4];
    B = [5 6;7 8];
    vert = cat(1,A,B) %沿着第1维度进行拼接，相当于[A;B]
    horz = cat(2,A,B) %沿着第2维度进行拼接，相当于[A B]
    layr = cat(3,A,B) %没有以上简便的方法
    %结果
    vert =
         1     2
         3     4
         5     6
         7     8
    horz =
         1     2     5     6
         3     4     7     8
    layr(:,:,1) =
         1     2
         3     4
    layr(:,:,2) =
         5     6
         7     8
    ```

26. reshape可以在不改变数组数据的前提下，改变其结构形式：

    ```matlab
    A = [1 2;3 4];
    >> reshape(A,1,4) %结果为[1 3 2 4]，因为矩阵在内存中是按列存储的。
    ```

27. format指令控制数字的显示样式，不加任何参数就是默认的short，这可以在设置中设置。

    ```matlab
    >> pi
    ans = 3.1416
    >>  pi-3.1416
    ans = -7.3464e-06  %可以证明pi的实际值3.1416，只是显示为3.1416
    >> format long     %双精度浮点数
    >> pi
    ans = 3.141592653589793
    >> format shortE       %单精度科学计数法
    >> pi
    ans = 3.1416e+00
    >> format longE        %双精度科学计数法
    >> pi
    ans = 3.141592653589793e+00
    >> format hex          %16进制显示
    >> pi
    ans = 400921fb54442d18
    >> format rat          %将结果有理数显示
    >> pi
    ans = 355/113
    >> 3/13
    ans = 3/13
    ```

28. 语句最后如果没有分号，会将结果输出到界面上，不过并不会影响是否赋值给ans。

    ```matlab
    >> 3
    ans = 3
    >> 5;
    >> 3+5
    ans = 8
    >> 3+6;    %仍会将计算结果赋值给ans
    >> ans
    ans = 9
    ```

29. 常用命令：

    ```matlab
    clc  %清理屏幕的输出,快捷键为Ctrl+L
    clear %清理工作空间的所有变量
    who   %列出工作空间的所有变量
    whos  %列出工作空间的所有变量的详细信息
    %%%%%%%%%%%%%
    >> a=1.5
    a =
         1.500000000000000e+00
    >> b=int8(a)
    b =
      int8
       2
    >> whos
      Name      Size            Bytes  Class     Attributes
      a         1x1                 8  double              
      b         1x1                 1  int8   
    ```

30. 可以使用disp函数在命令行输出变量，类似于C语言的printf，matlab的print是打印图窗或保存为特定文件格式。

31. `rand`的底层数字生成器是一个伪随机数生成器，它创建一个看似随机的确定性数字序列。如果已知种子和生成器的算法，则可以完全推断出整个序列。虽然生成的数字不是真正随机的，但它通过了各种随机性的统计测试，满足独立同分布(i.i.d)条件，并且证明伪随机名称的合理性。

32. 可以在每次使用随机数前都执行`rng default`，这样可以确保每次执行的随机数序列相同。

# 向量和矩阵

1. matlab会将常量和向量都当作矩阵，而不是单独的类型。

2. 向量，下标默认从1开始。对行列向量都可以使用`( )`来选取元素。

   ```matlab
   a = [1 2 3 4]    %行向量 维度为1x4。也可以用逗号分隔 [1,2,3,4]
   b = [1; 2; 3; 4] %列向量 维度为4x1
   ̃>> a*b  %将向量当作矩阵来计算乘法
   ans = 30  %结果为1x1的矩阵，就是一个数
   >> b*a  %结果为4x4的矩阵
   ans =
       1    2    3    4
       2    4    6    8
       3    6    9   12
       4    8   12   16
   ```

3. 矩阵：

   ```matlab
   >> a = [1 2 3;4 5 6;7 8 9]
   a =
      1   2   3
      4   5   6
      7   8   9
   ```

4. Matlab用（）来做向量和矩阵的索引。认为矩阵是按列存储的，虽然最常用的矩阵赋值是按行赋予的。

   ```matlab
   >> a = [1 2 3;4 5 6;7 8 9]
   a =
      1   2   3
      4   5   6
      7   8   9
   >> a(4)     %将矩阵划分为列向量组，从左到右拼接成一个列向量，再做索引。这称为线性索引Linear index。可以使用sub2ind和ind2sub，在线性索引和下标之间转换。
   ans = 2
   a(2,3)     %第2行，第3列的元素
   ans = 6
   >> a([1 2 5]) %等价于从列向量组拼成的向量中取出3个数。
   ans =
      1   4   5
   %%% 以下可以从括号内是一个量还是由逗号分隔的2个量来区分，前者的话就是从列向量组中取值，后者就是从矩阵中取值。
   >> a([1 3],[1 3])  %按照[1 3],[1 3]的方式取出子矩阵，也就是网格形式，可以看作是a(2,3)的扩展，行和列的索引都变成了向量。这里不能将[1 3],[1 3]看作两个行向量的水平拼接，因为这里的逗号是用作索引的区分。
   ans =
      1   3
      7   9
   >> a([[1 3],[1 3]]) %等价于a([1 3 1 3])
   ans =
      1   7   1   7
   >> a([1 2;3 4])  %从列向量组拼成的向量中，依次取出[1 2;3 4]，放在对应的位置，组成一个二阶矩阵，相当于 [a(1) a(2);a(3) a(4)]，也就是[1 4;7 2]。
   ans =
      1   4
      7   2
   %%%%%%%%%
   >> b(1)=1; %可以不用声明b是一个向量，可以直接写入
   >> b(3)=3; %间隔写入，会导致中间的都被写入为0
   >> b(2)
   ans = 0
   >> b(4)    %没有声明不能直接读取
   error: b(4): out of bound 3 (dimensions are 1x3)
   ```

5. 索引也可以是logical的向量

   ```matlab
   >> a = [1 2 3 4 ];
   >>  a(logical([1 0 1]))  %按照下标的逻辑值取出向量的元素，构成新的向量，索引必须为logical的向量。
   ans =
      1   3
   >> a(a == 2) =6     %将向量a中等于2的元素都赋值为6
   a =
      1   6   3   4
   ```

6. matlab的语法设计不允许直接对函数的返回结果进行索引（除非该函数返回的是一个可索引的对象，如`struct`或`cell`）。这与Python或Julia不同。需要用一个临时的中间变量承接以下结果，然后再索引。

7. 为数组预先分配内存会提高速度：

   ```matlab
   %没有为数组预先分配内存
   tic  %计时开始
   for i=1:2000
     for j=1:2000
       A(i,j) = i+j;
     end
   end
   toc  %计时结束 Elapsed time is 2.016782 seconds.
   %为数组预先分配内存
   tic
   A = zeros(2000);
   for i=1:2000
     for j=1:2000
       A(i,j) = i+j;
     end
   end
   toc  %Elapsed time is 0.030410 seconds.
   ```

8. 冒号运算符，用来生成等比数列的向量，默认公差为1。在作为索引时，还表示全部行或列的意思。

   ```matlab
   a = [1:5]   %等价于a = [1 2 3 4 5]。也可以省略中括号写作a = 1:5
   a = [1:2:5] %等价于[1 3 5]
   a = [1:2:4] %结果为[1 3]
   >> a = [1:3;2:4]
   a =
      1   2   3
      2   3   4
   >> a(1,:)     %获取矩阵a的第一行和所有列构成的子矩阵。
   ans =
      1   2   3
   >> a(:,[1 3]) %获取矩阵的第1和3列构成的子矩阵。
   ans =
      1   3
      2   4
   >> linspace (1,5,3)  %将区间[1,5]做3-1等分，结果有3个点，包括起止点。结果存储在一个行向量中，第三个参数默认为100，即分为99份。
   ans =
      1   3   5
   ```

9. 矩阵的拼接，类似于分块矩阵。

   ```matlab
   >> A = [1 2; 3 4];     %也可以看作为两个行向量的竖向拼接
   >> A = [[1;3] [2;4]];  %也可以用列向量水平拼接来构造矩阵
   >> B = [5 6;7 8];
   >> C = [A B]   %水平拼接
   C =
      1   2   5   6
      3   4   7   8
   >> D = [A;B]   %竖向拼接
   D =
      1   2
      3   4
      5   6
      7   8
   >> C = [A zeros(2);zeros(2) B] %对角拼接
   C =
        1     2     0     0
        3     4     0     0
        0     0     5     6
        0     0     7     8
   ```

10. 矩阵的重复：

   ```matlab
   >> repmat([1 -2 1],1,4)
   ans =
        1    -2     1     1    -2     1     1    -2     1     1    -2     1
   >> repmat([1 -2 1]',1,4)
   ans =
        1     1     1     1
       -2    -2    -2    -2
        1     1     1     1
   >> repmat([1 -2 1],4,1)
   ans =
        1    -2     1
        1    -2     1
        1    -2     1
        1    -2     1
   >> repmat([1 -2 1]',4,1)
   ans =
        1
       -2
        1
        1
       -2
        1
        1
       -2
        1
        1
       -2
        1
   ```

11. 删除矩阵的某些行或列：

    ```matlab
    A = [1 2 3; 0 5 6;7 0 9];
    A([1 2],:)=[]; %删除A的第1，2行。
    >> A
    A =
         7     0     9
    ```

12. 四则运算，默认进行的是矩阵的乘除法，加点才会进行元素的运算。

    ```matlab
    >> A = [1 2; 3 4];
    >> B = [5 6;7 8];
    >> c = 2;
    >> A+B ;A-B;  %对应的元素相加减
    >> A*B        %矩阵的乘法，要求第一个矩阵的列数=第二个矩阵的行数
    ans =
       19   22
       43   50
    >> A/B       %也就是A*B^(-1),是矩阵方程CB=A的解
    ans =
       3  -2
       2  -1
    >> A.*B     %对应元素相乘，要求两个矩阵的行列数相同
    ans =
        5   12
       21   32
    >> A./B    %对应元素相除
    ans =
       0.2000   0.3333
       0.4286   0.5000
    >> A+c     %矩阵和数运算，就是将改数依次和每个元素进行相同的运算。
    ans =
       3   4
       5   6
    %A*c和A.*c是相同的结果。
    >> A^c   %等价于c个矩阵连乘，例如A^3为A*A*A  只有A是方阵,才有意义
    ans =
        7   10
       15   22
    >> A.^c   %每个元素都进行乘方运算，A的形状任意
    ans =
        1    4
        9   16
    >> A'    %矩阵的共轭转置，也适用于行列向量，等价于ctranspose(A)。可以使用A.'来执行仅转置，不共轭，等价于transpose(A)。
    ans =
       1   3
       2   4
    ```

13. 特殊的矩阵：

    ```matlab
    eye(3)     %3阶单位矩阵,eye(2,4)为2行4列的单位矩阵，多余的行或列全为0。
    zeros(3,4) %3行4列的零矩阵,zeros(3)为3阶零矩阵。
    ones(2,4)  %2行4列的全为1的矩阵。ones(3)为3阶全为1的矩阵
    diag([1 2 3 4])  %对角矩阵，只有对角线非零，对角线元素依次为1 2 3 4。该函数还可以获取任意矩阵的对角线向量。
    rand(3)    %3阶均匀分布的随机矩阵，取值范围为0到1。rand(2,3)为2行3列的均匀分布的随机矩阵
    ```

14. 矩阵相关的函数，下面的所有操作都不改变矩阵本身：

    ```matlab
    >> A = [1 2 3; 0 5 6;7 0 9]
    A =
       1   2   3
       0   5   6
       7   0   9
    >> max(A)    %相当于对矩阵的列向量组执行max函数。找出每一列的最大值。如果要求每一行的最大值，可以用max(A')，结果都是1x3的向量。如果要找整个矩阵的最大值，可以嵌套max(max(A))。
    ans =
       7   5   9
    >> sum(A)    %对每一列求和
    ans =
        8    7   18
    >> mean(A)   %对每一列求平均值
    ans =
       2.6667   2.3333   6.0000
    >> prod([1 2 3]) %连乘，可以用来计算阶乘。
    ans =
         6
    >> sort(A)   %对每一列单独进行排序,从小到大
    ans =
       0   0   3
       1   2   6
       7   5   9
    >> sortrows (A, 2)  %按照第2列升序排序,整行联动。第二个参数，默认为1
    ans =
       7   0   9
       1   2   3
       0   5   6
    >> sortrows (A, -2) %按照第2列降序排序,整行联动
    ans =
       0   5   6
       1   2   3
       7   0   9
    >> size(A) %获取A的维度，结果为一个行向量[3 3]。size(A(:,1))结果为[3 1]。
    ans =
       3   3
    >> length([1 2 3]) %专门用来获取向量的长度，结果为一个整数。如果对矩阵使用，则结果为行或列的最大值。
    ans = 3
    >> size([1 2 3])  %用size也可以获取向量的维度，不过会当作矩阵来处理，某一个方向的维度为1。
    ans =
       1   3
    >>  find(A == 0)  %查找元素等于0的那个索引,也就是说A(2)和A(6)等于3。实际上A==0的结果是一个和A同维度的逻辑量矩阵，等于0的位置为真，也就是1，反之为假，也就是0。
    ans = 7
    ```


# 结构化程序

1. 脚本需要先存储为.m文件才可以运行，文件名不能以数字开头，大小写有区别，类似于变量名。脚本文件中的每一行都建议用；结尾，这样可以只输出想要输出的。

2. 需要将.m文件存储到path包含的路径或当前目录中，才可以在命令行直接输入文件名来执行该脚本。

3. %之后的内容为单行注释，两个%%中间的为一个section，代码块。也可以通过插入分节符来完成，可以单独运行一节。如果不想保存文件的同时运行代码，可以点击运行节。%%后面也可以添加注释。

4. 只有保存文件后，才可以在文件中打断点进行调试。调试过程中，命令行输出界面的`>>`变为`K>>`，此时也是可以继续在此执行命令的。

5. matlab可以设置条件断点或暂时禁用断点。还可以设置出现NaN或Inf，警告或错误时暂停执行当前脚本。

6. matlab的缩进是非必须的，可以全选使用智能缩进。

7. 流程控制语句，if，while，for都必须用end结尾，条件部分都不用加分号，语句可以加可不加，会影响输出。

   ```matlab
   if 条件1        %条件不需要加括号等，esleif和else都可以省略
   	语句1
   elseif 条件2  %可以有多个
   	语句2
   else          %只能有一个，而且没有条件，执行到此时，会无条件进入
   	语句3
   end   %不能省略
   %%
   switch 表达式    %表达式的结果是一个数
   case 值1         %可以有多个
   	语句1
   otherwise     %只能有一个，如果以上都不满足，最终会执行到这里，类似于if中的else
   	语句n
   end
   %%
   while 表达式    %先判断表达式，为真的话执行语句，然后再判断表达式，循环往复。
   	语句
   	if a > 3
   		break     %终止本层循环
   		continue  %跳过本次循环中未执行的代码
   	end
   end
   %%
   for 变量=起点:增量:终点
   	语句
   end
   ```

8. 关系运算符，结果为logical类型的，1表示真，0表示假：

   ```matlab
   <  % 小于
   <= % 小于等于
   >  % 大于
   >= % 大于等于
   == % 是否相等
   ~= % 是否不相等
   && % 逻辑与
   || % 逻辑或
   ~  %逻辑非
   ```

9. 部分符号和数字之间必须有空格，建议都加上空格。

   ```matlab
   >> a += 1;
   >> a +=1;   %会报错
   error: a used as variable and later as function
   ```

10. 脚本的开头建议执行一下几条语句：

    ```matlab
    clear all   %清理所有的变量
    close all   %关闭所有的图片
    clc         %清理显示终端
    ```

11. 有时一行不够书写时，可以使用`...`来续行。在脚本和命令行中都可以使用。

12. 如果左下角显示Busy或正忙，则表示当前程序正在执行，还没有返回。可以按Ctrl+C强制终止。

13. 函数和脚本类似，不过脚本没有输入参数和输出结果，脚本的所有的变量都是在全局空间中的，而函数都是在局部空间内。

14. 函数的定义需要保存到单独的和函数名相同文件中，文件需要放在matlab的路径下，才能搜索到，所有的输入和输出都是可选的，调用时不检查参数：

    ```matlab
    function y = mean(x,dim,flag)      %定义函数,接受3个参数,将y作为输出返回,最后可以没有end，如果没有的话，就表示到文件结尾都是函数的范围。因此建议加上end，这样可以在一个文件中定义多个函数。
    function [y,v] = mean(x,dim,flag)  %若要返回多个值，可以用向量包裹起来，
    [a b] = mean(1,2,3)                %调用的时候也用向量来接受
    ```

15. 同一个文件中，第一个定义的函数为全局函数（可以被外部直接调用），必须和文件名相同，后续函数都是局部函数，只能内部使用，且不能和全局函数重名。内部函数的出现是为了方便函数编写而拆分的。

    ```matlab
    % 文件名为test.m
    function y=test(x)
    y=test2(x); %调用局部函数
    end
    % 局部函数，
    function y=test2(x)
    y=x-3;
    end
    ```

16. 函数的实际参数个数不能大于形式参数个数，即可以省略参数，此时不报错。

17. 函数内会有一些默认的变量：

    ```matlab
    inputname(argNumber) %返回与参数编号argNumber对应的工作区变量名称。如果参数是常量，则函数范围空字符串。
    mfilename  %当前函数所在的m文件的名称，不包括.m
    nargin     %实际输入参数的个数，而非函数定义中的形参个数。
    nargout    %实际输出参数的个数，这个和调用函数时使用了几个参数来接受有关，而非函数定义中的输出个数。有些函数会根据用户调用时的输入参数和输出参数的数量，进行不同的操作，返回不同的结果。
    %例如test(5,6)，nargin为2，nargout为0。
    varargin   %输入参数的维度
    varargout  %输出参数的维度
    ```

18. 函数句柄，也就是匿名函数，内置函数也可以作为参数传递给需要句柄的函数中，不过前面要加上@，例如@mean。

    ```matlab
    f = @(x) exp(-2*x);   %x是输入变量，后面是函数体。f是function handle类型的，会作为一个变量出现在工作空间中，优先级比文件中的函数高。
    x=3;
    f(x) %结果为0.002478752176666
    ```

19. which函数可以定位函数和文件的完整路径。

    ```matlab
    >> which("mean.m")
    D:\Program Files\MATLAB\R2023b\toolbox\matlab\datafun\mean.m
    ```

20. matlab中函数的调用：

    ```matlab
    which("mean.m")  %等价于 which mean.m，后者不用加引号，不过不是所有函数都支持后者的方式。
    ```

21. 元胞数组展开为函数的参数：

    ```matlab
    function z=test(x,y)
    	z=x+y;
    end
    a = [1 3]
    test(a(1), a(2)); %正常调用方式
    b = num2cell(a); %转化为元胞数组
    test(b{:}) %将元胞数组展开，也可以调用成功
    ```

# 绘图

1. matlab无法直接绘制函数图，只能人工离散化后再进行绘制。
2. 一个图窗包含多个对象，Figure对象（也就是背景布），Axes对象（坐标系统），Line对象（曲线），前者包含后者。Axes中除了包含曲线外，还可以包含Legend图例，Text文本，Surface曲面等。
3. `plot(x,y)`，要求1维数组x和y的大小相同，行或列向量无所谓。如果省略x则，会用`[1:n]`替代，其中`n=length(y)`。
4. 如果当前没有图窗，则会创建一个新的图窗用于绘制。默认情况下，新的plot会顶替掉旧的。
5. 使用`hold on`可以在同一个图窗上绘制多个曲线。

   ```matlab
   figure;
   hold on %这个hold on也可以放在第一个plot函数之后
   plot(cos(0:pi/20:2*pi));
   plot(sin(0:pi/20:2*pi));
   hold off
   ```
6. plot的第三个参数用于设置点的形式和颜色，线的形式和颜色。
7. 一个plot命令中也可以绘制多条曲线：

   ```matlab
   plot(0:pi/20:2*pi,cos(0:pi/20:2*pi),0:pi/20:2*pi,sin(0:pi/20:2*pi)) %注意这里不能省略x，否则第1个y会被当作x。
   ```
8. 使用`legend("cos(x)","sin(x)")`来按顺序设置图例，`title("图名")`添加图名，`xlabel("x轴")`添加xyz轴的标题。这里都支持latex的语法。
9. 绘制线段：

   ```matlab
   line([2,2],[2,5]);  %绘制一个，这个不需要hold on，也不会顶替当前图。
   ```
10. 向图中添加文字标注和箭头指向：

    ```matlab
    str = '$$\int_0^{2\pi}x^2dx$$'; %构造内容
    text(2.5,2,str,'interpreter','latex'); %前两个参数是位置，使用坐标轴的度量，第4和5个参数是设置属性，表示使用latex来作为解释器。
    annotation('arrow','X',[0.32 0.5],'Y',[0.6 0.4]); %设置箭头形式，起始点坐标为(0.32,0.6)，终点坐标为(0.5,0.4)，注意这里的坐标是图形的百分比，而非坐标轴的绝对值。
    ```
11. 可以使用如下函数操作图窗及其子对象：

    ```matlab
    f1 = figure; %该命令会创建一个新的图窗，使用变量f1保存。
    gcf  %返回当前图窗的句柄。如果图窗不存在，则gcf将创建一个图窗并返回其句柄。
    gca  %返回当前figure中的当前axes（或独立可视化）。如果当前图窗中没有坐标区或图，则gca会创建一个笛卡尔坐标区对象。
    child_handles = allchild(handle_list) %为每个句柄返回所有子对象的列表（包括具有隐藏句柄的子级）。如果handle_list为单个元素，则allchild以向量返回该输出。
    p = ancestor(h,type) %如果前代是type指定的图形对象类型之一，则返回h的最近前代的句柄。type可以是{'figure','axes'}。
    delete(obj) %删除指定的对象。如果 obj 是数组，则 delete 将删除数组中的所有对象。
    h = findall(objhandles) %返回objhandles中的图形对象及其所有后代。
    ```
12. 使用get和set函数来获取和设置对象的属性，注意get和set的属性名不区分大小写，而使用点获取属性需要区分大小写。

    ```matlab
    s = plot([1 2 3]);
    get(s,"color") %返回[0 1 0]
    set(s,"Color",[1 0 0]) %设置颜色为红色，等价于s.color = [1 0 0]
    ```
13. tick为坐标轴上的tick的数值，必须是一个数值数组，ticklabel为对应tick处显示的文本（可以使用latex语法），可以和tick相同，也可以不同。
14. 使用subplot为图窗添加多个axes，也就是绘制子图。

    ```matlab
    %切换到子图中，如果没有则创建。
    subplot(1,2,1); plot([1 2 3]); %1行2列，1表示第1个，按行索引。
    subplot(1,2,2); plot([4 5 6]); %1行2列，2表示第2个。
    ```
15. 如果有多个figure，gcf和gca都是最后产生的figure。
16. `axis equal`，可以设置两个坐标轴的实际像素占比相同。
17. ![image-20250404135756470](Matlab.assets/image-20250404135756470.png)
18. `axis off`，`box off`，`grid off`可以分别关闭坐标轴，框线和格线。
19. 可以使用saveas或print（可以控制大小和解析度）来保存图片，可以是位图或矢量格式。
20. `semilogx，semilogy，loglog`函数可以绘制单对数或双对数曲线图。
21. `plotyy(x,y1,x,y2)`可以绘制双y轴曲线，二者共用1个x轴。
22. `polar(theta,r)`函数可以根据极坐标来绘制图形。
23. `errorbar(x,y,e)`函数可以绘制带误差棒的曲线。
24. `fill`函数可以填充封闭的曲线。
25. matlab使用一个包含三个元素的数组来表示颜色，`[0 255 0]`表示绿色。
26. 可以将一个三维的图的第三维度变成颜色，绘制在平面上，也就是云图效果。

    ```matlab
    [x y] = meshgrid(-3:0.2:3, -3:0.2:3); %30x30的网格
    z = x.^2+x.*y+y.^2;
    surf(x,y,z); box on;
    imagesc(z); %将数组z中的数据显示为一个图像，该图像使用颜色图中的全部颜色。z的每个元素指定图像的一个像素的颜色。生成的图像是一个m×n像素网格，其中m和n分别是z的行列数。这些元素的行索引和列索引确定了对应像素的中心。
    ```
27. ![image-20250404141735058](Matlab.assets/image-20250404141735058.png)
28. `colorbar`可以显示颜色栏（可以在图窗上的工具栏手动添加），类似于云图的图例。还可以使用`colormap`函数来指定图例的颜色过度类型。
29. 3维绘图函数，实际上plot绘制的图也是3维的，不过z轴取值都是0，可以通过旋转图像发现。

    ```matlab
    plot3(x,y,z)   %3D空间的曲线图，其中x,y,z分别为一维数组，长度为曲线的点数。
    surf(x,y,z)    %3D空间的曲面图，其中x,y,z都是二维数组。
    surface(x,y,z) %
    mesh(x,y,z)    %和surf类似，不过不填充网格小面。
    contour(x,y,z) %等高线彩色图(不填充)，可以控制等高线的间隔。
    contourf(x,y,z)%填充的等高线彩色图
    surfc(x,y,z)   %就是surf和contour的组合，会在底部z平面绘制等高线图。
    meshc(x,y,z)   %就是mesh和contour的组合，会在底部z平面绘制等高线图。
    ```
30. 使用meshgrid生成坐标网格

    ```matlab
    [x y] = meshgrid(-2:1:2, 2:1:5);  %创建曲面图所需的网格。第一个参数是x轴范围，第二个是y轴范围。
    %两个矩阵都是4x5的
    x = %将-2:1:2=[-2 -1 0 1 2]向下扩展
        -2    -1     0     1     2
        -2    -1     0     1     2
        -2    -1     0     1     2
        -2    -1     0     1     2
    y = %将(2:1:5)'=[2 3 4 5]'向右扩展
         2     2     2     2     2
         3     3     3     3     3
         4     4     4     4     4
         5     5     5     5     5
    ```
31. 例子：

    ```matlab
    >> [x y] = meshgrid(-3.5:0.2:3.5, -3.5:0.2:3.5);
    >> z = x.*exp(-x.^2-y.^2);
    >> subplot(2,2,1); mesh(x,y,z);
    >> subplot(2,2,2); surf(x,y,z);
    >> subplot(2,2,3); contour(x,y,z); 
    >> subplot(2,2,4); surfc(x,y,z);
    ```
32. <img src="Matlab.assets/image-20250405011505927.png" alt="image-20250405011505927" style="zoom:67%;" />
33. `view(Azimuth, Elevation)`可以为当前坐标区设置相机视线的方位角和仰角，角度单位。`view(2)`可以按俯视角度观察，此时相当于`view(0,90)`。使用工具旋转时，图窗左下角也会显示这两个参数。
34. ![image-20250405010934302](Matlab.assets/image-20250405010934302.png)
35. light函数可以设置光源位置，等属性。一个图窗可以有多个光源。
36. `patch(X,Y,C)` 可以创建一个或多个彩色多边形补片，也就是小面。

# 符号运算

1. 符号计算可以含有未定义的符号变量，计算结果是精确的，运行速度稍慢，数值计算的结果是有限精度的。符号运算可以用于公式推导。数值计算中必须先对变量进行赋值，然后才能参与运算。符号变量可以赋值，也可以不赋值。

2. 数值计算在处理病态问题时，收敛慢且容易出错。符号运算可以给出精确结果，可以避免舍入误差。

3. Maple软件的符号计算功能比matlab要强。

4. 创建符号变量：

   ```matlab
   x = sym("x", set); %set为字符串类型，用于设置符号变量的取值约束，可以为positive，integer，rational，real或composite等。
   sym("x", "clear"); %清楚先前用set参数设置的符号变量var的约束。
   %
   y=sin(x); %定义一个依赖于符号变量的表达式，而非符号函数，因为此时x和y的函数关系是明确的。
   %可以同时创建多个同名的符号变量
   syms x a;  %相当于x=sym("x");x=sym("a");
   syms z(t); %定义1个符号变量t，和一个符号函数z，z是t的函数。
   syms x y z positive; %创建3个符号变量，并设置3个约束。
   ```

5. 推荐仅使用sym创建符号变量，然后再使用assume设置其约束。

   ```matlab
   assume(x,{'positive','integer'}); %正整数，第一个参数不应为字符串，而应该是符号变量，因为此时该符号变量已经创建了。
   assume(y<-1 | y>1); %或的关系
   assume(z>-1 & z<1); %且的关系
   assume(~in(y,'integer'));  %y不是整数
   assume(z/2, 'integer'); %z为偶数
   assume(z<x); %可以引用其他符号变量
   %可以输出符号变量的约束，默认输出所有的约束，也可以指定要查看的符号变量或表达式。
   >> assumptions
   ans =
   [in(x, 'integer'), 1 <= x] %2个，都是关于x的
   %对同一个符号变量的多个assume，后者会覆盖前者。可以使用assmueAlso来附加约束。
   >> assume(x<4)
   >> assume(x>1)
   >> assumptions
   ans =
   1 < x
   >> assumeAlso(x<6)
   >> assumptions
   ans =
   [1 < x, x < 6]
   ```

6. 可以保存假设，并再后期恢复假设：

   ```matlab
   syms x;
   assume(x<4);
   tmp = assumptions; %保存所有假设，也可以只保存指定符号变量的假设。tmp的类型也是符号变量。
   assume(tmp);%恢复tmp中保存的假设
   ```

7. 可以将数值转化为一个符号，这样可以保留精度来进行运算。

   ```matlab
   x = sym(2);
   x^0.01^100; %结果为2，如果x不是符号变量，则结果为2.000000000000015
   %推荐对子表达式定义符号变量，而非对整个表达式
   y= sym(1234567);
   z=1/y;  %而非z=sym(1/1234567)，因为后者会被当作7650239286923505/9444732965739290427392。
   z=sqrt(123456); %而非z=sym(sqrt(123456))，后者会被当作3090622161171759/8796093022208。
   ```

8. 创建符号矩阵

   ```matlab
   A = sym('A',[3,4],'positive'); %A为3行4列的矩阵，通过(m,n)来索引，而非Am_n。每个元素都是正数。
   A =
   [A1_1, A1_2, A1_3, A1_4]
   [A2_1, A2_2, A2_3, A2_4]
   [A3_1, A3_2, A3_3, A3_4]
   %也可以手动设置每项的格式
   B = sym('B%d%d',3) %3阶方阵
   B =
   [B11, B12, B13]
   [B21, B22, B23]
   [B31, B32, B33]
   ```

9. 从匿名函数句柄创建符号表达式：

   ```matlab
   fhandle1 = @(x) sin(x)+cos(x); %创建函数句柄
   sym_h = sym(fhandle1); %创建符号表达式
   ```

10. 可以用ezplot或ezmesh来根据符号变量绘制2D曲线或3D曲面。

11. 定义向量值函数：

    ```matlab
    syms x;
    f(x) = [x+1 x.^2];
    f(3)     %结果为[4 9]
    f([2 6 4]) %结果为1x2的cell数组，{[3    7    5]}    {[4    36    16]}
    ```

12. 查找符号表达式中的符号，像pi，i，j等这样的变量，不用定义，可以直接当作符号变量来使用。

    ```matlab
    symvar('cos(pi*x - beta1)')  %结果为2×1的cell数组{'beta1'} {'x'}。
    %symvar(expr) 搜索表达式 expr，查找除 i、j、pi、inf、nan、eps和公共函数之外的标识符。这些标识符是表达式中变量的名称。
    ```

13. 合并同类项，也就是归纳为变量的多项式：

    ```matlab
    syms x;
    f1 = (exp(x)+x)*(x+2);
    collect(f1);  %结果为x^2 + (exp(x) + 2)*x + 2*exp(x)。首先展开，然后按照x(如果不指定变量，默认为x)的幂次合并同类项。
    syms x y;
    f2 = x^2*y+y*x-x^2-2*x;
    collect(f2,x); %关于x合并，结果为(y - 1)*x^2 + (y - 2)*x。
    collect(f2,y); %对y进行合并，结果为(x^2 + x)*y - x^2 - 2*x。
    %可以指定对多个符号变量进行合并同类项，可以构成乘积项。
    syms a b x y;
    f3 = a^2*x*y+a*b*x^2+a*x*y+x^2;
    collect(f3,[x y]) %结果为(a*b + 1)*x^2 + (a^2 + a)*x*y
    ```

14. 展开符号表达式，操作对象可以是多项式，三角函数，指数函数等。

    ```matlab
    syms x y;
    f1 = sin(x+3*y);
    e1 = expand(f1) %结果为4*cos(y)^3*sin(x) - 3*cos(y)*sin(x) - cos(x)*sin(y) + 4*cos(x)*cos(y)^2*sin(y)
    %然后可以再对结果进行合并同类项
    collect(e1,cos(y)) %结果为4*sin(x)*cos(y)^3 + 4*cos(x)*sin(y)*cos(y)^2 + (-3*sin(x))*cos(y) - cos(x)*sin(y)
    collect(e1,'cos') %也可以对函数形式进行合并，结果为4*sin(y)*cos(x)*cos(y)^2 + (-sin(y))*cos(x) + 4*sin(x)*cos(y)^3 + (-3*sin(x))*cos(y)
    %多项式展开
    syms x y;
    f1 = (x+y)^3;
    expand(f1) %结果为x^3 + 3*x^2*y + 3*x*y^2 + y^3
    %可以设置只只进行算术（加减乘除，乘方，开方操作）展开
    syms x;
    f1 = (sin(3*x)+1)^2;
    expand(f1) %默认会展开3*x，结果为sin(x)^2 - 2*sin(x) + 8*cos(x)^2*sin(x) - 8*cos(x)^2*sin(x)^2 + 16*cos(x)^4*sin(x)^2 + 1
    >> expand(f1,"ArithmeticOnly",true) %结果为 2*sin(3*x) + sin(3*x)^2 + 1
    %忽略约束条件
    syms x y;
    f1 = log(x*y);
    expand(f1) %结果还是log(x*y)
    expand(f1,"IgnoreAnalyticConstraints",true) % log(x) + log(y)，这个展开只有在满足x和y均大于0时才有效。注意，这里不会自动为x,y加约束。
    ```

15. 将函数转化为嵌套表达式，多项式的嵌套格式会在计算是减少运算次数。秦九韶算法（也成为霍纳算法）。

    ```matlab
    syms x;
    f1 = expand((x+3)^3);
    horner(f1) %结果为x*(x*(x + 9) + 27) + 27
    ```

16. 因式分解：

    ```matlab
    factor(5*9*8*7); %结果为[2 2 2 3 3 5 7]
    factor(sym('1234567898765432')) %大数可以用字符串表示，转化为符号后，再进行因式分解。结果为[2, 2, 2, 7, 11, 73, 101, 109, 109, 137, 167]
    factor(sym(112/81)) %分数也可以，结果为[2, 2, 2, 2, 7, 1/3, 1/3, 1/3, 1/3]
    syms x;
    factor(4*x^3+x^4+8*x+5*x^2+6) %可以对符号表达式分解，结果为[x + 3, x + 1, x^2 + 2]
    %默认情况下，只对有理数进行因式分解，也可以指定参数
    syms x;
    factor(x^4 - 2*x^2 - 3, x) %默认结果为[x^2 - 3, x^2 + 1]
    factor(x^4 - 2*x^2 - 3, x,"FactorMode","real") %会将x^2-3进行分解，结果为[x - 1.7320508075688772935274463415059, x + 1.7320508075688772935274463415059, x^2 + 1.0]
    factor(x^4 - 2*x^2 - 3, x,"FactorMode","complex") %会将x^2+1进行分解，结果为[x + 1.7320508075688772935274463415059, x - 1.7320508075688772935274463415059, x + 1.0i, x - 1.0i]
    ```

17. 化简表达式，使用Maple中的化简方法。通常情况下，matlab输出的结果都是化简过的，再对其进行化简，效果不大。

    ```matlab
    syms x;
    simplify(sin(x)^2+cos(x)^2) %结果为1
    simplify((x^2+5*x+6)/(x+2)) %结果为x + 3
    ```

18. 符号表达式的替换

    ```matlab
    %将符号表达式中，重复出现的字符串替换为中间变量，以简化表达式。
    syms x;
    f1 = (x^2+1)/(x^2+3)+x^4;
    subexpr(f1,"beta") %结果为(beta + 1)/(beta + 3) + beta^2，其中beta = x^2。matlab会使用beta来表示中间变量，如果没有提供，则使用默认的sigma。
    %将符号表达式中的符号变量替换为具体的值或普通变量，也就是对符号表达式进行求值
    syms x;
    f1 = x^2;
    subs(f1,3) %结果为9，用3替换x。
    %将符号表达式中的符号变量替换为新的符号变量
    syms x t;
    f1 = x^2;
    f2 = subs(f1,x,t) %结果为t^2，注意，不会改变f1。
    ```

19. 将有理表达式转化为浮点数：

    ```matlab
    syms x;
    f = 1/3*sin(2*pi*x);
    s1 = subs(f,0.2) %结果为(2^(1/2)*(5^(1/2) + 5)^(1/2))/12
    vpa(s1) %结果为0.31701883876505119070547977779313
    vpa(s1, 15) %只保留8位有效数字，0.317018838765051。
    ```

20. 符号表达式的美化显示：

    ```matlab
    syms x;
    f1 = sin(x)+x^3+3*x+2;
    pretty(f1)
    %输出结果为
                    3
    3 x + sin(x) + x  + 2
    latex(f1) %结果为'3\,x+\sin\left(x\right)+x^3+2'
    ```

21. 对符号函数进行绘图，也可以直接对函数句柄进行绘制，而不用转化为符号表达式。

    ```matlab
    %ezplot和ezplot3分别进行2D和3D曲线的绘制，不过推荐使用fplot和fplot3替换二者。
    %ezmesh和ezsurf绘制3D网格图和3D表面图，不过推荐使用fmesh和fsurf替换二者。
    %ezcontour和ezcontourf绘制等值线和带有填充的等值线，不过推荐使用fcontour。
    %ezmeshc和ezsurfc相当于ezmesh和ezsurf附加了投影等高线图，推荐使用fmesh和fsurf附加'ShowContour','on'参数来开启投影等高线图。
    %ezpolar绘制极坐标图，默认域为0到2pi。
    ```

22. `ezplot`的默认的区间为`[-2pi, 2pi]`，可以手动指定区间。

    ```matlab
    syms y(x); %显函数
    ezplot(y,[xmin,xmax]);
    f(x,y)=0; %隐函数绘制，功能非常强大
    ezplot(f,[xmin,xmax,ymin,ymax]); %默认x,y都在[-2pi,2pi]。
    x=x(t),y=y(t); %参数方程
    ezplot(x,y,[tmin,tmax]); %默认t在[-2pi,2pi]。
    ```

23. `ezplot3`函数可以添加'animate'参数来生成空间曲线的运动轨迹。图窗左下角可以重复播放动画。

24. 空间曲面的显式方程可以指定区间：`ezmesh(z,[min,max])`区间表示的是x和y的坐标范围，默认平均分为60段，如果x和y的范围不同，可以分别指定。

25. 空间曲面的参数方程需要两个参数，一般为s和t。`ezmesh(x,y,z,[smin,smax,tmin,tmax])`如果s和t的范围相同，可以指定一对范围。

26. 符号表达式求极限：

    ```matlab
    limit(F,x,a) %计算当x趋近于a时，表达式F的值。可以添加'right'或'left'来单独求左或右极限。
    ```

# 线性代数

1. matlab的线性代数函数提供快速、数值稳健的矩阵计算。其功能包括各种矩阵分解、线性方程求解、特征值或奇异值计算等等。

## 线性方程组求解

1. 求解方程组：

   ```matlab
   %求解方程组 Ax=B，要求矩阵A和B必须具有相同的行数，
   x = A\B %等价于mldivide(A,B)，不过很少使用。
   A = magic(4);
   b = [34; 34; 34; 34];
   x = A\b %会报警告: 矩阵接近奇异，或者缩放不良。结果可能不准确。RCOND = 1.306145e-17。这里会计算逆条件数，而非条件数。
   #当rcond介于0和eps（2.220446049250313e-16）之间时，MATLAB会发出近似奇异警告，但会继续计算。处理病态矩阵时，即使残差 b-A*x 相对较小，也可能产生不可靠的解。在此例中，残差的范数为零，尽管rcond较小，但仍获得了精确解。注意，残差才是真正衡量解是否正确的。
   #当rcond等于0时，会出现单一警告。
   A = [1 0; 0 0];
   b = [1; 1];
   x = A\b  %警告: 矩阵在工作精度内为奇异的。此时，除以零会导致计算结果为Inf或NaN，从而使计算结果不可靠。
   %求解方程组 xA=B
   x = B/A %等价于mrdivide(B,A)
   A = [1 1 3; 2 0 4; -1 6 -1];
   B = [2 19 8];
   x = B/A %结果为[1 2 3]
   ```

2. 如果A是方阵，`A\B`大致等于`inv(A)*B`，但MATLAB以不同的方式且更稳健的方式处理`A\B`。

3. 如果A不是方阵，则返回`Ax=B`的最小二乘解，结果可能不是最小范数解。

   ```matlab
   A = [1 2 0; 0 4 3];
   b = [8; 18];
   x = A\b  %结果为x =[0;3.999999999999997;0.666666666666670]
   ```

4. mldivide在解决线性系统问题中的多功能性源于它能够利用问题中的对称性调度到合适的求解器。这种方法旨在最小化计算时间。首先会判断矩阵A是否为稀疏格式，如果A为满矩阵，则按照如下流程进行计算：首先判断是否为方阵，然后判断是否为三角矩阵，再判断是否是小尺寸矩阵（使用LU分解更快），再判断是否为上海森堡矩阵，三对角矩阵，置换三角矩阵（通过对一个标准的三角矩阵进行行或列的置换而得到的矩阵），共轭对称矩阵来调用不同的求解器。

5. 线性方程组的分类（这样分类不如直接计算秩来对解进行分类清晰）：

   1. 矩阵A为方阵，且非奇异，有唯一解，可以直接用`A\b`计算。

   2. 矩阵A为方阵，但奇异（如果检测到A接近奇异或精确奇异，则`A\b`会发出警告），解的情况需要取决于b。

      1. 如果$rank(A)<rank(A|b)$​，则无解，只能获取最小二乘解。

         ```matlab
         A = [1 3 7;-1 4 4;1 10 18]; %rank(A)=2
         b = [3;6;0]; %rank(A)=3
         A\b %警告: 矩阵在工作精度内为奇异的。 
         x=pinv(A)*b %结果为[-1.0892;1.2512;-0.5235]，带入A*x，结果为[-1;4;2]。
         ```

      2. 如果$rank(A)=rank(A|b)$​，则有无穷多解。

         ```matlab
         A = [1 3 7;-1 4 4;1 10 18];%rank(A)=2，第三行等于2*第一行+第二行。
         b =[5;2;12]; %rank(A)=2，第三行也等于2*第一行+第二行。这样第三个方程就可以被完全消除掉。
         A\b %会报错，警告: 矩阵在工作精度内为奇异的。
         pinv(A)*b %可以使用伪逆获得其中一个解，为[0.3850;-0.1103;0.7066]，带入A*x，结果为[5;2;12]。
         ```

   3. 矩阵为瘦高形状，$m>n$​，为超定系统（约束比未知数多，数据拟合时经常遇到），需要判断秩才能确定唯一解，无解，无穷多解的情况。如果矩阵的列秩<n，则为秩亏。此时最小二乘解不唯一，因为$A^TA$不可逆。如果`A`秩亏，`A\B`会发出警告并生成最小二乘解。可以使用`lsqminnorm`找到所有最小二乘解中范数最小的那个。

      ```matlab
      t = [0 0.3 0.8 1.1 1.6 2.3]'; %自变量
      y = [0.82 0.72 0.63 0.60 0.55 0.50]'; %因变量
      %使用y(t)=c1+c2*exp(-t)来拟合。这表明向量y应该由两个向量的线性组合来近似。一个是全1的向量，一个是分量为exp(-t)的向量。未知数为[c1;c2]。
      E = [ones(size(t)) exp(-t)]; %rank为2，最小二乘解唯一
      c = E\y %最小二乘解，结果为[0.4760;0.3413]
      %将插值点和插值函数分别绘制出来查看
      T = (0:0.1:2.5)';
      Y = [ones(size(T)) exp(-T)]*c;
      plot(T,Y,'-',t,y,'o')
      %最小二乘解不唯一的情况
      A=[1 1;0 0;0 0];
      b=[1;1;1];
      x1=A\b %警告: 秩亏，秩 = 1，tol =  6.661338e-16。 给出一个解[1;0]
      x2=[1;0] %构造另一个解，
      norm(A*x1-b) %结果为均为根号2，即都是最小二乘解。
      norm(A*x2-b)
      %可以使用如下函数获得范数最小的那个解
      lsqminnorm(A,b) %结果为[0.5;0.5]
      ```

   4. 矩阵为矮胖形状，$m<n$​ ，为欠定系统（约束比未知数少），有无穷多解或无解，不可能有唯一解，因为$rank(A)\le m<n$。

      ```matlab
      A = [1 1 0;2 2 0];
      b = [1;0];
      x=A\b %结果为[0.2;0;0]
      ```

6. 

7. 

8. 

9. 如果稀疏矩阵A的条件数（condition number）非常大，也就是矩阵A的缩放比例非常不均衡，二者是一回事。

10. 矩阵的条件数衡量了矩阵对于数值计算误差的敏感性（求解结果对输入数据的小扰动会非常敏感）。条件数越大，矩阵越接近奇异（不可逆）。

11. 条件数的定义通常是矩阵的最大奇异值与最小奇异值的比值：`cond(A)=σ_max/σ_min`。

12. 如果矩阵A的不同行或列的数值尺度差异巨大（例如某一行或列的值在1e-10量级，而另一行或列的值在1e10量级），也会导致数值计算的不稳定性。 这种不均衡的缩放会使得浮点运算中的舍入误差被放大，从而影响解的精度。

13. 此时MATLAB仍然会计算出一个解，但该解的数值精度可能非常差，甚至完全错误。在极端情况下，矩阵可能是实际奇异的（不可逆），但由于浮点误差没有被检测到，MATLAB仍然会返回一个解（可能无意义），也就是假阴性。

14. 解决方法有：

    1. 重新缩放矩阵： 尝试对矩阵A和向量B进行缩放，使得所有行或列的数值范围接近。例如，可以使用`diag(1./scale_vec)*A`来均衡缩放。 

       ```matlab
       A = [1e6, 2e6;   %第1行的值在1e6量级
              3,   4];  %第2行的值在1e0量级，可见A的行尺度差异很大。cond(A)为2.500000000012100e+06
       B = [1e6; 2];
       x = A \ B; %直接求解可能会因尺度问题导致数值误差
       %可以先对A进行行缩放
       scale_vec = max(abs(A), [], 2); %获取每行的绝对值的最大值，结果为[2e6; 4]
       D = diag(1./scale_vec); %构造一个对角矩阵，值为最大值的倒数
       A_scaled = D * A; %对矩阵A的行进行缩放，cond(A_scaled)为11.160397456371145，缩小了很多。
       B_scaled = D * B; %对B也进行相同的缩放
       x_scaled = A_scaled \ B_scaled;  % 求解缩放后方程
       ```
    2. 使用更稳定的算法： 对于病态问题，可以考虑使用正则化方法（如Tikhonov正则化，也称为岭回归）或奇异值分解（SVD）来求解。
    3. 检查问题的物理意义： 如果矩阵 A 来自实际问题，可能需要检查建模是否正确，是否存在冗余或冲突的方程。

15. 使用`decomposition`对象可以创建可重复使用的矩阵分解（LU、LDL、Cholesky、QR 等），从而高效地多次求解具有不同右侧的线性系统。该对象非常适合解决需要重复求解的问题，因为系数矩阵的分解不需要多次执行。

16. 注意，这里的分解默认不会产生对应的结果矩阵，因此如果只是要进行分解，应该使用各自对应的函数。这里分解的目的是让用户可以像使用A一样使用decomposition对象来进行`A\b`。

17. 例如，调用`dA = decomposition(A)`对矩阵进行分解后后，再调用`dA\b`会返回与`A\b`相同的向量，但通常速度要快得多。

    ```matlab
    dA = decomposition(A,type,triangularFlag)
    %可选参数type可以为'qr','cod','lu','ldl','chol','triangular','permutedTriangular','banded','hessenberg',或'diagonal'，默认会根据输入矩阵的属性自动选择，方法和mldivide中的策略相同。
    %可选参数triangularFlag可以是'upper'或'lower'，指定只有上三角部分或下三角部分将用于分解。此时分解类型必须是'ldl','chol'或'triangular'。
    %对于'triangular'，如果上三角矩阵和下三角矩阵都存储在同一个矩阵中（为了节省空间），可以使用triangularFlag指定只对其中一个三角矩阵进行分解。
    %对于'ldl','chol'（此时矩阵必定对称），使用triangularFlag避免对近似对称的系数矩阵进行对称化（即(A+A')/2）。
    %后续还可以添加各种设置参数来控制分解的过程，例如dA = decomposition(A,'qr','CheckCondition',false)，指示在用于求解线性系统时，关闭有关系数矩阵条件的警告。
    ```

18. `decomposition`对象包含以下属性和方法：

    ```matlab
    dA.Datatype %具体使用的分解类型
    dA.IsReal   %返回系数矩阵是否是实数
    dA.IsSparse %返回系数矩阵是否是稀疏格式
    dA.ScaleFactor %返回系数矩阵的乘法比例因子。默认值1表示系数矩阵不缩放。但当乘或除decomposition对象时，ScaleFactor会发生变化。例如3*dA是与dA等价的decomposition对象，但其ScaleFactor为3 。
    isIllConditioned(dA) %测试该对象是否基于病态矩阵
    ```

19. 如下情况，可以使用`decomposition`对象`dA`来代替原始系数矩阵`A`：

    1. 转置`-dA`，乘以或除以标量`c*dA dA/c`。
    2. 使用`x = dA\b`求解线性系统`Ax = b`。
    3. 使用`x = b/dA`求解线性系统`xA = b`。

20. 对于任意矩阵`A`都可以进行如下分解：

    1. `'qr'`，QR分解给出最小二乘解，`AP=QR`，Q是酉矩阵的，R是上三角，P是置换矩阵。此时无法求解`A'\B`或`B/A` 。对于这些问题，可以使用`'cod'`。
    2. `'cod'`，完全正交分解给出最小范数最小二乘解，`A=QRZ*`，*表示共轭转置操作。R是上三角，并且Q和Z具有正交列。

21. 对于方阵，还可以进行如下分解：

    1. `'lu'`，LU分解，适用于任意方阵。对于稠密矩阵，`PA=LU`，L是下三角，U是上三角，P是置换矩阵；对于稀疏矩阵，`P(R\A)Q=LU`，P和Q都是置换矩阵，R是对角缩放矩阵。
    2. `'ldl'`，LDL分解，适用于共轭对称（也称为Hermite）矩阵。对于稠密矩阵，`P*AP=LDL*`，L是对角线为1的下三角，D是对角，P是置换矩阵；对于稀疏矩阵，`P*SASP=LDL*`，S是缩放矩阵。
    3. `'chol'`，Cholesky分解，适用于正定的共轭对称矩阵。对于稠密矩阵，`A=LL*`，L为下三角；对于稀疏矩阵，`A=PLL*P*`，P是置换矩阵。
    4. `'triangular'`，适用于三角矩阵，此时`A=T`，即不分解。
    5. `'permutedTriangular'`，适用于置换三角矩阵，`A=PTQ*`，即A是三角矩阵T的重新排列。
    6. `'banded'`，适用于低带宽矩阵，`A=P*LU`，L和U都是带状的，P是置换矩阵。
    7. `'hessenberg'`，A的第一个下对角线下方必须全为零，`A=P*LU`。
    8. `'diagonal'`，A是对角矩阵，此时`A=D`，即不分解。

22. 一个显著的例子是，使用逆迭代法来迭代求解矩阵的特征值，该算法中会多次求解具有相同系数矩阵的线性方程组。它从一个初始向量开始迭代计算，每次迭代计算`x = A\x`，然后根据x的范数对其进行缩放。

    ```matlab
    n = 1e3;
    rng default % 为了可重复性
    A = sprandn(n,n,0.2) + speye(n);
    x1 = randn(n,1);
    x2 = x1;
    %不事先进行矩阵分解
    tic
    for ii=1:100
        x1 = A \ x1; %每次循环都会进行矩阵分解
        x1 = x1 / norm(x1);
    end
    toc %计时结束，历时 6.823118 秒
    lambda = x1'*A*x1 %计算特征值，结果为-0.670718259473704
    norm(A*x1-lambda*x1) %检查容差，结果为0.029785011647099
    %
    tic
    dA = decomposition(A); 
    for ii=1:100
        x2 = dA \ x2;
        x2 = x2 / norm(x2);
    end
    toc %历时 0.374441 秒
    lambda = x2'*A*x2 %计算特征值，结果为-0.670718259473704
    norm(A*x2-lambda*x2)%检查容差，结果为0.029785011647099
    %可以发现两次的结果一样，但是计算速度却差很多。对于后者，可以增加循环次数到1000，此时norm的结果为8.067328835205450e-12。
    ```

23. 最小二乘：当`Ax=b`有无穷多解时，`A\b`或`lsqminnorm`得到的解都会使得范数`||Ax-b||`最小化。但是`lsqminnorm`输出的解是所有解中使得`||x||`最小的。

    ```matlab
    %例如2x1+3x2=8，它有无穷多个解
    A = [2 3];
    b = 8;
    x_a = A\b  %结果为 [0;2.666666666666667]
    norm(A*x_a-b) %结果为0，此处为零，仅仅是因为浮点数计算的巧合，将A修改为[2 3.7]就可以发现结果不为零了。
    norm(x_a)  %结果为2.666666666666667
    x_b = lsqminnorm(A,b)  %结果为 [1.230769230769231;1.846153846153846]
    norm(A*x_b-b)  %结果为1.776356839400250e-15，此处不为零，只是因为浮点数误差
    norm(x_b)  %结果为2.218800784900916，可以发现解的范数更小。
    %可以从下图看出，横坐标为x1，纵坐标为x2，蓝色斜线上的点都是方程的解，而和以原点为圆心的圆相切的点只有一个，就是其最小范数最小二乘解。
    ```

24. ![image-20250417101224370](Matlab.assets/image-20250417101224370.png)

25. 可以在`lsqminnorm`中指定秩计算的容差或解的Tikhonov正则化因子。这有助于定义问题的规模，从而避免随机噪声破坏解。

    ```matlab
    U = randn(200,5);
    V = randn(100,5);
    A = U*V';  %认为构造一个低秩矩阵，rank(A)=5。
    b = U*randn(5,1) + 1e-4*randn(200,1);
    x = lsqminnorm(A,b);
    norm(A*x-b) %结果为0.001348858130389
    norm(x)  %结果为0.193676015862339
    %现在向矩阵A中添加少量噪声（也可以对向量b添加噪声），再次求解线性系统。噪声会对解向量x产生不成比例的影响。
    Anoise = A + 1e-12*randn(200,100);
    xnoise = lsqminnorm(Anoise,b);
    norm(Anoise*xnoise - b) %结果为9.172334895679098e-04
    norm(xnoise) %结果为1.037839513397792e+08，远大于添加的噪声级别（1e-12）。
    %解之间差异巨大的原因是噪声影响了A的低秩近似值。换句话说，lsqminnorm 将A的QR分解中R矩阵对角线上的小值视为比实际更重要。理想情况下，R对角线上的这些小值应被视为零。
    %绘制Anoise的QR分解中R矩阵的对角线元素。大量对角线元素的数量级为1e-10。
    %增加lsqminnorm使用的容差，以便在计算中使用误差小于1e-8 Anoise低秩近似值。增加容差可以显著降低结果受噪声的影响。使用容差后的解非常接近原始解x。
    xtol = lsqminnorm(Anoise,b,1e-8);
    norm(Anoise*xtol - b) %结果为0.001348858130154
    norm(xtol) %结果为0.193676015862337
    norm(x - xtol) %结果为1.372108682309926e-14，可以看出，结果影响不大，成功地消除了噪声的影响。
    %或者，指定Tikhonov正则化因子为1。对于病态问题（例如涉及噪声的问题），您可以指定正则化因子，以避免发生过度拟合。这个功能在matlab2024b中才引入。
    xreg = lsqminnorm(Anoise,b,RegularizationFactor=1);
    norm(Anoise*xreg - b)
    norm(xreg)
    norm(x - xreg)
    ```

26. QR分解和SVD分解均可以用来求解最小二乘问题：

    1. 通过QR分解，将最小二乘问题$\min⁡||Ax−b||_2$转化为$min⁡||Rx−Q^Tb||_2$（方程两侧同乘以$Q^T$即可），由于R是上三角矩阵，直接回代即可求解。但对病态问题，QR分解可能无法有效处理接近零的$r_{ii}$，因为要除以$r_{ii}$​​。
    2. 通过$A=UΣV^T$，可直接写出解$x=VΣ^+U^Tb$（$Σ^+$是伪逆）。SVD允许显式截断小奇异值（若$σ_i<ϵ$，则将其视为零），从而抑制噪声影响，更适合病态问题。

27. 当矩阵A是病态或接近低秩时，噪声会显著影响解的稳定性。`lsqminnorm`会对A进行QR分解`A=QR`，其中R是上三角矩阵。R的对角元$r_{ii}$反映矩阵A的奇异值大小（并不相等，）。小的$r_{ii}$通常对应A的不显著方向（即接近零的奇异值），意味着矩阵在这些方向上信息较弱或噪声主导。

28. 噪声会导致本应为零的$r_{ii}$​值变为很小的非零值。而`lsqminnorm` 将这些微小值视为“重要”（即保留它们参与计算），但实际上它们应被忽略（理想情况下视为零）。这会导致解过度拟合噪声，从而偏离真实解。

29. 若将过小的$r_{ii}$直接视为零（类似截断奇异值分解的思想），可以避免噪声放大，得到更鲁棒的解。但`lsqminnorm`未主动截断这些小值，因此解对噪声敏感。推荐手动截断或使用正则化方法。

30. SVD对噪声和病态问题更稳定，可通过截断小奇异值（如Truncated SVD）实现正则化。但是相比QR分解，SVD的计算复杂度更高。精确SVD的复杂度为$O(\min⁡(mn^2,m^2n))$，大规模数据需用随机化方法。

31. QR分解是SVD的中间步骤：在计算SVD时，通常先对矩阵A进行QR分解，然后对R进行奇异值分解（$R=U_RΣV^T$），最终得到$ A=(QU_R)ΣV^T$。这可以加速SVD的计算，尤其是当$m\gg n$时。

32. SVD适用于任意矩阵（包括非方阵和秩缺陷矩阵），而QR分解通常要求A列满秩以保证R的非奇异性。若A秩亏损，QR分解需要对列主元调整（如列主元QR分解）。

33. QR的$r_{ii}$和SVD的$σ_i$：

    1. R的对角元$r_{ii}$的绝对值通常与奇异值$σ_i$相关，但不严格单调递减（除非进行列主元QR分解）。
    2. 在QR分解中，若$r_{ii}$很小，可能对应A的“弱方向”，但需谨慎判断（可能需结合列交换或SVD确认）。

34. 在噪声问题中SVD更鲁棒的原因是：

    1. SVD可以获得显式奇异值，因而直接通过$σ_i$即可区分信号与噪声。
    2. SVD的U和V是全局正交基，而QR分解的Q依赖于分解顺序。

35. 何时选择QR或SVD？

    1. 稠密矩阵的最小二乘解，推荐QR分解，因为计算更快，数值稳定（如MATLAB的`A\b`默认使用QR）。
    2. 病态/秩亏问题的最小二乘解，推荐SVD，因为可截断小奇异值，避免噪声放大（如pinv或lsqminnorm的某些实现）。
    3. 低秩近似（如PCA），推荐SVD，因为直接提供最优低秩逼近（Eckart-Young定理）。
    4. 大规模稀疏矩阵最小二乘解，推荐随机化QR或迭代方法，因为SVD计算成本过高，QR更高效。

36. 也可以使用`linsolve`求解线性方程组`Ax=B`，A不能是稀疏矩阵：

    ```matlab
    X = linsolve(A,B,opts) %当A为方阵时，使用部分选主元的LU分解，否则使用列主元的QR分解。
    %如果A是病态（对于方阵）或秩不足（对于矩形矩阵），会发出警告。
    %opts为可选参数，结构体类型，用于标记A的特征，例如opts.LT=true则表示A为下三角，opts.TRANSA=true表示要求解A'x=B，而非Ax=B。可以同时指定多个特征，只要他们互相不冲突即可。linsolve不会测试以验证A是否满足该特征。
    [X,r] = linsolve(A,B,opts) %此时还会将A的逆条件数（方阵）或秩（矩形矩阵）作为r范围。此时还会抑制warning。
    ```

37. 如果A具有`opts`中的属性，则`linsolve`比`mldivide`要快，因为`linsolve`会立即使用对应的求解器，而不用执行任何测试来验证`A`是否具有特定的属性。`linsolve`的速度优势是因为它避免了对大矩阵进行冗长的属性检查。如果提前了解矩阵A的属性，可以使用`linsolve`来加速计算。

38. 输出参数`r`的行为取决于矩阵A的形状（方阵或非方阵），原因：对于方阵，需警惕是否病态，对于非方阵，需关注秩是否缺陷。

    1. 对于方阵，解的唯一性取决于矩阵是否可逆。条件数的倒数直接反映了问题的数值稳定性，适合作为稀疏矩阵为方阵时，解的可靠性指标。

    2. 非方阵的解取决于秩。对于超定方程组（行多于列），秩决定最小二乘解的唯一性；对于欠定方程组（列多于行），秩决定自由变量的数量。非方阵通常对应最小二乘或欠定问题，条件数的定义可能不唯一（例如取决于是否计算奇异值的比值）。而秩直接反映了方程组的可解性，更实用。对于非方阵，条件数的倒数可能不如秩直观（例如，秩可以明确判断是否满秩，而条件数可能因计算方式不同而模糊）。

39. 求方阵的逆矩阵：

    ```matlab
    Y = inv(A)  %等价于A^-1的操作。很少需要显式求矩阵的逆。
    %不建议用inv(A)*b来求解线性方程组Ax=b。使用A\b的速度是inv(A)*b的两到三倍，并且产生的残差与数据量级的机器精度相当。
    %inv对输入矩阵进行LU分解（如果输入矩阵是Hermitian矩阵，则进行LDL分解）。然后求解矩阵方程AX=I，X的每个列向量构成矩阵inv(X)的列向量。
    ```

40. 伪逆：

    ```matlab
    B=pinv(A,tol) %返回矩阵A的Moore-Penrose伪逆。可选参数tol用于指定公差。伪逆的计算基于svd(A)，pinv将小于或等于公差的A的奇异值视为零。
    ```

41. Moore-Penrose伪逆是一个矩阵，当逆不存在时，它可以部分替代逆矩阵。当线性方程组无唯一解时，通常使用该矩阵来求解。定义为：当且仅当B满足`A*B*A=A`且`B*A*B=B`时，B是A的伪逆。

42. 对于任何矩阵A，伪逆B存在、唯一，且与A的维度相同。如果A是方阵且非奇异，则`pinv(A)`只是一种计算普通逆`inv(A)`昂贵方法。但如果A不是方阵，或者是方阵且奇异，那么`inv(A)`就不存在。

43. 伪逆的性质：当B是A的伪逆时，AB和BA都是共轭对称的。

44. 对A进行SVD分解，同时将矩阵S主对角线上小于等于`tol`奇异值视为零，因此可得如下分块形式：$A=USV^*=\begin{bmatrix}U_1&U_2\end{bmatrix}\begin{bmatrix}S_1&0\\0&0\end{bmatrix}\begin{bmatrix}V_1&V_2\end{bmatrix}^*$，其中$S_1$是一个可逆方阵，继续简化$A = U_1S_1V_1^*$，因此$B=V_1S_1^{-1}U_1^*$，可以验证，满足$A*B*A=A$等。

45. 如果非方阵是低秩的，那么最小二乘问题`norm(A*x-b)`有无穷多解，有三种求解方法：

    ```matlab
    A = magic(8); 
    A = A(:,1:6)
    b = 260*ones(8,1)
    x1 = A\b %警告: 秩亏，秩 = 3，tol =  1.882938e-13。结果为[3.0000;4.0000;0;0;1.0000;0]
    x2 = pinv(A)*b %结果为[1.1538;1.4615;1.3846;1.3846;1.4615;1.1538]
    x3 = lsqminnorm(A,b) %结果同上
    %三个解都是精确的，因为norm(A*x-b)都属于舍入误差的量级，x1的特点是它仅包含rank(A)个非零分量，x2和x3完全相同，都是最小范数，而lsqminnorm(A,b)通常比pinv(A)*b更有效。
    ```

46. 最小二乘问题可以转化为求正规方程：$A^TAx=A^Tb$，此时系数矩阵为方阵，最小二乘解的唯一性取决于$A^TA$的可逆性，等价于$A$的列秩是否是满的。不过matlab的内部一般不用正规方程法求解最小二乘问题，而是直接对矩阵A进行各种分解。

47. 各种最小二乘问题：

    ```matlab
    %残差向量r为b-A*x
    x = lscov(A,b) %常规最小二乘法，最小化r'*r，也就是r的2范数。
    x = lscov(A,b,w) %加权最小二乘法，最小化r'*diag(w)*r。当w的每个值均相等时，退化为常规最小二乘，此时每个参数的权重均相同。
    x = lscov(A,b,C) %广义最小二乘法，最小化r'*inv(C)*r。当C是对角矩阵时，退化为加权最小二乘，此时不同观测值是独立的。当C时单位矩阵时，退化为常规最小二乘。
    x = lscov(A,b,C,alg) %指定求解inv(C)的算法。默认情况下，Cholesky分解，当alg为"orth"时，正交分解。如果C不可逆，则使用正交分解，而不管alg的值如何。
    [x,stdx,mse] = lscov(A,b) %stdx为估计标准误差。标准误差是x标准差的估计值，mse为均方误差，它与以下值成正比： 函数最小化
    ```

48. 在广义最小二乘问题中，系数矩阵A也称为设计矩阵，b是观测向量（响应变量），C是协方差矩阵（对称正定），表示观测值b的误差协方差结构。这里将b看作随机向量，包含n个随机变量。因此可以计算这些随机变量之间的协方差。

49. 协方差矩阵对角线元素$C_{ii}$是$b_i$的方差（观测值的离散程度），非对角线元素$C_{ij}$（$i≠j$）是$b_i$和$b_j$的协方差（描述两观测值的线性相关性），例如当$C_{12}>0$时，表示$b_1$和$b_2$​正相关，即一个增大时，另一个也会增大。

50. 协方差矩阵C描述了观测数据b的不确定性（方差）和误差相关性（协方差）。矩阵C的作用：

    1. 使用$C^{-1}$对残差进行加权。当C的对角元较大时（观测量精度低），则$C^{-1}$的对应对角元较小，即权重较小。这么做会降低精度差的量的权重。
    2. 处理相关性，C的非对角元会修正相关性。

51. 当观测数据b存在相关性（C是非对角矩阵）或异方差性（C的对角元不等，可能是因为使用了不同型号的传感器）时（例如传感器误差相关或时间序列中相邻点误差相关），需使用广义最小二乘而非普通最小二乘。


## 特征值

1. 特征值问题是求解方程$Av=λv$的解，其中A是一个n阶方阵，v是长度为`n`的列向量，$\lambda$是一个标量。满足该方程的$\lambda$值即为特征值，对应的*v*就是对应的右特征向量。满足方程$w'A=λw'$的w称为左特征向量，这里w也是一个列向量。左右特征值构成相同的集合，但是对应特征值的左右特征向量不一定相同。当A对称时，W等于V。

2. 方阵A的特征值求解：

   ```matlab
   e = eig(A) %返回由特征值构成的列向量。因为可能存在复数，因此结果是无序的。
   [V,D] = eig(A) %返回特征值构成的对角矩阵D和对应右特征列向量拼成矩阵V，满足A*V=V*D。
   [V,D,W] = eig(A) %矩阵W的列的转置是A的左特征行向量，W'*A = D*W'
   A = gallery("circul",3) %从测试矩阵库中取出名为circul的矩阵
   A = 3×3
        1     2     3
        3     1     2
        2     3     1
   e = eig(A) %结果为[6.0000 + 0.0000i;-1.5000 + 0.8660i;-1.5000 - 0.8660i]
   D = eig(A,"matrix") %以对角矩阵形式输出，相当于diag(e)
   [V,D,W] = eig(A) %测试第一个特征值，norm(A*V(:,1)-D(1,1)*V(:,1))，结果为2.8436e-15，norm(W(:,1)'*A-D(1,1)*W(:,1)')，结果为9.9301e-16。
   V =
     -0.5774 + 0.0000i   0.5774 + 0.0000i   0.5774 + 0.0000i
     -0.5774 + 0.0000i  -0.2887 - 0.5000i  -0.2887 + 0.5000i
     -0.5774 + 0.0000i  -0.2887 + 0.5000i  -0.2887 - 0.5000i
   D =
      6.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i
      0.0000 + 0.0000i  -1.5000 + 0.8660i   0.0000 + 0.0000i
      0.0000 + 0.0000i   0.0000 + 0.0000i  -1.5000 - 0.8660i
   W =
     -0.5774 + 0.0000i  -0.2887 - 0.5000i  -0.2887 + 0.5000i
     -0.5774 + 0.0000i  -0.2887 + 0.5000i  -0.2887 - 0.5000i
     -0.5774 + 0.0000i   0.5774 + 0.0000i   0.5774 + 0.0000i
   %可以看到第1个特征值对应的左右特征向量相同，而第2和3个特征值对应的左右特征向量则不同。
   norm(A*V-V*D) %结果为2.9308e-15
   norm(W'*A - D*W') %2.0883e-15
   ```

3. 矩阵A可对角化的充要条件是它有n个线性无关的特征向量。

4. 当$V$可逆时，$A=VDV^{-1}$，也称为矩阵的特征值分解。所有的矩阵都有特征向量和特征值，但并非都可以进行特征值分解。

5. 判断方法：计算所有特征值的几何重数和代数重数。如果存在至少一个特征值的几何重数<其代数重数，则矩阵不可对角化。

6. 如果A有n个不同的特征值，则它一定可以对角化（但反之不成立，充分但非必要条件）。

7. 矩阵的特征值的几何重数是对应线性无关特征向量的个数。特征值的代数重数是特征值在特征多项式中的重数。例如`A=[1 1;0 1]`，只有一个特征值，为1，其代数重数为2，因为特征方程为$(\lambda-1)^2=0$​，几何重数为1，因为只有一个线性无关的特征向量$(1,0)$。

8. 对于一个n阶方阵A，设$\lambda$是它的一个特征值，则其

   1. 代数重数（Algebraic Multiplicity, AM）：$λ$在特征多项式$det(A−λI)=0$中的重数。即$(λ−λ_i)^k$中的k，表示$λ$在多项式中的重复次数。
   2. 几何重数（Geometric Multiplicity, GM）：特征值$λ$对应的线性无关特征向量的个数，即特征空间$Ker(A−λI)$的维数，也就是$n−rank(A−λI)$。

9. 对于任意特征值$λ$，以下不等式恒成立：$1≤GM(λ)≤AM(λ)≤n$，即几何重数≤代数重数，且几何重数至少为1（因为每个特征值至少有一个特征向量）。

10. 当$GM(\lambda)<AM(\lambda)$，说明矩阵在该特征值方向上有广义特征向量，导致Jordan块的出现。

11. 无论矩阵是否可对角化，所有特征值的代数重数之和一定等于n，这是因为特征多项式是n阶，且要满足代数基本定理。当每个特征值的几何重数等于代数重数时，所有特征值的特征向量一共也就是n个了，由于不同特征值的特征向量线性无关，又由于每个特征值的几何重数=代数重数（因此同一特征值的特征向量线性无关），因此这n个特征向量也是线性无关的。

12. 当几何重数等于代数重数时，此时每个特征值提供了尽可能多的线性无关特征向量。

13. 可对角化矩阵的作用可以分解为沿特征向量方向的独立伸缩变换。

14. 不可对角化矩阵的作用包含“剪切”或“旋转”等更复杂的变换，操作无法完全解耦。

15. 不可对角化的矩阵可以通过相似变换化为Jordan标准形（而非对角矩阵），其中包含Jordan块。

16. 对于不可不可对角化的矩阵，eig也会给出结果：

    ```matlab
    A = [3 1 0; 0 3 1; 0 0 3];
    [V,D] = eig(A)
    V =
        1.0000   -1.0000    1.0000
             0    0.0000   -0.0000
             0         0    0.0000
    D =
         3     0     0
         0     3     0
         0     0     3
    %只有一个特征值，其代数重数为3，几何重数为1，因此不可对角化。就一个线性无关的特征向量(1,0,0)。
    ```

17. 广义特征值问题是为了确定方程$Av=λBv$的解，其中A和B是n阶方阵，v是长度为n的列向量，$\lambda$是标量，称为广义特征值。$\lambda$对应的v称为广义右特征向量。广义左特征向量w满足方程$w'A=λw'B$。左右广义特征值构成相同的集合，但是对应广义特征值的左右广义特征向量不一定相同，当A和B均对称时，W等于V。

18. 广义特征值：

    ```matlab
    e = eig(A,B) %返回由广义特征值构成的列向量。
    [V,D] = eig(A,B) %返回广义特征值构成的对角矩阵D和对应广义右特征列向量拼成矩阵V，满足A*V=B*V*D。
    [V,D,W] = eig(A,B) %矩阵W的列的转置是A的广义左特征行向量，W'*A = D*W'*B
    ```

19. 一种常规的计算广义特征值的方法就是将$Ax=λBx$的两侧同时左乘$B^{-1}$，然后求$B^{-1}A$的特征值和右特征向量，这就是A和B的广义特征值和广义右特征向量。在方程两侧同时右乘$B^{-1}$，然后求$AB^{-1}$​的特征值和左特征向量，这就是A和B的广义特征值和广义左特征向量。

    ```matlab
    A = [1/sqrt(2) 0; 0 1];
    B = [0 1; -1/sqrt(2) 0];
    [V,D] = eig(A,B)
    V =
       1.0000 + 0.0000i   1.0000 + 0.0000i
       0.0000 - 0.7071i   0.0000 + 0.7071i
    D =
       0.0000 + 1.0000i   0.0000 + 0.0000i
       0.0000 + 0.0000i   0.0000 - 1.0000i
    [V1,D1]=eig(inv(B)*A) %V1会默认归一化
    V1 =
       0.8165 + 0.0000i   0.8165 + 0.0000i
       0.0000 - 0.5774i   0.0000 + 0.5774i
    D1 =
       0.0000 + 1.0000i   0.0000 + 0.0000i
       0.0000 + 0.0000i   0.0000 - 1.0000i
    V(:,1)/norm(V(:,1)) %将V(:,1)归一化，就可以发现它和V1(:,1)是一个方向。
    ```

20. 当其中一个矩阵奇异时，无法使用上述常规算法计算广义特征值：

    ```matlab
    A = eye(2);
    B = [3 6; 4 8]; %奇异矩阵
    %由于B不可逆，则B\A会包含inf，因此eig会报错，警告: 矩阵在工作精度内为奇异的。
    [V,D] = eig(B\A)
    %建议将两个矩阵分别作为eig函数的参数传入，来计算广义特征值和右特征向量，因为eig算法内部并非使用该常规算法。此时返回一组特征向量和至少一个实特征值，即使B不可逆。
    [V,D] = eig(A,B)
    V =
       -0.7500   -1.0000
       -1.0000    0.5000
    D =
        0.0909         0
             0       Inf
    %验证第一个特征值
    norm(A*V(:,1) - D(1,1)*B*V(:,1)) %结果为2.4825e-16
    %验证第二个特征值
    A*V(:,2) - D(2,2)*B*V(:,2) %结果为 [NaN;NaN]，因为出现了inf-inf。
    ```

21. 以上eig函数还接受可选参数：

    1. `balanceOption`，如果为`"nobalance"`，则禁用算法中的初步平衡步骤。如果为`"balance"`，则启用平衡（默认）。大多数情况下，平衡步骤可以改善`A`的条件，以获得更准确的结果。然而有些情况下，平衡会产生不正确的结果。当`A`包含数值尺度差异很大的值时，应使用`"nobalance"`。例如`A`包含非零整数以及非常小（接近于零）的值，平衡步骤可能会缩放这些小值，使其与非零整数具有同等重要性，从而产生不准确的结果。
    2. `algorithm`，指定广义特征值的算法，如果为`"chol"`，则使用`B`的Cholesky分解来计算广义特征值。如果为`"qz"`，则使用QZ算法，也成为广义Schur分解，此算法忽略A和B的对称性 。`algorithm`的默认值取决于`A`和`B`的属性，当A不对称或B不对称正定时，总会使用QZ算法。总体而言两种算法返回的结果相同。对于某些问题（例如涉及条件不良矩阵的问题），QZ算法可能更稳定。

       ```matlab
       A = diag([10^-16, 10^-15]) %包含接近机器精度的值的条件不良的对称矩阵。
       [V1,D1] = eig(A,A) %默认使用"chol"
       V1 =1.0e+08 *
           1.0000         0
                0    0.3162
       D1 =
           1.0000         0
                0    1.0000
       [V2,D2] = eig(A,A,"qz")
       V2 =
            1     0
            0     1
       D2 =
            1     0
            0     1
       norm(A*V1 - A*V1*D1) %结果为6.6174e-24
       norm(A*V2 - A*V2*D2) %结果为0，更稳定
       ```
    3. `outputForm`，指定的返回特征值的形式，如果为`"vector"`，则以列向量形式返回特征值，如果为`"matrix"`，则以对角矩阵返回特征值。如果输出请求中包含了V或W，则默认为matrix，否则为vector。

22. 当A为实对称或复共轭对称矩阵时，特征值为实数，当A为实斜对称或复斜共轭对称矩阵时，特征值为虚数。

23. 如果A是实对称、复共轭对称或复斜共轭对称矩阵时，右特征向量构成的矩阵`V`是正交的。

24. 注意所有函数返回的特征向量都是归一化后的。当包含"nobalance"参数时，每个特征向量的2范数不一定为1。

25. 对于广义特征值问题中，输出的特征向量的范数不一定为1。

26. 对于广义特征值问题，当A共轭对称，B共轭对称正定时，且使用chol算法时，`eig`会对`V`中的特征向量进行归一化，使每个特征向量的`B`范数为1，也就是$v'Bv=1$。

27. 特征向量的特点：

    1. 对于实特征向量，符号改变后还是特征向量。
    2. 对于复特征向量，乘以任意复数后仍然是特征向量。有人可能会担心乘以复数会改变特征值。然而特征值是由特征方程确定的，乘以标量不会改变特征值，只是对特征向量进行了缩放。
    3. 同一个特征值的线性无关的特征向量的线性组合，仍然是该特征值的特征向量。

28. `eig`函数可以计算实对称稀疏矩阵的特征值。要计算稀疏矩阵的特征向量，或非实对称稀疏矩阵的特征值，请使用`eigs`函数。

29. 如果只寻找大型矩阵的部分特征值，推荐使用`eigs`函数，该函数使用迭代法计算。

    ```matlab
    d = (A,k) %返回前k个幅值最大的特征值，k默认为6。
    %还可以添加sigma参数，用于设置其他排序准则。如果A对称，则sigma可以是："largestabs"最大幅值（默认）; "smallestabs"最小幅值; "largestreal"最大实部; "smallestreal"最小实部; "bothendsreal"实部排序，最大k/2个，最小k/2个，如果k为奇数，则用k+1替代k。如果A非对称，则sigma还可以是："largestimag"最大虚部; "smallestimag"最小虚部; "bothendsimag"虚部排序，最大k/2个，最小k/2个，如果k为奇数，则用k+1替代k。
    d = (A,B) %此时计算广义特征值问题，仍然可以包含以上参数。
    ```

30. 如果`A`是对称的，则`eigs`会使用专门的算法。如果`A`是几乎对称，则考虑使用`A=(A+A')/2`使`A`对称，然后再调用`eigs`。这确保了`eigs`输出的特征值为实数而非复数。

31. 

32. 

33. 

34. 矩阵的平衡：通过相似变换（即左右同乘可逆矩阵）来调整矩阵的行和列的尺度，使得不同行或列的元素数量级（用范数衡量）尽可能接近。这样可以：

    1. 避免某些元素因数量级过大或过小而引发浮点运算中的舍入误差，导致特征值计算不准确。某些应用中的矩阵可能因单位不一致（如同时存在米和千米）导致尺度差异巨大。
    2. 改善矩阵的条件数，使得后续的数值算法（如QR算法）更稳定，增加迭代算法的收敛速度。

35. matlab的平衡使用特殊的可逆矩阵，即对角矩阵D，使得$B = D^{−1}AD$的行和列范数更均衡。因为B和A是相似的，它们的特征值相同（特征向量不一定相同），但B的数值性质更好，计算出的特征值$λ$更精确。因为特征值对矩阵的尺度敏感。

36. 对平衡后的矩阵B计算特征值和特征向量$v_B$。然后计算$v_A=Dv_B$，它就是A的特征向量，因为$A(Dv_B)=\lambda(Dv_B)$。分为平衡和还原两个过程。这是因为数值计算精度有限，才需要的这么做。

37. 平衡（对角缩放）以提高特征值精度：

    ```matlab
    B = balance(A) %返回平衡矩阵B，它比A更接近对称结构。
    [T,B] = balance(A) %返回变换矩阵T和平衡矩阵B，T使得B和A满足相似变换，B=T^{-1}A*T，且B行范数和列范数尽可能近似相等。T是对角矩阵的置换，其元素为2的整数幂，以避免引入舍入误差。如果A是对称矩阵，则 B=A且T为单位矩阵，也就是不用进行对角缩放。
    [S,P,B] = balance(A) %S为记录缩放的列向量，P为记录置换的向量。变换矩阵T和平衡矩阵B可以通过A，S和P获得，T(:,P) = diag(S)和B(P,P) = diag(1./S)*A*diag(S)得到。
    B = balance(A,'noperm') %缩放A而不改变其行和列的排列。
    %矩阵A的右上角元素较大，左下角元素较小，二者差异巨大，它远非对称。
    A = [1 100 10000;0.01 1 100;0.0001 0.01 1]
    [T,B] = balance(A) %
    T =
      512.0000         0         0
             0    8.0000         0
             0         0    0.0625
    B = %可以发现对角线元素不变，因为这里使用的可逆矩阵T是对角矩阵。此时矩阵B的对称性得到了改善。
        1.0000    1.5625    1.2207
        0.6400    1.0000    0.7812
        0.8192    1.2800    1.0000
    [V,E] = eig(A) %这三个向量的第一个分量最大。这表明V的条件很差，实际上cond(V)为9.4430e+03
    V =
       0.9999 + 0.0000i   0.9999 + 0.0000i   0.9999 + 0.0000i
       0.0100 + 0.0000i  -0.0078 - 0.0116i  -0.0078 + 0.0116i
       0.0001 + 0.0000i  -0.0000 + 0.0001i  -0.0000 - 0.0001i
    E =
       3.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i
       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i
       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 - 0.0000i
    [V,E] = eig(B) %现在特征向量表现良好，cond(V)为1.4830 。病态集中在缩放矩阵中，cond(T)为8192。
    V =
       0.6933 + 0.0000i   0.6045 + 0.0000i   0.6045 + 0.0000i
       0.4437 + 0.0000i  -0.3014 - 0.4490i  -0.3014 + 0.4490i
       0.5679 + 0.0000i  -0.1094 + 0.5747i  -0.1094 - 0.5747i
    E =
       3.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i
       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i
       0.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 - 0.0000i
    ```

38. 平衡操作可能会破坏某些矩阵的属性，请谨慎使用。如果矩阵中包含由舍入误差引起的较小元素，平衡操作可能会将其按比例放大，使其与原始矩阵的其他元素一样重要。

39. 非对称矩阵的特征值条件可能较差。矩阵中的微小扰动（例如舍入误差）可能导致特征值的较大扰动。特征向量矩阵的条件数将矩阵扰动的大小与特征值扰动的大小联系起来，注意，A本身的条件数与特征值问题无关。

40. 平衡是尝试将特征向量矩阵的任何病态问题集中到对角线缩放中。平衡通常无法将非对称矩阵转换为对称矩阵，它仅尝试使每行的范数等于相应列的范数。

41. `eig(A)`会在计算A的特征值之前自动平衡`A`，使用`eig(A,'nobalance')`以关闭平衡功能。经过测试，发现禁用平衡无效。

42. 

43. 

44. 

45. 


## 奇异值

1. 

2. 

3. 

4. 

5. 

6. 


## Schur分解

1. 许多高级矩阵计算不需要特征值分解。它们基于Schur分解，$A=USU'$​。其中U是正交矩阵， *S* 为分块上三角，对角线上分别为1×1和2×2的块。特征值由S的对角线元素和分块表示，而U提供了一个正交基，其数值特性比一组特征向量好得多。例如计算如下秩亏矩阵的特征值分解和Schur分解：

   ```matlab
   A = [ 6    12    19 
        -9   -20   -33 
         4     9    15 ];
   [V,D] = eig(A)
   V =
     -0.4741 + 0.0000i  -0.4082 - 0.0000i  -0.4082 + 0.0000i
      0.8127 + 0.0000i   0.8165 + 0.0000i   0.8165 + 0.0000i
     -0.3386 + 0.0000i  -0.4082 + 0.0000i  -0.4082 - 0.0000i
   D = %有2个特征值相同
     -1.0000 + 0.0000i   0.0000 + 0.0000i   0.0000 + 0.0000i
      0.0000 + 0.0000i   1.0000 + 0.0000i   0.0000 + 0.0000i
      0.0000 + 0.0000i   0.0000 + 0.0000i   1.0000 - 0.0000i
   [U,S] = schur(A) %矩阵A是有缺陷的，因为它没有一组完整的线性无关的特征向量（V的第二列和第三列相同）。由于V并非所有列都是线性独立的，因此它的条件数较大，约为1e8 。然而schur能够计算U中的三个不同的基向量。由于U是正交的，cond(U)=1。
   U =
      -0.4741    0.6648    0.5774
       0.8127    0.0782    0.5774
      -0.3386   -0.7430    0.5774
   S = %S对角线上的第一个元素为实数特征值，右下角的2×2块为其重复的特征值。该2×2块的特征值也是A的特征值：
      -1.0000   20.7846  -44.6948
            0    1.0000   -0.6096
            0    0.0000    1.0000
   %
   eig(S(2:3,2:3)) %结果为[1.0000 + 0.0000i; 1.0000 - 0.0000i]
   ```

2. 

3. 

4. 

5. 

6. 

## LU分解

1. 部分选主元的LU分解是标准LU分解的改进版本，通过引入行交换（部分选主元操作）来提高数值稳定性。在标准LU分解中，当A的主对角线上存在零元素或非常小的值时，分解过程可能导致数值不稳定（例如除以零或舍入误差放大）。

2. 部分选主元法在每一步分解中，选择当前列中绝对值最大的元素作为主元（pivot），并通过行交换将其移动到主对角线位置。目的是避免小主元导致的数值不稳定，同时控制舍入误差的增长。因此部分选主元LU分解可以写为：$PA=LU$，其中P是一个置换矩阵，每次行交换都相当于左乘一个置换矩阵，而P就是这些置换矩阵累乘，因为其结果还是一个置换矩阵。

3. 部分选主元的部分不是指只在部分步骤中进行行交换，而是指只对行进行操作。因此完全主元选择（Full Pivoting）为同时交换行和列，数值稳定性更高，但计算成本更大。
4. 因此在方程组`Ax=b`两侧同乘以P，变成$(LU)x=Pb$，此时可以求解得到x。

5. 

6. 

7. 

8. 

9. 

10. 

11. QR分解通常通过Householder变换或Givens旋转实现，具有数值稳定性，适合求解最小二乘问题。

12. 

13. 

14. 


## 条件数

1. 矩阵A的条件数$κ(A)=||A||⋅||A^{−1}||$，用于衡量矩阵求逆或解线性方程组的数值稳定性。条件数越大，矩阵越接近奇异（不可逆），解的数值误差可能越大。

2. 条件数的倒数$1/κ(A)$​是一个介于0到1之间的值，越接近0表示矩阵越病态，越接近1表示矩阵越良态。
3. 奇异矩阵不存在逆矩阵，近似奇异的矩阵，其逆矩阵的计算容易出现数值误差。`cond`函数计算求逆的条件数，该条件数指示了矩阵逆运算结果的准确性。条件数的范围从`1`（数值稳定矩阵）到`Inf`（奇异矩阵）。

4. 

5. 


## 范数

1. 向量的p范数：$||x||_p=(\sum|x_i|^p)^{1/p}$，每个元素的绝对值或模长的p次方，求和再开p次方根。使用`norm(x,p)`，可选参数p默认为2，当p为inf时，结果为无穷范数。

2. 矩阵的p范数：$||A||_p=\max_\limits x\frac{||Ax||_p}{||x||_p}$，定义时借助了向量的p范数，如果矩阵是非方阵时，分子和分母两个向量的长度不同。同样使用`norm(A,p)`函数。

3. 如果想要对矩阵的每个向量单独计算其向量范数，可以使用`vecnorm(A)`。

4. 

5. 
6. 

7. 

8. 

9. 

## 秩

1. 低秩矩阵通常指的是矩阵的秩相对于其行数和列数来说比较小。比如，一个100x100的矩阵，如果其秩是5，可以称之为低秩矩阵。
2. 关于秩的定义：
   1. 可以通过高斯消元法将矩阵化为行阶梯形，然后非零行的数量就是秩。
   2. 行（列）向量组中极大线性无关组所包含的向量的个数。
   3. 矩阵的行秩和列秩是相等的，所以统称为矩阵的秩。

3. mxn的矩阵A的秩最大为$\min(m,n)$​，当秩为n时，称为列满秩；当秩为m时，称为行满秩。
4. n阶方阵是可逆的，等价于它行列均满秩。
5. 从几何上看，矩阵的秩对应于矩阵的行空间或列空间的维度，这也是矩阵的秩的另一个定义。低秩意味着矩阵的行向量或列向量都位于一个低维的子空间中。例如一个秩为1的3×3矩阵的所有行向量都在一条直线上，所有列向量也在一条直线上。
6. 低秩矩阵的一个重要性质是它可以被分解为两个较小矩阵的乘积。如果一个m×n的矩阵A的秩为r，那么存在一个m×r的矩阵B和一个r×n的矩阵C，使得`A=BC`，这种分解不是唯一的。反之也成立，因为$rank(AB)≤\min(rank(A),rank(B))$。
7. 低秩矩阵在很多领域都有应用，比如：
   1. 数据压缩：如果一个大型矩阵是低秩的，可以用两个小矩阵的乘积来表示，从而节省存储空间。
   2. 推荐系统：用户-物品评分矩阵通常是低秩的，可以用矩阵分解（如SVD）来预测缺失的评分。
   3. 图像处理：图像可以表示为矩阵，低秩矩阵近似可以用于去噪或压缩。
8. 矩阵的秩还与线性方程组的解有关。对于一个线性方程组`Ax=b`，矩阵A和增广矩阵`A|b`的秩决定了方程组的解的情况：
   1. 如果rank(A) = rank(A|b) = n（n为未知数的个数，也就是A的列数），有唯一解。
   2. 如果rank(A) = rank(A|b) < n，有无穷多解。
   3. 如果rank(A) < rank(A|b)，无解。相当于有最小二乘解，但不一定唯一。
   4. 对于低秩矩阵A（rank(A) = r < n），如果`Ax=b`有解，则解空间维度是`n-r`。

9. 矩阵的低秩近似（Low-Rank Approximation）是指用一个秩更低的矩阵$\hat{A}$来近似原始矩阵A，目的是在保留主要信息的同时减少数据复杂度、去除噪声或降低计算成本。
10. 定义：给定矩阵$A\in R^{m\times n}$，假设$rank(A)=r$，其秩为k（$k≤r$）的低秩近似$\hat{A}$满足：$\hat{A}=\arg\min_\limits{rank(B)\le k}||A-B||$，其中范数为Frobenius范数（平方误差和）或谱范数（最大奇异值）。也就是说$\hat{A}$是所有秩不超过k的矩阵中，与A的Frobenius范数误差最小的矩阵，最优性由Eckart-Young 定理保证。
11. SVD是低秩近似的核心工具。$A=U\Sigma V^T=\sum_\limits{i=1}^r\sigma_iu_iv_i^T$，构造$\hat{A}_k=U_k\Sigma_kV_k^T=\sum_\limits{i=1}^k\sigma_iu_iv_i^T$，$U_k$和$V_k$是由前k个奇异向量组成的，$\Sigma_k$是由前k个奇异值构成的对角矩阵。
12. 低秩近似的功能：
    1. 一张1000×1000的图片通过SVD保留前50个奇异值，只需存储1000×50+50+50×1000个数值，而非原始的一百万个像素。
    2. 小的奇异值通常对应噪声或次要信息，截断后可以提升信噪比（如PCA去噪）。
    3. 秩矩阵乘法、求逆等操作复杂度显著降低。
    4. 提取主要特征（如主成分分析本质上是SVD的低秩近似）。
13. 若A本身不是低秩的，近似会引入误差，需权衡精度与复杂度。
14. 
15. 
16. 
17. 


# 稀疏矩阵

1. 稀疏矩阵可以高效存储具有大量零的`double`或`logical`数据。而全（或密集 ）矩阵将每个元素存储在内存中，无论其值如何。稀疏矩阵仅存储非零元素及其行列索引。使用稀疏矩阵可以显著减少数据存储所需的内存量，通过消除对零元素的操作来减少计算时间。

2. 稀疏运算的计算复杂度与非零元素的数量`nnz`成正比。还与矩阵的行列大小线性相关，但与矩阵行列乘积无关。相当复杂的运算（例如稀疏线性方程组的解）的复杂性涉及排序和填充等因素。一般来说，稀疏矩阵运算所需的计算机时间与非零量的算术运算次数成正比。

3. 所有内置算术、逻辑和索引运算均可应用于稀疏矩阵，或稀疏矩阵和稠密矩阵的混合。稀疏矩阵上的运算返回稀疏矩阵，稠密矩阵上的运算返回稠密矩阵。

4. 如果S是稀疏矩阵，则`chol(S)`也是稀疏矩阵，`diag(S)`是稀疏向量。列函数（例如`max`和`sum`）也会返回稀疏向量，即使这些向量不包含零元素。如果S为稀疏，F为满的，则`S+F`、`S*F`和`F\S`为满的，而`S.*F`和`S&F`为稀疏的。使用`cat`函数或方括号的矩阵拼接会为混合操作数产生稀疏结果。

5. matlab以压缩稀疏列格式存储稀疏矩阵，这样支持高效的列切片，快速的矩阵和向量乘法。

6. 创建稀疏矩阵和预分配空间：

   ```matlab
   >> S = spalloc(5,3,6); %创建一个大小为5×3的全零稀疏矩阵S。有空间容纳6个非零元素，预分配的空间，如果后续非零元素超过了这个值，则会继续自动分配，但是不会自动缩小空间。
   >> S(1:2,1:2) = magic(2) %稀疏矩阵只会输出非零元素的位置和值，而不会显示整个矩阵
   S =
   %输出的元素按列排序，反映了内部数据结构
      (1,1)        1
      (2,1)        4
      (1,2)        3
      (2,2)        2
   >> full(S) %返回矩阵的稠密等价形式
   ans =
        1     3     0
        4     2     0
        0     0     0
        0     0     0
        0     0     0
   >> nnz(S) %当前有4个非零元素
   >> nzmax(S) %最多存储6个非零元素
   >> numel(S) %返回矩阵中的元素个数，也就是mxn=15
   >> spy(S) %绘制系数矩阵的稀疏模式图，如下图所示，非零元素用一个圆点表示
   >> spones(S) %将非零稀疏矩阵的非零元素替换为1
   >> issparse(S) %判断矩阵是否为稀疏类存储的，这里并非检查密度
   >> nonzeros(S) %将稀疏矩阵中的非零元素输出成一个列向量，结果为[1;4;2;3]。
   >> spfun(@exp,S) %将指定函数exp应用于非零稀疏矩阵元素。
   ```

7. <img src="Matlab.assets/image-20250416001124793.png" alt="image-20250416001124793" style="zoom:50%;" />

8. 对稀疏矩阵进行赋值仍然是一个相对昂贵的操作，如果可以轻松地用以下方法之一替代：

   1. 调用`sparse`或`spdiags`函数，一次性赋值完毕。

   2. 一次性将多个矩阵组装来初始化一个稀疏矩阵。

9. find操作：

   ```matlab
   >> find(S) %将矩阵当作一维数组，返回非零元素的位置，结果为[1;2;6;7]。可以使用find(~S)来寻找零元素的位置。
   >> find(0<S & S<=2) %对于稀疏矩阵通常要设置0<S，否则会找到大量零元素的位置。结果为[1;7]
   #要获取X中满足条件X<5的元素，请使用X(X<5) 。避免使用X(find(X<5))，这些函数调用不必要地在逻辑矩阵上使用find。
   >> [row,col,v] = find(S) %相当于sparse(row,col,v,size(A))
   ```

10. 提取非零对角线并创建稀疏带和对角矩阵

   ```matlab
   %创建三对角矩阵
   Bin = repmat([1 -2 1],6,1)
   Bin =
        1    -2     1
        1    -2     1
        1    -2     1
        1    -2     1
        1    -2     1
        1    -2     1
   A = spdiags(Bin,-1:1,6,6);full(A)
   ans =
       -2     1     0     0     0     0
        1    -2     1     0     0     0
        0     1    -2     1     0     0
        0     0     1    -2     1     0
        0     0     0     1    -2     1
        0     0     0     0     1    -2
   %从矩阵中提取所有非零对角线及其编号，这种适合用于带状（不一定非得稀疏）矩阵。
   >> A = [0     5     0    10     0     0
           0     0     6     0    11     0
           3     0     0     7     0    12
           1     4     0     0     8     0
           0     2     5     0     0     9];
   >> [Bout,d] = spdiags(A)
   Bout = %第1列为第一个非零对角线（即-3）的值，由于是-3，因此前面要补3个零，然后才是1和2。
        0     0     5    10
        0     0     6    11
        0     3     7    12
        1     4     8     0
        2     5     9     0
   d = %一共4条对角线有非零元，编号分别为-3,-2,1,3
       -3
       -2
        1
        3
   %提取特定对角线
   >> A = randi(10,5,5)
   A =
       10     5     8     1    10
        7     2     5     6     5
        1     1     5     3     3
        1     8     1     9     3
        3     4     1     9     6
   Bout = spdiags(A,[-1 0 1]) %三条对角线
   Bout =
        7    10     0
        1     2     5
        1     5     5
        9     9     3
        0     6     3
   ```

11. 为了使得`Bout`得所有列具有相同的长度，`A`的其他非零对角线会在`Bout`中相应的列中添加额外的零。对于`m×n` 矩阵（`m < n`），规则如下，当`m ≥ n`时，结果相反：

    1. 对于非零得主对角线，不进行补零（如`Bout`得第3列）。

    2. 对于主对角线下方的非零对角线，会在列顶部添加额外的零（如`Bout`的前2列）。

    3. 对于主对角线上方的非零对角线，会在列底部添加额外的零（如`Bout`的最后1列）。

12. 创建单位稀疏矩阵：

    ```matlab
    S = speye(4,8); %4x8的矩阵，主对角线为1，其余均为0。
    R = speye(S);  %创建一个尺寸和S相同的单位稀疏矩阵。
    ```

13. 随机数填充的稀疏矩阵，非零元素的位置和值都是随机的。

    ```matlab
    S = sprand(50,10,0.1); %50x10尺寸，密度为0.1，即有大约50个元素非零。
    nnz(S) %结果为46
    R = sprand(S); %创建和S同尺寸的，同样稀疏模式的矩阵R，但是元素取值是随机的，即两个矩阵的spy结果相同。
    R = sprand(50,10,0.2,0.25); %50x10，密度为0.2，倒数条件数为0.25。
    cond(full(R)) %结果为4.000000000000001，不能直接对稀疏矩阵R使用cond函数，会报错。
    %如果倒数条件数rc是一个长度为n的向量，则R具有特征值rc。因此，如果rc是一个正（非负）向量，则R是一个正（非负）定矩阵。无论哪种情况，R都是通过对具有给定特征值或条件数的对角矩阵进行随机雅可比旋转生成的。它具有丰富的拓扑和代数结构。
    ```

14. `sprand`被设计来生成大尺寸小密度的稀疏矩阵，如果尺寸较小，或密度较大，则产生的结果中比预期计算出来的零要少的多，也就是密度小于预期值。从下面的例子可以看出：

    ```matlab
    >> S = sprand(50,10,0.1);nnz(S) %47，密度为0.094
    >> S = sprand(50,10,0.2);nnz(S) %92，密度为0.184
    >> S = sprand(50,10,0.4);nnz(S) %163，密度为0.326
    ```

15. `sprandn`，用法和`sprand`完全相同，不同的是它使用`randn`正太分布随机数生成器，而非`rand`均匀分布随机数生成器。可以使用rng函数控制生成器。

16. `sprandsym`生成对称的稀疏矩阵。

17. 使用sparse创建稀疏矩阵：

    ```matlab
    >> A = eye(10000);
    >> S = sparse(A); %将普通矩阵转化为稀疏矩阵格式来存储
    >> whos
      Name          Size                   Bytes  Class     Attributes
    
      A         10000x10000            800000000  double              
      S         10000x10000               240008  double    sparse 
    >> sparse(5,3) %创建一个5x3的全零的稀疏矩阵
    >> i = [3 3 5 5]; %行数组
    >> j = [2 4 2 2]; %列数组
    >> v = [5 8 9 3]; %值数组
    >> S = sparse(i,j,v,8,8) %尺寸为8x8。
    S =
    
       (3,2)        5
       (5,2)       12  %sparse具有累积行为，重复位置的赋值会叠加，9+3=12
       (3,4)        8
    ```

18. `spconvert`可以从外部文件导入到matlab中，并生成稀疏矩阵

    ```matlab
    % 创建一个ASCII文件uphill.dat，内容如下。通常会故意让文件的最后一行包含具有0值的矩阵所需大小（由于会累积，所以不会改变矩阵的值）。这种做法可确保转换后的稀疏矩阵具有想要的尺寸。
    1    1    1.000000000000000
    1    2    0.500000000000000
    2    2    0.333333333333333
    1    3    0.333333333333333
    2    3    0.250000000000000
    3    3    0.200000000000000
    1    4    0.250000000000000
    2    4    0.200000000000000
    3    4    0.166666666666667
    4    4    0.142857142857143
    4    5    0.000000000000000
    %加载并转换
    load uphill.dat %会产生一个uphill的11x3的double数组
    H = spconvert(uphill) #H是4x5的稀疏矩阵，如果没有.dat文件的最后一行，则H会为4x4的。
    H =
    
       (1,1)      1.000000000000000
       (1,2)      0.500000000000000
       (2,2)      0.333333333333333
       (1,3)      0.333333333333333
       (2,3)      0.250000000000000
       (3,3)      0.200000000000000
       (1,4)      0.250000000000000
       (2,4)      0.200000000000000
       (3,4)      0.166666666666667
       (4,4)      0.142857142857143
    ```

19. 

20. 二阶差分算子可以用矩阵来表示，将离散的二阶微分运算编码为矩阵，便于利用线性代数工具进行数值计算，广泛应用于科学计算和工程问题中。

    ```matlab
    
    
    
    ```

21. 在求解偏微分方程（如泊松方程$\nabla^2u=f$）时，离散化后的问题转化为线性方程组$Au=f$，其中$A$​就是二阶差分矩阵。

22. 在离散情况下（如有限差分法），二阶差分用于近似函数的二阶导数。对于一维函数$u$在均匀网格点$x_i$上的值$u_i$，中心二阶差分公式为：$\nabla^2 u_i=(u_{i+1}-2u_i+u_{i-1})/h^2$。

23. 将二阶差分作用在所有网格点上时，可以将其表示为矩阵乘法。例如，对n个内部网格点（边界条件固定时），二阶差分算子对应一个n×n矩阵：

24. $$
    A = \frac{1}{h^2} 
    \begin{bmatrix}
    -2 & 1 & 0 & \cdots & 0 \\
    1 & -2 & 1 & \ddots & \vdots \\
    0 & \ddots & \ddots & \ddots & 0 \\
    \vdots & \ddots & 1 & -2 & 1 \\
    0 & \cdots & 0 & 1 & -2
    \end{bmatrix}
    $$

    

25. 不同边界条件（Neumann、周期性）会修改矩阵的结构。

26. ![image-20250416151625062](Matlab.assets/image-20250416151625062.png)

27. 可以使用以下两种方式对矩阵的行列进行重新排序：

    1. 置换矩阵`P`对`S`的行作用为`P*S`；对`S`的列作用为`S*P'`。

    2. 置换向量`p`是包含`1:n`置换的满向量，对`S`的行作用为`S(p,:)`，；对`S`的列作用为`S(:,p)`。

    3. 例子：

       ```matlab
       >> p = [1 3 4 2 5]; %
       >> I = eye(5,5);
       >> P = I(p,:) %通过置换向量生成对应的置换矩阵，按照p对单位矩阵的行进行置换。
       P =
            1     0     0     0     0
            0     0     1     0     0
            0     0     0     1     0
            0     1     0     0     0
            0     0     0     0     1
       >> e = ones(4,1); %e为[1;1;1;1]
       >> S = diag(11:11:55) + diag(e,1) + diag(e,-1)
       S =
           11     1     0     0     0
            1    22     1     0     0
            0     1    33     1     0
            0     0     1    44     1
            0     0     0     1    55
       >> S(p,p) == P*S*P' %结果相等。
       ```

28. 置换矩阵是正交矩阵，即`P*P'=I`。

29. 置换矩阵和置换向量的相互转换：

    ```matlab
    p = [1 3 4 2 5];n = 5;I = speye(n);
    %行置换矩阵
    Pr = I(p,:);
    pr = (Pr*(1:n)')';
    %列置换矩阵
    Pc = I(:,p);
    pc = (1:n)*Pc
    ```

30. 随机的置换向量：

    ```matlab
    randperm(6)   %生成1到6的整数的随机排列，结果可能为[5 1 2 3 4 6]
    randperm(8,4) %生成从1到8中随机选择（不重复，也称为无放回抽样）的四个整数的随机排列。可能为[6 4 7 3]。
    %randperm(n)和randperm(n,n)均会生成从1到n的整数排列，但它们可以对排列赋予不同的随机顺序，也就是结果不同。对于较大的n，randperm(n,n)更快。
    ```

31. 矩阵的重新排序需要对行和列应用相同的置换操作，也就是`S(p,p)`或`P*S*P'`。这个操作相当于将图中的节点编号按照置换序列p进行重新排序。

32. 重新排序矩阵的列通常可以使其LU或QR因子变得更稀疏，这样可以节约存储空间，较少计算次数。 重新排列行和列通常可以使其Cholesky因子更稀疏。矩阵的重新排列，对于有限元就是节点重新编号。

33. 最简单的重新排序是按非零计数对列进行排序。对结构非常不规则的矩阵来说，这有时是一个很好的重新排序。特别是如果有很大行或列的非零计数的变化。

34. `colperm`函数计算一个排列，该排列按矩阵每列中非零元素的数量从小到大的顺序排列。

    ```matlab
    
    ```

35. 有时重新排序的目的是为了减小矩阵的带宽或轮廓（profile），例如逆Cuthill-McKee排序。它不能保证找到最小的带宽（因为这个问题是NP完全的），但通常可以做到。`symrcm`实际上作用于对称矩阵`A + A'`的非零结构，但其结果也适用于非对称矩阵。这种排序对于来自一维问题或某种意义上细长问题的矩阵很有用。

36. CM算法本质上就是一种BFS（宽度优先搜索）算法，选择一个根节点根据图中各节点与根节点的距离来得到一个图的遍历。后来Alan George在此基础上改进出Reverse Cuthill-Mckee算法，即把CM算法的遍历顺序倒过来写，并证明了RCM得到的结果至少不会比CM的坏。更重要的是他给出了一个选择起始点的方法。

37. 图中的一个节点的度是指该节点的连接数。如果将矩阵看作图的邻接矩阵（adjacency matrix），则矩阵的非零元$A_{ij}$表示$i$节点和$j$节点相连。非对称矩阵用有向图表示，即$i$指向$j$的边与$j$指向$i$的边不同，对称矩阵用无向图表示。可以将元素的取值当作边的权重，这样普通的非对称矩阵可以用有向加权图表示。

38. 近似最小度算法基于以下条件这些度数在高斯消去法或乔列斯基分解法过程中是如何改变的来生成重新排序的排列。这是一种复杂而强大的算法，通常会导致比其他大多数算法更稀疏的因子，包括非零计数列和反向Cuthill-McKee方法。因为跟踪每个节点的度数非常耗时，近似最小度数算法使用近似度数，而非精确度数。

    ```matlab
    symamd — 与对称矩阵一起使用。
    colamd — 用于非对称矩阵和 A*A' 形式的对称矩阵，或 A'*A 。
    spparms %更改与算法细节相关的各种参数
    ```

39. 与近似最小度排序类似，嵌套剖分排序算法（`dissect`）也将矩阵视为图的邻接矩阵。该算法通过将图中的顶点对折叠在一起来把问题简化为更小的尺度。在对小图进行重新排序后，然后算法应用投影和细化步骤将图形扩展，恢复到原始大小。该算法能够生成高质量的重新排序，并且与其他重新排序技术相比，在有限元矩阵中表现尤为出色。

40. 稀疏矩阵的LU分解：

    ```matlab
    [L,U,P] = lu(S); %返回值都是稀疏格式的。矩阵满足P*S = L*U，其中L为单位下三角，U为上三角。
    %lu函数通过部分选主元高斯消去法得到因子L，U，P。其中置换矩阵P就记录了部分选主元的过程。置换矩阵P只有n个非零元素。与稠密矩阵一样，[L,U] = lu(S)返回置换的单位下三角矩阵和上三角矩阵，其乘积为S 。lu(S)本身返回单个矩阵中的L和U没有选主元的信息。
    
    
    
    ```

41. 

42. 

43. 

44. 

45. 

46. 

47. 

48. 

49. 

50. 