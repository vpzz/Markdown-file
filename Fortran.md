# 基础

1. 早期被称为FORTRAN，是Formula Translation的缩写。后来被收录入字典中，变成了Fortran，从Fortran90开始。

2. Fortran的语法规范的版本：F66→F77→F90→F95→F2003→F2008。

3. 在1956年由IBM发明，是第一个高级语言。可以像数学书中的公式一样方便地在Fortran中定义数学公式。Fortran的程序员更习惯称自己为数值算法工程师。

4. 1978年ANSI制定了Fortran77标准，1980年被ISO接受为国际标准。Fortran77还不是完全结构化的语言，但是由于增加了结构化语句，也可以进行结构化编程。此外还扩充了字符串处理功能，使得Fortran可以应用于非数值计算领域。

5. F77中一行只能写一个语句，如果一行写不下，可以用&来续行。F90中可以使用；将两行并为一行，使一行包含多个语句。

6. F77中以c，C或*开头的行都是注释行，整行都是注释。F90中支持注释一行的一部分，! 后面到行尾是注释的内容。

7. 早期的计算机必须使用卡片将程序输入，卡片类似于表格，一般是12行80列，也就是Fortran77中使用的固定格式。一张卡片只能表示源代码的一行。在上机算题时，将穿好孔的卡片按顺序放入卡片输入机，启动机器，就将卡片上的信息输入计算机了。

8. Fortran77的80列分为4个区域：

   1. 第1-5列，为标号区域，可以填写1-5位的整数，也可以没有，标号区域内的空格不起作用。标号之间没有顺序要求。此区域内不得出现标号以外的内容，注释除外，注释行必须顶格为c，C或*。

      ```fortran
      !以下三种都一样，都表示100
      100
      10 0
        100
      ```

   2. 第6列，续行区，如果某行的第6列为一个非空格且非零的字符，则表示该行为上一行的续行。这由预处理器来处理。F77允许一个语句有19个续行(即一个语句最多可以写成20行)。有的程序中第6列上用“l”，“2”，…表示该行是第1个或第2个续行，但用数字字符容易与第7列的数字形成连续的数字串而引起错觉，故最好使用固定的特殊字符。

      ```fortran
            a
           } =1. !因为这行的第6列为}，因此续上一行，相当于 a =1
      	m    ! 使用tab键，可以直接绕过续行
           # =4
      ```

   3. 第7-72列，语句区域，不要求顶格书写，

   4. 第73—80列，注释区域，在卡片输入法时代，程序员一般利用此8列为程序行编序号以便查找

9. 早期的Fortran代码不允许小写，所以老的代码都是全大写的。$和?在Fortran代码中没有确切的意义。

10. 在语句名和变量名中间不能有空格。需要空格的地方必须有一个以上空格，==，<= 不能写成 = =，< =，这与F77有很大不同之处，因为F77的设计中将编译源程序的空格忽略。

11. Fortran源代码中允许的字符：

    ```fortran
    英文字母   ：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
    阿拉伯数字 ：0 1 2 3 4 5 6 7 8 9
    特殊符号   ：空格 = + - * / ( ) , . ': " ! % & ; < > $ ? _ (双引号之后的为F90中新增的字符)
    ```

12. 1991年，ANSI制定了Fortran90标准，同年被ISO接受为国际标准。该标准废弃了过时的严格的源程序书写格式，改善了语言的正规性，并提高了程序的安全性，功能有更大的扩充，是一个现代程序设计语言。整个Fortran77成为Fortran90的严格子集。Fortran90并没有删去任何Fortran77的功能，而只是将某些功能看成是将要摒弃的。

13. 标准还允许F90扩充进各国文字，各种专业用符号，这要看厂商装入的编译系统是否支持这些字符的使用

14. Fortran95增加了许多并行计算的功能。在Fortran95中则删去了一些在Fortran90中被声明为过时的特性。新写的程序尽量避免使用过时的用法。

15. 高性能Fortran语言(HPF)是Fortran90的一个扩展子集，主要用于分布式内存计算机上的编程，以减轻用户编写消息传递程序的负担。Fortran90之后，程序员在编程时可有目的的控制并行化。

16. Fortran 90是现代Fortran的第一个版本。

17. Fortran90和Fortran2003都是大更新，Fortran95和Fortran2008都是小更新。

18. Fortran90的现代特性有：

    1. 加强了程序的可读性、可维护性。

    2. 淘汰了所有的转移语句，用新的控制结构实现选择分支与循环操作，使程序结构化。

    3. 增加了结构块、模块及过程的调用灵活形式，使程序易读易维护，新的模块装配取代了Fortran77的许多旧语句，使程序员可以清晰明确地定义全局数据

    4. 增加了新的数据种别 kind 说明，提高了Fortran程序的移植性。

    5. 引进了许多对数组的操作，使得可以像操作变量一样操作数组，使数组的并行化运算成为可能。

    6. 增加了适于操作数据结构的派生类型，提高了文字处理功能。

    7. 增加了动态存储功能，加强了它在数值计算领域中应用的威力

    8. 使用新的编程形式，减少了烦琐与格式束缚，接近自然语言与公式演算。

    9. 允许在字符数据中选取不同kind，在字符串中可使用各国文字（例如汉字），还可任意使用化学、物理、数学的各种专业字符。

19. F90的一行为132列，允许最多有39个续行。只需要在前一行的末尾添加一个&即可，后一行的开头不用添加&，添加了也没事。如果字符串被续行拆分开，则在后一行的开始位置也要加&号。

    ```fortran
    Program main
        Implicit None
        character (10) ::str1
        str1 = "abc&
        &   d"    ! &后面的3个空格还是有效的
        print *, len(trim(str1)) !结果为7，即abc三个空格d
    End Program
    ```

20. 一些关键字允许两种写法，例如：

    ```fortran
    GOTO !GO TO
    ELSEIF !ELSE IF
    ENDDO  ! END DO，类似的还有PROGRAM, FUNCTION, MODULE, SUBROUTINE
    ```

21. Fortran矩阵运算强大，自带复数运算。语法严格，适合于科学计算，并行计算效率高。

22. F90相对于F77，增加了动态数组，模块，结构体等。F95相对于F90只有小范围的提升，删除了些过时的语法。F2003相对于F95，增加了面向对象的内容。

23. C语言主要是用于微机上的廉价开发，而Fortran的目的是为了产生高效最优化运行的可执行程序。用Fortran编写的大型科学计算软件较C语言编写的通常要快一个数量级。Fortran具备处理相应问题的标准并行化语言，其独特的数组操作充分体现了它的先进性。

24. Fortran在运算密集型的问题中，性能极其恐怖，未加任何优化，性能超过C++的3倍。可能是因为：默认即可充分利用到Simd向量化(本机的AVX指令集)。而C++即使启用了Intel的向量化编译(Intel默认是启用的)，因为复杂的语法也很难充分实现自动向量化。需要加入向量化编译指令，如#program simd 等，甚至需要手工编码向量化(如OpenCV中的优化实现)。这样程序优化的工作量和程序复杂度将会大为提升。

25. 简单的函数，符号计算：

    ```fortran
    Program main
        Implicit None
        integer :: f, x
        f(x) = x**5+6*x**4+2*x**3+x**2+4
        x = 1
        print *, f(x) !结果为14
    End Program
    ```


# 源代码结构

1. 早期的Fortran使用固定格式 fixed format 编写源代码，从F90开始推荐使用自由格式 free format，从F2003以后，标准废除了固定格式（虽然编译器还支持），推荐使用自由格式，使用何种格式不会影响编译后的结果。

2. 推荐书写 Implicit None，可以避免很多错误。

3. 编译器会通过源文件的后缀名来自动分辨其使用的语法格式，也可以手动指定。

4. 同一个工程中，两种格式的源文件可以混用。可以使用如下工具来将固定格式的代码转化为自由格式的：F77toF90，FIXCON，plusFORT等。

5. ![image-20210507003214795](Fortran.assets/image-20210507003214795.png)

6. 固定格式的代码中的tab在不同的系统会编辑器中会被解读为不同长度的空格，会造成对其错乱。

7. 源代码的组织：语句→程序单元→模块（不是必须的，F90后才出现）→程序。

8. 程序单元是指执行某一特定任务的具有一定独立性的代码区域。存在的目的是为了提高代码的重用性。不同程序单元之间的变量是不互通的，每个程序单元中都应有Implicit None。

9. 常见的程序单元：

   1. 主程序（main program），由系统调用，包含程序入口点。第一条语句不能是SUBROUTINE，FUNCTION，MODULE和BLOCK DATA。每个完整的Fortran程序必须有且仅有一个主程序。
   2. 过程（procedure）：
      1. 子例行程序(subroutine)，只是没有返回值的函数。
      2. 函数(function)

      3. 模块 = 一组程序单元 + 一组相关的变量。

   3. 块数据单元：Block Data，用来对有名的公用块的数据对象规定初始值。常用于定义全局常数和全局初始化，已经被F90中的module和use取代。
   4. 内部过程：Contains，包含在模块，主程序内部。不能被其他过程调用，只能被定义的过程调用。

10. 主程序结构：

    ```fortran
    [PROGRAM  程序名]       !语句可省略
    .....
    END [PROGRAM [程序名]]  !END必须有
    ```

11. 任何程序单元都不能调用主程序。主程序和模块中定义的函数都要放在Contains中。

12. 在F77中，—个源文件可以包含一个主程序和几个分别独立的函数或子程序（相当于F90中的外部过程）。在F90中，可以将若干个过程用CONTAINS结构包含在主程序里，它们与宿主程序单元共享变量名。

13. 在宿主中不要定义子程序名和函数名的类型，也不能指定它们是有EXTERNAL属性。宿主中的变量名和数组名等在内部过程中有效，有相同的数值。但同一名称若在内部过程中又进行了类型声明，则此名被视为其过程中的独立变量，无相同的数值，外部的名称被暂时覆盖。

14. 写成内部过程的子程序有一个重要特征，即它们通常没有说明语句。因为它们使用到的变量等实体的说明已统一出现在主程序说明部分中。内部过程的第二个重要特征是它们一般没有哑元。主程序调用时也不需要哑实结合，因为可以直接引用。

15. 内部过程是包含于外部过程、模块或主程序单元之中的程序单元。内部过程中不能再包含内部过程，即F90不是过程嵌套式语言

    ```fortran
    SUBROUTINE语句
        [说明部分]
        [可执行部分]
    [CONTAINS
        内部过程]
    END [SUBROUTINE子程序名]
    ```

16. 如果过程是一个独立于主程序单元的程序单元，它就是外部过程。外部过程也可以通过非Fortran语言(通常是汇编语言)来定义。

17. 主程序名和外部过程名和公共块名都被认为是全局名称。全局名称在一个程序中必须是唯一的

18. 如果要用内在（intrinsic）过程名作为其它过程的实元，需要用INTRINSIC语句或属性加以声明。内在过程名必须是内在过程的通用名或专用名，只有专用名才可以在其作用范围单元中作为一个过程的实元。一个内在过程名只能在INTRINSIC语句中出现一次，并且不能同时出现在INTRINSIC语句和EXTERNAL语句中。

19. 各程序单位(除模块程序单位外)的形式基本相同，共分两部分：前面是说明部分，后面是执行部分，两者不允许交叉，

20. F90中程序单元的组成和顺序如下：

    1. 起始语句，例如program，function，subroutine，block data等。

    2. 变量和函数定义

    3. 执行语句，DATA语句，Format语句

    4. END语句

21. 在F90中，Use 其他模块要在本程序单元的Implicit None前。

22. 整个程序中只能有一个PROGRAM，一个BLOCK DATA，可以有多个各自命名的FUNCTION和SUBROUTINE过程。

23. Fortran中的语句可以分为3类：

    1. 声明语句，编译时就被执行了，例如下图中蓝色的部分。Integer :: v=2是声明语句，因此多次调用函数，并不是每次进入函数后，v都会被赋值为2。==不太确定==
    2. 执行语句，在运行时才会被执行，下图中倒数第5到倒数第2行之间。
    3. 结构语句，用户对代码划分结构用的，大多是语法内容，下图中第一和最后一行。

24. 例子：

    ```fortran
    subroutine Fcode_video_test(a,x) !结构语句
    	use MyModule
    	implicit none  !结构语句
    	real, parameter :: PI = 3.1415927
    	real, intent(in) :: a
    	real, intent(out) :: x
    	integer :: v = 2, N = 30, i
    	x = 0.0
    	do i = 1, N
    		x = x+sin(i*PI/a)
    	end do
    end subroutine  !结构语句
    ```

25. Fortran77中，data语句被用来专门给变量赋予初值，在DATA语句中赋值的变量都有SAVE属性，除非变量名又出现在COMMON语句中。

    ```fortran
    DATA 变量名表1/初值表1/[[,]变量名表2/初值表2/…] !变量名表可以是隐DO循环，初值表中的常数之间须用逗号分开，重复的常数表值可以采用如下表示方法：重复次数*常数值
    !数值
    real ::A(10,10) !10*10的数组
    DATA A/100*1.0/ ! 对数组的内存空间直接进行初始化，所有元素都是1.0
    DATA A(1,1), A(10,1), A(3,3) /2*2.5, 2.0/  ! 给3个元素逐个初始化
    DATA ((A(I,J),I=1,5,2),J=1,5) /15*1.0/     ! 按隐DO循环初始化，第1到5列的第1,3,5行初始化为1.0
    !字符串
    character(10) name
    character(6) stars
    DATA name,stars /'Zhang Fei1','****1'/
    DATA name(1:5),name(6:10) /2*'HELPM'/ !如果出现对同一个变量的多次data初始化，只有第一个有效，所以此句无效
    ```

26. 块数据单元（BLOCK DATA）是一种为有名公用块中的变量定义初始值的一种程序单元，它只包含数据声明和初始值，不包含可执行语句。变量一般由data语句来初始化。公共块中命名的变量只能在块数据单元或某个过程中初始化一次，或只能由所有的过程完全一致地初始化。更好的编程法是用模块而不是块数据单元来声明和初始化变量。

    ```fortran
    BLOCK DATA[块数据名] !不能放在program或过程内部
    	[说明部分] !这里不能包含ALLOCATABLE，AUTOMATIC，EXTERNAL，INTENT，OPTIONAL，PRIVATE或PUBLIC等属性说明符
    END [BLOCK DATA[块数据名]]
    
    BLOCK DATA BLKDAT
        INTEGER S,X
        LOGICAL T,W
        DOUBLE PRECISION U
        DIMENSION R(3)
        COMMON /AREA1/R,S,U,T/AREA2/W,X,Y
        DATA R/1.0,2*2.0/,T/.FALSE./,U/0.214537D-7/,W/.TRUE./,Y/3.5/
    END BLOCK DATA BLKDAT
    ```

# 变量

1. F90程序中的数据都有三个特征：类型、种别、属性。

2. 5种基本数据类型，一种派生类型就是结构体：

   ```fortran
   integer   !整型
   real      !浮点数
   complex   !包含实部和虚部的有序对
   character !字符串
   logical   !逻辑型，存储布尔变量
   ```

3. 关键字和变量名都不区分大小写，但是推荐保持一致的风格。变量名以字母开头，可以包含字母，数字和下划线。Fortran77的名称最多6个字符，Fortran90可以有31个。Fortran没有规定保留字，因此可能出现变量名成

4. Fortran是强类型的语言，如果未显示声明变量的类型，则会按照隐式规则（以ijklmn开头的为整型，其他的为实型，也成为I-N规则）确定变量的类型，非常不安全，因此建议使用Implicit None，告诉编译器取消隐式规则，然后显式声明每个用到的变量。现代Fortran中认为implicit typing是一种不好的习惯，会导致bug。

5. 可以用IMPLICIT语句将某一字母开头的全部变量指定为所需的类型，还可以用一个IMPLICIT语句同时指定几种类型，不过已经不再推荐这么做了。IMPLICIT语句和类型说明语句应该出现在本程序单位中的所有执行语句之前，IMPLICIT语句又应在所有的类型说明语句之前：

   ```fortran
   implicit integer (A，C，T-V) !将以A,C,T到V开头的当作整数变量
   implicit integer (A，B)，real(I,K)，integer (X-Z)
   ```

6. 优先级从高到低位：显式的类型说明语句，implicit语句，I-N规则。

7. Fortran是静态类型语言，意味着所有变量的类型在编译时就固定了，运行时无法改变。

8. 变量的声明方式：

   ```fortran
   类型[(种别)][,属性] :: 变量名1(数组外形) [=初值],变量名2(数组外形) [=初值] !数组外形为各个变量私有的，种别和属性为共有的
   real(kind=8),parameter,private :: rVar = 20.0d0 !双冒号表示形容词的结束。只有在没有形容词时，才可以省略::。
   real(8),dimension(1:10) ::a,b !a和b都是数组
   real(8) ::c(1:10),d !c是数组，d不是
   character(len=32),intent(IN) :: cStr(5,8) !一个属性，一个形容词，一个数组外形(2个维度)
   integer,save :: n = 30, m = 40                  !多个变量名用逗号分隔。
   integer m                                       !最简形式，只有类型和变量名是不能省略的。
   integer :: n =40       !允许在声明的同时赋值，此时隐含了变量具有save属性(这种变量在过程调用之间会保持值)，此时双冒号不可省略。不过推荐将声明和初始化分开。
   ```

9. 一些不建议使用的变量声明：

10. <img src="Fortran.assets/image-20210507010133537.png" alt="image-20210507010133537" style="zoom:67%;" />

11. 每种属性说明都有专门的关键字，各属性关键字间用逗号分开，全部属性关键字写在kind之后，::之前，次序任意。属性也可以用于说明过程。

12. Visual Fortran常见的属性：

    ```fortran
    parameter !表示该变量的值在编译时确定，运行时无法修改，即常量化。可以将一些表示选项的数定义为整型常量，方便理解。
    save        !保存过程执行后其中的变量值，类似于C语言的static
    ALLOCATABLE !说明数组是动态分配的
    AUTOMATIC   !声明变量实在栈中，而不是堆中
    DIMENSION   !说明数组，需要带上维度，例如dimension(5,10)
    EXTERNAL    !说明名称为为外部函数
    INTENT      !说明形参的用意，例如intent(in)
    INTRINSIC   !说明名称是一个内部函数
    OPTIONAL    !说明该形参是可选的
    POINTER     !说明数据对象为指针
    PRIVATE     !说明名称仅限模块内访问
    PUBLIC      !说明名称可以再模块外被访问
    TARGET      !说明变量为目标
    VOLATILE    !声明对象为完全不可预测并在编译时无优化
    ```

13. kind是种别的意思，在F90中引入，用于表示同一种数据类型，但长度，精度或编码方式不同的代号，在编译时确定，受编译器的影响。对不同的数据类型，kind的含义也不同。

    1. 对于Integer，Kind值影响整数能表达的最大范围。

    2. 对于Real和Complex，Kind值影响实数的最大范围和最小精度。

    3. 对于Character，Kind值表示编码，通常为ASCII编码，因此一般不写。

    4. 对于Logical，Kind值表示长度，对逻辑型无影响。

14. 有了kind说明后，程序更易于移植。因为在不同的计算机系统上，同一种变量类型可以有不同的精度，因此当程序在另一种机子上运行时可能出现溢出或下溢。规定种别后可以避免这种情况的出现。国际标准FORTRAN90版本没有规定每个类型必须有哪些种别，具体的种别划分由FORTRAN软件开发商自行设置。

15. 一个变量必有一个种别，如果没有显式声明，则使用默认的。

16. F90标准没有规定浮点数的指数的允许范围和有效位数。

17. 字面值常量也有kind值，用后缀标注，这样在初始化带kind的变量时，不会造成精度丢失：

    ```fortran
    real(kind=8) :: a = 1.6_8
    0.87D-16       !将指数的E替换成了D，表示禁止说明种别值
    (4.7_8,5)      !实部kind为8，虚部为默认
    ```

18. 内置模块 iso_fortran_env 提供了通常32位和64位浮点数的kind参数

    ```fortran
    program float
        use, intrinsic :: iso_fortran_env, only: sp=>real32, dp=>real64 !分别为32和64位浮点数
        !use, intrinsic :: iso_c_binding, only: sp=>c_float, dp=>c_double 这样sp和dp在和C语言交互时就能兼容
        implicit none
        real(sp) :: float32
        real(dp) :: float64
        print *, sp,dp    !sp和dp都是整型常量，分别为4和8
        float32 = 1.0_sp  !对字面值常量使用显式后缀，总是推荐加上这个后缀
        float64 = 1.0_dp
    end program float
    ```

19. 推荐将所有基本类型变量的kind值放到一个模块中统一管理，使用的时候直接use该模块即可

    ```fortran
    module kind_parameter
       implicit none
       public
       ! (默认)单精度实数, 6位有效数字, 范围从 10^-37 到 10^37-1, 占用32位
       integer, parameter :: sp = selected_real_kind(6, 37)
       ! 双精度实数, 15位有效数字, 范围从 10^-307 到 10^307-1, 占用64位
       integer, parameter :: dp = selected_real_kind(15, 307)
       ! 四精度实数, 33位有效数字, 范围从  10^-4931 到 10^4931-1, 占用128位
       integer, parameter :: qp = selected_real_kind(33, 4931)
    
       ! char型整数, 范围从 -2^7 到 2^7-1, 占用8位
       integer, parameter :: i1 = selected_int_kind(2)
       ! short型整数, 范围从 -2^15 到 2^15-1, 占用16位
       integer, parameter :: i2 = selected_int_kind(4)
       ! 默认长度的整数, 范围从 -2^31 到 2^31-1, 占用32位
       integer, parameter :: i4 = selected_int_kind(9)
       ! long型整数, 范围从 -2^63 到 2^63-1, 占用64位
       integer, parameter :: i8 = selected_int_kind(18)
    end module kind_parameter
    ```

## Integer

1. 对于Integer来说，kind=1,2,4,8分别表示超短，短，正常（长），超长整型，默认为4。取值范围分别为有符号的8，16，32，64位整数。不同的编译器支持的kind值范围不同，含义也不同，有的编译器使用1 2 3 4来表示1 2 4 8。因此可以用Selected_Int_Kind()来获得表示参数位数所需的最小的kind值，提高代码的移植性。例如下面的代码中，当i=9时，函数输出为4，即使用4*8=32位整数可以表示9位十进制数。32位整数的最大值位2^31=2147483648≈21亿，而9位十进制数最大位999999999≈10亿，确实是可以用32位有符号整数表达。而10位十进制数则不够了，因此当参数为10时，结果为8。

   ```fortran
   Program main
   	Implicit none
   	Integer :: i
   	Do i = 1,20
   		write(*,*) i,Selected_Int_Kind(i) !参数i表示需要支持的最大数的十进制位数。
   	End Do
   End Program main
   !结果如下
   1           1
   2           1
   3           2
   4           2
   5           4
   6           4
   7           4
   8           4
   9           4
   10           8
   11           8
   12           8
   13           8
   14           8
   15           8
   16           8
   17           8
   18           8
   19          16
   20          16
   ```

2. ```fortran
   Program main
      Implicit none
      Integer, parameter :: KI = Selected_Int_Kind(9)  !不能使用变量来保存Selected_Int_Kind的返回值。否则下面的语句会报错。该函数在编译时就运行了。如果参数特别离谱，则会返回-1
      Integer(Kind = KI) :: i=0
      write(*,*) kind(i), i          !kind(i)返回变量i的kind值。结果为4  0
      write(*,*) huge(i)             !huge(i)返回变量i所能达到的最大值。结果为2147483647
   End Program main
   ```

3. 该函数在编译时就运行了。如果参数特别离谱，则会返回-1。

   ```fortran
   Integer, parameter :: DP=Selected_Int_Kind(40)
   write(*,*) DP     !DP为-1
   ```

4. 整型和整型运算的结果还是整型，整数和浮点数的运算结果为浮点数。因此有时需要将其中一个整数转化为浮点数：

   ```fortran
   1/2=0
   3/2=1
   -3/2=-1
   3/2.0=1.5
   
   real(dp) :: a
   a = real(3, dp) / 4  ! 结果a=0.75_dp
   a = 3 * 1.0_dp / 4   ! !或者给其中一个乘以1.0，结果同上
   ```

5. 函数传参时也会进行自动类型转换，高精度向低精度转换会丢失精度，低精度向高精度转换会引入误差

6. 定义二进制、八进制和十六进制整数常量（即BOZ字面值常量），但是只能用于DATA赋值语句中。

   ```fortran
   !二，八，十六进制分别以字母B，O，Z开头，后面都是跟定界符括起来的二进制位串(单双引号都可以)，定界符可以是撇号或括号(GFortran不支持括号)。
   integer ::x(3)
   data x /B'01111010',O'172' ,Z'7A'/  !都是122
   
   !在Compaq Fortran中，还可以这样定义非十进制数：数字#数字串，最前面的数字表示进制，省略式表示十六进制
   2#110 !等价于B'110'
   #a1   !等价于Z
   ```


## Real

1. 对于Real来说，kind取值有4,8,16分别表示32，64，128位存储。单精度，双精度，四精度，默认为单精度。它们可以表达的最大十进制位数分别为38，308，4932。同样也有Selected_Real_Kind()来帮助选择kind值。

   ```Fortran
   Integer, parameter :: DP=Selected_Real_Kind(p=14,r=50)  !参数p表示最少能表示15个有效数字，参数r表示最少能50个十进制位数。需要两者都满足才可以。
   !但该机型上不能提供满足要求的种别值时，它的返回值是：-1(当精度位数达不到时)，-2(当数值范围达不到时)，-3(两者都达不到时)
   !使用
   print *,PRECISION(2.8_8),RANGE(2.8_8) !结果为15,307，分别表示变量的kind能表示的最大精度和指数范围。
   Real(Kind=DP) :: r1=1.0_DP     !如果DP=8，也可以写成1.0_8
   DOUBLE PRECISION ::r2  !等价于real(kind = 8)
   ```

2. Complex是复数类型，实部和虚部都是按照浮点数来存储的。但是对于Real来说，Kind=8表示占用8个字节存储，而Complex(Kind=8)变量占用16个字节存储，因为有实部和虚部两部分。也使用Real的selected函数来确定Kind值。

3. 浮点数是有精度的，即有效数字。Fortran使用IEEE标准：

   1. 单精度格式，32位中，阶占8位，尾数占23位，符号占1位。具有23位二进制精度，因为$23\times log_{10}2=\approx 6.9$，具有6或7位十进制精度。即有些情况下具有6位，有些情况下具有7位有效数字。

   2. 双精度格式，64位中，阶占11位，尾数占52位，符号占1位。具有52位二进制精度，因为$52\times log_{10}2=\approx 15.6$​，具有15或16位十进制精度。

      ```fortran
      Program main
          Implicit none
          Integer, parameter :: DP = Selected_Real_Kind(p=14,r=50)
          Real(Kind=DP) :: r1 = 0.0_DP
          Write(*,*) Kind(r1),r1     !结果为 8 0.0000000000000000
          r1 = r1 + 1.6
          Write(*,*) Kind(r1),r1     !结果为 8 1.6000000238418579
          r1 = r1 + 1.6_DP
          Write(*,*) Kind(r1),r1     !结果为 8 3.2000000238418580。因为此处的1.6是默认的单精度，在和双精度数据相加前，会先提升至双精度再相加，提升精度中会引入额外的误差。例如1.60000到1.6000000238418579
      End Program main
      ```

4. 避免浮点数直接做==比较，应该用abs(a-1.3)<1.0e-5。浮点数不应做数组的下标，也不应做为循环控制变量。

   ```fortran
   Program main
       Implicit None
       real :: a !定义为单精度浮点数
       read *, a
       print *,"a = ",a
       print *, a == 0 !直接进行浮点数的判断，实际上是二进制位的逐位判断，不推荐
       print *, abs(a) < tiny(a) !tiny(单精度浮点数)为1.17549435E-38，有时这个条件过于严格，也可以自定一个界限，例如1e-10。
       print *,tiny(a)
   End Program
   !输入0时，567行输出为0.00000000 T T
   !输入0.0000时，567行输出同上
   !输入1e-37时，567行输出为9.99999991E-38 F  F
   !输入1e-38时，567行输出为9.99999935E-39 F  T
   !输入1e-45时，567行输出为1.40129846E-45 F  T
   !输入1e-46时，567行输出为0.00000000 T  T
   !输入2e-45时，567行输出为1.40129846E-45 F  T 可见这时误差达到了2倍
   ```

5. 浮点数的累加会造成误差的积累，因此应该多用乘法。

   ```fortran
   Program main
       Implicit none
       Real :: r1 = 0
       integer ::i
       do i=1,10
           r1 = r1 + 1.6
       end do
       Write(*,*) r1,10*1.6 !；累加的结果为16.0000019，乘法的结果为16.0000000
   End Program main
   ```

6. 函数也可能会放大误差，例如tan(x)，x在pi/2附近时，x**3也会放大误差。

7. 浮点数的范围，上溢和下溢：

   ```fortran
   Program main
       Implicit None
       real::a,b,c !单精度浮点数
       a=1.e-38
       b=1.e-40
       c=1.e-60 !编译时会提示 Real constant underflows its kind
       print *, a, 1./a  !9.99999935E-39   1.00000007E+38
       print *, b, 1./b  !9.99994610E-41         Infinity
       print *, c, 1./c  !0.00000000             Infinity
   End Program
   Program main
       Implicit None
       real(kind = 8)::a,b,c !双精度浮点数
       a=1.e-38_8
       b=1.e-40_8
       c=1.e-60_8
       print *, a, 1./a  !9.9999999999999996E-039   9.9999999999999998E+037
       print *, b, 1./b  !9.9999999999999993E-041   1.0000000000000000E+040
       print *, c, 1./c  !9.9999999999999997E-061   9.9999999999999995E+059
   End Program
   
   Program main
       Implicit None
       real(kind = 8) pi_d
       real pi_s
       print *, tiny(pi_s), huge(pi_s) !分别返回b所能容纳的最小/大的正数，即1.17549435E-38   3.40282347E+38
       pi_s =3.14159265358979_8 ! pi定义为单精度，但是赋值用双精度，会丢失精度
       pi_d  =3.14159265358979_8 ! 不会丢失精度，_8 的作用相当于 d0, 正确的方法
       pi_d=3.14159265358979d0 ! 正确的方法
       pi_s=3.14159265358979   ! 尽管=右侧为双精度，但无d0或_8，因此会丢失精度
       print *, 3.14159265358979_8   ! 直接打印双精度数3.1415926535897900
       print *, 3.14159265358979_4   ! 直接打印单精度数3.14159274
   End Program
   ```

## Character

1. 字符串类型，Character的kind只能是1，表示ASCII编码，通常不写。字符串可以用双引号(Fortran90支持)或单引号括起来。

   ```fortran
   CHARACTER[(LEN=整型字符长度表达式[,KIND=种别值])][,属性说明] :: 变量名表[=初始值]
   !在Fortran77的时代，使用两个连续的单引号来表示字符串中真正的单引号，但是中间不能有空格，这种方式在某些情况下不能被替代，例如当一个字符串内既要出现单引号又要出现双引号，就必须使用连续的单引号或双引号
   print *,"('I''m a"" boy')") !输出I'm a" boy
   print *, 'I''m a boy.' !输出，I'm a boy.
   print *, 'I' 'm a boy.' !会报错，这不是将两个字符串拼接到一起，拼接需要加上//
   print *, 'I' // 'm a boy.' !输出，Im a boy.
   !只用双引号也有上面的效果
   print *, "I""m a boy." !输出，I"m a boy.
   ```

2. 字符类型除了有kind外，还有一个额外的属性就是长度len，也写在类型后面的括号中，而且kind和len可以同时出现，长度必须有，kind可以省略，以下四种等价：

   ```fortran
   CHARACTER(LEN=12,KIND=1) :: A
   CHARACTER(KIND=1,LEN=12) :: A
   CHARACTER(12,1) :: A ! len在kind之前
   CHARACTER*12 :: A
   
   !长度也可以写成一个*号，表示长度暂不确定，待以后与程序中实际需要的长度相一致，此时必须具备parameter属性。
   CHARACTER(LEN=*),PARAMETER :: C_NAME='GIRL'  ! len(C_NAME)为4
   !括号内的长度是其后字符串的公共长度，如果想为某一变量单独指定长度，可以变量名后用*长度标出。
   CHARACTER(LEN=12) :: A,B*5   ! len(A)为12, len(B)为5
   ```

3. 声明字符串的方式，这和数组的方式不一样，数组中元素个数附属于变量名，这里字符个数是附属于character类型的，这一点可以通过字符串数组看出来，但是字符串也可以使用数组的索引方式，有一点区别就是：

   ```fortran
   character(len=12) :: Str1 = "www.fcode.cn"  !正好12个字符，可以省略len=
   integer :: A
   Str1(5:9) = "codef"    !此时Str1 = "www.codef.cn"  字符串切片，两侧都是闭区间,即[5,9]
   Str1(:3)  = "bbs"      !此时Str1 = "bbs.codef.cn"  [1:3]
   Str1(10:) = ""         !此时Str1 = "bbs.codef   "     会用空格补齐   [10:len(Str1)]
   A = len(Str1)          !结果为12，包括空格在内。
   A = len(trim(Str1))    !结果为9。trim函数的返回值为去掉末尾的空格后的参数字符串，不会改变原字符串。开头的空白不处理
   !字符串赋值
   character(len=4)::str1 =  'John' !如果len=3则会裁剪掉最后一个字符，如果len=5则多出来的字符为
   ```

4. 字符串类型并不是特殊的数组类型，因为虽然字符串获取子串的方式和一维数组获取切片的方式相同，但是对于单个元素的获取则不相同：

   ```fortran
   character(len=4)::str1 =  'John'
   integer ::arr1(4) = [1,2,3,4]
   print *, str1(2:2), arr1(2) !前一个不能替换成(2)，否则编译时会报错，提示函数str1没有被初始化，因此str1不是数组，arr1则两种方式都可以
   character(4)::str1(2) = ['John', 'Jobn'] !定义并初始化一个1维数组，有2个元素，每个元素都是一个长度为4字符串
   print *, str1(2)(3:3)  !结果为'b'，优先执行数组索引，然后执行字符串索引，因此str1(2)为第二个字符串
   !二者各有专用的获取长度的函数
   print *, len(str1), size(arr1)   ! len为字符串的长度，size为数组的元素多少，与维度无关。
   ```

5. 字符串数组：

   ```fortran
   character(len=4)::str1 =  'John'
   character ::str2(4) = 'John' !声明一个含有4个元素的数组，每个元素都是含有单个字符的字符串。这次赋值相当于每个元素都用'John'赋值，会导致四个元素都为'J'。需要用['J','o','h','n']或者(/'J','o','h','n'/)才能得到四个元素依次为'J','o','h','n'
   print *, size('John' == ['J','o','h','n']) !结果为4，比较的结果为布尔类型数组[.false., .false.,.false.,.false.]。用一个标量和一个一维数组比较，相当于该标量和数组的每个元素比较
   ```

6. ==诡异情况==：

   ```fortran
   print *, ['J','o','h','n'](1)   !会报错
   
   write(*,*) len(['J','o','h','n']) !结果为1
   ```

7. 字符串变量在定义时，必须有长度，一般是固定的，因此不需要\0字符来界定字符串的结尾。

8. 字符串和数字相互转化：==需要验证==

   ```fortran
   read("123",*)  a    !将"123"转化为数字，赋值给a。
   write(123,*) b      !将123转化为字符串，赋值给b。
   ```

9. 字符数组无法在所有位置都写入字符：

   ```fortran
   Program main
      Implicit None
      Character(Len=6) ::cStr
      cStr = "123456"  !编译通过,运行时不会报错
      Write(cStr,*) "123456"  !运行时会报错，写入5个字符就不会报错
      Write(*,*) cStr
   End Program
   ```

10. 字符串之间的操作符只有一个，就是并置符，可以将两个字符串拼接起来：

    ```fortran
    'John'//'Smith' !结果为 'JohnSmith'
    ```

11. 字符串赋值语句要求，两个kind值一致。当两侧长度不同时，右侧长了会截断，短了会填充空格。

12. 不同系统上允许的字符集合不同，同一个字符在不同系统上的排序号也不同。在字符串的比较中，Fortran是区分大小写的。

13. Fortran不支持转义字符，可以用char(n)来输入换行，tab等符号，可以使用ichar(chr)来将单个字符（gfortran限定）转化为整数：

    ```fortran
    'a' == char(ichar('a'))  !结果为.true.
    !char函数还有一个可选参数为kind值,默认为1,即ASCII，也可以使用achar来强制使用ASCII编码
    !ichar函数也有一个可选参数为kind值,默认为1,即ASCII，也可以使用iachar来强制使用ASCII编码
    ```


## Logical

1. Logical的kind范围通常和Integer相同，默认为4字节。任何kind值的逻辑型数据都只能表示真.true.，假.false.两种状态，实际上只要一位即可，因此也没有设置的必要，没有selected函数。

2. 关系运算符，会先计算运算符两侧的表达式的值，再计算关系运算的结果。关系表达式中关系操作符只准出现一次，例如3<x<7是错误的写法，这个和C语言还不一样：

   ```fortran
   ==  !等价于 .eq. 
   /=  !等价于 .ne. 判断是否不相等
   >   !等价于 .gt.
   >=  !等价于 .ge.
   <   !等价于 .lt.
   <=  !等价于 .le.
   !分为两种，算术关系表达式，字符关系表达式
   1+2 > 4 !结果为.false.
   "a" >"c" !结果为.false. 比较的是ASCII码值
   "abc" <"aba" !结果为.false. 逐个比较，直到遇见不同的字符，比较原理和C语言的strcmp类似但是不完全一样，如果两个字符串不一样长，则会给短的补齐空格再比较。
   'a ' == 'a' !结果为.true.
   'a ' >'a'//char(31) !结果为.true.，因为空格的ASCII值为32
   !还可以使用函数来进行字符串之间的比较
   lge('aa','ab') !判断'aa'是否<='ab'，类似的还有lgt,lle,llt
   ```

3. 逻辑运算符，操作数的求值结果必须都为逻辑值，操作数不会自动转为逻辑变量。一个逻辑表达式中可以包括多个逻辑运算符，优先级顺序为：.not. → .and. → .or. → .eqv. = .neqv。优先级相同的同或和异或，从左向右计算：

   ```fortran
   .not. !逻辑非
   .and. !逻辑与
   .or.  !逻辑或
   .eqv. !逻辑同或(等价)，相同为真
   .neqv !逻辑异或
   1 .and. .false !错误，1不是逻辑值，这一点和C语言不一样
   !注意，Fortran标准并没有规定，逻辑运算符要具备短路功能，因此不能假设它具有短路功能。因此对于如下代码，如果cs未分配内存，则即使mcs=0，使得第一个参数为假，也会计算cs(2,1)，从而触发段错误。
         if((mcs.ne.0).and.(cs(2,1).ge.0.d0)) then
            cyclicsymmetry=1
         endif
   ```

4. Fortran规定了运算符的优先级，先计算算术表达式的值，再求关系表达式的值，最后求逻辑表达式的值：

   ```fortran
   A.GE.0.0.AND.A+C.GT.B+D.OR..NOT..TRUE. !可以将关系运算符改写成符号，方便识别
   A >= 0.0 .AND. A+C > B+D .OR. .NOT. .TRUE. 
   !首先为所有的算术表达式加上括号:
   A >= 0.0 .AND. (A+C) > (B+D) .OR. .NOT. .TRUE. 
   !然后为所有的关系表达式加上括号:
   (A >= 0.0) .AND. ((A+C) > (B+D)) .OR. .NOT. .TRUE. 
   !最后变成了3个逻辑运算符的逻辑表达式，加上括号后为:
   ((A >= 0.0) .AND. ((A+C) > (B+D))) .OR. (.NOT. .TRUE.)
   ```

5. 逻辑值 .true.和.false.输出成字符串时，就是T和F。但是源代码中不能用T和F来代替。

6. == 和/=判断是否相等或不等。

# 运算

1. Fortran77允许使用四种表达式，其中关系表达式和逻辑表达式的结果都是布尔值：

   ```fortran
   1+2  !算术表达式
   1>2  !关系表达式
   .true .and. .false. !逻辑表达式
   "abc" !字符表达式
   ```

2. Fortran77的赋值语句有三类：算术赋值语句、逻辑赋值语句、字符赋值语句。

3. 不允许在算术量和非算术量(如逻辑型、字符型)之间进行算术运算。例如.true. + 1

4. 赋值语句会先计算右侧表达式的值，如果赋值语句两侧的类型不同，则会将右侧转化为左侧，再赋值。

5. Fortran中无大、中、小括号之分，一律用小括号。

6. 同一优先级的两个运算，乘方按“先右后左”，其它按“先左后右”原则。

   ```fortran
   x**y**z  !等价于x**(y**z)
   ```
   
7. 类型的转换是从左向右进行的，在遇到不同类型的算术量时才进行转换。

   ```fortran
   1/2*1.0  !结果为0，先计算1/2，结果为0，再将0转化为0.0进行计算
   ```


# 流程控制

1. F90明确提出了块的概念。块是作为单元看待的一个可执行构造的序列，可用于IF构造、CASE构造和DO构造。
2. 禁止从块的外部转入块的内部，可以在块的内部进行控制转移，也可以从块内转移到块的外部。这里的转义指的是goto。

## IF

1. IF条件判断：

   ```Fortran
   IF (Expression) ... !只有括号后的语句在IF的判断内。逻辑IF，又称为行IF，最常用在循环退出的条件中
   
   IF (Expression) THEN !块IF
   	...
   	... !对应的END IF之前的语句都在IF的判断内。
   	...
   END IF
   
   IF (Expression) THEN
   	...
   ELSE IF (Expression) THEN !IF和ELSE中间可以有任意多个ELSE IF
   	...
   ELSE IF (Expression) THEN !只有之前的IF后面的表达式都为假，才会测试这个表达式
   	...
   ELSE   !如果没有最后的兜底的ELSE，可能不会执行条件语句的任何代码。
   	...
   END IF
   ```
   
2. IF中的条件表达式的结果必须是单值，不能是数组，可以为 ：

   ```fortran
   a == 5
   str == "fcode"
   isf == .TRUE.
   .TRUE.
   ```

3. 数组比较需要使用ALL或ANY函数，例如 a和b分别为数组，a == b的结果为一个logical类型的数组，标识相对应元素是否相等。ALL(a == b) 只有a和b中的所有对应元素都相同时，才会为.TRUE. , ANY(a == b) 只要a和b中有一对对应元素相同就为.TRUE.

4. ==两侧的对象要相容，例如标量可以和任意维度的数组比较，结果就是该标量逐个和数组的每一个元素比较。数组只能和同形状的数组比较，同形状指的是维度相同，每一维度的范围也都相同。

5. 对于较长或嵌套的IF可以进行署名来提高程序的易读性，例如：

   ```fortran
   inner: IF (ConditionA) THEN     !第一行必须要署名
   	...
   ELSE IF (ConditionB) THEN inner  !中间的ELSE IF和ELSE随意，如果署名，则要求和该IF结构体的首尾署名相同。
   	...
   ELSE inner
   	...
   ENDIF inner         !最后一行也必须要署名
   ```
   
6. F66中有两种IF语句：算术IF语句(F90/95中已废除)和逻辑IF语句。


## SELECT CASE

1. SELECT CASE结构（Fortran90增加的），所有case条件的范围不能有重合的，否则会报编译错误：

   ```fortran
   select case (a) !表达式的结果可以是整数，字符串，逻辑值，不能是浮点数，复数
       case (-1,-2,-5) !当expression=-1或-2或-5时，执行下面的语句。
       print *, 1
       case (20:) !当expression>=20时，执行下面的语句。
       print *, 2
       case (:-20) !当expression=<-20时，执行下面的语句。
       print *, 3
       case (12:15) !当expression>=12且expression<=15时，执行下面的语句。
       print *, 4
       case (8,18:19) !可以混合使用之前的几种方式，当expression=8或在18到19之间时执行以下语句
       print *, 5
       case default  !可选，用来兜底
       print *, 6
   end select
   ```

2. case语句后面不能加分号或冒号，case值必须和表达式的值类型相同，case块内可以包含其他块，例如if块。

3. select case块会从前往后，依次判断，直到找到一个符合条件的case，就执行其下的块，然后跳到end，如果都没有匹配的，则执行default块（如果有的话）。

4. Fortran2003中新增了SELECT TYPE结构，主要用于多态编程中。



## Do循环

1. 类似于C语言的for循环，语法构造如下：

   ```fortran
   DO [[标号][,]] 循环变量＝初值式,终值式[,增量式] !其中初值，终值，增量式都可以是浮点数或负数，增量不能为0。如果这三者的类型和循环变量的类型不一样，则先转化类型。
   !循环次数=INT((终值-初值+增量)/增量) 如果计算出的循环次数<=0，则一次也不执行循环，但是仍会将初值赋予给循环变量。
   !实际上计算循环次数，也只是会判断以下是否>0，如果>0，则继续执行循环，并不一定会真正执行那么多次循环。
   ```

2. do循环：

   ```fortran
   integer :: i   !和C语言不同的是，Fortran不允许将循环变量定义为循环语句块的局部变量，因为变量的定义必须统一放在所有执行语句之前。
   do i = 1,100  !循环变量的增加值默认为1。在Fortran中，循环的起始变量一般从1开始，因为数组的下标是从1开始的。 1,100 等价于1,100,1   1,100,2 表示1,3,5...99，增量也可以是负数。
   	...
   end do
   
   do while(Expression)   !条件满足会继续循环，直到条件不满足时退出循环。Fortran90增加的
   	...
   end do
   
   do        !无穷循环,或者do while(.true.) 内部应有exit语句来退出
   	...
   end do
   ```

3. 带标号的do：

   ```fortran
   integer :: i
   DO 10 i = 1,5  !表示将标号为10的语句作为循环的底部
   	print *, i
   10    CONTINUE   !标号
   
   DO i = 1,5 !双重循环，内层为死循环，使用第9行的exit跳出
       loop1: DO !给当前行添加标签loop1，循环的底部也要为end do loop1
           print *, i
           exit
       END DO loop1 !已有标签名时不能省略标签名
   END DO
   ```

4. 对于嵌套循环，Fortran允许为每一个循环打上标签tag，可以提高代码的可读性，exit和cycle语句后可以指定要作用的循环：

   ```fortran
   Outer:do i=1,3    !署名DO循环
       Inner:do j=1,2
           print *,i,j !依次输出1 1,1 2,2 1,2 2,3 1,3 2。
       end do Inner
   end do Outer
   
   Outer: do i = 1, 3
       Inner: do j = 1, 3
           if (i < j) then
               cycle Outer  !i j经历过 1 1,1 2后，会直接跳到外层循环的下一次，即2 1而不是1 3
           end if
       end do Inner
   end do Outer
   ```

5. 隐式(Implied)do循环，I=m1,m2,m3的形式，它不是独立语句，可以用作为读写语句的输入输出表中一个组成部分，用来控制重复读写的次数，或者数组构造器。

   ```fortran
   Integer :: a(10), i
   a = [(2*i+1, i=1, 10)] ! []是数组构造器的符号，也可以替换为(/ /),其中/和括号中间不能有空格
   !等价于以下内容：
   Do i = 1, 10
   	a(i) = 2*i+1
   End Do
   
   READ *,(VALUE(i),i=1,20) !等价于以下内容：
   Do i = 1, 20
   	READ *,VALUE(i)
   End Do
   
   WRITE(*,*)(A,B,N=1,5,2) !等价于以下内容：
   Do i = 1, 5, 2
   	WRITE(*,*) A,B
   End Do
   ```

6. 隐式do循环也可以嵌套：

   ```fortran
   integer ::A(2,3),i,j
   A = reshape([1,2,3,4,5,6],[2,3])
   PRINT *,((A(i,j),j=1,3),i=1,2) !输出结果为1 3 5 2 4 6
   !等价于以下内容：
   Do i = 1, 2
   	print *, (A(i,j),j=1,3)
   End Do
   !再展开为
   Do i = 1, 2
   	Do j = 1, 3
   		print *, A(i,j) !即一行一行输出
   	End Do
   End Do
   ```

7. do concurrent循环可以显式声明循环内部没有相互依赖关系，这对循环体的要求较高，这会提示编译器可以（并不一定会）使用并行的SIMD（单指令多数据）指令来加速循环的执行，更清晰地表述程序员的想法：

   ```fortran
   integer, parameter :: n = 3
   integer :: i
   integer :: result_sin(n)
   
   do concurrent (i = 1:n) !循环控制变量需要放在括号内，普通的do循环不能加括号
       result_sin(i) = i**2  !循环体内的运算只和当前的i有关，因此可以作为do concurrent的循环体
   end do
   ```

8. 循环控制关键词，CYCLE和EXIT（通常放在if内，用于提前退出本轮或本层循环），功能分别等价于C语言中的Continue和Break。默认都只对最近一层循环起作用。如果后面加上循环名称，则可以退出相应的循环。

   ```fortran
   integer :: i
   do i = 1, 100
     if (i > 10) then
       exit  ! 直接退出do循环，跳到end do后执行,此时i=11
     end if
     print *, i
   end do
   
   do i = 1, 10
     if (mod(i, 2) == 0) then
         cycle  ! 如果i为偶数，则不执行循环内后续的代码，直接跳到下一次循环，最终的效果就是不输出偶数
     end if
     print *, i
   end do
   ```

9. 循环变量必须使用整型变量，如果在循环内要使用实数，可以使用Real函数转换。

10. 不允许在循环内修改循环变量的值，如果要更改的话，可以使用死循环，把循环变量变成普通变量。

    ```fortran
    Do i = 1,100
    	...
    	i = i-1  !编译会报错:Variable ‘i’ at (1) cannot be redefined inside loop beginning at (2)
    End Do
    !可以改写成如下：
    Do
        i = 1         !将该语句移动到循环外即可
        i = i+1  
        if (i>4) exit !编译运行都不会报错，但是实际上i永远不会达到5，因为每次循环开始i就被置为1
        print *,i
    End Do
    ```

11. 如果循环的上下限是使用表达式给定的，在首次进入循环时，会对表达式进行求值，此后循环的次数就固定不变了，即使修改了表达式中的变量值。

    ```fortran
    Program main
       Implicit none
       Integer ::i,n=10
       Do i = 1,n*10     !循环会进行100次,即使在循环内修改了n的值
          n=2
       End Do
       Write(*,*) i,n   !结果为101  2
    End Program main
    ```

12. Fortran标准没有规定循环正常结束后循环控制变量的值，不同的编译器结果可能不一样。但是标准规定使用Exit退出循环时，循环变量的值是确定的，就是退出前的值。

    ```fortran
    Program main
       Implicit none
       Integer ::i = 4,n=10
       Do i = 1,100
          If (i ==30) Exit
       End Do
       Write(*,*) i  !此时i为30，如果没有Exit，正常退出的话，gfortran为101。
    End Program main
    ```

## Goto

1. 可以用标号或标签对语句进行标记，在同一个程序单元中标号不能重复，标记可以当作Goto的目的地。带标号的语句不能放到程序单元之外。

2. 其中标签号是1-5位的十进制整数，且至少1位不为0，前导0不起作用，F90中，不可对空语句添加标号。标签为英文名，后面要接上冒号，Fortran90才支持添加标签。

3. Goto会无条件跳转到某一个标号，C语言也支持，F90后不推荐：

   ```fortran
   Program main
       Implicit None
       Real:: r
       Call random_number(r) !产生一个随机数
       If (r<0.5) Then
           Goto 10 !这里的10并不是源文件中的行号，而是一个标号。可以将标号10的内容直接复制到这里来避免使用Goto。
       Else
           Goto 20
       End If
       print *, "end" !无论如何都不会执行到这条语句了
   10  print *, "10"  !跳转到这里后，会紧接着执行后面的行，而不会回到goto前的地方
   20  print *, "20"
   End Program
   ```

4. 不能使用整型变量来指定转向语句的标号

   ```fortran
   n = 10
   goto n !错误
   ```

5. 另一种 Computed Goto：

   ```fortran
   Goto (10,11,12) N    !意思就是当N=1时跳转到标号10处执行，当N=2时，跳转到标号20，以此类推。整个可以用Select Case或一串If Else If来替换。
   10 ...
   11 ...
   12 ...
   ```

6. Fortran77的程序中，循环的结尾是通过行号或行号+Continue来指定，而不是End Do。

   ```fortran
   n = 0
   Do 5 i=1,100    !Do后面的标号5表示循环的结束在标号5的位置。
   	n = n+1
   5 Continue
   !也可以两层循环共享一个结束标号
   Do 10 i=1,100
   	Do 10 j=1,100
   	
   10     !等价于两个End Do
   ```

7. Arithmetic IF根据表达式的结果是负数，0还是正数来确定跳转位置。普通的If，括号内为逻辑表达式，这里括号内必须为算数表达式。

   ```fortran
   If (Expr) 10,20,30     !当Expr<0时，跳转到标号10;当Expr=0时，跳转到标号20;当Expr>0时，跳转到标号30。
   10 ...
   20 ...
   30 ...
   ```

# 聚合数据类型

1. 聚合数据类型：枚举 parameter，数组 dimension，结构体 type，类 class

# 枚举

1. 枚举类型一般定义为整型常量：

   ```Fortran
   Integer,parameter ::SUN=0,MON=1,TUE=2   !类似于C中的枚举
   ```


# 类

1. 类类型，类的定义和结构体的定义只是多了成员函数，都是用 type关键字。

# 数组

1. 数组使用连续的内存块存储数据，字符串不等于字符数组。数组名代表整个数组。

2. 数组的维数(dim)称为秩(rank)，F90中规定数组最多可以有7维，标量的秩为0，数组的秩至少为1。在某一维中元素的个数称为该维的长度(extent)。数组中所有元素的个数称为数组的大小(size)，它等于各维的长度的乘积，数组的大小可以为0。数组的形状(shape)取决于秩和每一维的长度，和每一维的起始下标无关。

3. 数组是多维变量，需要使用（下标）来索引，数组下标从1开始计数。定义数组的两种方式：

   ```fortran
   !使用dimension属性
   integer, dimension(10, 5) :: array1  !2维数组，第一维范围位1-10，第二维范围位1-5
   !在变量名后添加括号和维度，维度可以是一个整数，也可以是一个允许下标范围
   integer :: array2(10, 5) !结果同上
   integer :: array3(-4:5, 0:4) !数组的大小同上，但是每一个维度的范围不一样，相当于数组平移
   Integer :: farr(1:10),carr(0:9) !farr是Fortran风格的数组，carr是C语言风格的数组。
   !混合定义，不建议使用
   Real,Dimension(5)::arr1,arr2(8)    !arr1含有5个元素，arr2含有8个元素，并非定义了一个二维数组
   !F77常用单独的语句
   DIMENSION   A(10,2,3)
   ALLOCATABLE B(:,:)                ! ALLOCATABLE语句
   POINTER     C(:,:,:)              ! POINTER语句
   !F90中对应的如下，都由单独的语句变成了属性:
   REAL，DIMENSION(10,2,3):: A
   REAL，ALLOCATABLE :: B(:,:)
   REAL，POINTER :: C(:,:,:)
   ```

4. 无论何种声明数组的方式，都要说明秩的大小，形状是否需要声明视情况而定。

5. 当COMMON语句指定了数组的秩和大小后，只能定义数组的类型而不能再次重复给定维界。

6. 数组定义中的维界表达式是整型的数学表达式，维界值可以是正、负或零，但维上界必须大于维下界的值。

7. 一维数组逆序的方法：

   ```fortran
   integer :: a(5) =[1,2,3,4,5]
   a = a(5:1:-1) !数组逆序，此时a为[5,4,3,2,1]
   ```

8. 数组切片的下标中，某一维可以用三元下标或向量下标来表示：

   ```fortran
   REAL A(5,9)
   A(1:4:3,6:8:2)=3.0 !第1维可以是1,4，第2维可以是6,8。因此一共4个元素
   A(1,[2,7,4]) !第2维为2,7,4，因此一共有3个元素即[A(1,2), A(1,7), A(1,4)]
   INTEGER :: a(4)=[0,1,2,3],b(3)=[1,4,3]
   print *, a(b)  !结果为[0,3,2]
   ```

9. Fortran的数组索引和函数调用都是使用( )，这点和C语言不同。

10. data语句执行初始化，必须要放在执行语句之前，否则不会生效。

    ```fortran
    Program main
        Implicit None
        integer :: arr1(10)
        arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        data arr1 /10,9,8,7,6,5,4,3,2,1/  !这条语句不会生效，此时array1数组还是1到10
    End Program
    !而且data语句是内存初始化，将所有数组都当作1维的来处理。数组构造器[ ]则不可以，必须要reshape才可以
    program main
        implicit none
        real ::arr2(2,3)
        data arr2 /1,2,3,4,5,6/
        arr2 = reshape([6,5,4,3,2,1],[2,3]) !直接用arr2 = [6,5,4,3,2,1] 会报错
        print *,arr2
    end program main
    ```

11. 数组维度的范围只能使用字面值常量或整型常量，使用变量会报错：

    ```fortran
    Integer,parameter ::nmax = 5
    Real,Dimension(nmax)::arr1
    ```

12. Fortran内置了对数组的操作，数组的切片，两侧都是闭区间。

    ```fortran
    integer :: i
    integer :: array1(10)
    integer :: array2(10, 10)
    
    array1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  !数组构造器，赋值，[]可以替换为(/ /)
    array1 = [(2*i+1, i = 1, 10)]  ! 隐式do循环构造器，类似于python的生成器，元素依次为3,5,7,9...21，不能将integer::i的声明移动到构造器内
    array1(:) = 0  ! 将所有元素赋值为0
    array1(1:5) = 1  ! 将下标1到5的所有元素都赋值为1
    array1(6:) = 1  ! 将下标6到末尾的元素都赋值为1
    
    print *, array1  !打印整个数组，array1(:)同样的效果
    print *, array1(1:10:2)  ! 打印下标为1，3，5，7，9的元素
    print *, array2(:,1)  ! 打印二维数组中第二维下标为1的所有元素，也就是矩阵的第1列
    print *, array1(10:1:-1)  ! 逆序打印下标在1到10的元素
    ```

13. Fortran之所以支持数组修改维度的起止点，是因为它的数组不只是存储数据，而是会当作矩阵使用，矩阵中定位时，可能会用到负数。

14. Fortran的数组按照“列优先”原则存储，下标从前往后开始索引。

    ```fortran
    integer :: arr1(2, 3)
    arr1 = [1, 2, 3, 4, 5, 6]
    
    !对于一个m*n的二维数组，元素(i,j)在内存中的序号为 m*(j-1)+i
    integer :: arr2(2,3) = 0
    arr2(1,2) = 1 !2*(2-1)+1=3
    print *,arr2 !当作一维数组输出，结果为 0 0 1 0 0 0
    ```

15. 二维数组是按列存储的。dim=1表示按列处理，dim=2表示按行处理，不写dim就表示对整个数组进行处理，不存在dim=0的情况。

    ```fortran
    !如下二维数组，在内存中是1 2 3 4 5 6
    ! [1 3 5]
    ! [2 4 6]
    ! 2行3列，arr(2:3)为最后一个元素6，arr(1:3)为第一行第三列，即第5个元素，值为5。
    !1维数组默认是列向量，也可以reshape成行向量，但此时会被当作2维数组来看待
    Integer ::arr(6) = [1,2,-3,4,-5,6]  !6行1列的一维数组
    Write(*,*) size(arr,dim=1)  !结果为6，dim=2时会报错，因为1维数组只有第1维，此时不能将其当作6*1的二维数组。
    Write(*,*) size(reshape(arr,[1,6]),dim=1) !结果为1，形状为1行6列
    Write(*,*) size(reshape(arr,[1,6]),dim=2) !结果为6
    ```

16. 高维数组的存放次序可由二维数组类推，即最右边指标（相当于最外层循环变量）变动最慢，最左边的第一个指标变动最快。

    ```fortran
    integer arr(2,3,4),i
    arr = reshape([(i,i=1,2*3*4)],[2,3,4])
    print *, arr(1,1,1),arr(2,1,1),arr(1,2,1) !结果为1 2 3
    print *, arr(2,2,4),arr(1,3,4),arr(2,3,4) !结果为22 23 24
    !对当前下标的第一维+1，然后考虑进位，可以得到下一个元素，例如arr(2,2,4)对第一维+1后为arr(3,2,4) 但是第一维的上界为3，因此要进位到第2位，所以为arr(1,3,4)
    ```

17. 数组分为固定大小的和动态分配的（区别在于前者是编译时就分配了空间，后者是运行时分配）。固定大小数组又可以分为静态数组（在源文件中直接声明数组大小）和自动数组（当将数组作为函数实参时，在函数内部使用自动数组来接受实参）。

18. 动态分配可以用于标量和任何类型的数组。

19. 静态数组的缺陷是，即使数组已经使用完毕，它仍占据着内存空间，浪费了系统资源。因此，F90增加了动态的数组功能，动态数组的储存在程序运行当中是可以分配、改变和释放的。

20. 动态数组只有两种：可分配数组和自动数组。

21. 已经被分配的数组不能被再分配，否则会引起运行错误。错误状态可以由ALLOCATE语句中的STAT值获得。如果指定STAT选项，语句的成功执行时将返回0，否则返回正值。若未指定STAT选项且出现错误时，程序将中止执行

22. 动态分配的数组的两种流程：

    ```fortran
    !allocate语句中的秩必须和可分配数组定义的秩相同，下界可以不为1，可以一次给多个数组动态分配空间。如果维上界比下界小，则该维的长度为零，并且数组的大小为零。大小为零的数组不能被赋值。
    ALLOCATE(数组名[维界符][,数组名[(维界符[,维界符...])] ] ...[,STAT=状态值])。!stat标识分配成功与否。如果指定STAT选项，语句的成功执行时将返回0，否则返回正值。若未指定STAT选项且出现错误时，程序将中止执行。
    !显式调用allocate函数来分配，维度数量不能改变，只能指定每个维度的范围
    integer, allocatable :: array2(:,:) !声明array2为一个二维数组
    integer, allocatable, dimension(:,:) :: array2 !效果同上
    array2(2,3) = 5    !如果此时对数组的某个元素读写，则编译不会报错，但是运行时会发生段错误，显示非法内存访问
    allocate(array2(10,10)) ! 显式给array2动态分配10*10的数组,这里的10可以是运行时生成的值
    DEALLOCATE(数组名[,数组名]...[,STAT=状态值]) !只有被ALLOCATE语句分配的内存空间才可以被DEALLOCATE语句释放，否则产生运行错误。
    deallocate(array2) !手动释放array2的内存
    array2(2,3) = 5 !此时也不能对array2进行读写
    !在第一次赋值时自动进行动态分配
    integer, allocatable :: array2(:)
    array2 = [1,2,3] !
    array2(5) = 8  !编译时不会提示数组越界的warning，因为此时编译器也不知道数组的边界是多少
    ```

23. C语言不支持动态数组，不过可以将malloc动态分配的内存当作动态数组。

24. 可以定义字符串数组，不过要求数组的每个元素都是同样长度的字符串，否则无法在内存中对齐：

    ```fortran
    Character(Len=2) ::strarr(3) = ["a", "cd", "ef"] !此时会报错，提示数组元素的长度不同，可以做如下修改
    Character(Len=2) ::strarr(3) = [character(len=2)::"a", "cd", "ef"] !这里通过在数组构造器中添加一个类型说明，强行将strarr(1)这个元素变为"a "
    ```

25. 动态分配的局部数组，会在离开变量的作用域后会被自动释放，==缺少代码实例==：

26. 对于定义在过程中的动态数组，当过程的执行被RETURN或END语句中止时，除非可分配数组是有SAVE属性的，否则它的分配状态变成未定义的。但是，RETURN和END语句并不释放数组分配的内存，所以应该在退出过程前主动释放数组分配的内存。

27. 数组刚被分配后，其内的值是不定的。

28. F90中，允许把整个数组作为一个操作数进行操作，也允许在赋值语句中对整个数组进行赋值，就像对一个简单变量的操作和赋值一样，不必用DO构造对每一个元素逐一赋值。使用数组给数组赋值时，两侧的数组的形状必须相同，每一维的范围可以不同。

29. 数组赋值的方法：

    ```fortran
    Integer :: I
    Real, Dimension(4) ::arr
    !数组构造器是由括号和斜线之间的一系列值或隐DO循环组成。
    arr(2:4) = [(I**2 ,I=2,4)]   ! =右侧等价于[2**2,3**2,4**2]。隐式列表赋值
    arr(:3) = (/3,4,1/)      !可以用[和]来替代(/和/),显式列表赋值，左右的大小要匹配，否则会报错
    integer a(8),b(6)
    integer ::i
    b = [(i,i=1,6)]
    a = [b(2:3),b(5:6),(i,i=1,4),[9,0]] !此时a为[2 3 5 6 1 2 3 4 9 0]
    !函数赋值
    ```

30. Fortran90引入的数组赋值语句和Fortran77的do循环赋值不同。F90的赋值语句考虑到了在并行机上计算的功能，即使不是用的并行计算机，在形式上也是按并行化处理的。Fortran77的do循环是串行的。

    ```fortran
    INTEGER :: a(1:10)=[1,2,3,4,5,6,7,8,9,10] !并行处理和串行处理没区别
    a(2:10)=a(1:9) !并行处理，等价于 a(2:10) = [1,2,3,4,5,6,7,8,9] 得到a为[1,1,2,3,4,5,6,7,8,9]
    !DO循环
    DO i=2,10
    	a(i)=a(i-1) !此时a(i)会被逐个赋值为前一个，a(2) = a(1) =1，然后都会赋值为1
    END DO
    !如果要用DO循环达到和上面同样的效果，需要数组的拷贝。
    INTEGER :: a(1:10)=[1,2,3,4,5,6,7,8,9,10], b(1:10) !并行处理和串行处理没区别
    b=a
    DO i=2,10
    	a(i)=a(i-1) !此时a(i)会被逐个赋值为前一个，a(2) = a(1) =1，然后都会赋值为1
    END DO
    ```

31. 数组的访问方式：

    ```fortran
    Real,Dimension(5)::arr,arr1 = [1,2,5,3,4]
    !单个元素访问
    arr(2) = 1  !将下标为2的那个元素赋值为1，不一定为第二个元素，因为下标可以不从1开始。
    !非连续下标访问
    arr(arr1(:3)) = 1 !将arr1的下标<=3元素的值作为数组arr的下标。即[arr(1),arr(2),arr(5)]。将一个数组的不连续片段作为实参时，编译器会构建一个临时数组，因此在函数内修改该实参，并不会影响外面的实参。
    ```

32. 数组变形 reshape，当指定order数组时，还可以修改数组的实际数据存储顺序，可以用于Fortran和C语言的数组互通，不过还要同时修改shape数组：

    ```fortran
    结果=reshape(source,shape,[,pad][,order])
    ! source源数组的形状不重要，只有数据重要
    ! shape形状数组，一维非负，值固定，最多7个元素，因为Fortran的数组最多有7维。
    ! pad补充数组，大小任意，其内的元素和源内的元素同类型，当源数组的大小比结果数组小时用来补充元素值，必要时重复使用补充数组直至结果数组的所有元素均有其值。当补充被省略或为0时，源的大小必须大于形状的大小。
    ! order顺序数组，形状数组大小相同，其元素为(1,2,...,n)的排列，默认值为(1,2,...,n)。当省略顺序数组时元素按通常的顺序排列。顺序数组用来控制源数组的数据往形状数组中填充时，各个维度的优先级，会先填充顺序数组中值小的维度，再填充大的，默认情况下，会先填充最左侧的，也就是Fortran的默认情况，当顺序数组为(n,...,2,1)时，则先填充右侧，此为C语言的情况
    arr2 = reshape(array,shape)  !将数组array重组为shape的外形，然后返回，不改变数据源的形状。两个数组在内存里存储是一样的。
    Integer ::arr(6) = [1,2,3,4,5,6] ,b(2,3)  !数组可以看成是列向量，但是和一列的矩阵不一样。arr的shape为6，而reshape(arr,[6,1])结果为一列的矩阵，shape是[6,1]而不是6。
    b = reshape(arr,shape(b))  !2行3列。shape(b)就是一个数组 = [2,3], shape(shape(b))=[2], shape(shape(shape(b))) = [1]
    b = reshape(arr,[2,3])  !结果同上
    ! [1 3 5]
    ! [2 4 6]
    Write(*,*)  b(1,2) !结果为3，第1行，第2列
    
    integer :: a(2,4) = reshape([3,4,5,6,7,8],[2,4],[1,1],[2,1])!源有6个元素，形状应该是8个元素，所以会使用补充数组，补充1次即可，补充完源为[3,4,5,6,7,8,1,1]，顺序数组为C语言的情况，结果为：
    ![3 4 5 6]
    ![7 8 1 1]
    print *,a !结果为3 7 4 8 5 1 6 1
    
    integer :: a(6), b(3,2) !
    a = reshape(b,[6]) !将b赋值给a之前，先转化为向量
    ```

33. 使用数组名作为实参时，传递的是地址。

34. 在过程(函数和子程序)中，数组的上界和下界可以由变量或表达式指定。使用变量或表达式的数组是自动数组和可调数组。

35. 数组有几种不同定义方式，主要分为：在过程外定义，可以作为其实参的，和在过程内定义，作为其形参的。有的定义方式两种都适用，有的只能适用其中一种。其中假定形状数组是最推荐的：

    1. 显式形状数组，可以出现在任何位置

       ```fortran
       INTEGER M(10,10,10)  !()内都是常数或字面值常量
       ```

    2. 自动automatic数组，是显式形状数组的一个变种，数组本身只是函数的纯局部变量，而不是形参。数组的维度通过形参传入：

       ```fortran
       Program main
           Implicit None
           integer :: n = 5
           call fun1(n)
       End Program
       
       subroutine fun1(n)
           integer, intent(in) :: n
           integer :: arr(n) !显式指定数组参数的维度和范围，只能在过程内这么写，因为在过程外n必须为常数或整数字面值常量
           n = 8 !即使可以在执行语句中修改n，也不会修改arr的形状
           arr = 3
           print *, arr
       end subroutine fun1
       ```

    3. 可调adjustable数组，是显式形状数组的一个变种，除了将数组本身外作为参数传递外，还要将数组形状作为参数传入。和自动数组的区别在于，可调数组本身是过程的形参，即自动数组在被调用者的栈上，可调数组在调用者的栈上。相同点在于他们的形状都只能在函数调用内才能确定。

       ```fortran
       Program main
           Implicit None
           integer :: arr(5) = 3
           call fun1(arr,size(arr))
       End Program
       
       subroutine fun1(arr,n)
           integer, intent(in) :: n
           integer :: arr(n) !显式指定数组参数的维度和范围，只能在过程内这么写，因为在过程外n必须为常数或整数字面值常量
           print *, arr
       end subroutine fun1
       ```

    4. 假定形状assumed-shape数组，从实际传递过来的数组获得形状参数，它的秩由定义时的冒号的个数决定，每一维度，最多只能指定下界，不能指定上界，和显式形状数组不同的时，调用函数处需要有函数的interface或者contains函数：

       ```fortran
       !在program内contains上过程
       Program main
           Implicit None
           integer :: arr(5) = 3
           call fun1(arr)
       contains
           subroutine fun1(arr1)
               integer, intent(in) :: arr1(2:) !arr1的下界为2，上界=下界+长度-1
               print *, arr1
           end subroutine fun1
       End Program
       !或使用interface说明过程的参数
       Program main
           Implicit None
           integer :: arr(5) = 3
           interface
               subroutine fun1(arr1)
                   integer, intent(in) :: arr1(2:) !显式指定数组参数的维度和范围，只能在过程内这么写，因为在过程外n必须为常数或整数字面值常量
               end subroutine fun1
           end interface
           call fun1(arr)
       End Program
       subroutine fun1(arr1)
           integer, intent(in) :: arr1(2:) !显式指定数组参数的维度和范围，只能在过程内这么写，因为在过程外n必须为常数或整数字面值常量
           print *, arr1
       end subroutine fun1
       ```

    5. 假定大小(Assumed-size)数组，除了最后一维的上界以外，其它所有特征（秩，长度和维界）都必须指定，最后一个的上界用星号*表示。接受的过程中假定大小数组的最后一维的长度会改变来接受所有传递进来的数组元素，于是最终给出数组的大小。参数传递会按列进行，实际上就是reshape一下。最后一维没有必要成为完整的维，所以数组始终没有确定的形状。形参的秩和形状可以和实参不同，根据实参的大小确定形参最后一维的大小。

       ```fortran
       Program main
           Implicit None
           integer :: arr(3,5) !共15个元素
           integer :: i
           arr = reshape([(2*i+1,i=1,15)],[3,5])
           call fun1(arr)
       End Program
       subroutine fun1(arr)
           integer, intent(in) :: arr(2,2,*) !*的具体值会根据参数的大小计算得出，即ceiling(3*5*1.0/2/2)=4, (2,2,2)的数组有8个元素，可以装下实参的7个元素
           print *, arr !会报错，因为假定大小数组没有形状，所以这样的数组不能仅仅通过名称来向其它过程传递
           print *, arr(1,2,4) !结果为15，输出倒数第2个元素，即arr的最后一个元素。因为假定大小数组没有形状，所以这样的数组不能仅仅通过名称来向其它过程传递
           print *,arr(2,2,4)  !每次运行，结果都不定
       end subroutine fun1
       ```

    6. 延迟形状(Deferred-shape)数组，可分配数组必须以延迟形状的形式来声明，每一维的长度只有在分配数组才被确定，秩由冒号确定，但长度是未知的：

       ```fortran
       !声明方式：使用ALLOCATABLE语句、DIMENSION语句、TARGET语句或在类型声明中使用ALLOCATABLE属性。如果迟形数组以DIMENSION语句或TARGET语句声明，则在其它语句中必须给出ALLOCATABLE属性
       REAL,ALLOCATABLE:: A(:,:) !2维数组
       ALLOCATE(A(2,3))  !在ALLOCATE之前，其任何部分都不能被引用。可分配数组的大小、形状和维界在ALLOCATE语句执行时才被确定
       ```

36. 所有的算术运算符(+，-，*，/，**)、逻辑运算符(如.AND.，.OR.，.NOT.)和所有关系运算符(如.LT.，.EQ.，.GT.)都可以用于数组之间，数组和标量的运算，用于数组之间的运算时，需要两侧数组形状相同。数组乘法并不是向量内积，也不是矩阵乘法，而是单纯地对应元素相乘。

37. F90中提供了一种带条件的数组赋值语句，只对某些符合条件的数组元素赋值。分为where语句和where构造，类似于if语句和if构造，与IF构造不同的是，这里没有关键字THEN和ELSE块：

    ```fortran
    WHERE语句的一般形式为：WHERE(屏蔽表达式) 赋值语句 !屏蔽表达式的值为数组，其元素为逻辑值，要求屏蔽数组和赋值语句中的左值数组具有相同的形状
    WHERE(ABS(A)>1.0) A=1./A !对数组A中绝对值>1的元素取到数。abs(A)>1.0的结果就是和A同形状的逻辑数组，每次执行赋值语句的第(m,n...)个分量前都会查看逻辑数组的(n,m,...)个值，如果该值为.true.则执行赋值语句，否则不执行。
    B=.FALSE.
    WHERE(ABS(A)>1.0) B＝.TRUE !记录一下数组a中那些元素的绝对值>1.0
    
    WHERE构造的一般形式为：
    [构造名:] WHERE(屏蔽表达式1)
    	[块]
    [ELSEWHERE(屏蔽表达式2) [构造名]
    	[块]]
    [ELSEWHERE [构造名]
    	[块]]
    END WHERE [构造名]
    
    !上面两个where语句可以合并为一个where构造
    B=.FALSE.
    WHERE(ABS(A)>1.0)
    	B＝.TRUE. !赋值语句块要么都执行，要么都不执行
    	A＝1./A
    END WHERE
    !也可以改写为如下形式
    WHERE(ABS(A)>1.0)
    	B＝.TRUE.
    	A＝1./A
    ELSEWHERE
    	B=.FALSE. !当where的条件为.false.时，执行这里
    END WHERE
    ```

38. 

# 结构体

1. F90允许定义和使用派生数据类型，派生数据类型有一个类型名称，它不能和任何已有的类型重名。可以用它来定义变量、命名常量或其它派生类型了。推荐将结构体类型名命名加上_type的后缀，方便识别
2. TYPE块应写在程序的说明部分中，一般形式为：

   ```fortran
   TYPE[,访问属性说明::] 派生类型名 !访问属性说明为public或private，默认值是public，即所有成员都可以在结构体外通过%直接访问。只有当TYPE块写在module说明部分中时，才允许使用private。
       成员1类型说明 !字符型成员不可取*为长度，必须是确定长度
       ……
       成员n类型说明 !TYPE块中只有类型说明语句，不允许有可执行的动作语句。
   END TYPE [派生类型名]
   !系统不一定会按定义时的顺序储存各个成员，除非在定义中包含有SEQUENCE语句，这样有助于和C语言的交互
   ```
3. 类似于C语言的结构体，可以容纳不同类型的数据，使用%来获得结构体的成员：

   ```fortran
   type :: student  !定义一个名为STUDENT的结构体类型，包含4个成员，第二个为一个长度为10的字符串。
   	integer ::ID  
   	character(len=10) ::name
   	integer ::MathScore,EnglishScore = 3!任何成员都可以定义默认值，如果构造时未指定，则会使用该值，但是类似于函数的默认参数，成员的默认值也只能出现在末尾成员上，如果构造时使用关键字参数则可以例外
   end type student     !最后的结构体名可以省略
   
   type(student) :: st1  !定义一个STUDENT类型的结构体，变量名为st1
   st1%ID=3    !给结构体变量st1的名为ID的成员赋值，调用结构体类型的成员函数也是使用%
   write(*,*) st1%ID
   ```
4. 可以使用结构体构造器来初始化：

   ```fortran
   type(student) :: st1 = student(1, "abcd", 4) !成员EnglishScore会使用默认值3
   type(student) :: st2 = STUDENT(1, "abcd", 4,5)      ! 通过位置参数来初始化
   type(student) :: st3 = STUDENT(ID = 1, MathScore = 4, EnglishScore = 5, name = "abcd")  ! 通过关键字参数来初始化，可以乱序
   ```
5. 和类相似，结构也有构造函数，用来产生一个结构体对象。定义了一个派生类型，实际上也同时建立了一个构造函数，这个函数名就是派生类型名，函数的自变量就是派生类型内各成员。

6. 结构体可以嵌套：

   ```fortran
   Type ::st1        !定义一个结构体类型
   	Integer ::i1
   	Real :: r1
   End Type
   Type ::st2        !定义一个结构体类型，包含一个子结构体成员和一个Integer成员
   	Type(st1) t1
   	Integer :: i2
   End Type
   Type(st2) ss   !定义一个结构体变量
   !可以直接给结构体赋值
   ss = st2(st1(2,4.5),5)  !这里调用了构造函数
   ```

7. type的详细语法构成

   ```fortran
   type [,attribute-list] :: name [(parameterized-declaration-list)]
     [parameterized-definition-statements]
     [private statement or sequence statement]
     [member-variables]
   contains
     [type-bound-procedures]
   end type
   ```

8. attribute-list可以是如下内容：

   1. 访问类型，例如public或private，一旦出现，则会影响其后所有的成员。
   2. bind(c)，提供和C语言的兼容性。如果拥有了bind(c)或sequence属性，则无法拥有extends属性，反之亦然。拥有bind(c)的结构体无法同时拥有sequence和extend属性，也无法拥有pointer和allocatable类型
   3. sequence属性表明以下属性，应该按照其被定义的顺序来访问。
   4. extends(parent)，其中parent是之前声明过的一个派生类型，也就是继承中的父类型。
   5. abstract，面向对象中的高级特性

9. 例子：

   ```fortran
   module f_to_c
     use iso_c_bindings, only: c_int !导入iso_c_bindings模块中的常数c_int
     implicit none
     type, bind(c) :: f_type
       integer(c_int) :: i
     end type
   end module f_to_c
   
   !和如下C语言的结构体匹配：
   struct c_struct {
     int i;
   };
   ```

10. parameterized-declaration-list是一个可选的特性，如果使用了，则

11. extends属性是Fortran2003中添加的一个重要的面向对象特性，也就是继承的意思，子类型会全部继承父类型的成员和函数

12. type可以包含函数或子程序的定义，称之为类型绑定的过程。放在contains语句之后，放在所有成员之后。

    ```fortran
    module m_shapes
        implicit none
        private
        public t_square
        type :: t_square
            real :: side
        contains
            procedure :: area  ! 过程声明
        end type
    contains !模块内部定义的函数
        real function area(self) result(res) !过程定义
            class(t_square), intent(in) :: self
            res = self%side**2
        end function
    end module m_shapes
    
    program main
        use m_shapes
        implicit none
        type(t_square) :: sq !变量声明
        real :: x, side
        side = 0.5
        sq%side = side
        x = sq%area() ! self does not appear here, it has been passed implicitly
    end program main
    ```

13. F95中，允许为结构体成员指定初值，但没必要为每一个成员都指定初值。显式初始化会覆盖缺省初始化。

    ```fortran
    TYPE REPORT
        CHARACTER (LEN=20) REPORT_NAME
        INTEGER DAY
        CHARACTER (LEN=3) MONTH
        INTEGER :: YEAR = 1999        ! 年份这个成员有缺省初始值
    END TYPE REPORT
    
    TYPE(REPORT):: NOV_REPORT=REPORT("Sales",15,"NOV",2001) !覆盖
    ```

14. 

15. 

# 过程，子程序，函数

1. Fortran中可以被调用的东西统称为过程procedure，分为子程序subroutine和函数function。两者的不同之处在于函数返回一个值（因此调用函数前需要声明返回值的类型），且通常不改变哑元的值，因此，它代表数学上的一个函数。而子程序通常完成一项更为复杂的任务，通过变元或其他手段返回几个结果

2. 子程序通过call 子程序名()  调用，调用函数不用加call。

3. 过程包括下面几种类型：

   1. 外部过程：它是在某个外部程序单元中定义的独立过程，或是用非Fortran语言编写的过程。可以单独以源文件存储和编译，也可以包括在主程序源代码的END语句后。外部过程本身也可以包含有内部过程。

   2. 内部过程：在程序单元内部定义而且只能被该程序单元调用

   3. 内在过程：由编译系统内部定义，不用任何附加声明或说明就可以可直接引用。

   4. 模块过程：它在模块中定义，可以被所有使用该模块的程序调用。包含过程的模块称为宿主。

   5. 哑过程 ：如果一个哑元被指明为过程或作为过程名出现在过程引用中，那么该哑元代表的过程为一个哑过程。

   6. 语句函数：它是由单个语句定义的函数，其形式为：函数名([哑元名表])＝标量表达式。F90不推荐使用，因为它不符合过程的一般规则。类似于lambda表达式，但是又不是匿名函数。

4. 一个程序单元不一定要包含可执行语句。通过contains包含内部子程序或函数的程序单元称为宿主程序

5. 过程不必非得在调用位置之前定义。

6. 子程序和函数都可以通过参数关联访问调用该过程的作用域中的变量，也就是实参，除非变量指定了value的属性，类似于引用传递。

7. Fortran的参数默认是传地址的。因此可以通过参数来返回值。

8. 实参也叫实元 actual argument。形参也叫哑元dummy argument，虚参。

9. 形参可以是变量名、数组名、过程名、指针名。

10. 形参和返回值（函数名或result）都不能在声明时初始化，也就是不能有默认值。否则会报错。

11. 在未指定可选参数的情况下，实参和形参的个数，数据类型，数组维度都要严格匹配。

12. 如果过程不需要任何参数，可以省略括号，这一点和C语言不一样。

13. 哑元表中的哑元个数，理论上不受限制，但从软件工程观点看，不宜过多，一般不应超过六、七个。如果太多，意味着该子程序的算法较复杂，应该把该过程再分解为几个子功能分别编写成几个子程序。

14. END既是一个程序单位的结束标志，又是一个独立的语句(结束语句)。主程序中的END语句的作用是使程序“停止运行”。过程中的END或RETURN语句是“使执行流程返回到调用单元”。

15. F90中增添了结果名功能，是为了区别函数字面上的名称(函数名)和实际运算结果变量的名称。

16. F90中新增了可以为函数指定前缀：

    ```fortran
    !前缀可以是：类型说明 [关键词]或关键词 [类型说明]
    !关键词可以是RECURSIVE(F90)，PURE(F95)，ELEMENTAL(F95)
    RECURSIVE表示过程时可以直接或间接地调用自身，即递归调用，其过程是递归过程。
    ```

17. 在F77中，不能确切地说明哑元的目的。在F90中，为了避免当过程内部变量的值变化后返回到调用处时时可能造成的混淆情况，在过程内的形参定义中，可以对哑元指定INTENT属性，也可以使用intent语句。

18. 如果一个形参被定义为intent(out)或intent(inout)的属性，那么对应的实参不能是字面值常量或常数。

19. 由于Fortran的过程在定义的（）内只能给定形参的名字，而不能给定形参的类型，因此需要在过程内的前几行（应在执行语句之前）增加形参的声明，这也和可以将形参当作局部变量来看待相符合。如果某个形参没有在过程内的前几行声明，则会报错，即符号没有隐式类型。

    ```fortran
    program string_array
        implicit none
        real ::arr1(2,3) = reshape([1,2,3,4,5,6],[2,3])
        call print_matrix(2,3,arr1) !调用子程序
    end program string_array
    
    subroutine print_matrix(n,m,A) !不支持在括号内添加形参类型
        implicit none
        integer, intent(in) :: n !形参的类型声明，intent(in)属性不是必须的，而是给编译器提示，这个参数是只读的，编译器会检查，避免误修改而出错，推荐为所有的形参都添加intent属性
        integer, intent(in) :: m
        integer, intent(in) :: A(n, m)
        integer :: i !普通的局部变量定义，非形参的普通参数无法添加intent属性
        do i = 1, n
            print *, A(i, 1:m) !一次输出矩阵的一行，首先是1 3 5 ，然后是2 4 6
        end do
    end subroutine print_matrix
    ```

20. 调用函数时，必须指定变量来接受返回值：

    ```fortran
    !定义
    [形容词][返回类型]   Function 函数名称([形参1, 形参2, ...]) [result(返回变量)]
    	[形参的声明]
    	[局部变量的定义]
    	[函数具体要做的工作]
    	函数名称 = 返回值 !通过将返回值赋值给函数名，函数名称这个变量可以直接使用，不用声明
    	[return]  !末尾的return可以省略
    End [Function [函数名称]] !end不可以省略
    !调用函数
    要存储返回值的变量 = 函数名称([实参1,实参2, ...])
    
    program string_array
        implicit none
        real :: arr1(3)
        real :: vector_norm !不可缺少，否则不知道函数的返回值类型，会提示返回值的类型不匹配。类型需要和函数定义中的返回值类型匹配
        arr1 = [1,2,3]
        print *,vector_norm(3,arr1)
    end program string_array
    
    function vector_norm(n,vec) result(norm) !这里使用了result,显式将norm作为返回值，而不是默认的函数名vector_norm。如果没有result，那就得在function前加上返回值的类型
        implicit none
        integer, intent(in) :: n
        integer, intent(in) :: vec(n)
        integer :: norm !返回值就是普通的局部变量
        norm = sum(vec**2) !设置返回值
    end function vector_norm
    !函数头末尾的result()和函数头开始的integer只能选择一个。如果使用integer，则函数名自动成为一个变量，需要在函数内赋值，作为返回值。如果使用result()，则需要指定一个变量(只能是某个局部变量,不能是某个形参)作为返回值，且函数名不能当作变量来使用。推荐使用integer的这种，和C语言类似。也可以同时使用result()和integer，函数名可以看作是函数对外的接口，result可以看作是对内的接口，但是不推荐。
    !无论函数的定义如何，都不能省略调用函数前的返回值类型声明
    integer function vector_norm(n,vec)
        implicit none
        integer, intent(in) :: n
        integer, intent(in) :: vec(n)
        vector_norm = sum(vec**2) !设置返回值
    end function vector_norm
    ```

21. 子程序，没有返回值：

    ```fortran
    !定义
    [形容词] Subroutine 子程序名称([形参1,形参2, ...])
    	[形参的声明]
    	[局部变量的定义]
    	[子程序具体要做的工作]
    	[return]   !末尾的return可以省略
    End [Subroutine [子程序名称]]
    !调用
    call 子程序名称([实参1,实参2, ...])  !如果子程序没有定义参数，可以省略()
    ```

22. 一般不推荐在函数内修改其形参，即其所有形参都应是intent(in)属性，这种函数成为纯函数，如果要修改，则可以定义为子程序。

23. 将数组作为函数的参数时，还会传递维度和每一维的范围等信息。

    ```fortran
    call sub(a,b)    !虽然只有两个参数，但是实际编译产生的指令中，还传递了
    ```

24. 传递数组的三种方式：

    ```fortran
    !自动数组，需要的参数比较多，什么都不假定
    Subroutine sub(a,m,n)    !参数a只传递地址，维度和大小信息由参数m,n来传递。
    	Integer ::m,n
    	Real a(m,n)
    	a = 2
    End Subroutine
    !假定大小，不传递上限，因此容易越界。非常不推荐，旧代码中很多
    Subroutine sub(a)     !参数a只传递地址，只能用于下限是1的1维数组。
    	Real a(*)
    	a(1:5) = 2      !越界读取的话，编译运行都不会报错；越界写入的话，编译时不会报错，运行时会报错。
    End Subroutine
    !假定形状，推荐使用
    Subroutine sub(a)
    	Real a(:,:)     !假定a是一个2维数组，下限都是1，上限未知。
    	a(3,4)=1
    End Subroutine
    ```

25. 当形参为假定形状数组时，形参的下限都是1，对应于实参的下限。相当于将原来的数组左上角平移到（1,1）的位置了：

    ```fortran
    Program fcode_cn
        Implicit None
        Real ::a(2:4,2:3)
        a = 0
        call sub(a)
        Write(*,*) a(2,2)  !结果为4.0
    contains
        Subroutine sub(x)
            Implicit None
            Real ::x(:,:)
            x(1,1) = 4.0 !修改的相当于实参x的左上角元素，也就是x(2,2)
            Write(*,*) shape(x) !结果为一个一维数组
        End Subroutine
    End Program fcode_cn
    ```

26. 传递结构体，主函数和被调函数中都需要有对结构体的定义，且必须是由同一个Type定义得到的，如下情况是错误的：

    ```fortran
    Program fcode_cn
    	Implicit None
    	Type ST
    		Real::a,b
    	End Type
    	Type(ST) st1
    	call sub(st1)     !会报 类型不匹配 错误，编译器认为Program fcode_cn和sub子程序中定义的Type ST不是一个类型,即使名字和成员完全相同。因为编译器会给名称添加前后缀，不同程序单元内的同名名字，在处理完后就不同名了。
    	Write(*,*) st1
    End Program
    
    Subroutine sub(stdata)
    	Implicit None
        Type ST
    		Real::a,b
    	End Type
        Type(ST) stdata
        stdata%a = 4.3
    End Subroutine
    ```

27. 传递字符串，形参的声明可以指定特定的长度，也可以为*，这样会自动匹配实参的长度：

    ```fortran
    Program main
        Implicit None
        CHARACTER(LEN=*),PARAMETER :: C_NAME='GIRL' !声明是也可以使用自动长度
        call func1(C_NAME)
    contains
        subroutine func1(str1)
            character(*) :: str1
            print *,len(str1) !结果为4
        end subroutine
    End Program
    ```

28. 可以定义一个模块，然后在主程序和子程序中都use这个模块，来解决上面的问题。

    ```fortran
    Module typedef
    	Implicit None
        Type ST
    		Real::a,b
    	End Type
    End Module
    
    Program fcode_cn
    	use typedef   !所有的use语句都要放在Implicit None前
    	Implicit None
    	Type(ST) st1
    	call sub(st1)
    	Write(*,*) st1
    End Program
    
    Subroutine sub(stdata)
    	use typedef
    	Implicit None
        Type(ST) stdata
        stdata%a = 4.3
    End Subroutine
    ```

29. 函数的局部变量具有临时性，当函数退出时，就会被销毁，下次进入函数时，值也不确定。拥有save（即退出函数时把该变量save起来）属性的局部变量相当于C语言的static局部静态变量。下一次进入函数时，还是上次退出时的值。也可以用save语句说明变量。

    ```fortran
    Program fcode_cn
       Implicit None
       call sub()     !输出4
       call sub()     !输出5
       call sub()     !输出6
    End Program
    
    Subroutine sub
       Integer ,save ::i1  !显式声明save属性
       Integer ::i2 = 3    !由于定义时进行了初始化，因此也隐式具有save属性
       i2 = i2+1
       Write (*,*) i2
    End Subroutine
    ```

30. 形参的Intent属性（需要Interface），用来指定形参的目的，建议为每个形参都指定。Intent的检查发生在编译期间。Windows系统的C语言头文件有些会有这种写法。无法为常量或不能作为左值的量来赋予out或inout的intent属性。

    ```fortran
    Integer ,Intent(in) ::input_arg  !输入参数，在子程序内部不能被改变，只读参数。
    Integer ,Intent(out) ::output_arg !输出参数，子程序返回前必须改变，因此对应的实参不能是常量和表达式。
    Integer ,Intent(inout) ::neutral_arg !中性参数，可以修改，也可以不修改。in或out
    Integer ::neutral_arg1   !未指定Intent属性的默认为中性
    ```

31. 形参的Value属性，用于指定该参数为传值参数，而非传地址参数。除非混合编程，否则一般不使用value属性。

    ```fortran
    Program fcode_cn
        Implicit None
        integer a,b
        a = 0
        b = 0
        call sub(a, b)
        print *, a, b !结果为1 0
    contains
        Subroutine sub(a, b)
            integer a
            integer,value ::b !传值参数只能作为输入参数使用。因为在函数内改变，不会影响外部的实参。
            a = a + 1
            b = b + 1
        End Subroutine
    End Program
    ```

32. 形参的Optional属性，用于指定该参数是可选参数，调用时，可以传递，也可以不传递。

    ```fortran
    Program fcode_cn
       Implicit None
       call sub(7,6)
       call sub(7,6,5)
    contains
       Subroutine sub(a,b,c)
          Integer :: a,b
          Integer, Optional:: c
          Write(*,*) a,b
          If(present(c)) Then     !present(c) 函数检测形参c有没有对应的实参。
             Write(*,*) "optional:",c
          Else
             Write(*,*) "Not Found c"
          End If
       End Subroutine
    End Program
    ```

33. Optional形参和C语言的默认参数不同，默认参数也一般都放在形参列表的末尾，否则就需要使用关键字参数的方式来调用。

    ```fortran
    Program fcode_cn
       Implicit None
       call sub(a=7,c=6)
       call sub(7,6,5)
    contains
       Subroutine sub(a,b,c)
          Integer :: a,c
          Integer, Optional:: b
          Write(*,*) a,c
          If(present(b)) Then
             Write(*,*) "optional:",b
          Else
             Write(*,*) "Not Found b"
          End If
       End Subroutine
    End Program
    ```

34. Fortran的所有函数都可以使用关键字参数来调用，调用时指定的参数名是定义函数时使用的。使用关键字参数可以不按顺序调用，可以提高代码的阅读性。主调程序中如采用关键字变元调用过程，就必须写出被调子程序的接口块。

35. 指定EXTERNAL语句或属性说明实元实际上是外部过程，由于这里没有指定形参类型，所以会导致编译报warning。当用EXTERNAL语句说明SIN，COS等名字时，它们被解释为自定义函数，而非内在函数(三角函数)。

    ```fortran
    类型,EXTERNAL :: 外部函数名[,外部函数名]…    !external属性
    EXTERNAL [外部函数名][,子程序名][,块数据名]… !external语句，不过对于函数还要声明类型
    ```

36. 函数名也可以作为参数，类似于C语言的函数指针，此时形参可以用External或Interface定义，以便让编译系统明白，该实元不是一般的简单变量，而是一个过程。推荐使用后者，因为interface会在编译时检查参数传递是否正确，而external不会。过程内部不能再contains其他过程，因此不能将x2的定义放在Integral的定义中。

    ```fortran
    Program fcode_cn
       Implicit None
       Write(*,*) Integral(x2,1.0,2.0,0.01)   !结果为2.33332348
    contains
       Real Function x2(x)   !被积函数
          Real ::x
          x2 = x*x
       End Function x2
       Real Function Integral(func,low_bound,up_bound,delta) result(y)  !梯形积分算法
          !Real ,External ::func     !也可以用这个，不太推荐
          !real ::func
          !external func    !也可以用这个，不太推荐，这里会IDE会提示func被定义两次，不过不会编译不会报错
          Interface                  !定义函数形参的接口
             Real Function func(x)
                Real ::x
             End Function func
          End Interface
          Real ::low_bound,up_bound,delta
          Integer ::i
          Real ::x
          y = 0.0
          x = low_bound + delta/2.0
          Do
             y = y+func(x)
             x = x+delta
             if(x>up_bound) exit  !避免使用浮点数x来作为循环变量
          End Do
          y = y*delta
       End Function Integral
    End Program
    ```

37. Recursive形容词用来声明过程是递归的。只有这样的过程才可以自己调用自己。

    ```fortran
    Module def
       Integer, Parameter ::DP = Selected_Real_Kind(p = 12)
    Contains
       Recursive Real(Kind=DP) Function Func1(n) result(r)
          Implicit None
          Integer ::n
          If(n > 0) Then
             r = sqrt(2.0_DP * Func1(n-1))
          Else
             r = sqrt(2.0_DP)
          End If
       End Function Func1
    End Module
    Program fcode_cn
       use def
       Real(Kind=DP) ::r1
       r1 = Func1(10)
       Write(*,*) r1
    End Program fcode_cn
    ```

38. 一些不建议使用的特殊用法：多入口(entry)函数，返回语句标号的函数(Alternate returns)，语句函数(statement function)

# Interface

11. 在编译时，编译器知道内部过程的一切情况，这种成为显式接口。还有一种情况，在调用一个外部过程或一个哑过程时，编译器通常不知道该过程的各种情况，这种接口是隐式的。

12. 在F77中可用EXTERNAL语句来指明一个外部过程或哑过程，但此语句仅说明每一个外部名是一个外部过程名或哑过程名，并没有指明过程的接口，所以接口仍是隐式的。为了全面准确地通知编译系统，在主调程序中有时需要加入接口块，以说明主调程序与被调程序的接口。接口块是F90中引进的新颖程序块，它显式指明了过程接口的机制。通过接口块可用为一个外部过程或哑过程指明一个显式的接口。这比EXTERNAL语句提供了更多的信息，也提高了程序的可读性。

13. 接口就是函数相互调用或传参的指导（包括信息如：该过程是一个函数或子程序、过程名、哑元的名字、变量类型和属性、函数结果的特性等等）。在Fotran90以前，没有显式的Interface方法。函数之间的相互调用是不安全的。书写函数的Interface时，只需要保留形参声明即可，将执行语句和局部变量定义都去掉。实际上就是起到Fortran的头文件的功能。

14. Interface规定了函数间调用的方式，参数的传递方式，变量的限定，数组的上下限，是否可以忽略等。编译器会进行检查这些条件是否满足。

15. 接口块被放在主调程序的说明部分中，通常还应写在类型说明语句之前，它的内容是被调用的过程中的说明部分。

16. 除了更安全之外，有些情况下，必须使用Interface：

    1. 函数的返回值是数组，或指针

    2. 如果函数的形参为假定形状的数组，那么所有调用该函数的地方都应该用Interface声明该函数。使用假定形状的数组可以在调用函数时不用传递数组的维度，大小信息。

       ```fortran
       Program fcode_cn
          Implicit None
          Real ::a(2,5)
          Interface
             Subroutine sub(x)
                Real ::x(:,:)
             End Subroutine
          End Interface
          call sub(a)
       End Program fcode_cn
       
       Subroutine sub(x)
          Implicit None
          Real ::x(:,:)
          Write(*,*) size(x,dim=1),size(x,dim=2)
       End Subroutine
       ```

    3. 参数具有Intent，Value，Optional属性时

17. 当函数名作为参数时，即存在函数指针，也建议使用Interface。实际上建议在任何函数调用时，都是用Interface。

18. 如果将子程序或函数放在主程序内部，也就是End Program之前。在其上一行加上contains，就可以不用声明Interface了。

    ```fortran
    Program fcode_cn
       Implicit None
       Real ::a(2,5)
       call sub(a)
    contains
       Subroutine sub(x)
          Implicit None
          Real ::x(:,:)
          Write(*,*) size(x,dim=1),size(x,dim=2)
       End Subroutine
    End Program fcode_cn
    ```

19. 在过程内要调用其他外部过程，或者其他模块的内部过程，前者需要使用interface对该过程进行说明，后者不需要。

20. 

# 模块

1. 使用模块的目的是将有关联的数据和函数聚合起来，好处有：

   1. 避免每次都在调用函数的地方书写Interface
   2. 数据共享
   3. 数据和过程的封装，保护和继承

2. 模块的主要作用是供其它程序单元引用。一个程序单元如果引用模块，实际上就是把该模块内的全部语句复制到本程序单元中，并且所有与模块中的名字相同的变量等，彼此取值相通、共享存贮单元。所以引用模块起两个作用：共享与复制。它可代替COMMON、EQUIVALENCE和INCLUDE语句的功能。存储在公共块COMMON中的变量可以被摘录和保存到模块之中。使用模块还可以保证在所有使用这些变量的程序单元中，变量声明是一致的，且是用同一个值初始化的。

3. 如果一个程序单元中，只使用模块中的部分变量或需要重新命名部分变量，该单元可以指定这些变量具有ONLY属性。

4. 模块中的内部过程，实际上可以看作是外部过程，因为被use之后，可以直接调用。

5. 模块内部不能有执行语句。不能执行函数和变量赋值。不过变量可以有初始值。

6. 使用模块时，use 模块一定要出现在Implicit None前。Module中也应该使用Implicit None。

7. Module是F90区别于F77的重大进步。在F2003之后，Module和Type结合，使得Fortran面向对象编程成为可能。Module的出现是为了替代Common，Common是按照字节数结合，而不是变量名，不建议使用。

8. 不同编译器的mod文件不兼容，需要重新生成。当有保密源码需求时，可以将源码中模块的执行语句都删除，然后发送给对方，生成mod文件即可。所以有些闭源的库在提供给用户使用时，也提供源代码，不过是删减过执行语句的源码。

9. 函数如果和主程序Program在同一个文件中，应该用Contains包含在Program中或写在Module中。要不然大多需要写Interface。

10. 模块中可以包含数据对象，类型定义，过程和接口，通过在program，过程和其他模块中使用use来访问模块中定义的东西。例子：

   ```fortran
   ! hello.f90
   program use_mod
       use my_mod
       implicit none
       real :: mat(3, 3)
       mat(:,:) = public_var !由于在模块my_mod中将public_var导出为public了，所以这里可以直接使用
       call print_matrix(mat)
   end program use_mod
   
   ! newmod.f90
   module my_mod
       implicit none
       private  ! 所有的名称默认为private的，即在模块外use后，也不能访问的
       public public_var, print_matrix  ! 显式导出2个名称为public
       real, parameter :: public_var = 2
       integer :: private_var =3
   contains
       subroutine print_matrix(A)
           real, intent(in) :: A(:,:)  ! 假设形状的形参
           integer :: i
           do i = 1, size(A,1) !会获得A的第一维的元素数量
               print *, A(i,:)
           end do
       end subroutine print_matrix
   end module my_mod
   ```

11. 推荐将函数和子程序放在模块中。一个.f90文件中可以同时包含program和module，但是必须将module放在program前。

12. 模块定义的文件名后缀也是.f90，每次保存后，IDE会自动编译产生一个同名的.mod文件。但这并不是模块编译后的目标文件。：

    ```fortran
    !hello.f90内use了newmod.f90的内模块my_mod，有2种编译方法：
    gfortran hello.f90 my_mod.f90 -o hello  !可以直接将所有源文件一起编译链接
    !也可以逐个将所有的源文件都编译为目标文件，然后一起链接生成可执行文件
    gfortran -c hello.f90 !产生hello.o
    gfortran -c newmod.f90 !产生newmod.o和my_mod.mod
    gfortran hello.o newmod.o -o hello !这里不能使用gcc
    ```

13. 在单独编译使用模块的源文件时，如果没有模块对应的.mod文件则会报错提示.mod文件不存在，可以打开模块.f90文件，随便修改一下然后保存，IDE就会自动生成对应的.mod文件，也可以手动编译.f90文件，此时除了会生成对应的目标文件外，也会生成.mod文件。

14. use的用法：

    ```fortran
    USE 模块名1, 模块名2, … 模块名n
    use my_mod !会导入模块中所有的public名字
    use my_mod, only: var1,var2 !仅导入模块中特定的名字 var1和var2, 如果使用了没导入的名字，则会提示名字没有implicit类型的错误
    use my_mod, only: printMat=>print_matrix !仅导入模块中特定的名字print_matrix，同时重命名为printMat，类似于python的from import as，注意这里=>后的是模块中原本的名字
    ```

15. 可以在模块定义中规定哪些名称允许共享、也可以在use模块时规定只导入那些名称。

16. Module中定义的变量，在模块内可以任意使用，其他use了模块的地方也可以任意使用。其值是保持一致的。模块内函数可以相互调用，模块内的函数不能访问其他函数的形参。

    ```fortran
    module fcode_mod
       implicit none
       Integer,save::a = 0
    contains
       Subroutine fc_init()
          a = 1    !在模块的函数内可以使用模块内定义的白能量
       End Subroutine
    end module fcode_mod
    
    Program fcode_cn
       use fcode_mod
       Implicit None
       Write(*,*) a  !结果为0
       a = 3
       Write(*,*) a  !结果为3
       call fc_init()
       Write(*,*) a  !结果为1
       call sub()
       Write(*,*) a  !结果为5
    contains
       Subroutine sub()
          Implicit None
          a = 5   !在use了模块的函数内也可以使用
       End Subroutine
    End Program fcode_cn
    ```

17. Fortran中没有全局变量。Common称为(未命名的)公共区，Module称为模块。因为要使用它们必须要use，例如 Common /变量列表/或者use 模块名。而全局变量是不需要任何引入就可以使用的。

18. Module支持对其内的变量和子程序定义访问权限。有三个：

    1. Public，变量和子程序都可以在模块外使用，默认权限
    2. Protected，变量在模块外部只读，对函数的效果和Private相同。
    3. Private，变量和函数在模块外不可见。

19. 可以在模块的开头，Implicit None之后，声明整个模块内变量和函数的默认访问权限（下面的第3行）。也可以单独对变量和函数声明访问权限。如果违反了权限规则来使用变量和函数，会报对应的符号没有隐式类型的错误。

    ```fortran
    Module name
       Implicit None
       Private     !如果省略，则整个模块的默认访问权限为public,访问权限对模块内部不起作用。
       Real ::r1    !使用默认的private权限
       Real, public ::r2 !单独声明为public权限
       Public :: sub
    Contains 
    	Subroutine sub()
    		Implicit None
    		Write(*,*) "sub"
    	End Subroutine
    End Module
    Program fcode_cn
       use name
       Implicit None
       r1 = 3.4
       r2 = 4.5
       Write(*,*) r1,r2
    End Program fcode_cn
    ```

20. 模块内部也可以use其他模块，这样构成了模块的继承。这样子模块就获得了父模块所有的public变量和函数。也可以使用only，只继承父模块的部分成员。

    ```fortran
    Module ma
    	use mb 
    	use mc, only: c1,c2  !只继承部分成员
    	use md, only: a5 =>d1,d2  !继承的同时，将d1改名为a5，可以避免名字冲突或者简化写法。
    End Module
    ```

21. 不建议使用多继承。不能出现环状继承。模块改变后，使用它的所有文件都应重新编译。因此编写Make file文件时，要考虑模块之间的依赖。

22. 每个模块在编译时，都会产生一个和内部module同名的.mod文件。.mod文件可以认为是module的概述，不含执行语句，与C语言的头文件作用类似，但是Fortran的mod文件是自动生成的。use module时，编译器需要在搜索路径中找到对应的mod文件。

23. 建议模块内所有public的变量和函数的名称都加上模块名的前缀，这样可以尽可能避免名字重复。

24. 通常在为某一个派生类型规定新的操作符时，就把实现这些新操作的过程作为模块的内部过程放在CONTAINS后面，以便把这种操作定义供各外部过程共享。

25. 可以把整个可执行程序中都要用到的全局过程封装在一个模块的contains中，之后在需要调用全局过程的地方USE该模块，再写上接口块即可使用该全局过程，接口块的实体是模块过程语句。

    ```fortran
    PROGRAM fcode_cn
        USE Module1
        call func1(5)
    END PROGRAM
    
    MODULE Module1
    CONTAINS
        subroutine func1(x)
            integer, intent(in) :: x
            print *,x
        END subroutine
    END MODULE
    ```

26. 有一些需要全局公用数组，它们的大小在程序执行前是不知道的，可以将其放在在模块中，定义为可分配的，然后在其他地方use模块，实际用到的时候再进行allocate即可。

# Common，Equivalence，Include

1. 不同的程序单元间的变量相互传递数值有两个办法，一个是哑实结合，一个就是数据共享。共享就是让编译系统把两个变量名分配在同一个内存单元中。共享方式有以下几种：

   1. Fortran77中可以使用COMMON语句和EQUIVALENCE语句，使用这些语句共享数据的效率不高，编程时容易出错。
   2. Fortran90中可以使用模块。
   3. 使用INCLUDE语句可进行语句段复制。

2. COMMON语句比哑实结合的方法进行数据传递的速度要快，其方法是开辟一个公共块，公共块可以是无名的(只能有一个)，也可以是有名称的。COMMON语句是说明语句，通常是紧跟在程序单元的起始句之后。一个程序单元可以有多条COMMON语句。：

   ```fortran
   COMMON [/[公共块名1]/]变量名表1[[,]/[公共块名2]/变量名表2]... !公共块名可以和变量名相同，变量名不得是哑元、可分配数组、自动对象、函数名或函数结果名或ENTRY名，并且不得有PARAMETER属性。
   !不同程序单元中相同公共块名下的变量名可以是不同的。因为在不同程序单元中的相同公共块名中的变量，是按位置一一对应共享同一存储单元的。
   !对于公共块名是按照名字搜索，对于变量是按照位置对应的
   !例子，如下一个程序单元中有5条common语句，可以合并为两条有名公共块语句，而//是无名的。
   COMMON/happy/we,you,they !定义了一个公共块，名为happy，内部包含3个变量we,you,they
   COMMON/     /our,your,their ! //之间的空格无效
   COMMON/happy/i,he,she !可以和第1句合并
   COMMON/angry/dog,cat,mouse
   COMMON my,his,her !可以和第2句合并
   !等价于
   COMMON/happy/we,you,they,i,he,she !一个公用名happy对应6个变量
   COMMON/angry/dog,cat,mouse
   COMMON/     /our,your,their,my,his,her
   !使用例子
   Program fcode_cn
       Implicit None
       integer :: a,arr1(3)
       common a,/ar/arr1 !变量a为空块的第1个，common / /a也是一样的效果，变量arr1在ar块的第一个位置
       a = 3
       arr1 = 5
       call func1()
       print *,a !输出为4
       print *,arr1 !输出为6
   End Program
   !将subroutine func1单独放到一个.f90文件中或者和program fcode_cn放在一起，结果都是一样的。
   subroutine func1()
       integer ::b,arr2(3) !需要定义成同形状的，这样才是所有数组元素也共享
       common b,/ar/arr2 !变量b为空块的第一个，所以和主程序的a共享同一存储单元。变量arr2在ar块的第一个位置，和主程序的arr1共享同一存储单元
       b = 4 !也会修改a的值
       arr2 = 6 !也会修改arr1的值
   end subroutine
   ```

3. EQUIVALENCE语句必须出现在程序单元的执行语句之前。可以使同一个程序单元中的两个或更多的变量共用同一个存储单元，以节省内存，允许用两个或更多的变量名代表同一个量。不同程序单元之间没有效果。

   ```fortran
   EQUIVALENCE (变量名表1),(变量名表2),…
   Program fcode_cn
       Implicit None
       integer :: a,b
       equivalence (a,b)
       a = 3 !此时a,b都为3
       b = 5 !此时a,b都为5
       print *,a !结果为5
   End Program
   ```

4. INCLUDE语句会另一个文件中的原程序段包括进来，实现复制功能。和C语言的include一样，单纯的复制。被包含文件中也可以有其它的INCLUDE语句，但不能是循环的。

   ```fortran
   INCLUDE '文件名[/[NO]LIST]'
   ```


# 作用域

1. 作用域单元可以包含其他作用域单元。例子：

   ```fortran
   MODULE SCOPE1                            ! Scoping unit 1
       ...                                  ! Scoping unit 1
   CONTAINS                                 ! Scoping unit 1
       FUNCTION SCOPE2                      ! Scoping unit 2
           TYPE SCOPE3                      ! Scoping unit 3
               ...                          ! Scoping unit 3
           END TYPE SCOPE3                  ! Scoping unit 3
           INTERFACE                        ! Scoping unit 3
               ...                          ! Scoping unit 4
           END INTERFACE                    ! Scoping unit 3
           ...                              ! Scoping unit 2
       CONTAINS                             ! Scoping unit 2
           SUBROUTINE SCOPE5                ! Scoping unit 5
               ...                          ! Scoping unit 5
           END SUBROUTINE SCOPE5            ! Scoping unit 5
       END FUNCTION SCOPE2                  ! Scoping unit 2
   END MODULE SCOPE1                        ! Scoping unit 1
   ```


# 泛型，操作符重载

1. 统一接口允许把多个子程序绑定成一个名字，由编译器根据实参的情况来决定到底调用那个，也就是泛型。

   ```fortran
   Module plus_2
      Interface plus
         Module Procedure :: plus_Int,plus_Real
      End Interface
   Contains
      Integer Function plus_Int(a,b)
         Integer::a,b
         plus_Int = a+b
         Write(*,*) "Int"
      End Function
      Real Function plus_Real(a,b)
         Real::a,b
         plus_Real = a+b
         Write(*,*) "Real"
      End Function
   End Module
   
   Program fcode_cn
      use plus_2
      Implicit None
      Integer ::a
      Real ::ra
      a = plus(3,4)
      ra = plus(2.5,3.5)
   End Program fcode_cn
   ```

2. 标准库中函数，基本都使用了泛型，例如sin函数，是sin dsin qsin csin cdsin cqsin的统一接口。d表示双精度，q表示四精度，c表示复数。而且它们大多还是逐元函数，也就是说参数可以是数组，此时结果也会是数组。

3. 类属过程是过程的一种，它允许用不同类型的实元与同一个哑元结合，也即放宽了哑实元结合时类型必须一致的条件。在内在基本函数中，已经有许多类属过程，例如abs。

4. 编写类属过程的方法是先编写着干个功能相同的过程，它们分别以整型、实型、复型等作哑元类型。而后在主调程序中编写接口，为接口取一个统一的名，接口内分别列出哑元类型不同的过程说明部分语句。这个统一的接口名就是类属过程名。

5. 自定义操作符，类似于C++的操作符重载。要求重载函数的第一个形参的属性必须是Intent(in)，即不能改变左操作数。

   ```fortran
   Module SecMod
      Implicit None
      Type ST_sec
         Integer ::sec
         Integer(Kind=2) ::ms,us
      End Type
      Interface Operator(-)  !两个结构体直接相减
         Module Procedure SecDec_Us
      End Interface
   Contains
      Integer(Kind=8) Function SecDec_us(stSec1,stSec2)
         Type(ST_sec), Intent(IN)::stSec1,stSec2
         Integer(Kind=8) :: n1,n2
         n1 = stSec1%sec*1000000_8+stSec1%ms*1000_8+stSec1%us
         n2 = stSec2%sec*1000000_8+stSec2%ms*1000_8+stSec2%us
         SecDec_us = abs(n1-n2)
      End Function
   End Module
   
   Program main
      use SecMod
      Implicit None
      Type(ST_sec)::stSec1=ST_sec(4,5,6),stSec2=ST_sec(1,2,3)
      Write(*,*) "between,", stSec2-stSec1, " seconds" !结果为3003003
   End Program
   ```

# 标准输入输出

1. 数据传输语句有：READ，ACCEPT，WRITE，PRINT和REWRITE。

2. 文件连接、查询和定位语句有：BACKSPACE，CLOSE，DELETE，ENDFILE，INQUIRE，OPEN，REWIND和UNLOCK。

3. 一个记录是一个数字或字符的序列，有三种记录形式，格式化记录、非格式化记录和文件结束记录。

4. PRINT语句向屏幕输出，TYPE语句是PRINT语句的别名，其规则是：

   ```fortran
   PRINT {*|格式}[,I/O列表]  !和write不同的是，不用括号了
   PRINT 名称列表 
   !以下两条语句等价
   PRINT     '(A3)', 'Abb'
   WRITE (*, '(A3)') 'Abb'
   ```

5. 为了在打印记录时提供走纸控制，使用*的每个输出记录自动以空格作为开头。

6. 3种输入输出情况：格式化I/O，直接列表I/O，名称列表I/O。后两种都是非格式化的，使用系统默认的格式输出。

7. 直接列表I/O的输入输出由I/O列表中每一项确定，格式符使用*。用户从键盘输入或从文件读入时，每一项之间以空格或逗号分隔，两个连续的分隔符表示为空值。两个数字之间的空格被解释为分隔符。

   ```fortran
   !只有字符常量可以在内部包含空白
   character(len = 5) ::str1
   read(*,*) str1 !如果输入 "ab c"，则str1 = "ab c" 
   !与分隔符(逗号，斜杠或其它空格)相邻的空格被忽略
   integer ::a,b,c
   read(*,*) a,b,c !输入5,  6  /7 等价于5,6,/7，因此a,b分别被赋值为5 6，而c保持原来的值
   !重复输入的值可以通过给该值乘上要重复的次数来实现。
   integer ::a,b,c
   read(*,*) a,b,c !输入2 2*5 等价于2 5 5，因此a,b,c分别被赋予2 5 5。
   !使用用连续分隔符可以为某项指定空值，空值不会修改变量原有的值，也可以用n*来表示多个连续的空值
   !斜杠(/)将结束输入流，后续项获得空值
   integer ::i1,i2,i3,i4,i5,i6
   i1 = 1
   i2 = 2
   i3 = 3
   i4 = 4
   i5 = 5
   i6 = 6
   read(*,*) i1,i2,i3,i4,i5,i6!如果输入7,,8,2*/9 此时会给i1赋值7，而i2,i4,i5,i6和维持原来的值,i3被赋值为8
   print *, i1,i2,i3,i4,i5,i6 !结果为7 2 8 4 5 6
   ```

8. 直接列表输出，每种内部数据类型有其默认的输出格式。

9. 名称列表I/O是指：名称列表组namelist语句将一组变量用一个名字相关联。可以在输入和输出中使用这个名字代替这一组变量。如果指定了名称列表，则后面不需要I/O列表也不允许出现I/O列表。其一般形式为：

   ```fortran
   namelist/名称列表组名/变量列表[[,]/组名/变量列表]...
   namelist/INPUT/NAME,GRADE,DATE/OUTPUT/TOTAL,NAME !2个组，第一个组名为input，包含3个变量NAME,GRADE,DATE，第二个组名为output，包含2个变量TOTAL,NAME。
   
   !名称列表输出中第一个输出记录是连字符(&)，紧接着是大写的名称列表组名称。然后是一个等号和变量当前的取值。名称列表输出由斜杠结束。变量的输出格式与直接列表I/O中的相同。
   INTEGER a,b(3)
   LOGICAL    b
   REAL       c
   CHARACTER(len = 5)  str1
   NAMELIST /example/ a,b,c,str1 !定义namelist名为example
   a  =  14
   b  = .TRUE.
   c  =  24.0
   str1 = 'abcde'
   WRITE (*,example) !这里输出example中的所有变量。输出为：
   &EXAMPLE  !首先输出连字符&，然后是namelist的名字
    A=14         , !逐个namelist中的变量名和变量值
    B=T,
    C=  24.0000000    ,
    STR1="abcde",
    / !结束后输出一个/
   !使用名称列表从文件输入时，只能读取同样方式输出的文件。
   ```

10. print输出一个数组或结构体时，会依次对输出每个元素或成员调用print，中间不额外加空格或换行，即当作一维数组。使用read读入时也一样。

   ```fortran
   integer ::arr1(3) = [1,2,3] !一维数组,结果为           1           2           3
   Character(Len=2) ::strarr(3) = ["ab", "cd", "ef"] !字符串数组,结果为 abcdef
   integer ::arr(3,4) = reshape([1,2,3,4,5,6,7,8,9,10,11,12],[3,4]) !测试下二维数组的结果
   ```

11. print输出一个结构体时，会依次输出其所有的成员，按照定义的成员顺序。

    ```fortran
    type(student) :: st1 = student(1, "abcd", 4,5)  ! 通过位置参数来初始化
    print *,st1   !结果为 1 abcd                 4           5
    ```

12. read语句的数据源中数据之间以英文逗号、空格或换行符为间隔，单个数据中间不能有空格。

13. 如果一次要读取多个数据，但是只输入了部分数据后就按下了回车，则会继续读取：

    ```fortran
    INTEGER :: a(3),i
    READ *, (a(i), i=1,3) !输入1，按回车后会继续提示输入，此时输入2 3，按回车后，则结束输入
    print *,a
    read *,a !等价于第二句
    ```

14. 使用隐式do循环读取比显式do循环好的一点是，隐式的do支持一次读入多个数据

    ```fortran
    READ *, (a(i), i=1,3) !输入1 2 3，按下回车，会将1 2 3赋值给a(1),a(2),a(3)
    do i =1,3
    	read *,a(i) !输入1 2 3，按下回车，也只会将1赋值给a(1)
    end do
    ```

15. 多维数组的输入输出顺序是按照数组的存储顺序来进行的：

    ```fortran
    integer ::a(2,3)
    read *,a !输入1 2 3 4 5 6
    print *,a(2,1) !结果为2
    print *,a !结果为1 2 3 4 5 6
    ```

## 格式化I/O

1. 格式化I/O：格式列表是一系列格式描述符构成的字符常量，之间用逗号隔开。

   ```fortran
   100 FORMAT('A=',I5,'B=',F7.2) !使用format语句定义格式列表，100为可以被引用的标号。系统按write,read,print语句中指定的标号找到相应的FORMAT语句。
   !format语句可以出现在程序的任何地方(主程序中必须在PROGRAM语句之后和END语句之前，如果在子程序中用FORMAT语句，则应在子程序定义语句之后)
   WRITE(*,"(F8.5,2I3,A20)") REAL1, INT1, INT2, "format list example" !外部的括号不可省略，如果是在format语句中出现，则不用括号
   !可以使用ASSIGN语句把FORMAT语句的标号和一个整型变量相联系，随后使用这个变量来引用FORMAT语句
   ASSIGN 9000 TO MYFMT
   WRITE(*,MYFMT) iolist !相当于WRITE(*,"(I5,3F4.5,A16)")
   9000 FORMAT(I5,3F4.5,A16)
   !格式列表也可以使用字符串表达式
   CHARACTER(80) MYLIST
   MYLIST='(I5,3F4.5,A16)'
   WRITE(*,MYLIST) iolist
   !使用字符串数组也可以
   CHARACTER(6) array(3)
   DATA array/’(I5’, ’,3F4.5’, ’,A16) ’/ !三个元素分别初始化
   WRITE(*,array) iolist
   ```

2. 输出规则：

   1. 如果输出字符的数目超过了指定的区域宽度或指数宽度，则整个区域将被写为星号(*)。如果实数的小数点后包含的数字位数比区域允许的多，结果会四舍五入。
   2. 输出时数字是右对齐的，如果输出数字少于规定宽度前面会补上空格。
   3. 规定复数的格式时需要两个连续的F，G和D编辑描述符，而且两个编辑符可以不同，第一个指定实部，第二个指定虚部。
   4. 在可重复编辑描述符之间可以出现不可重复编辑描述符。

3. 可重复编辑符告知Fortran输入输出系统如何解释FORMAT语句中的数据项。它可以根据I/O列表中数据项的需要重复任意次。：

   ```fortran
   !可重复编辑符有
   I !整数，Iw[.m]，w用来指定字段宽度，负号也会计入，m表示需要输出的最少数字位数，不足添0
   B O Z !分别表示2,8,16进制，用于整数、实数和逻辑量的输出，Fortran90新增的，Bw[.m]，m表示需要输出的最少数字位数，默认为1，负数使用补码输出，这个和具体的CPU有关。一个数据存储中的INTEGER(4)输出时是32个二进制字符。
   F  !没有指数的实数，也就是单精度小数，Fw.d w也是字段宽度，负号和小数点都会计入，d是小数位数，由于难以事先确切估计出数据值的大小，输出过大的数时容易产生 宽度不够 的错误，输出过小的数时会出现丢掉有效数字的情况。
   E  !有指数的实数，Ew.d，w为字段宽度，d为以指数形式出现的数据的数字部分的小数点后的位数，例如-0.746578E+03的d就是6，w为13，包括E和后面的加号。考虑到一些固定出现的字符，需要满足w≥d+7才不会输出*。用E编辑符可以避免“大数印错，小数印丢”的情况，但是和F编辑符相比可能不太直观。有的编译器会省略小数点前的0，例如-.746578E+03
   D  !双精度实数，Dw.d，和F类型
   EN !工程计数法，F90新增的，ENw.d[Ee]，和E基本类似，区别在于EN输出数据的非指数部分的绝对值强制在1到1000的范围内，且指数可以被3整除。例如将-0.746578E+08调整位-74.6578E+06
   ES !科学计数法，F90新增的，ESw.d[Ee]，和E基本类似，区别在于ES输出数据的非指数部分的绝对值强制在l到10的范围内，而非E的0到1的范围
   L  !逻辑，Lw，真时输出T，假时输出F，w>1时左边补空格。
   A  !字符串，A[w]，如果待输出的字符串的长度大于w，则左边补空格，否则只输出最左边的w个字符。如果省略w，则按照字符串定义的长度输出
   G  !普通 !综合了F和E的长处，可以根据输出的实数大小决定用F型格式输出或E型格式输出。Gw.d，绝对值小于10^-d或大于10^d的数用E格式，否则用F格式，有效数字为d位
   X  !空格
   ```

4. 有两种重复的形式，不过第二种带<>的形式已经被gFortran移除支持了。改成了新的形式：

   ```fortran
   3I5      !I5会重复3次
   <J+K>I5  !会先计算J+K，然后重复结果的次数
   <max(2,4)>I5 !会先计算max(2,4)，然后重复结果的次数
   CHARACTER(LEN=7) FMT
   WRITE(FMT,'("(", I0, "f8.4)")') 1+1 !写入到FMT字符串中，3个编辑符号，第1个位字符串(I，第二个位整数表达式1+1的值，第3个为字符串) 此时FMT="(2f8.4)" 正好7个字符
   WRITE(6,FMT) INT1
   ```

5. 可重复编辑符的例子：

   ```fortran
   INTEGER :: a = 456
   WRITE (*,"(I6.4)") a !结果为  0456，0前面有2个空格
   real :: f1 = 2.56
   WRITE (*,"(f8.4)") f1 !结果为  2.5600，2前面还有2个空格
   real :: f1 = -746.578
   WRITE (*,'(E15.6)') f1 !结果为  -0.746578E+03，负号前还有2个空格
   real :: f1 A = 758321.6
   WRITE (*,'(G14.7)') f1 !结果为  758321.6，7前面还有2个空格，由于d=7,而这个数<10^7所以使用F格式
   WRITE (*,'(G14.5)') f1 !结果为   0.75832E+06，0前面还有3个空格，由于d=5,而这个数>10^5所以使用E格式
   write(*,'(B8.8)') 22 !结果为00010110，由于最少输出8位数组，因此会补0
   write(*,'(O4.4)') 22 !结果为0026
   write(*,'(Z4.4)') 22 !结果为0016
   real :: f1 = -74657800
   WRITE (*,'(E15.6)') f1 !结果为  -0.746578E+08
   WRITE (*,'(EN15.6)') f1!结果为 -74.657800E+06
   WRITE (*,'(ES15.6)') f1!结果为  -7.465780E+07
   !规定复数的格式时需要两个连续的F，G和D编辑描述符，而且两个编辑符可以不同，第一个指定实部，第二个指定虚部。
   complex ::c1 = (5,3)
   write(*,"(f8.4,f6.2)") c1!输出为  5.0000  3.00，5前面有2个空格，3前面有2个空格
   ```

6. 不可重复编辑符，可以改变解释重复编辑符的方式，还可以改变完成输入输出的方式，在可重复编辑描述符之间可以出现不可重复编辑描述符。例子：

   ```fortran
   !()内放置字符串即可，但是需要考虑外部引号的存在
   WRITE(*,"('lala')") !输出字符串lala
   WRITE(*,"('I''m boy')") !输出字符串I'm boy
   WRITE(*,'(9HI''m a boy)') !9H表示输出长度为9的字符串，保留H编辑符是为了和Fortran66兼容，不过在Fortran95中已经被废除。
   WRITE(*,"(1X,'I=',I3,5X,'J=',I4)") 215,1125 !5X表示5个连续的空格结果为 I=215     J=1125，I前面有1个空格，J前面有5个空格。
   !斜杠(/)编辑符的作用是结束记录在本行的输出并从下一行开始输出下一个记录。如果有两个连续的斜杠，相当于增加一个空行输出。如果在编辑符的最后出现斜杠，也是再输出一个空行。
   WRITE(*,"(I3,I4/I1,I2//3F4.2/)") 3,4,5,6,5.3,5.8,6.5 !一共输出5行，第3和5行为空行
     3   4
   5 6
   
   5.305.806.50
   
   !反斜杠(\)编辑符和美元($)编辑符的作用相同，都是在输出一个记录行后取消默认的回车符
   integer :: My_age
   Write(*,'("Please Enter Your Age =",$)') !2个编辑符，第二个为$
   Read(*,*) My_age !回合上面的提示字符串出现在同一行
   ```

# 文件读写

1. Fortran支持两种文件的访问方式(顺序访问和直接访问)和三种文件的结构(有格式、无格式、二进制)。顺序访问或直接访问可以用于这三种结构的文件进行的每一种。因此，共有6种文件情况。

2. 文件分为3种：

   1. 格式化文件（form = "formatted"，open中form参数的默认值）：记录数据内容的记录是以ASCII字符的方式存在的，每一条记录是以ASCII码中的回车符CR(0D)加换行符LF(0A)来结束的。可以使用文本编辑器直接打开查看。记录用回车符(0DH)和换行符(0AH)分开。文本文件一般小于100MB，否则读取速度就明显变慢。

   2. 无格式文件（form = "unformatted"）：由一系列物理块组成的记录组成，记录的内容和内存中的数据非常像。这使得即使数据的内容是可显示的ASCII字符，用记事本打开也无法正确显示。Read和Write时不能使用任何格式，表控格式也不行。由于去掉了格式控制，读写速度比格式化文件更快。

   3. 二进制文件（form="binary"）：二进制文件是处理最快、最简洁的一种文件，也是最紧凑的存储格式，适合于大批量数据的存储。gFortran不支持。

3. 读写方式有2种：

   1. 顺序读写（access = "sequential"，open的默认值）：存放在顺序文件中的数据必须一个记录接一个记录地按顺序被访问，即程序中要读写第N条记录时，必须至少已对前面的N-1记录进行过读操作。内部文件也必须使用顺序文件。键盘、显示器和打印机等顺序访问的外部设备必须连接成顺序文件。
   2. 直接读写（access = "direct"）：存放在直接访问文件中的记录可以以任意顺序进行读写操作。记录的长度是通过OPEN语句中的RECL选项来描述的。通过指定要访问的记录号来实现读写记录。因此想要实现数据的随机访问可以使用直接访问文件。直接文件中的每个记录的长度必须相等。如果实际输出的记录长度不等，则应取输出的所有记录中最大的长度作为每个记录的长度。用直接方式建立的文件可以使用顺序方式打开进行读操作。用顺序方式建立的文件，只要记录长度相等，也可以用直接方式打开进行读操作。

4. 6种情况：

   1. 顺序读写格式化文件：

      ```fortran
      OPEN(3,FILE='xx.txt') !form和access都取默认值。
      WRITE(3,'(A,I3)') 'RECORD',1 !输出RECORD  1
      WRITE(3, '()') !输出一个空行
      CLOSE(3)
      ```

   2. 直接读写格式化文件，CR和LF是分隔符，不包括在RECL中：

      ```fortran
      OPEN(3,FILE='xx.txt',FORM='FORMATTED',ACCESS='DIRECT',RECL=10)
      WRITE(3,'(A10)',REC=1) 'RECORD ONE' !在开头写入10个字符
      WRITE(3,'(I5)',REC=3) 30303 !在21处写入5个字符，因此中间空了一个记录，即10个字符，会被填充为0。所以此时文件中存在空字符，记事本会提示为二进制文件，如果将这句的rec修改为2，则不存在控制符，记事本可以正常打开。
      CLOSE(3)
      ```

   3. 顺序读写无格式文件：

      ```fortran
      CHARACTER(3) ::xyz
      INTEGER ::idata(4)
      DATA idata/4*-1/,xyz/'xyz'/ !初始化
      OPEN(3,FILE='xx.txt',FORM='UNFORMATTED')
      WRITE(3) idata !第1条记录为4个32位的整数，一共占用16个字节，所以辅助数据位0x10
      WRITE(3) xyz !第2条记录为一个长度为3的字符串，一共占用3个字节，所以辅助数据位0x03
      CLOSE(3)
      !文件的二进制数据为
      10 00 00 00 ff ff ff ff
      ff ff ff ff ff ff ff ff
      ff ff ff ff 10 00 00 00
      03 00 00 00 78 79 7a 03
      00 00 00
      ```

   4. 直接读写无格式文件：

      ```fortran
      OPEN(3,FILE='xx.txt',RECL=10,FORM='UNFORMATTED',ACCESS='DIRECT')
      WRITE(3,REC=3) .TRUE., 'abcdef'!在21的位置处输出2个变量，.true.被输出为4字节的整数1。
      WRITE(3,REC=1) 2049 !输出一个4字节的整数，第1条记录还有6个字节
      CLOSE(3)
      !文件的二进制数据为
      01 08 00 00 00 00 00 00
      00 00 00 00 00 00 00 00
      00 00 00 00 01 00 00 00
      61 62 63 64 65 66
      ```

5. 格式化文件一打开就直接写的话，会先将文件长度截断为0。

6. 默认情况下使用“顺序读取”的方式来读取文本文件，使用“直接读取”的方式来读取二进制文件。

7. 一个记录就是数字或字符的序列，有3种记录形式：

   1. 格式化记录，读写时需要在内部数据和外部数据之间转换，外部数据=内部数据+辅助数据，辅助数据前后各4个字节，记录了内部数据的长度。格式化I/O语句有确切的格式说明符或名称列表，只有格式化I/O语句才能读写格式化记录。

   2. 非格式化记录，非格式化记录保持其内部形式，而内部形式依赖于处理器（例如大端或小端），直接将内存中的字节序列拷贝到文件中。只有非格式化I/O语句才能读写非格式化记录。

   3. 文件结束记录，是文件的最后一个记录，可以在顺序文件中用ENDFILE语句输出一个文件结束记录。

8. 读写文件常用的函数：

   ```fortran
   Open(Unit=通道号，File="文件名") !其中通道号可以省略。
   Read(通道号，*) 变量列表        !第二个参数是表控格式，*表示使用自动控制格式。
   Write(通道号，*) 变量列表
   Close(通道号)                   !关闭文件，释放资源。
   ```

9. 通道号相当于文件描述符，打开后通过通道号来操作文件。在以前，通道号一般由程序员给定，一般用>10的数字。10以下的数字会被编译器用作标准输入和输出等。如果通道号被占用，则会报错。从F2003开始增加了输出参数NewUnit，允许编译器自动分配通道号。

   ```fortran
   Integer ::FILE_1
   Open(NewUnit = FILE_1, File = "xx.txt")
   ```

10. 如果不指定表控格式，每次Read读取完整的N行（至于N是多少，取决于变量列表中的变量个数），后续的每次读取都会从整行的开头读取：

    ```fortran
    !文件内容如下
    11 22 33
    44 55
    66 77
    !
    Program main
       Integer ::a,b,c,d,e,f
       Integer ::FILE_1
       Open(NewUnit = FILE_1, File = "xx.txt")
       Read(FILE_1,*) a,b,c,d  !会读取2行，然后赋值a=11,b=22,c=33,d=44。丢弃掉55
       Read(FILE_1,*) e,f     !从第三行开始读取，赋值c=66,d=77
       Write(*,*) a,b,c,d
       Write(*,*) e,f
    End Program  
    ```

11. 自动表控格式也是有格式，表示是文本文件，使用自动表控格式来读取文本文件特别方便。二进制文件不需要任何格式。直接读取时不能使用表控格式。

12. Open函数：

    ```fortran
    OPEN([UNIT=]unit[,ACCESS=access][,ACTION=action][,BLANK=blanks][,BLOCKSIZE=blocksize][,CARRIAGECONTROL=carriagecontrol][,DELIM=delim][,ERR=err][,FILE=file][,FORM=form][,IOFOCUS=iofocus][,IOSTAT=iostat][,PAD=pad][,POSITION=position][,RECL=recl][,SHARE=share][,STATUS=status])
    form = "formatted" !指定文件是有格式的，即文本文件。顺序读取时，默认是formatted，直接读取时，默认是unformatted。
    access = "Direct"，"Sequential"或"Append"  !指定读写时使用的方式：直接读写，顺序读写或追加
    ACTION = "read"，"write"或"readwrite" !文件的打开方式，读写，只读，只写，默认为读写。
    BLOCKSIZE !指定以字节为单位的设备缓存的大小
    DELIM ="APOSTROPHE"，"QUOTE"，"NONE" !指明分隔直接列表或格式化名称列表记录的方式，单引号，双引号，不用分隔符
    FILE  !文件名，字符串表达式，省略此项时，编译器将自动产生一个文件名唯一的临时文件，这个临时文件将在结束运行或与文件连接的设备关闭后被删除掉。
    POSITION="ASIA"，"REWIND"，"APPEND"     !指定打开顺序文件的访问位置，ASIA表示，如果重复打开已经被打开的文件，则asia表示保持同一个位置，从未打开的文件则是开头。rewind表示调整到文件开头，append表示调整到文件末尾。对一个新文件，则总是放在开头。
    Recl = 64  !直接读取时用来指定每次读取多少个字节，也就是一个记录的大小。顺序读取时不能指定。
    ```

13. Read语句：

    ```fortran
    READ({[UNIT=]单元|*}[,{[FMT=]格式说明符|[NML=]名称列表组名|*}][,REC=记录号][,IOSTAT=状态变量名][,ERR＝错误标号][,END=文件结束标号][,EOR=记录结束标号]) [I/O列表]
    !1个必选参数，6个可选参数，第一个为单元号UNIT，第二个参数为FMT|NML|*中的一个。
    !对于单元号，读写外部文件时为一个指定设备号的整型表达式，读写内部文件时是一个字符串变量、数组、数组元素的名称，总之都是数据的来源和目的地。即当UNIT为整型变量时，则表示外部文件，其余变量时则表示内部文件。
    !第二个参数，对于格式化读写来说，格式说明符是必须的，非格式化读写则不能有。如果制定了名称列表组，则I/O列表必须省略。
    
    !直接读取时，要指定rec，即从第多少个记录开始读取。例如Recl=64,rec=5，此时会从第64*(5-1)+1字节开始读取。
    !IOSTAT，一个整型变量，用于接收是否出错的返回值，无错时返回0，有错时返回错误信息号。
    !ERR,END,EOR都是一个可执行语句的标号。
    !ERR是指，如果指定了它，发生I/O错误时将把控制传递给此标号处，未指定时，如果指定了IOSTAT则正常报错，如果没有指定IOSTAT则报错退出。
    !END是指，当读到文件结束记录时把控制传递给end标号处的语句。
    !EOR是指，当读完一个记录后把控制传递给标号处的语句。在结构化编程中，END和EOR都不建议使用。
    ```

14. Write语句：

    ```fortran
    WRITE({[UNIT=]单元|*}[,{[FMT=]格式说明符|[NML=]名称列表组名|*}][,REC=记录号][,IOSTAT=状态变量名][,ERR＝错误标号]) [I/O列表]
    !和read相比，少了end和eor参数，因为写入不存在遇到末尾的情况。
    ```

15. rewind语句，使指定设备号的文件指针指向文件的开头，通常用于顺序文件的操作：

    ```fortran
    REWIND{unit|([UNIT=]unit[,ERR=err][,IOSTAT=iostat])
    ```

16. BACKSPACE语句，使指定设备号的文件指针退回一个记录位置，一般用于顺序文件：

    ```fortran
    BACKSPACE{unit|([UNIT=]unit[,ERR=err][,IOSTAT=iostat])
    ```

17. I/O列表提供将要传输的数据的信息，从文件中读取到的数据要写入到I/O列表，写入文件的数据要从I/O列表获取。指定I/O列表可以有以下方法：

    ```fortran
    !无实体，即空列表。结果记录要么是零长度，要么是只包含填充字符
    WRITE(*,FMT='(2I8)')  !输出空行
    WRITE(*,'("string")') !输出字符串string。其中内外引号不能一样
    WRITE(*,*) 'string'   !和上一句结果不一样，会有一个前导的空格
    !变量名、数组元素名、派生类型名、派生类型元素名或子字符串名
    integer ::a = 3
    write(*,*) a !输出3
    !指定数组名或数组片段。没有下标的数组指的是按列存储的所有数组元素
    integer arr(3)
    arr = 3
    write(*,*) arr !输出3 3 3
    !表达式，类型可以是数值、逻辑型、字符型或派生类型
    write(*,*) 1+2 !结果为3
    !隐DO列表，会输出多次
    WRITE(*,*) (my_data(i),i=1,3) !等价于3次的write
    ```

18. 在F90中，可以用OPEN语句打开一个已经打开的文件，但是通过这种方式打开的文件只能对这个文件的输入输出属性选项进行修改，而不能对其进行输入输出操作。

19. Fortran有4个预定义的外部文件，*代表键盘和显示器，0代表键盘和显示器，5代表键盘，6代表显示器。单元号在-32768到32767之间。不能关闭星号设备，设备号0，5，6可以通过OPEN语句连接到其他文件上，当在程序中关闭设备号是O，5，6的外部文件后，如果下次还要使用这些设备号进行输入输出操作，这些设备号将自动连接到它们各自的缺省的设备上去。

20. 对内部文件只能使用格式化的输入输出操作。只能用READ和WRITE语句对内部文件进行操作，不能用文件连接(OPEN)、文件指针位置的设置(REWIND，BACKSPACE)或是文件属性查询(INQUIRE)语句。

    ```fortran
    !读取内部文件，将字符串转化为整型变量
    CHARACTER str(10),fname(14)
    str = " 1   2   3"
    READ(str,*) n1,n2,n3  !结果 n1=1, n2=2, n3=3
    !写入内部文件，将整型变量转化为字符串
    WRITE(fname,200) 4    !结果 fname ='FM004.DAT'
    200 FORMAT('FM',I3.3,'.DAT')
    ```

21. 读取一行，将它赋值给一个数组：

    ```fortran
    !文件内容如下, 4行3列
    11.0 2.2e3, 3.13
    44, 000055  66
    77 0.008e-3 99
    234 567 890
    !
    Program main
        Implicit None
        Real ::a(4,3)
        Integer ::File_in,i
        Open(NewUnit = File_in,File="xx.txt")
        Do i=1, size(a,dim=1)
            Read(File_in,*) a(i,:)  !一次读取一行的数据，也就是3个数据。一些老的代码中会使用隐循环,  Read(File_in,*)  (a(i,j),j=1,3)
            Write(*,*) a(i,:)
        End Do
        Write(*,*) a(2,3)  !结果为66.0
    End Program
    ```

22. 当没有变量列表时，Read会跳过一行，也就输仍然会读取，但是读出来的数据不会赋值给变量了。可以将不需要的列分配给不重要的变量，来略过多个列。

23. 使用Backspace(通道号)可以将读取光标后退一行。

24. 字符串查找子串函数 index：

    ```fortran
    !内容如下，需要注意的是Δ占用2个字节。
    n=11 Δt=232.56ms
    !
    Program main
       Implicit None
       Integer ::File_in,i,j
       Real :: r
       Character(Len=512) ::cStr
       Open(NewUnit= File_in, File = "xx.txt")
       Read(File_in,"(a512)") cStr
       i = index(cStr,"Δt=") + 4  !结果为6+4=10
       j = index(cStr,"ms")       !结果为16，意味着cStr(16:17)是"ms"
       print *,i,j,len("Δ") !分别为10 16 2
       Read(cStr(i:j-1),*) r    !从字符串的子串中读取内容到变量r中
       Write(*,*) r
    End Program
    !也可以一次读取多个变量
    Real :: r,q
    cStr = "232.56 5.3"
    Read(cStr,*) r,q    !读取两个变量
    Write(*,*) r,q !结果为232.559998 5.30000019
    ```


## 顺序读写二进制文件

1. 顺序写入无格式文件时，以记录为基本单元，Fortran会在每个记录的开头和结尾各增加4个字节的辅助数据，用来标识本条记录的长度。顺序读取时，Fortran会自动处理这些辅助数据，用户可以忽略他们的存在，仅关心有效的数据。如果手动修改了前后边界的8个字节或这内部字节，都会导致以后读入时产生错误。

   ```fortran
   08 00 00 00 DB 0F 49 40 E5 AC 23 00 08 00 00 00 !从DB开始的8个字节就是内容。前后两个00000008是用来相互校正的。
   ```

2. 按照记录读写变量的例子：

   ```fortran
   Program main
   	Implicit None
   	Integer ::FID,a=1000,c=2338021
   	Real ::b=3.14159265
   	Character(Len=8) ::s = "fcode_cn"
   	!写入
   	Open(NewUnit=FID,File="xx.txt",form="unformatted")
   	Write(FID) a,s  !内容占4+8=12字节，加上前后的计数，一共=12+4*2=20个字节。
   	Write(FID) b,c  !内容占4+4=8，加上前后的计数，一共=8+4*2=16个字节。
   	Close(FID)  !所以文件大小为20+16=36字节。
   	!读取
   	Open(NewUnit=FID,File="xx.txt",form="unformatted")!以
   	read(FID) a,s
   	print *,a,s !输出 1000 fcode_cn
   	read(FID) b,c
   	print *,b,c !输出3.14159250 2338021
   	Close(FID)
   End Program
   ```

3. ![image-20221103154117307](Fortran.assets/image-20221103154117307.png)

4. 如果使用顺序读入无格式文件时，Fortran会自动先读取4个字节，获取本记录的长度，然后读取本记录的最后4个字节，校正以下是否一致，如果一致再读取中间的内容，逐个给变量赋值。

5. 由于前后的4个字节的存在，使用Fortran写入的文件最好还是用Fortran读取，反之也是。如果要进行混合编程，不建议使用顺序读写二进制文件。


## 直接读写二进制文件

1. 为了方便混合编程，一般使用直接方式读写二进制文件。此时是以记录为基本单元，可以一次性读写若干笔记录。Open时指定每笔记录的长度RECL，固定不变。某些编译器上，RECL的单位并不是字节，而是4字节。读写的时候要指定从第几笔记录开始，Rec。直接读写不会在记录前后添加8字节的辅助数据。

   ```fortran
   Program main
   	Implicit None
   	Integer ::FID,a=1000,c=2338021
   	Real ::b=3.141592654
   	Character(Len=8) ::s = "fcode_cn"
   	Open(NewUnit=FID,File="xx.txt",form="unformatted",access="direct",Recl=12)
   	Write(FID,Rec=2) a,s  !内容占4+8=12字节，在第二笔记录(即13处)开始写入。如果源文件在13之前没有内容，则跳过的字节会先填\0
   	Write(FID,Rec=1) b,c  !内容占4+4=8<12，因此会补4个\0，返回到第一笔记录(即1处)写入。
   	Close(FID)  !所以文件大小为12+12=24字节。
   End Program
   ```

2. ![image-20221103165535230](Fortran.assets/image-20221103165535230.png)

3. 直接读写可以随意跳转到任意一条记录，可以一边读一边写。如果一个文件中不同记录的长度不同，则需要多次打开关闭。



## 流方式读写二进制文件

1. F2003中引入，每次读写的大小任意。根据变量列表来自动决定读写的大小。不需要指定记录RECL长度，打开后，文件光标默认在开始处。read时也不用指定rec，会自动计算。

   ```fortran
   Program main
   	Implicit None
   	Integer ::FID,a=1000,c=2338021
   	Real ::b=3.141592654
   	Character(Len=8) ::s = "fcode_cn"
   	Open(NewUnit=FID,File="xx.txt",form="unformatted",access="stream")
   	Write(FID) a,s  !内容占4+8=12字节
   	Write(FID) b,c  !内容占4+4=8
   	Close(FID)  !所以文件大小为12+8=20字节。
   End Program
   ```

2. 可以通过pos参数来指定读写的位置。也可以通过Inquire函数来查询当前指针的位置：

   ```fortran
   Integer ::i
   Inquire(FID,pos=i)  !将FID文件的当前指针保存到i中。
   ```

3. 可以定义结构体，一次性读取一个结构体：

   ```fortran
   Type ::grd
   	Sequence  !如果需要变量对齐避免产生空隙，应该加上这一行。
   	character(Len=8)::flag
   	Integer(kind=2) m,n
   End Type
   ```

4. 默认情况下，打开一个已经存在的文件，不会截断内容。直接写入的话，会覆盖已有的内容。

5. gcc下可以用ChDir修改当前工作目录，GetCWD获取当前工作目录。


## 内部文件

1. Read和Write的第一个参数可以是整数和字符串（浮点数会报错），表示读取和输出的位置。为整数时，表示外部文件；为字符串时，表示内部文件。

2. 默认情况下将整数或浮点数写入到字符数组中时，会右对齐：

   ```fortran
   Program main
       Implicit None
       Character(Len=15) ::cStr
       integer :: i
       Write(cStr,*) 123
       do i =1,15
           print *, i, cStr(i:i)
       end do
   End Program
   !输出结果为
              1  
              2  
              3  
              4  
              5  
              6  
              7  
              8  
              9  
             10 1
             11 2
             12 3
             13  
             14  
             15
   ```



# 标准库函数

1. F90中定义了113个内在（intrinsic）过程，分为4类：

   1. 查询函数，返回值是根据变元的性质而非变元的取值。例如size

   2. 基本过程，由标量变元指明的基本过程，但可以用标量或数组实元进行调用。许多函数是这种基本函数，并有一种基本内在子程序(MVBITS)。例如sin

   3. 变换函数，其变元是数组，但过程不施加于每个元素，而是把变元变换成另一数组。例如reshape

   4. 非基本过程，只能以标量实元进行调用，除了MVBITS以外的所有内在子程序都是非基本过程。

2. 大多数的标准库数值函数都是泛型的，由Generic和Specify name两类，使用Generic就够了，编译器会根据实参类型来自动选择。当需要输入和输出参数的类型不一致，例如双精度浮点数输入，单精度浮点数输出，或者多个参数类型不一致，才需要使用Specify name。

3. 函数名分为通用名和专用名，例如求余函数的通用名为MOD，专用名有3个MOD，AMOD，DMOD。调用时会自动根据参数类型来调用对应的专用函数。只有专用名才能作为其他函数的实参。

4. 大多数的数值函数都是逐元的，只要函数只接受一个参数，就也可以使用任意维度，形状的数组作为参数。可以使用数组名作为参数的内在函数称为基本内在函数。

5. 数值类型相互转换函数：

   ```fortran
   real(x,kind=8)  !将x转化为双精度的浮点数
   int(x,kind=4)   !将x转化为4字节整数
   cmplx(a,b,kind=8) !将a作为实部，b作为虚部，构造一个双精度复数。
   ```

6. 内部文件，用来将字符串和数值类型相互转换：

   ```fortran
   !将数值类型转化为字符串，写入到cStr中。
   Character(Len=24) ::cStr
   Write(cStr,*) 123
   !将字符串"123"转化为数值类型，赋值给i。
   Integer::i = 0
   character(12) :: str1 = "123"
   Read(str1,*) i !第一个参数只能是字符串变量，不能是字符串字面值常量
   ```

7. 使用Write(\*,\*)将数值写入到字符串中时，默认是右对齐的。==存疑==

   ```fortran
   Character(Len=24) ::cStr
   Write(cStr,*) 123
   Write(*,*) cStr(22:24)  !结果为 123
   ```

8. 将数值123和字符串"123"写入到字符数组或文件中，结果都是一样的，会先将数值转化为字符串，然后再写入。

9. 一般的数值函数：

   ```fortran
   ceiling(r)  !返回>=r的最小整数
   floor(e)    !返回<=r的最大整数
   abs(r)      !绝对值
   conjg(c)    !复数取共轭
   max(r1,r2, ...) !最大值
   min(r1,r2, ...) !最小值
   mod(a,b)        !a/b的余数
   sign(x1,x2) !符号函数，如果x2>=0，则结果为|x1|，否则为-|x1|。相当于x2的符号*|x1|
   ```

10. 三角函数：

   ```fortran
   sin(r)     !正弦，默认为弧度制
   asin(r)    !反正弦
   sinD(r)    !正弦，角度制，不推荐使用
   asinD(r)   !反正弦，角度制
   sinh(r)    !双曲正弦函数
   ```

11. 对数函数：

    ```fortran
    log(r)   !自然对数
    log10(r) !以10为底的对数
    exp(r)   !指数
    ```

12. 向量和矩阵函数：

    ```fortran
    dot_product(a,b)  !向量内积
    transpost(a)      !矩阵转置
    matmul(a,b)       !矩阵相乘
    ```

13. 字符串处理函数：

    ```fortran
    trim(str)    !去掉尾部的空白字符
    adjustl(str) !左对齐，相当于将左侧的空白去掉，右侧补齐，总大小不变。
    adjustr(str) !右对齐
    New_line("A")   !返回一个换行符，不同的操作系统不同。返回值的类型和该参数相同。
    char(i)      !返回编码为i的字符
    ichar(c)     !返回字符c的编码
    len(c)       !返回字符串c的长度，定义时的长度。
    len_trim(c)  !返回字符串c不计尾空格的长度，但是不修改c。
    len_trim(c)        !返回字符串ctrim后的长度。
    index(c,cf[,back]) !在字符串c中查找字符串cf第一次出现的位置。  index("abcd","cd")结果为3。当back为.true.时，从后往前查找。
    scan(c,cf[,back])  !在字符串c中查找字符串cf中的任意一个字符第一次出现的位置。   scan("3*4=12","=*") 结果为2
    verify(c,cf[,back]) !在字符串c中查找不包含在字符串cf中第一个字符出现的位置。verify("1345s56","0123456789X")  结果为5
    ```

14. all，any，count：

    ```fortran
    all(arr[,dim])  !判断逻辑数组是否所有元素都为真，dim标识要判断的维数，二维数组可以看成是多个一维列数组的组合。
    any(arr[,dim])  !判断逻辑数组是否有元素为真
    count(arr[,dim]) !统计逻辑数组中值为真的元素个数
    
    Integer ::arr(6) = [1,2,-3,4,-5,6]
    Write(*,*) all(arr>0)  !输出F，arr>0的结果是一个和arr形状相同的逻辑数组，为[.true.,.true.,.false.,.true.,.false.,.true.]。
    reshape(arr,[2,3]) > 0 !结果为一个2x3的数组。
    Write(*,*) any(arr>0)  !输出T
    
    all (reshape(arr,[2,3]) > 0,dim=1)  !如果没有给定dim的值，默认是对2维数组中所有元素来判断，结果为 .false. 。dim=1表示逐列处理，每一列得出一个结果，最终结果为 [.true., .false., .false]当dim=2时，结果为[.false., .true.]
    ```

15. maxval，minval，maxloc，minloc：

    ```fortran
    maxval(arr[,dim][,mask]) !获得数组中的最大值，mask是一个和arr同维逻辑数组，例如mask=(arr>3)。
    [m,n,...]=maxloc(arr[,dim][,mask]) !获得数组最大值的位置，结果是一个表示位置数组。
    
    Integer ::arr(6) = [1,2,-3,4,-5,6]
    maxval(reshape(arr,[2,3]),dim=1)  !结果为[2,4,6]，每一列的最大值，组成结果数组。
    maxloc(reshape(arr,[2,3]))        !结果为 [2,3]
    maxloc(reshape(arr,[2,3]),dim=1)  !结果为 [2,2,2],每一列都是第二个元素最大。
    maxloc(reshape(arr,[2,3]),dim=1)  !结果为 [1,3]
    !所有的loc函数的返回值都是由系统将它们按线下界为1重新排列，不考虑原来数组的下界。
    INTEGER :: A(3:5)=[3,7,0]
    maxloc(A) !结果为2，并不是4
    ```

16. cshift，圆周平移：

    ```fortran
    Integer::arr(5) = [1,2,3,4,5],b(2,3)
    a = cshift(arr,2) !平移后为[3,4,5,1,2]，正数向左，负数向右
    b = cshift(reshape(arr,shape(b)),1)
    ```

17. 只有一个元素的一维数组不等于一个变量

    ```fortran
    Integer ::a(1),b=3
    a=b  !不会报错，因为可以看作是将一个数赋值给整个数组,虽然这个数组只有一个元素
    b=a  !会报错
    ```

18. F90中增加了许多新的数组专用内在函数：

    ```fortran
    MATMUL(A,B) !矩阵乘积，A和B必须是秩为1或2的数值或逻辑型数组，至少有一个的秩为2。A的最后一维的长度需要和B的第一维的长度相等。
    DOT_PRODUCT(A,B) !向量内积，A和B必须都为秩为1的数组，结果为标量。
    SUM(ARRAY[,DIM][,MASK]) !沿着维DIM，对在MASK真值中的数组ARRAY的所有元素求和。如果未指定dim，则表示对所有元素求和。dim=1时，按列求和。例如SUM(C,MASK=C>0.0)表示仅对C中＞0的元素求和。
    PRODUCT(ARRAY[,DIM][,MASK]) !求乘积，跟sum类似
    
    SIZE(ARRAY[,DIM]) !查询各个维度的大小
    SHAPE(ARRAY)  !获得形状数组
    ALLOCATED(数组名) !查询数组是否已经分配，返回布尔值
    UBOUND(array[,dim])  !获取某一维的上界，LBOUND获取下界
    MERGE(TSOURCE,FSOURCE,MASK) !在逻辑型数组mask的控制下，合并数组TSOURCE和FSOURCE，二者的类型和形状相同
    merge([1,2,3],[4,5,6],[.true.,.true.,.false.]) !mask取真时，取TSOURCE的元素，否则取FSOURCE的元素，结果为[1,2,6]
    TRANSPOSE(MATRIX) !矩阵转置，matrix的秩必须为2
    SPREAD(SOURCE,DIM,NCOPIES) !将数组SOURCE沿着DIM方向拷贝NCOPIES次后扩展成一新的数组。
    INTEGER :: A(3)=[3,7,0]
    spread(A,1,3)  !结果为
    ![3 7 0]
    ![3 7 0]
    ![3 7 0]
    ```

19. 命令行参数获取：

    ```fortran
    i = Command_Argument_Count()   !获得命令行参数的个数
    call Get_Command_Argument(number,str[,len][,status])    !获得第number个命令行参数，命令行参数可以看作是一个字符串数组。len存储该命令行参数的长度。
    
    Program main
       Implicit None
       Integer::i,leng,j
       character(Len=32) ::cStr
       i = Command_Argument_Count()
       Write(*,*) "Args number:",i
       Do j=1,i
          call Get_Command_Argument(j,cStr,leng)
          Write(*,*) "Arg",j,":",cStr,leng
       End Do
    End Program
    !调用程序
    ./hello abc 12 d  !一共有3个命令行参数。["abc", "12", "d"]长度分别为3，2，1。
    ```

20. 环境变量获取：

    ```fortran
    call Get_Environment_Variable(name,value[,length][,status][trim_name]) !获取名称为name的环境变量，值存在value中，长度存在length中，环境变量可以看作是一个键值对集合，键值对的键和值都是字符串。status是状态，trim_name表示是否对name进行trim。
    ```

21. 时间相关：

    ```fortran
    i = Date_And_Time([date][,time][,zone][,values])  !获取当前的日期，时间，时区。精度不高
    call CPU_Time(time)   !获取程序的cpu时钟，用来计算程序段执行的时间。在程序段开头和结尾分别调用，两次的time相减即可得到cpu时间。
    call System_Clock([count][,count_rate][,count_max]) ! 获取系统时钟，也就是从1970年1月1日开始到现在有多少秒。也可以用来计算程序段运行的时间。
    !cpu_time的特点是多线程会重复计算每个线程的消耗。进程阻塞时不会计算。
    !System_clock计算的是物理小号。
    ```

# 编译链接

1. Gfortran编译选项：

   ```shell
   --check=bounds    #检查数组是否越界访问
   -fimplicit-none   #等价于在每个函数和子程序开头添加Implicit None的声明
   -std=f95          #强制使用F95标准，不使用编译器扩展
   -ffree-form       #强制将源代码作为自由格式处理，而不是根据文件扩展名识别
   -default-real-8   #默认双精度
   -g                #编译时加入调试信息，后续可以用gdb进行调试
   -m32              #生成32位程序
   ```

2. 常见报错：

   1. 由于使用了findent调整缩进后，原有的固定格式代码中，某些行会超过72个字符，因此会截断，这就造成字符串结尾没有引号，因而报错，可以通过续航解决该问题

      ```shell
      gfortran -O2 --std=legacy  -c openfile.f
      openfile.f:33:27:
      
         33 |               write(*,*) '*ERROR in openfile: input file name is too long:'
            |                           1
      Error: Unterminated character constant beginning at (1)
      ```

   2. 

3. 模块依赖与静态链接：

   ```fortran
   !main.f90
   Program main
   	use funcmod
   	Implicit None
   	Integer:: i
   	i = func()
   	call sub()
   End Program main
   !func.f90
   Module funcmod
   	Implicit None
   Contains
       Integer Function Func()
   		Write(*,*) "This is Func"
   		Func = 1
   	End Function Func
   End Module funcmod
   !sub.f90
   Subroutine sub()
   	Write(*,*) "call sub()"
   End Subroutine sub
   ```

4. .mod文件称为模块中间体，包含了use该模块的文件在编译时所需要知道的一切信息，例如模块中的名称，函数接口等。这样编译器可以检查模块是否被正确使用了。类似于C语言的头文件。

5. 一般情况下，.mod文件会和包含该模块的.f90文件在同一个目录，这样就会造成.mod文件可能分散在各个子文件夹中，此时gfortran提供了一个选项，-J，例如-J../include可以让所有编译产生的.mod文件都存放到../include目录中，这样后续编译依赖该模块的f90文件时，直接-I../include包含即可。同时use命令也会去-J的目录搜索.mod文件

6. 当.mod文件找不到时，gfortran可以使用-I 目录选项来设置，VS可以将其Include directory。静态链接.lib文件找不到时，需要指定目录和文件名。和查找C语言的头文件一个路径。

7. 在use模块的源文件编译前，模块.mod文件必须存在，因此要先编译模块本身。

8. 静态链接方法：

   ```shell
   gfortran -c sub.f90 func.f90  #结果产生sub.o，func.o和funcmod.mod。任何含有module的文件，编译时都会产生一个对应的.mod文件。
   ar rv my.lib sub.o func.o     #将sub.o和func.o打包生成一个静态库my.lib
   gfortran -c main.f90    #编译主程序文件，生成main.o，此时funcmod.mod文件必须存在，否则会报错。链接时不再需要funcmod.mod
   gfortran main.o my.lib -o main  #完成静态链接
   ```

9. 动态链接方法：

   ```shell
   gfortran sub.f90 func.f90 --shared -fPIC -o libmy.so  #编译成共享库，如果不重命名，则会为a.out。会产生funcmod.mod和libmy.so。这里没有-c选项，因为共享库本质也是一种可执行文件。-fpic和-fPIC一样。
   gfortran main.f90 libmy.so -o main   #
   ./main    #执行时会遇到问题，因为Linux中动态库的默认搜索路径不包括当前目录。
   export LD_LIBRARY_PATH=/home/zj/test/F:$LD_LIBRARY_PATH #使用本命令可以将特定目录加入到动态库搜索路径中。该环境变量主要用于指定查找共享库时除了默认路径之外的其他路径。或者也可以将对应的.so文件拷贝到默认的搜索路径中，例如/usr/lib。或者在/etc/ld.so.conf.d目录下添加一个.conf文件，文件内添加一行搜索路径，这里是全局的配置文件
   ```

10. ar 命令的r选项要么创建一个新的.a文件（以r后面的那个名字），要么将新的目标文件加入到原来的.a文件中，并替换.a文件。

11. 由目标文件创建静态库和动态库所使用到的工具不同，前者是ar，后者是链接器。

    ```shell
    gfortran -fpic -c file1.f90 file2.f90 #生成包含位置无关代码的目标文件，普通的目标文件没必要是位置无关的，只有该目标文件将要作为共享库时才需要 -fPIC参数
    gfortran -shared -o supportlib.so file1.o file2.o #使用链接器，从位置无关的目标文件创建共享库，一般共享库都是需要位置无关的
    ```

12. 在Windows和IVF编译器下，还应在动态链接库要导出的函数前加上如下注释，来显式指明要导出该函数：

    ```fortran
    !DEC$ ATTRIBUTES DLLEXPORT,ALIAS:"func"::func    !其中func是函数名
    ```

13. 动态库有两种使用方式，第一种是链接时带上导入库lib文件（Windows下）或指明.so文件（Linux下）。这样程序运行前会动态链接所有的动态库，如果找不到某一个会报错。第二种是利用加载动态库的系统调用，这样编译链接时不需要有该动态库文件，可以在运行的某一时刻按需加载，用完也可以释放，节省内存，适合编写插件（该系统调用会在没有找到对应动态库时返回一个错误值，并不会直接退出程序），且不会被dependency wallker或ldd侦测到。

14. 不同的编译器支持的语法规范版本不同，一般都是向下兼容的。

15. Intel Visual Fortran 也就是IVF，编译器为ifort，调试器为idb。会自动安装Intel的函数库MKL和IMSL。

16. Fortran产生的可执行文件运行时需要依赖C语言编写的运行时库，这是因为系统调用使用C语言写的。

17. helloworld程序：

    ```fortran
    program main
    	implicit none
    	write(*,*) "hello,fortran" !或者 print *, "hello,fortran"
    end program main
    ```

18. GFortran会检查静态数组访问是否越界，并报warning。对于动态数组访问，默认不检查，可以添加 --check=bounds选项，来在运行时检查，无论如何，编译时都不会报warning或error。

    ```fortran
    program fcode_cn
       Implicit None
       Integer i, arr(3)
       Read(*,*) i
       Write(*,*) arr(i) !动态数组访问，无论如何，编译时都不会保warning或error
       Write(*,*) arr(6) !静态数组访问，无论是否添加--check=bounds都会报告warning
    end program fcode_cn
    ```

19. 当上面的程序输入5时会出现数组越界行为，运行时错误如下。

    ```shell
    At line 5 of file hello.f90
    Fortran runtime error: Index '5' of dimension 1 of array 'arr' above upper bound of 3
    
    Error termination. Backtrace: #调用栈
    #0  0x7f750a4ccad0 in ???
    #1  0x7f750a4cd649 in ???
    #2  0x7f750a4cdc46 in ???
    #3  0x5561175682bf in ???
    #4  0x556117568331 in ???
    #5  0x7f750a2aad8f in __libc_start_call_main
            at ../sysdeps/nptl/libc_start_call_main.h:58
    #6  0x7f750a2aae3f in __libc_start_main_impl
            at ../csu/libc-start.c:392
    #7  0x5561175680f4 in ???
    #8  0xffffffffffffffff in ???
    ```

20. 当单独编译一个源文件，如果其中不含program语句且没有使用-c选项，则会报错。

21. 不同编译器对同一个源文件产生的目标文件不一样，不同编译器产生的目标文件可能无法一起链接。


# 与C语言交互

1. 混合编译分为两种层级：源代码级，目标(可执行)文件级别。可执行文件包括动态链接库。

   1. 同一种语言的源代码级混编比较简单，使用同一个编译器就能自动完成，不需要额外配置。

   2. 不同语言的源代码级混编，会使用到不同的编译器，需要满足ABI（application binary interface）兼容。

   3. 同一语言的目标文件级别混编，尽量使用同一个编译工具链，例如推荐在Windows上使用MSVC工具链，因为大部分的库都是用该工具链编译的。如果使用不同的工具链，例如GNU的，就需要额外配置。

   4. 不同语言的目标文件级别混编，由于无法使用相同的编译器，因此各自在编译的时候需要保证ABI兼容。

2. ABI包含：数据类型的大小、布局和对齐，局部变量在栈上的管理，堆中内存的管理，名称修饰，过程调用约定（参数传递，过程完成后平衡栈的方法）。

3. 只有ABI完全兼容才可以进行目标文件级别的混编。

4. 一般推荐Fortran和C语言混编，而不是C++，因为C语言中一个函数名只能代表一个函数，C++中由于函数重载的存在一个函数名并不能唯一确定一个函数。如果必须用C++编译器编译的话，可以加入extern "C"，确保特定函数使用C规则编译。

5. msvc都是默认\_stdcall的调用约定，Fortran默认是\_cdecl，不过建议对所有可能要被混合调用的函数都显式指定调用约定。

6. Fortran源代码中的名字会被编译器加上_的后缀修饰，而C语言不会，因此C语言在引用Fortran的名字时，都应加上下划线后缀。Fortran函数的参数都是默认传递指针，因此C语言也应传递指针到Fortran的函数。

7. Fortran和C不一样，它会进行命名粉碎，由于它不区分大小写，因此会统一转化为小写，又因为为了和C语言区分，又会添加_后缀。这样`add, AdD, aDd, Add`，都会被粉碎成`add_`。

8. 随着fortran90中`module`语法的引入，`module`实际上也提供了命名空间类似的东西，于是在`module`中名称被粉碎后是带有`module`名信息的。

9. Fortran和C进行混合编程时，不支持隐式类型转换，这是因为参数传递的是指针。

10. 如果Fortran中的参数本身就是指针，那么在C语言对应的参数不用再取地址了。

11. C语言的数组下标从0开始，Fortran的下标从1开始，因此如果要输出到屏幕时，可以选择一个作为标准，具体是哪个，主要是看哪种语言为主。

12. C语言的数组，有一点和Fortran是相同的，也就是`i,j`下标都表示第i行第j列的元素：

    ```c
    int arr[2][3]={{1,2,3},{4,5,6}}; //arr数组2行3列，arr[i][j]为第i行，第j列的元素，数据按行存储，内存中的数据就是1 2 3 4 5 6，所以arr[0][1]为第二个元素，即2
    ```

13. Fortran的数组：

    ```fortran
    integer :: arrf(2,3) = reshape([1,2,3,4,5,6],[2,3]) !内存中的数据为1 2 3 4 5 6，只和reshape的第一个参数有关。
    integer :: arrf_c(3,2) = reshape(arrf,[3,2],order = [2,1]) !此时内存中的数据改为了1 3 5 2 4 6。C语言要想呈现出2行3列的矩阵，且按列输出时为1-6，那么它在内存中的数据(按行输出)应为1 3 5 2 4 6。reshape的第2个参数必须为[3,2]，若为[2,3]，则数组如下，此时内存中的数据为1 4 2 5 3 6，和想要的不一样。
    !arrf数组   arrf_c数组   [2,3]的数组
    ![1 3 5]    [1 2]       [1 2 3]
    ![2 4 6]    [3 4]       [4 5 6]
    !           [5 6]
    !实际上arrf_c和arrf数组互为转置，可以使用transpose()函数替代reshape函数(仅限2维数组)。如果arrf为对称矩阵，则转置也可以省略
    arrf_c = transpose(arrf)  !arrf_c(i,j) = arrf(j,i)→第m*(j-1)+i个元素 = 第m*(i-1)+j个元素
    !将该数组传递给C语言时，只会传递一个数组头元素地址和2个维度参数，还有每个元素占用的字节数。C语言中需要还原出来该数组，使得两个数组的(n,m)的结果是一样的。
    
    func(arrf,2,3,4) !
    void func(arrf, n, m, ele_size){
    	!int(*arrc)[*n] = arr; 如果不想复制，也可以直接使用
    	int *arrc = malloc(n* m* ele_size); !在堆上分配内存,C语言的指针天生支持数组操作，因此将arrc声明为指针即可。
    	memcpy(arrc, arrf, n* m* ele_size); !将Fortran空间的数据[1 4 2 5 3 6]复制过来
    	print("%d",arrc[1][0]); !第2行第1列为2,因为C语言的数组下标从0开始。Fortran中数组的(2,1)结果也为2
    }
    !arrc数组，和arrf数组一样
    ![1 3 5]
    ![2 4 6]
    ```

14. Fortran调用C语言：

    1. Fortran文件：

       ```fortran
       !testf.f90
       program main
           implicit none
           interface !为了单独编译需要，应给出C语言中的函数接口
               real(8) function fun1(n1,n2,n3,arr,m,n)
                   integer ::n1,m,n
                   real ::n2
                   real(8) ::n3
                   integer :: arr(m,n)
               end function
           end interface
       
           integer :: n1
           integer,parameter ::m = 2, n = 3
           real :: n2
           real(8) :: n3
           integer :: arr(m,n),arr_c(n,m)!arr是Fortran内部的数组，arr_c是用于和C语言沟通的数组
       
           n1 = 3
           n2 = 5.123456
           n3 = 3.1234567898765432_8
           arr = reshape([1,2,3,4,5,6],[m,n])
           arr_c = transpose(arr) !转化为C语言的数组
           print *,arr !结果为1 2 3 4 5 6
           print *,fun1(n1,n2,n3,arr_c,m,n) !输出为4.1234567898765437，可以看到，C函数中成功接收到了双精度的浮点数
           arr = transpose(arr_c) !从C语言返回后，再转化为Fortran的数组，方便后续使用
           print *,arr !结果为2 4 6 8 10 12
       end program main
       ```

    2. C语言文件，被调用的一方，没有main函数：

       ```c
       //testc.c
       #include <math.h>
       #include <stdio.h>
       //被调用的一方，没有main函数
       double fun1_(int* n1, float* n2, double* n3, int** arr, int* m, int* n) {//这里arr不用是三级指针，二级指针即可，方便第9行使用
           printf("n1=%d, n2=%f, n3=%f\n", *n1, *n2, *n3);
           int(*arr1)[*n] = arr;//将二级指针arr转化为指针arr1,该指针指向一个包含n个int的数组，实际上就是arr数组的一行。这里gcc会报warning
           for (int i = 0;i < *m;i++) {
               for (int j = 0;j < *n;j++) {
                   printf("arr[%d][%d] = %d\n", i, j, arr1[i][j]);
                   arr1[i][j] = 2 * arr1[i][j]; //在C语言函数中修改一下传过来的数组
               }
           }
           return (*n3) + 1;
       }
       ```

    3. Makefile

       ```makefile
       all: 
       	gcc -c -Wall testc.c
       	gfortran -c -Wall testf.f90
       	gfortran -o main testc.o testf.o
       clean:
       	rm -f *.o main
       ```

15. C语言调用Fortran：

   16. C语言：

       ```c
       #include <string.h>
       #include <stdio.h>
       double fun1_(int* n1, float* n2, double* n3, char* str1, int* str_len, int** arr, const int* m, const int* n);
       int main(int argc, char* argv[])
       {
           int n1 = 3, i, j;
           const int m = 2;
           const int n = 3;
           float n2 = 5.123456;
           double n3 = 3.1234567898765432;
           int arr[2][3] = { {1,2,3},{4,5,6} }; //这里不能使用[m][n]，gcc提示变长数组不能被初始化。
           char str1[] = "Hello Fortran from C";
           int str_len = strlen(str1);
           for (i = 0;i < m;i++) {
               for (j = 0;j < n;j++) {
                   printf("In C: arr[%d][%d] = %d\n", i, j, arr[i][j]); //按行输出数组
               }
           }
           printf("Return : %f\n", fun1_(&n1, &n2, &n3, str1, &str_len, arr, &m, &n)); //输出4.123457
           for (i = 0;i < m;i++) {
               for (j = 0;j < n;j++) {
                   printf("In C: arr[%d][%d] = %d\n", i, j, arr[i][j]);//按行输出修改后的数组
               }
           }
           return(0);
       }
       ```

   17. Fortran：

       ```fortran
       real(8) function fun1(n1, n2, n3, str1, str_len, arr, m, n)
           integer ::n1,m,n,i,j,str_len
           real ::n2
           real(8)::n3
           integer arr(n,m),arrf(m,n) !转化后的数组arrf应该是m行n列，所以转化前应为n行m列
           character(len=512) str1 !传递字符串需要2个参数，一个首字符地址str1，一个长度str_len，这里使用大长度来接收，输出的时候根据源长度来切片
           write(*,"(A)") str1(1:str_len)
           write (*,100) "n1=",n1," n2=",n2," n3=",n3 !结果为n1=3 n2= 5.123456001281738 n3=3.1234567898765433 可以看出n2确实是单精度，n3确实是双精度
           n3 = n3+1
           fun1 = n3
           arrf = transpose(arr) !arr数组仅用于输入输出时，Fortran内部不使用arr，而是使用arrf
           do i=1,m
               do j=1,n
                   write(*,200) "In Fortran: arr[",i, "][",j,"] = ",arrf(i,j) !按行输出
               end do
           end do
           arrf = 2*arrf
           arr = transpose(arrf)
           
       100 FORMAT(A,I1,A,F18.15,A,F18.16)
       200 FORMAT(A,I1,A,I1,A,I2)
       END function fun1
       ```

18. 除了在跨语言传递数组之前，进行数组数据的转换(会产生数据复制的开销)，还可以不转换，后续在使用的时候用宏替换掉。

    ```c
    #define get(array,i,j,m,n)     //从m行n列的数组array中获取第i行,第j列的元素
    ```

19. 变量会传递loc(x)，也就是地址，而loc(数组)也就是数组首元素的地址。

    ```fortran
    !testf.f90
    integer ::arr(3)
    print *,loc(arr), loc(arr(1)) !都是140735528250656，转化为十六进制为0x7fff8b2b2d20
    fun1(arr)
    !testc.c
    void fun1_(int* arr){
    	printf("%p",arr); //输出为0x7fff8b2b2d20，因此这里获取到的也是数组首元素的地址
    }
    ```

20. 可以通过loc来确认函数内的形参数组是否分配了空间，类似于判断空指针。

21. Fortran2003标准中新增了模块iso_c_binding，使用该模块可以更方便地进行C和Fortran的混合编程。优势有：

    1. 代码与编译器和平台无关

    2. 在Fortran中可以定义C数据类型的变量

    3. 使用Interface接口声明，清晰明了

22. gfortran可以直接同时编译c和fortran文件，gcc同样亦可不过需要添加编译参数。

