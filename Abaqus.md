# 基础

1. 2005年ABAQUS被法国达索公司收购，公司更名为SIMULIA。ABAQUS的早期历史与MARC分析研究公司的早期历史紧密相连。abaqus的的名字起源于中国的算盘（abacus），标志就是算盘的算珠。

2. 达索系统（Dassault Systèmes）和达索航空（Dassault Aviation）同属于达索集团（Dassault group）。达索航空主要生产阵风（Rafale），幻影（Mirage）战斗机和猎鹰（Falcon）公务机。abaqus属于达索系统旗下的SIMULIA品牌，同类的品牌还有CATIA，SOLIDWORKS。2012年，推出了3D Experience平台，整个这些软件。

3. ABAQUS最早的版本是为特定的客户-西屋电气公司创建的，该公司使用该软件分析核燃料棒组件。Explicit的第一次正式发布是在1992年亲手交付给麻省理工学院的，1998年发布后处理viewer，1999年发布前处理CAE。该公司一开始起名为HKS（三位创始人的名称缩写），在2002年改名为abaqus。在2005年10月，这家拥有525名员工的公司被达索系统以4.13亿美元收购。abaqus公司的总部位于罗德岛州。2002年进入中国。

4. 6.14版本发布于2014年，后续为2016，没有6.15版本。近年来，Abaqus的新版本每年年底都会发布。

5. ABAQUS/CAE是Complete ABAQUS Environment的缩写，CAE不包含求解器。

6. ABAQUS包含CAE模块，CAD交互接口，求解器，后处理接口。

7. ABAQUS的求解器有3个：
   1. Standard，通用的有限元，使用隐式求解方法。静力分析，线性动力学（模态分析，谱分析），非线性动力学（瞬态的），也可以做热传导，声学分析，质量扩散。多场耦合可以包含：热-力学，结构-声学，热-电（焦耳热），线性压电，饱和与不饱和空隙流体渗流变形，流固耦合。
   2. Explicit，动力分析首选，使用显式求解方法，也可以求解拟静态问题。
   3. CFD。

8. Standard和Explicit是求解方法不同，不同的求解方法适用于不同的问题形式。

9. ABAQUS/CAE是将所有的模块整合成一个GUI环境。

10. <img src="Abaqus.assets/image-20200615101623389.png" alt="image-20200615101623389" />

11. .cae是模型数据库（Model Database）文件，一个.cae文件可以存放数个model。.inp文件是求解器输入文件，类似于LS-Dyna的K文件。.odb是求解结果数据库文件，.dat文件是结果打印列表，对求解过程进行记录。.jnl文件是CAE建模时自动记录下的操作，如果.cae文件存在错误时，可以使用.jnl来修复。给他人传递工程文件时，可以不用传递.jnl文件。

12. 不建议将.cae文件名和job的文件名重复，这样会导致结果文件夹中的混乱。

13. 同一个.cae文件中的不同模型内的数据可以互相复制，例如零件，材料，边界条件等。在model→copy objects中选择。

14. obd文件中没有几何信息，只有网格信息。

15. ABAQUS官方一共给出了三个实例系列：

    1. Abaqus Example Problems Guide
    2. Abaqus Benchmarks Guide，包含了NAFEMS规定的一些例子
    3. Abaqus Verification Guide

16. ABAQUS官方给的例子中，包含了一系列的inp文件，保存在(EstProducts\2023\win_b64\SMA\samples\job_archive目录中)，获取方法：

    ```shell
    abaqus fetch job=xxx.inp
    #如果不加扩展名，则会提取出符合名称的所有后缀文件。
    #可以使用通配符，例如*表示任意字符。
    ```

17. 可以通过findkeyword程序来查找使用特定关键字的例子：

    ```shell
    #可以提供关键字（必须），参数（可选）和值（可选）的约束。如果指定多个关键字，则会列出包含所有指定关键字的输入文件，然后可以使用abaqus fetch获取例子
    #下面命令有3行，列出使用*RESTART关键字和WRITE参数且使用*NGEN关键字的示例问题，最后以空行结尾。输入时，需要省略关键字开头的*，因为命令行自动提供它。
    abaqus findkeyword
    *BEAM SECTION,SECTION=ARBITRARY
    *RESTART,WRITE
    #结果如下，它会依次在每个包含例子的集合中寻找，给出分别满足每个关键字的例子数量，和全部满足的数量。注意，参数的顺序无所谓，只要包含即可
    Searching in Abaqus Verification Problems
    Matches for line: RESTART, WRITE : 6950
    Matches for line: BEAMSECTION, SECTION = ARBITRARY : 60
    Common matches  : 2
    xbeamaddinertia_xpl_lin3d   xbeamaddinertia_xpl_quad3d
    #用户指定的参数值（例如，数字数据、集合名称、方向名称等）将被忽略。以下两个示例是等效的，因为值MYSET是一个元素集名称。
    abaqus findkeyword
    *ELSET,ELSET=MYSET
    
    abaqus findkeyword
    *ELSET,ELSET
    #查找的范围为
    Abaqus Benchmark Problems
    Abaqus/Standard Training Seminar and Primer Problems #不在帮助文档中
    Abaqus/Explicit Training Seminar and Primer Problems #不在帮助文档中
    Abaqus Example Problems
    Abaqus Verification Problems
    Abaqus/Standard Timing Problems #不在帮助文档中
    Abaqus/Explicit Timing Problems #不在帮助文档中
    ```

18. 通过findkeyword找到了特定的inp文件名后，可以在帮助文档中搜索该文件名，可找到使用它的页面，离线文档不支持搜索文件名。

19. 官方的在线帮助文档支持模糊搜索，可以使用双引号包括起来进行精确搜索。

20. 本地安装的文档需要在文件`D:\SIMULIA\EstProducts\2023\win_b64\SMA\site\EstablishedProductsConfig.ini`中添加一行`documentation=http://desktop-r2r1l2q:4040/English/`才可以关联到abaqus内部。

21. 打开软件前应设置工作目录，推荐的方法是在特定的文件夹打开命令行窗口，然后运行`abaqus cae`即可。

22. 默认在job提交后，才会生成对应的job.inp，计算完成后生成结果文件job.odb。也可以使用write input来只生成inp文件而不计算。运行datacheck也会产生inp文件和odb文件，不过对应的输出都是0。

23. job内并没有存储模型的内容，因此如果计算失败，然后修改模型，再进行计算时，可以不用新建Job，直接Submit之前的那个Job即可，这样会覆盖掉之前的那个job对应的结果文件，由一个job产生的所有结果文件只是后缀名不同。

24. 输出图片print到file，可以选择eps格式，再输出为tif，这样既清晰，体积又小。如果想要直接截图，可以按F11来全屏显示视口。还可以在viewport annotation option中取消所有其他挂件的显示。默认的背景是渐变的，出图时推荐切换为纯白颜色，在Graphics options→viewport background。

25. abaqus还提供了一个官方插件save current viewport，它可以保存透明背景的图片，会保存到工作目录中文件夹additionalImages。

26. .inp文件是ABAQUS/CAE和求解器之间的唯一沟通媒介。.inp文件中没有几何，只有网格。一个job对应一个jobname.inp文件。

27. *开头表示是关键字。**开头表示注释。黄色区块内的关键字已经要在蓝色之后，区块内部的关键字顺序可以互换。

28. <img src="Abaqus.assets/image-20200617012530360.png" alt="image-20200617012530360" />

29. 之所以存在inp文件，是因为某些功能在CAE中还不支持。例如指定梁单元的法线。

30. 如果直接编辑.inp文件，这是不会影响CAE中的设定的。如果要运行修改后的inp，可以在create job是选择使用input file。

31. 另外一种方式是在CAE中编辑关键字（在model上右键→Edit keywords），这样CAE中会变更，此时如果再生成inp文件时也会保存之前的修改。如果通过这种方式改了很多，要想恢复最初的状态，也可以按Discard all edits。

32. inp文件也可以作为ABAQUS和其他软件之间交互的媒介（可以包含除了几何以外的任意数据）。

33. 可以将一个已有的inp文件导入到CAE中，然后修改模型，不过这里就没有几何了。需要注意，这种方法会丢弃CAE不支持的特性，例如用户通过自己修改inp文件添加的特性，观察CAE的消息区域获得具体信息。

34. 对于从外部下载或修改后的inp文件，可以在CAE中重新创建job来运行，但是如果文件路径包含空格，会报错。这时建议使用命令行提交计算。`abaqus job=xx cpus=4 int`。

35. 但是不建议在CAE中导入inp后再以此模型创建job，提交分析，因为这会将CAE不支持的关键字或操作方式都删除掉。

36. ABAQUS的.cae文件不同版本是向下兼容。但是.inp文件是前后都兼容的，可以跨版本。当升级.cae的版本时，abaqus会自动将所有的part和assembly都锁住，避免以外修改，可以在模型树中对应的位置解锁即可。升级会将已有的xx.cae重命名为xx-6.14-1.cae，然后将转化后的文件保存为xx.cae。

37. 使用命令行来执行inp文件。job名可以不加.inp后缀。还可以在最后添加int参数，进行互动，展示计算信息。

    ```shell
    abaqus job=要执行的inp文件名 oldjob=多个分析工作之间如果有数据传输需求，这里为数据来源的文件名 cpus=使用的核心数量
    ```

38. 如果静态分析中出现numerical singularity数值奇异或zero pivot，就是矩阵的主元为0的错误，一般情况下是缺少了限制刚体位移的约束。

39. ABAQUS后处理时会将默认30个数据达成一个group（例如history 数据包含大量的能量曲线），可以右键group children，取消group。

40. 推荐观看士盟科技的视频中的例子。

41. abaqus支持多核并行计算，几十个核心内，还是可以保持线性增长的。

42. abaqus的用户界面是使用fox-toolkit开发的，它是跨平台的，规模小巧。支持多种语言的绑定，例如python。

43. abaqus插件ODB reduction plug-in可以将选定的frame单独保存到odb文件中，实现减小odb文件体积的功能。它是通过创建一个空的odb文件，然后向其中添加frame完成的。

44. isight是参数优化软件，可以调用多种软件，例如matlab，excel，abaqus等。

45. tosca是几何优化（非参数的）软件，例如减少模型的质量。

46. fe-safe是用来做疲劳分析或可靠度评估的。需要先进行有限元分析，然后将其结果导入到fe-safe中。

47. 在job的编辑页面，General→Preprocessor Printout中可以勾选，以输出预处理器的相关信息。对应的关键字为*PREPRINT。

48. job的编辑页面最上方的描述可以添加说明内容，对应的关键字为*HEADINGS。

49. inp文件中包含`*PART`和`*END PART`。part中包含`*NODE`，`*ELEMENT`，`NSET`，`*ELSET`，`*SOLID SECTION`等关键字。

50. inp文件中包含`*ASSEMBLY`和`*END ASSEMBLY`。assembly中包含`*Instance`等关键字。

51. 这样组织并非是必须的，CalculiX就没有这么做，这样做可以在后处理中方便聚类处理。如果不需要，可以在Edit→attributes中勾选Do not use parts and assemblies in input files

52. abaqus通过AM Modeler插件支持增材制造（就是3D打印）和切削仿真。

53. abaqus官方社区为SIMULIA User Communities，这里可以提问，也可以找到官方的一些插件或教程。

54. abaqus支持import ANSYS的cdb文件，但是不支持导入LS-DYNA的k文件，不过提供了一个小工具可以将k文件转化成inp文件：

    ```shell
    abaqus fromdyna job=output.inp input=input.k
    #还有一个参数splitFile，默认为OFF，为ON时，会将节点，单元数据单独提取出来，为.inc文件，然后用一个总的inp文件导入include它们。
    ```

55. inp文件支持参数化，参数的定义遵循python的语法（因此可以使用简单的数学函数），虽然这是在inp文件中。

    ```python
    *PARAMETER
    width = 2.5 #一行定义一个参数，这是独立参数
    height = width*2 #可以使用之前定义的参数来定义非独立参数
    *BEAM SECTION, SECTION=RECT, ELSET=name, MATERIAL=name
    <width>, <height> #引用参数时，需要用<>包括起来。
    ```

56. 非独立参数有两种定义方式：

    1. 表达式依赖

       ```python
       width = 2.0
       height = 5.0
       area = width*height #表达式依赖参数，必须先定义它所依赖的所有参数。
       ```

    2. 表格依赖，通过指定依赖和独立参数以及依赖表来定义参数之间的关系。定义参数之间依赖关系的表每行的值必须与依赖参数的数量加上将使用它的独立参数的数量一样多。该表必须只包含实数；首先给出依赖参数值，然后给出独立参数值。参数名和字符串不能在表中使用。

57. 壳单元可以较好地计算横向剪切效应（壳平面内和法向的剪应力），因为它在厚度方向有至少5个积分点，这在厚板中不可忽略。如果使用实体单元模拟，则需要建模多层。

58. 支持多物理场耦合，在第三本手册中，下图展示不同求解器之间交互的内容。

59. ![image-20250301094456294](Abaqus.assets/image-20250301094456294.png)

60. 





# 建模技巧

1. 创建part时，需要输入approximate size，这个参数原则上和最终part中最大尺寸在一个数量级即可。
2. ABAQUS支持多种选择模式，可以规定只选择某种类型的单元。也可以指定选择选择框内或外的单元。使用Shift加选，Ctrl减选。可以使用by angle来选择一些夹角在一定范围内的面或线等。
3. 单元和节点的集合称为网格mesh。网格只是实际结构几何形状的近似表达。
4. ABAQUS并不是用特殊的单位，用户只要使用自洽的量纲系统即可。SI(mm)单位下，钢材的密度为7.8e-9tonne/mm^3。注意，此时能量的单位是mj。
5. <img src="Abaqus.assets/image-20241211223838569.png" alt="image-20241211223838569" />
6. 相比于Ansys建模时，abaqus不用构建多种坐标系。但也有类似于工作平面的概念，即sketch。part中的三维实体必须是通过二维的sketch拉伸，旋转得到，方法类似于solid works。sketch是可以撤回操作的。
7. 可以在sketch option中将图片导入作为背景，这对于描绘很有帮助。
8. sketch option中可以改变sketch坐标系的原点和转动坐标系，这对于复杂建模有帮助。
9. 2D底稿sketch推荐使用AutoCAD的.dxf格式或.iges格式来导入。
10. 复杂的三维实体建议从CAD软件中导入，建议使用ACIS的.sat和STEP的.step（或.stp）格式。不建议使用.iges格式。
11. ACIS的.sat格式是ABAQUS内核使用的格式，是最可靠的导入格式。ACIS是由Spatial Technology公司开发的。IGES的实体是使用一系列的面来构成的，缝合这些面构成一个水密watertight的实体，对于大型模型，会很耗时。
12. STEP（Standard for the Exchange of Product model data）格式是替代IGES格式的，STEP使用B-rep格式来表示实体，是ASCII格式的。细节由国际标准ISO 10303规定。
13. step文件是由多个part组成的，导入时，可以将每个part独立导入，或者合并为一个part导入（推荐，同时应勾选merge和retain）。
14. 导入时，可以设置导入的part是变形体，离散刚体或欧拉part。还可以选择是否缩放尺寸。
15. 每一个model只包含一个assembly。一个assembly可以包含part的实例，也可以包含其他model的assembly。一个model中可以有多个part，part需要被实例化为part instance才可以组装为assembly，只有在assembly中的物体才会被最终计算分析。同一个part的所有instance具有相同的section。
16. part的第一个feature都是在XY平面内创建的。
17. part模块中不能进行布尔运算，只能进行拉伸增长或切除之类的操作，一个part必须是连通的。可以在assembly中将多个part的instance进行布尔运算，合并成一个新的part。
18. 有两种instance类型：
    1. 独立的，mesh是在instance上，和part无关，每个instance需要单独划分网格。
    2. 非独立的，mesh在part上，只需对part划分一次，之后的所有instance的网格都一样。

19. 一个part的所有instance要么都是独立，要么都是非独立。
20. 使用assembly的好处是，可以修改part中的模型，进而自动修改assembly中的模型。
21. 组装时定位的方式有两种：
    1. 平移和旋转。
    2. 使用constraint来对点线面进行约束。使用constraint时，可能会产生冲突。注意设定好哪些instance是可以动的，那些是不动的。

22. 可以将几何constraint转化成固定的（Instance→Convert Constraints），也就是打断，并且instance保持现在位置，这样做是为了防止后续的其他修改影响现有的instance位置。这一点和cad软件完全相反。
23. 每个自由度都用数字来表示，123分别表示xyz方向的线位移。456分别表示绕xyz轴旋转。其他的自由度例如温度用11来表示。
24. part包括4种：可变形体，离散刚体（可以使复杂的外形，可以从外部导入几何，需要划分网格），解析刚体（只能用简单的外形，一般用来定义刚性面，只能在CAE中创建，不能从外部导入），欧拉零件（用于欧拉分析，网格不动，材料在网格内流动）。两种刚体受力都不变形，解析刚体比离散刚体计算效率更高，因为离散刚体还包含很多网格，需要逐个判定接触。
25. 壳和梁都是3D单元，创建part时应选择3D。因为它们都有3个方向的位移。

26. part的外形可以由以下三种方式定义：
    1. 直接在CAE模块中建立，称为native geometry。
    2. 从其他CAD系统中导入，分为原生格式（proE或CATIA等默认的格式）和中立格式（通用的文件交换格式，例如.sat）。推荐使用原生格式。
    3. 导入的单独的网格，orphan mesh，独立网格也称为孤儿网格，不含几何部分。这可以从.inp，.odb，.cdb（ANSYS专用），STL(via plug-in)等文件中导入。
27. 还支持连接导入associative import，这样在CAD系统中修改后，abaqus的part会自动修改，这对于已经设置好荷载和边界条件的情况非常好用。
28. 导入的part都会有一个feature，表示它是哪种格式导入的。
29. 如果是在CAE模块中建立的part，就会保留许多建立时候的feature，可以进行修改。ABAQUS很少有撤回的动作，一般使用feature来记录操作，删除feature就可以撤销操作。
30. feature就是对part，datum，partition，assembly等进行的操作。
31. ABAQUS可以为part建立基准Datum点线面参考系（分析时不会考虑）。可以利用基准平面来创建任意方向的part。同时基准几何还可以用来在assembly时进行定位。
32. 在assembly中第一次创建instance时，会产生一个用户自定义的直角坐标系Datum csys-1，它是assembly级别的feature。注意，它并不是全局直角坐标系（名称为Global），不过它俩是重合的，在施加荷载选取坐标系时可以看出来。
33. set用来保存一组选择，可以包含点(vertex)线面，节点(node)或单元。一般用来设定荷载和边界条件，或者定制输出变量。
34. 可以在inp文件中创建同时包含node和element的set，只要Nset和Elset的名称相同即可，这种在cae中会显示node+element，但是无法在cae中创建这样的，Nset和Elset重名时会报错。
35. surfaces集合分为几何面和单元面face，是用来定义接触（接触是根据surface来判断的，接受surface，而不是set）和施加分布载荷的。face是单元的表面，由node构成。
36. 如果没有划分网格，则只能定义几何的set和surface。划分网格之后，还可以定义关于node或element的set，关于mesh的surface。划分网格之后，默认仅在Mesh模组中显示网格和seed，这个可以通过工具栏的按钮开启或关闭，在其他模组中的显示情况。
37. 不同模块的顶部菜单来中都有set和surface的管理窗口，但是part和assembly中建立的set和surface，只在各自的层级的manager看到。
38. 施加荷载或边界条件时，可以选择已定义好的set或surface，基于part和assembly的都会显示，但是只会显示和荷载或边界条件对应的set或surface。例如集中力荷载只允许选择点的set，压力荷载只允许选择surface。
39. 虽然可以将一个edge和vertex都包含在同一个几何set中，但是在施加集中力时，不会显示在可选的set中。
40. 施加集中力时，如果选择的是包含多个node或vertex的set，则会给集合中每个点都施加同样大小的力。
41. 可以选择多个set或surface，进行bool运算。如果一个master要和多个slave接触或者反过来，则可以将多个slave合并为一个surface，这样只用一个接触对就可以定义接触。
42. set或者surface中不能既有几何，又有单元。删除set或surfaces并不会删除真实的几何或单元。
43. 同一个surface中的单元应该是相容的，同维度，同阶插值，同为可变性或不可变形的。
44. 推荐在assembly中定义set或surface。也可以在part下建立的set，在assembly中也会看到，会重命名，反之不会。例如在名为trussrod的part中建立名为Set-1的set，那么assembly中存在一个trussrod-3这样的instance，则对应的set名字为trussrod-3.Set-1，每个instance都会有对应的set。
45. 施加荷载或边界条件等时，也会提示创建新的set或surface，如果取消勾选，也会创建内部set，但是不在CAE中显示（能够让用户使用CAE时不会眼花缭乱），导出的inp文件中会包含，关键字表示如下，因此后处理中可以查看到。

    ```shell
    *Nset, nset=_PickedSet2, internal, generate #generate表示通过数据行的等差数列生成。
       1,  396,    1
    ```
46. 显示群组可以用来观察结构的内部，也可以用来进行施加载荷时方便选取，而不用建立set。它可以保存起来。
47. <img src="Abaqus.assets/image-20201026190047643.png" alt="image-20201026190047643" />
48. part模块可以使用view cut工具，来对零件裁切视图，来观察零件是实体还是薄壳。另一种方法是使用query information→geometry diagnostic，选择topology→solid cell和shell face，如果是没有进行partition的实体，则solid cell为1，shell face为0。如果是薄壳，则可能有多个shell face，但solid cell为0。可以观察输出区域的结果进行分析。
49. partition一般是用来分隔part，进而给同一个part的不同区域分配不同的材料，截面等参数。也可以是为了提高网格质量而界定边界。因为在partition的边界处一定会产生网格节点。
50. 未进行partition前，一个part由一个cell组成。对于非独立的instance，不能在assembly上进行partition，只能在对应的part上进行。对part切割之后，对应的所有instance都会被切割。
51. partition有3种情况，edge，face，cell。分别产生新的点，线，面。
52. 一个instance无论如何进行partition，都是相连的，划分网格后，节点是共用的。
53. 进行显式分析时，要手动选择显式分析的单元，因为默认是Standard的。
54. 使用embedded region构建钢筋混凝土构件时，可以打开透视Toggle Global Translucency，来选择混凝土内部的钢筋骨架。
55. 对于金属冲压成型问题，不要求板件和模具一开始贴合，可以分离开，分析开始会快速推进，然后接触发生后就会产生小增量。
56. 经常用到的sketch（例如多个part通过一个螺栓孔连接起来，都要进行拉伸切除），可以保存起来，后面可以载入到part中。
57. sketch绘图中可以将不在绘图平面的edge投影到平面上，这方便进行定位，注意这些并不是参考几何。
58. 拉伸时，可以扭转twist（需要在建模时添加一个单独的点，这个点会被当作旋转中心），也可以拔模draft。
59. 3D的线可以被当成零件或用来放样，例如用二次曲线连接多个点，折线段或者从薄壳或实体零件的边转成的线。
60. 使用分离式方法对钢筋混凝土结构建模时，钢筋可以使用桁架来简化，和用梁的结构差别不大。桁架的section只需要提供截面积即可，而梁的section还需要提供具体的beam profile。
61. 分离式方法中，钢筋和混凝土的耦合是通过embedded region约束来实现的，先选择所有钢筋为embedded region，然后选择混凝土本身为host region。
62. 混凝土单元推荐选择C3D8I，不使用缩减积分，因为容易发生沙漏。
63. 对梁进行受弯模拟时，可以施加平面外变形的约束，防止它发生屈曲。
64. 集中质量的施加：先建立ref point，然后将其和结构的一部分耦合到一起，可以是rigid body或coupling，然后在interaction→special→inertia→point mass中添加。一般是各向同性，也可以设置各向异性，这样对于相同的加速度，各个方向的惯性力不一样，或者对于同样的力，各个方向的加速度不同。
65. 一个方便记忆壳offset的方法是，将其当作要把section的哪个面和参考曲面重合。
66. 对于多层框架结构，part都是一些梁柱的线，可以在assembly中组装好，然后merge到一起，这样就不用将重合节点tie到一起了。
67. 由于abaqus早期没有CAE，全部依赖于用户手动编写inp文件，因此存在一些诸如`NFILL, ELGEN`的关键字，它们是用来简化用户输入的，这对于使用CAE的用户来说不是必须的。

# 几何修复和虚拟拓扑

1. 从外部导入的几何有3种状态：
   1. valid，有效几何是指由封闭体积构成，边之间没有缝隙，水密。导入的几何通常都会自动做成有效几何。
   2. precise，精确几何是指在valid的基础上，如果所有曲线与面都在ACIS的容许公差（1e-6）内。CAE中创建的几何都是精确的。不精确的几何可以使用，几乎不会有问题。如果进行partition时出问题，可以在几何修复中，convert to precise。
   3. invalid，无效几何。建议先修复好再使用，如果实在无法修复，abaqus允许忽略无效性（在part上右键→Ignore Invalidity），然后就可以划分网格了，但是不保证一定成功，部分几何功能（partition）可能失败。
2. IGES在保存时就是将实体保存为面的几何，然后在导入时再构建几何，将边缝合，可能会造成公差较大，不精确，因此不推荐使用IGES格式。
3. 可以使用query information→geometry diagnostic来检查几何是否有效和精确。
4. abaqus可以在导入几何时自动修复，不同文件格式的选项不同。如果自动修复失败，可以手动进行修复。
5. abaqus可以对导入的几何（整个part，edge，face）进行修复（在abaqus中创建的几何不太会用到这个功能），来缝合实体或删除一些不必要的特征（小边，小面，倒角等），提高网格质量，因为mesh一定会在edge 和 vertex上生成节点，所有的手动修复都会被保存为feature。也可以使用虚拟拓扑来忽略小的特征。建议最好在CAD中修复好。
6. 虚拟拓扑Virtual Topology并非直接修改几何，而是让网格划分器去忽略小的几何特征，因此它出现在mesh模块中。将小边/面和周围的边/面合并。能使用更好的单元获得更好的质量。生成虚拟拓扑的两种方式：自动（根据特定准则扫描整个模型），手动。虚拟拓扑被当作feature，因此可以被删除，还可以restore部分feature，这也是一个新的feature，抓大放小。
7. 可以先利用query information→geometry diagnostic找出小边/面，然后手动选择它们，创建虚拟拓扑。
8. 虚拟拓扑比几何修复好的一点是，在创建虚拟拓扑之前施加到模型上的荷载或边界条件不会因为创建虚拟拓扑而失效，而几何修复做不到这点。
9. 薄壳抽中面：CAD工程师建模时一般不会将薄壳建模成曲面，如果分析时想要使用壳单元，则需要抽中面。需要先选中实体区域，assign midsurface region，将其变为参考几何（会变成半透明，可以在工具栏取消其显示），然后使用几何修复中的offset功能生成中面。抽完中面之后，可能会产生空隙，可以使用几何修复中的blend face（会产生新的面，不太推荐）或extend face处理。如果抽中面比较复杂时，也可以使用连续体壳单元来分析。
10. abaqus选择时，默认会将选框内和相交的所有物体都选择，可以设置成只选择选框内的物体。

# 材料

1. ABAQUS支持工程应变和对数应变两种模式。ABAQUS中任意输入的应力和应变都默认是真实应力应变。
2. 工程（名义）应变NE：$\varepsilon_{nom}=\Delta l/l_0$，真实（对数）应变LE   $\varepsilon=\textrm{ln}(l/l_0)$。其中$\Delta l=l-l_0$。输出变量E通常是对数应变LE。实验中只能直接得到工程应力和应变数据。
3. 对数应变和工程应变的转换关系为：$\varepsilon=\textrm{ln}(1+\varepsilon_{nom})$。
4. 对于非弹性材料，总对数应变=弹性应变+塑性应变+徐变应变。$\varepsilon=\varepsilon^{el}+\varepsilon^{pl}+\varepsilon^{cr}$。
5. 应力也分为工程应力$\sigma_{nom}=F/A$和真实应力$\sigma=F/A_0$。真实应力和真实应变之间才满足胡克定律。
6. 对数应力和工程应力的转换关系如下：$\sigma=\sigma_{nom}(1+\varepsilon_{nom})$​。
7. 以上转化关系适用于：单轴试验，材料各向同性。
8. 塑性材料数据默认接受真实应力和真实应变。当从实验数据导入ABAQUS时，如果指定了该数据是工程应力应变，则会ABAQUS会做转化。
9. 真实塑性应变$\varepsilon^{pl}=\varepsilon-\varepsilon^{el}=\varepsilon-\sigma/E$。
10. 超弹性材料数据默认接受工程应力应变。
11. 可以使用calibration来导入材料单轴拉伸实验的数据，然后导入dataset。可以自动进行工程→真实应力/应变的转化。然后编辑一个behavior，将它赋予给一个空的material。ABAQUS会用多段线性来拟合这个数据，用滑块指定用多少个点来插值。
12. <img src="Abaqus.assets/image-20200617193057304.png" alt="image-20200617193057304" />
13. 如果材料性质和温度或场变量有关，则在温度或场变量范围内内插，范围外为恒定值，等于边界值。一般来说温度越高，弹性模量会降低，泊松比会升高。
14. 对于非各向同性材料，需要使用局部材料方向来定义材料性质。
15. 线弹性材料也可以是各向同性，正交各向异性的和各向异性。
16. 胡克定律的一般形式：$\sigma=D^{el}:\varepsilon^{el}$。
17. 定义塑性材料行为需要先定义弹性行为。表格数据的第一行为初始屈服应力和对应的0塑性应变。这是定义Mises塑性的步骤，Hill塑性需要使用suboption→potential选项。Mises用来对金属的初始等向屈服行为，Hill用于金属的初始非等向屈服行为，例如因为冷加工导致的，该模型假设非等向不介入材料的塑性变形，只能用于应变<5%的情况。
18. 材料的损伤一般是指，应力软化（也就是应力应变曲线的下降段）和刚度损失（卸载时的刚度小于初始刚度）。应力软化并非是金属材料的颈缩段，后者是因为使用了名义应力应变曲线导致的，也就是应变局部化导致的，金属的真实应力应变曲线仍然是上升的。混凝土材料会出现真实的下降段。
19. 塑性是指弹性到应力软件之间的区域，这还是上升阶段，只是没有弹性段的斜率大了。
20. 对于包含颈缩段的工程应力应变曲线，要转化为真实应力应变曲线，应该分为两段：
    1. 颈缩前，使用上述公式转换即可。
    2. 颈缩后，找到破坏点的真实应力（破坏力/断口面积，后者需要测量），真实应变（使用上述公式转换），然后认为颈缩开始点到破坏点之间为直线。如果没有测量端口面积，则可以认为颈缩后为颈缩点的切线，或者使用幂函数关系插值。

21. <img src="Abaqus.assets/无标题-1735044355658-1.png" alt="无标题" />
22. 整体上看，真实应力应变曲线相比于工程应力应变曲线，会偏左上。
23. 塑性定义的hardening rule对于单调加载（即不卸载）没有用。
24. 推荐论文：`Constitutive Modeling of Structural Steels: Nonlinear Isotropic/Kinematic Hardening Material Model and Its Calibration`。
25. ABAQUS可以建立材料库.lib文件，来共享材料数据，存储位置可以选择home（C:/user/xxx/abaqus_plugin目录下）和当前工作目录下的abaqus_plugin文件夹。
26. 存放在home目录下，所有的cae工程都可以使用，如果存在当前目录下，则只有该cae工程可以使用。
27. <img src="Abaqus.assets/image-20201026152232425.png" alt="image-20201026152232425" />
28. ABAQUS对于3D的单元也是用截面来定义材料，选择均质homogeneous即可。壳单元截面包含材料，节点厚度和积分选项，梁单元截面包含截面形状和材料。
29. 梁和壳都会提示选择截面积分的方法，对于线性分析，分析前积分就可以，非线性的话应选择分析中积分，因为截面性质会变化。
30. 梁单元公式中引入的梁理论适用于由单一材料构成均质梁，并假设梁横截面的剪切中心已知或易于计算。然而，如果梁的横截面形状任意，或者梁由多个材料层组成，那么找到横截面剪切中心和翘曲函数就不再是一项简单的任务。如果这些材质层具有各向异性材质行为，则可以使用其他梁单元公式。这些公式需要计算额外的横截面特性，考虑了梁单元的拉伸、剪切、弯曲和扭曲之间的额外耦合。为了执行这些任务，必须在二维横截面区域上使用有限元离散化对横截面进行数值积分（Meshed Beam Cross-Section）。有限元横截面模型的节点自由度表示翘曲位移（通常为平面内和平面外翘曲自由度），允许确定剪切中心和梁扭转刚度或表征所有潜在耦合的完全填充的6×6梁单元刚度矩阵。
31. 同一种材料可以用于不同的section。将section指定给part（或part中的单元构成的set region）之后，对应的part就有了材料和尺寸的定义。没有指定section的part会显示为白色，指定了1个section的为绿色，多个的为黄色。
32. 想要显示壳单元的厚度和梁单元的截面，则需要在view→对应的display option中勾选下面的选项。只有在赋予了section后才可以看到。
33. <img src="Abaqus.assets/image-20201026154608506.png" alt="image-20201026154608506" />
34. 材料的方向对于实体单元默认使用全局直角坐标，而壳单元，则是采用在全局直角坐标在参考面上的投影，随着单元面的法向方向变化。
35. 对于壳/膜单元，局部坐标系的1方向是全局X轴在单元参考面上的投影。参考面的法线方向（按照顶点顺序，右手定则）作为3方向，2方向由1和3方向确定。如果全局X轴和参考面法向很接近，则使用全局Z轴投影替代。如果是轴对称的壳/膜单元（模型为线段），局部坐标系1方向平行于r-z平面，2方向为环向，即+θ向。
36. 对于梁/桁架单元，局部坐标系的1方向沿着单元的指向，由起止节点确定。
37. 在几何非线性分析中，梁/桁架，壳/膜等单元的预设方向会随着单元的运动而运动。实体单元的则不会，始终和全局坐标系一致。
38. 如果对单元定义了局部坐标系，则单元内的任意点都会应用该坐标系。除非在节点定义了局部坐标系，否则节点的123方向和整体坐标系平行。
39. 实体单元如果发生了大转动，它的积分点的坐标系仍然是按照未变化全局坐标系来的，输出可能会不方便。用户可以为单元变量定义一个局部坐标系，该坐标系会跟随积分点旋转，方便输出。
40. 自定义材料方向就是建立局部坐标系，它会影响材料性质的输入和结果分量的输出。自定义的坐标系都会跟随积分点转动。
41. 支持的坐标系类型由直角，柱，球三种，其他的坐标系可以通过子程序设定。
42. 应力应变的输出和材料方向有关。如果想要输出第二种图形，则要后处理中，在result option→transformation→user defined，指定自定义的坐标系，这相当于坐标变换，得到新坐标的分量。不过这对于不变量来说没有用，因为他们是标量，不依赖于坐标系。
43. <img src="Abaqus.assets/image-20200614230943958.png" alt="image-20200614230943958" />
44. 截面点就是厚度方向的积分点，一般使用simpson数值积分法，它和高斯积分的区别在于，高斯积分点都是在区间内不，simpson会用到边界的点，这样方便观察梁/壳表面的情况。
45. 各向同性塑性相当于应力空间的屈服面关于静水压力轴是对称的。因此可以用拉压子午线来描述屈服面。到静压轴的径向距离是等效剪切应力的度量。一般模型都假设最初是各向同性的，不过可以通过随动强化发展称各向异性的，此时只要将屈服面沿背应力平移回来，仍然是关于静水轴对称的。
46. 对于拉压不一致的材料，如果只能执行一种试验，那么推荐进行拉伸试验，因为材料一般拉伸性能更差，这样趋于保守。

# 分析步

1. step是对时间上进行分割，这样做的目的是为载荷和边界条件的变化提供方便。在step之间可以改变输出量，一个step可以理解为一个工况。每创建一个step，都会创建一个对应的的输出请求，其中制定了要写入到结果数据库文件中的变量。
2. 载荷和边界条件和step分析步有关，用户可以指定他们在哪些step起作用。
3. ABAQUS静力分析的时间不具有真实的意义，只是用来设置载荷的加载比例和划分不同的step。一个step又可以划分为多个增量步（非线性step时），每个增量步可能需要多次迭代才收敛（取决于非线性的强弱和增量步的大小）。动态问题中，时间是具有真实物理意义的。
4. ABAQUS会自动生成初始的initial step（长度为0），它无法设置载荷，但是可以设置边界条件。所有指定在初始step的边界条件都必须赋值为0，这是ABAQUS的要求。创建一个新的model后，唯一自动生成的就是initial step
5. 每个step能够进行的分析类型是独立的，但有些step需要先完成特定的step后才可以解锁。后一个step的初始状态是前一个step的结束状态。
6. <img src="Abaqus.assets/image-20200615211327823.png" alt="image-20200615211327823"  />
7. 每一个step包含一个分析程序。分为两大类：
   1. 一般分析步：静态，隐式动态，显式动态，传质，热传导，热-力学耦合，压电，孔隙分析。
   2. 线性摄动分析步：都是基于特征值分析，例如频率提取，稳态动力学分析，反应谱，随机响应问题，此类step不会累加到时间中，因为长度非常小，可以忽略。
8. 在Explicit中，只能使用General分析步，不能是摄动分析。
9. 分析步只能都是隐式或都是显式，不能在一个分析步序列中同时存在这两者，这里将摄动分析看成隐式分析。主要原因是一个inp文件只能使用一个求解器运算，隐式或显式。
10. 可以supress某个分析步，例如进行完频率提取后，可以进行稳态动力学，也可以进行反应谱分析，后两个可以压制一个，只进行另一个。
11. 每个step都独立计时，因此时刻可以有两种计算方式，step time和total time：
12. <img src="Abaqus.assets/image-20200615212036783.png" alt="image-20200615212036783" />
13. Standard静态分析中初始时间增量一般为step长度的1/10，默认是1，需要手动修改。
14. 如果分析步较长，则需要修改最大增量数量，默认为100，例如非线性效果较强，增量较小，则会需要较多的增量来完成分析。
15. Explicit动力分析一般只用设置时长，求解器会完全自动进行增量调整，连初始增量大小都不用设置。
16. 如果想要替换某个分析步（例如隐式换显式），最好的方法是replace，而不是删除再新增。因为荷载，输出设置都是和step绑定在一起的，删除后就没了。replace可以完美继承。
17. 也可以suppress某些分析步，这样会直接跳过该分析步。
18. 几何非线性来自于大位移，预应力，荷载刚度，显式分析默认开启它。它的开销并不大，对于确实发生了几何非线性行为的问题，开启它会更容易收敛。
19. 边界非线性发生在荷载或边界条件随着结构的变形而改变。分为两种①接触，极度不连续的非线性形式②外力的方向在分析过程中发生改变，例如给气球充气的压力载荷。
20. <img src="Abaqus.assets/image-20200616104919764.png" alt="image-20200616104919764"  />
21. 一个step包含多个increment，一个increment可能包含多的iteration。如果在迭代规定次数达不到收敛条件，则会缩小increment，继续迭代尝试。一个attempt内会做几次iteration，如果不收敛会新增一个attempt（上一个attempt的数据没有用，完全丢弃），以更小的increment（原来的25%）进行迭代。ABAQUS通过判断力残差和位移修正是否满足要求来判断是否收敛。
22. <img src="Abaqus.assets/image-20200616151919353.png" alt="image-20200616151919353" />
23. 自动时间步长会监控迭代次数，如果轻易收敛（两个连续的增量都在4次迭代内收敛），则会增大increment，每次增加50%。
24. 如果总增量步数超过max number，或所需的最小增量<定义的Minum，都会中断。
25. implicit分析通常使用Newton-Raphson法,无条件稳定（任何增量大小都可以使用，不会发散）。
26. 下面这图是按照外荷载来划分增量（通过time step的划分来加载，也有按照位移加载的，总归是知道力或位移中的一个），第一个迭代结束时力的残差都较大，继续做切线，经过3次迭代，力残差达到收敛条件。
27. <img src="Abaqus.assets/image-20200616111820537.png" alt="image-20200616111820537" />
28. abaqus的平衡是指节点平衡，动力时需要考虑惯性力。
29. 求解完成后，可以在tools→job diagnostic中观察每一次迭代的收敛细节，例如残差和修正。求解过程中报错后，可以来这里查找问题。
30. standard中常见的不收敛的原因：
    1. 单元畸变，例如单元某个积分点的体积为负数，需要检查截面，边界，荷载等，推荐加密网格。
    2. 过度屈服，出现了较大的变形，应检查材料的塑性数据是否过小和荷载是否过大。
    3. 沙漏，使用一阶缩减积分容易出现，推荐加密网格，或使用完全积分或高阶单元，或使用非默认的沙漏控制算法。
    4. Numerical singularities，静态分析中存在未约束的部分。
    5. zero pivots，例如有一个力，但是没有对应的刚度，也是由于约束不足，和上一项类似。
    6. 负特征值，表示系数矩阵不是正定的，例如较大的屈曲荷载。
31. 创建第一个step后，就会分别创建一个field和history的输出请求，建议直接修改这2个，而非创建新的输出请求。
32. 有两种输出请求类型：history和field。field是用来绘制contour的，history是用来绘制XY图的。history默认会保留每一个increment的结果，field默认只会保存每个step最终的结果。
33. field的输出频率一般较低，因为体积较大，history的输出频率可以较高。
34. 在field输出中component表示分量，invariant表示不变量，一般用于张量。magnitude表示向量的模。
35. 可以勾选Contour Plot options→Limits→Show location，展示出云图最大/最小值的点在哪里。
36. 对于standard静力分析，field默认输出应力分量和不变量S，总应变E（或者对于应变LE，如果开启了几何非线性），塑性应变PE，等效塑性应变PEEQ，位移（包括转动）U，反力RF，集中力CF，接触应力CSTRESS，接触位移CDISP。
37. history默认会输出所有的能量，它可以帮助判断模型是否有问题。例如将artificial strain energy和internal energy对比来观察hourglass情况的严重与否。沙漏化的虚假能量（增加到单元的应变能中，使得单元显得没有那么软）应该<<内能（1%以下）。
38. internal energy=artificial strain energy+plastic dissipation +strain energy。
39. 频率提取分析步，由于时间步长为0，因此没有history数据。但是会产生field数据（例如振型），abaqus会自动为摄动分析和通用分析步分别建立两个输出请求。
40. 输出请求默认会对其后的所有分析步都有效，也可以在分析步之间改变请求的变量和频率。
41. 输出的频率设定：
    1. Last increment，最后一个增量，即仅在每个step的最后一个增量输出一次。这个在Explicit中没有。
    2. Every n increments，每n个增量步输出一次。
    3. Evenly spaced time intervals，一个step内输出固定的次数，时间平均的概念。
    4. Every x units of time，每隔x时长输出一次。
    5. From time points，在给定的时间点序列进行输出。时间序列可以在output→Time points中定义。
42. 对于后两种指定时刻的输出，有两种选择：TIME MARK=NO，特定时间点最近的下一个增量结果；TIME MARK=YES，调整增量大小来确保接近指定的时刻，只能用于自动增量控制的分析步。
43. Explicit中增量步非常多，必须有选择的输出。
44. 荷载的幅值amplitude，默认由两种，(a)为阶跃载荷stepped，在第一个increment就把整个荷载步的变化施加完，后续increment维持不变，(b)为斜坡载荷ramped，每个increment只施加等比例的荷载变化。下图中有2个分析步。第一个分析步有5个increment，第二个有3个。
45. <img src="Abaqus.assets/image-20200615215420739.png" alt="image-20200615215420739" />
46. 阶跃振幅虽然看从0到第一个增量之间是斜线，而非一开始就是最大振幅值，实际上这对于模拟是没有区别的，因为幅值只会在增量点上被取值，增量点之间的变化是没有用的（但是定义振幅的点的变化会有用，如果增量点比较密集，就会感知到振幅的变化）。而且无论多小的初始增量，阶跃振幅都能保证第一个增量的幅值为1。人工构造阶跃振幅时，用两点（0，1）和（1，1）即可。
47. 如果定义的幅值是高频变化的，那么为了确保这些变化被真实的施加在结构上，需要确保结构的最大增量不能太大，这个过程相当于对幅值进行采样。因此可以使用香农的采样定理来确定最大增量，1/最大增量>2*幅值的最高频率，幅值的最高频率可以用其中的最小时间间隔的倒数代替，也可以对幅值进行傅里叶分析来测试。
48. abaqus不能进行像XY data一样，对幅值进行运算，只能通过base值进行缩放。用户可以自己通过第三方软件构造好，然后输入。
49. 幅值可以由外部文件给出，例如`*AMPLITUDE, NAME=HAMP, INPUT=koyna_haccel.inp`。.inp文件中内容的布局就和关键字的数据行一样，一行8个数，逗号分隔，一个时间，一个幅值，依此类推。
50. 阶跃载荷一般用在有时间意义的程序中，例如瞬态分析。斜坡载荷一般用在没有时间意义的程序中，例如静态分析等。
51. 显式分析默认是阶跃，隐式分析默认是斜坡，不过都可以通过amplitude进行修改。可以让显式分析使用逐渐变化的荷载（tabular，设置两个点，ABAQUS会自动在两者之间进行插值），实现准静态分析。
52. 在瞬态分析中可以定义amplitude来获得任意随时间变化的荷载。
53. 如果荷载不是空间均匀分布的，可以使用analytical field（解析场）或discrete field（离散场）来设置。前者使用数学表达式，后者根据指定点的值来插值。
54. 荷载和边界条件一旦设定，默认在所有的step都生效，可以设定无效和恢复。
55. predefined field是设置初始状态的，例如初始速度或初始应力或温度场。
56. 预设的位移或速度在边界条件中设置，而非荷载。
57. 在边界条件中进行位移加载时。设置为0的位移和不设置约束不一样，前者表示固定位置不懂，后者表示可以自由运动。对于垂直下压的刚性面，不仅要设置下压的位移，其他方向的位移要约束住（勾选即可），否则会乱动。
58. pressure的荷载可以施加在实体的表面，正值表示压力，和面的法线反向。
59. <img src="Abaqus.assets/image-20241212152256464.png" alt="image-20241212152256464"  />
60. 金属成型中，第一步使用位移控制加载，第二步不应该是将下压轴的位移设置为0，而是deactivate位移约束，让工件自由回弹，或者释放下压轴的位移约束，保持其他轴的约束，避免工件飞走。
61. 分析步中可以设置如果某个region完全进入塑性阶段，则停止当前分析步。在Edit step→Stop when region xxx is fully plastic。

# 荷载与边界条件

1. 集中力和集中力矩都只能施加在节点或参考点上，如果是几何非线性问题，节点在分析中可能经历大转动，如果需要让荷载方向随节点转动而转动，Follow nodal rotation，则可也勾选该功能，应该视情况来决定。Shell edge load中自动是follow rotation。
2. shell edge load荷载只能对曲面的边施加，也就是要用壳单元模拟的结构的边缘施加。有3个方向，分别使得shell受压（normal），受弯（transverse），受剪（shear）的分布力，还有一个沿edge方向的分布力矩。单位都是单位长度的力或力矩。
3. 柱和球坐标系中的点的坐标值或向量的坐标中角度的单位都是deg，而非弧度。abaqus中没有明确指明的角度单位都是deg。
4. 重力荷载无法在initial 分析步施加，需要单独一个分析步，静态的即可。
5. 对结构进行地震分析时，需要在initial step中约束住支座其他方向的自由度，然后在动态分析步中为特定自由度设置加速度/速度/位移的边界条件。

# 重启动分析

1. 重启动分析允许用户从之前分析的某个时刻继续分析，3大应用场景：

   1. 继续因人为终止的分析，例如包含多个分析步的变参数分析，之前的若干分析步如果相同，就没必要重复分析，可以直接读取中间某步的结果，而只计算不一样的后续步骤。有时对于大模型的分析，需要先观察一下求解情况，来修改求解设置或荷载/边界条件。例如对于包含接触的问题，如果只有分析的后一部分有明显的接触行为，此时可以共享前一部分的结果，后一部分可以使用多种接触属性来分析，观察接触属性对结果的影响。这是只需要让abaqus在特定分析步的结束时刻输出重启动文件即可。
   2. 继续因意外终止的分析，例如断电，系统崩溃，磁盘空间不足，如果以一定的频率输出一些可以用于重启动分析的数据，就可以避免从头开始计算。
   3. 有时需要在隐式和显式求解器之间接力分析，此时需要互相读取对方的结果，这样可以充分利用两个求解器各自的优势。例如金属冲压涉及复杂接触，使用Explicit分析，后续回弹可以使用Standard分析。这里的重启动输出设置一般只输出最后结果即可，但是不能根据正常分析输出的文件接续分析，因为这相比重启动分析，少了很多文件。

2. 创建分析步后，会自动产生该分析步内的restart request，且不能新增。在Step→output→restart request中查看，对应的关键字为`*Restart, write, frequency=0`，可以在Edit keyword中查看到。frequency=0表示不输出，该参数的默认值为1表示每个增量都输出重启动文件，但是对于CAE，默认生成的参数值为0，并非该参数的默认值。只要frequency≠0，就会在分析步末尾输出，因此如果只想在分析步末尾输出，可以将该值设置成很大。
3. 新的重启动文件默认不会覆盖旧的，可以使用overlay参数来覆盖，不过也只能覆盖同一个分析步的，不同分析步可以有不同的overlay参数值。需要注意的是，一个job的多次输出重启动文件，并不会真正产生多个.res文件。
4. Standard还可以指定每多少个增量输出一次。Explicit只能指定分析步内一共输出多少次（NUMBER INTERVAL参数）重启动文件，因为它的增量数量太多了，不适合用于控制输出，而且分析前用户也不知道增量是多大。指定NUMBER INTERVAL而非FREQUENCY是co-simulation推荐的方法。NUMBER INTERVAL和FREQUENCY是互斥的，只能指定一个，二者的默认值都是0。
5. 文件：

   ```shell
   .res #restart，文件大小上限为16GB
   .abq .mdl .pac .stt #analysis database
   .prt #part
   .sel #selected results
   .odb #output database
   ```
6. 读取相关数据重启动分析，使用`RESTART, READ`，需要指定分析步和interval编号。还可以选择是否要继续指定分析步或者终止它。
7. 重启动的分析必须要和原始分析使用相同的模型，推荐在CAE中copy model。不能修改在原始模型中定义的几何，网格，材料，surface等。不能修改在重启位置前的任何分析步，荷载，边界条件，场或interaction。
8. 在复制后的model上右键→Edit Attributes，为Read data from job指定要读取的那个job的名称（通过它可以找到所有的重启动所需的文件，因为只有后缀名不同）。然后指定重启动的step，还可以指定是从该step的结尾开始继续，还是某个increment，interval，iteration等（increment是对standard来说，interval是对explicit来说，iteration是对direct cyclic分析来说）。如果从中途继续，还需要指定是否继续完成当前step，或者跳过当前步直接进行下一个step的分析（terminate）。
9. 可以根据需要添加新的step，不过需要注意新step的时间长度。对于原始分析中依据total time定义的amplitude，有必要的话也要新建替代，新建的可能需要基于total time。
10. 最后创建新的job，在Edit job→Submission→Job type选择restart。
11. 后处理中，重启动产生的odb文件会从重启动的位置记录step和increment。
12. 从Explicit传递数据给Standard时，需要保持几何非线性的开启。导入先前分析结果需要使用Create Predefine Field，在initial step，other→Initial state。然后输入job名称，step，frame编号。如果勾选了update reference configuration，则会以变形后的构型作为新的参考构型，否则以最开始的构型作为参考构型。创建job时不再使用restart，而是full analysis。
13. 将两个重启动分析的odb文件合并，打开Visulization：

    ```shell
    abaqus restartjoin originodb=name_1 restartodb=name_2 history
    #copyoriginal参数，这样会新建一个odb（名称前缀Restart_），而不是直接修改originodb文件。
    #history参数，也会复制history data
    #compressresult参数，压缩结果
    ```
14. 重启动文件和inp，odb文件一样，都不会保存用户子程序，如果原始分析包含任何用户子程序，则必须在重新启动中再次包含这些子程序。子程序可以在重新启动时进行修改，但应谨慎进行修改，因为可能会使重新启动的解无效。
15. 无法在线性摄动步中输出重启动文件。

# 单元

1. ABAQUS的单元可以从以下5个方面进行特征划分：
   1. 单元族，例如实体单元C，壳单元S，梁单元B，桁架单元T，刚体单元R。不同族的单元所假定的几何形状不同，一般反映在单元名称的第一个字母上。
   2. 自由度，和单元族直接相关。结构实体单元只有平动自由度，梁，壳单元还有转动自由度。热传导单元只有一个温度自由度。自由度1-6分别表示方向123的平动和转动自由度。对于轴对称单元，1表示径向r平动，2表示轴向z平动，3表示绕轴向的转动，θ向平动。
   3. 节点数目与插值的阶数。插值的阶数也称为单元的阶数。每一个方向上的节点数一般为2，3个，则表示分别为一阶和二阶插值。单元的节点数目也会标注在单元的名称中，例如C3D8表示有8个节点。梁单元稍有不同，它标识的为插值阶数，而不是节点数，例如B32表示2阶插值，实际有3个节点，而非2个节点。
   4. 数学描述，ABAQUS的所有应力分析用的单元都是基于拉格朗日描述的，分析中材料和单元保持关联，材料不能流出单元的边界。而Explicit中的自适应网格技术，将纯拉格朗日和欧拉分析的特点结合，允许单元的运动独立于材料。
   5. 积分方法，在求整个单元体的能量（需要使用势能原理推导单元刚度方程）的时候，需要进行体积分。大部分单元可以使用高斯积分的方法，由于等参元引入了雅可比行列式，导致被积函数从多项式变成有理函数，因此任意阶的高斯积分都不能获取准确值。根据积分点数的多少，可以分为完全积分（这里是只忽略等参元的分母，认为被积函数是一个多项式时所需要的代数精度）和缩减积分。末尾有R的表示使用了缩减积分，例如C3D8R。
2. 单元命名规则：C-continuum，3D-3Dimension，R-Reduced integration，S-Shell，AX-Axisymmetric，PE-Plane strain，B-Beam。
3. <img src="Abaqus.assets/image-20200616231613914.png" alt="image-20200616231613914" />
4. 高斯积分：每个方向布置3个积分点，有6个变量（每个点的位置和权重）可以达到5次多项式的精度。坐标分别为0，8/9，$±\sqrt{\frac{3}{5}}$​（5/9）。缩减积分的每一行或列比完全积分少一个积分点，并非是将最外侧或重心的积分点删除，所有积分点要重排。
5. 通常说的一阶单元指的是位移分布（也就是形函数）是一阶的，因而应力和应变是常量。二阶单元的位移是平方关系，应变和应力是1阶的，能量是2阶的。
6. <img src="Abaqus.assets/image-20200616004812087.png" alt="image-20200616004812087"  />
7. 壳单元有三类：通用目的壳，仅适合厚壳，仅适合薄壳 。
8. ABAQUS的某些单元除了提供标准的数学公式外，还提供了一些可选择的公式。这些单元在名称上一般表现为末尾附加字母。例如混合公式的单元C3D8H，B31H，它们将实体单元的静水压力或梁的轴力处理为一个附加的未知量，这样可以用来处理不可压缩的行为。
9. 还有一些耦合单元，例如C3D8T的节点具有热学和力学的自由度，可以模拟热-力耦合的问题。
10. Standard提供了一阶和二阶单元可供选择，而对于Explicit，除了二次梁单元和修正的四面体和三角形单元来说，只有线性单元可以使用。
11. Standard提供了完全和缩减积分可供选择，而对于Explicit，除了修正的四面体和三角形单元来说，只有缩减积分可以使用。
12. 对于Explicit，二阶四面体单元只有C3D10M，没有C3D10，一阶四面体和Standard一样，都是C3D4。
13. 3D实体单元可以是六面体，楔形（wedge实际是三棱柱，可由六面体退化得到），四面体形状的。楔形单元可以用于为圆柱体的中心划分放射状网格。
14. 一阶四面体单元C3D4具有简单的常应变，不推荐使用，因为需要划分非常细的网格。
15. 二维实体单元根据出平面行为的不同，可以划分为三类：
    1. 平面应变PE，假设出平面应变为0
    2. 平面应力PS，假设出平面应力为0
    3. 轴对称单元

16. 平面应力和平面应变单元可以指定单元的厚度，默认为1。
17. 广义平面应变单元是对平面应变单元的推广，即出平面应变随着平面的位置发生线性变化，适合厚截面的热应力分析。
18. 二维实体单元都是三维问题的简化，必须在1-2平面内定义。且单元内节点的序号满足右手定则，否则面积为负值。
19. 如果受弯构件在厚度方向上网格少于4层，则不应使用缩减积分，应该使用incompatible模式的单元。
20. 对于实体单元，pinned（铰接）和encastre（刚接）是一样的。因为节点本来就没有转动自由度。
21. ABAQUS中一般称壳（包含shell，membrane）和梁单元（包含beam，truss）为结构单元。membrane和truss不能受弯。
22. 结构单元是简化的单元，运算成本低于实体单元。但是这些结构单元的使用是有条件的，需要结构本身（而非单元）满足一定的假设，即壳的厚度和梁的截面尺寸应该<全局结构尺寸的1/10。全域结构尺寸可以是支座间距，截面渐变段的距离，所关注的最高阶模态的波长。实际上一个梁结构是可以划分成多个梁单元的，因此可以模拟高阶振动模态。
23. 如果使用了结构单元，又需要在局部获得更精确的结果，可以使用多点约束导入三维实体模型，或者以子结构进行分析。壳体单元简化了厚度方向上的变化，梁单元简化了截面上的变化。
24. 剪切或体积自锁会使得结构变刚，沙漏会使得结构变柔。
25. 二阶实体单元，不论是完全积分还是缩减积分都可以精确模拟纯弯曲，能够变形成曲边梯形。
26. 一阶完全积分的实体单元，模拟纯弯曲时，会在积分点产生不该存在的的剪应变。这使得单元变刚，因为还需要克服额外的剪应变，称为剪切自锁。因此几乎不会使用一阶完全积分的单元，即使模拟的不是纯弯曲。
27. 一阶缩减积分的实体单元，模拟纯弯曲时，不会出现完全积分的多余剪应变，但是原本应该有的弯曲应变也没了，即使会变形成平行四边形。这种有变形但是没有应变的情况称为零能或沙漏。如果在厚度方向只有一层单元时，结构会crush，无法抵抗外力。不过一阶缩减积分单元还是比完全积分好一些，它可以通过在厚度方向增加层数来挽救，此时每个单元都只会捕捉到拉或压应变，但不会同时捕捉到两者。至少4层，实践中推荐6层。一阶缩减积分单元是一种计算成本低且有效的单元，即使有多层，一般还是比二阶单元的计算量要小。
28. 2层比1层好，但是3层和2层是一样的，因为3层的中间层是不受力的，没有刚度。
29. 如果无法在厚度方向划分4层网格（不能使用C3D8R），也没法建立规则的网格（不能使用C2D8I），此时可以尝试使用C3D8R，但是不适用默认的hourglass控制，而是使用enhanced，这样单元就不太容易crush，但还是要在分析结束后检查能量关系。
30. 下面的第一张图就是沙漏化后的结果。ABAQUS有内建的沙漏化控制，能够减少因为沙漏造成的问题。
31. <img src="Abaqus.assets/image-20200617000216877.png" alt="image-20200617000216877" />
32. 出现沙漏问题的网格，虚假能量占比为2%，一般要在1%以下才可以。
33. <img src="Abaqus.assets/image-20200617000512386.png" alt="image-20200617000512386" />
34. 不相容单元（incompatible，并不是非协调元，后者是指相邻单元边界上的位移不协调，一般是特殊的壳单元），可能是用来模拟弯曲变形为主的问题的最有效的实体单元形式。没有剪切自锁和沙漏问题，厚度方向只要一层即可模拟弯曲问题。但是如果从厚度方向看去，网格必须要非常规整，如果单元是平行四边形，会降低精度（和倾斜角度有关），梯形时精度会非常差。C3D8I适用于足够规整，又非常薄的结构，例如玻璃。
35. 二阶单元在分析应力集中和静止裂缝上的问题时，比一阶积分更好。缩减积分更有效率，通常得到的结果更好。
36. 一阶或二阶的四边形或六面体对于初始网格扭曲较为敏感，会造成精度下降。其中一阶单元又比二阶单元更适应初始网格扭曲。
37. 二阶三角形和四面体对初始网格扭曲不太敏感。
38. 应该着重改善应力集中区域的网格质量，尽量将扭曲放在应力变化小的区域。
39. 不可压缩材料，即泊松比=0.5。几乎不可压缩材料（ 泊松比>0.475）。常见的有橡胶，和有大塑性应变的金属材料。
40. 传统的有限元网格通常会因为体积自锁volumetric locking而表现出刚硬的行为。在材料被约束严密时（例如被钢板严密包裹的橡胶）表现地更为明显。
41. <img src="Abaqus.assets/image-20200617004306209.png" alt="image-20200617004306209" />
42. 对于不可压缩材料，每一个积分点的体积要保持不变，即雅可比行列式为1，例如完全积分6面体单元使用8个积分点，则每个单元上比之前多了8个约束，这使得单元变得比原来刚硬了。
43. 体积自锁最常发生在完全积分单元中，缩减积分可以较好地减少体积自锁。
44. 在使用standard求解时，可以使用hybrid单元来处理不可压缩问题，该单元将单元内的压应力看做基本求解变量（相当于引入额外的自由度），可以减轻体积自锁，但会增加求解时间。几乎所有单元都有其对应的hybrid类型单元，除了平面应力，因为它不会发生体积自锁。尽量使用四边形或六面体的Hybrid单元，而不是三角形或四面体的。
45. 遇到以下两个问题时，才推荐使用混合单元：
    1. 所有的单元都使用不可压缩材料。
    2. 使用缩减积分的细化网格仍然会出现体积自锁时，可能会出现在应变距离塑性段还有较长距离的弹塑性材料。

46. 即使使用了混合单元，一阶三角形和四面体单元仍然会在模拟完全不可压缩材料时发生过度约束，因此只推荐它们作为四边形或六面体网格的填料（占比较低）。
47. 有时几何比较复杂，只能使用三角形或四面体网格，但是不推荐使用一阶的，因为他们计算效率低，且即使使用混合单元，仍然有体积自锁问题。二阶单元适用面较广，推荐使用。接触问题中，surface to surface接触不限制使用的单元类型。而node to surface限定使用修正modified的二阶三角形或四面体单元。
48. ABAQUS在拓扑上只有以下12种单元，和网格划分软件沟通只需要这些即可。不过还有1维的点单元，可以用来附加质量或转动惯量。
49. <img src="Abaqus.assets/image-20200617011220167.png" alt="image-20200617011220167"  />
50. 网格收敛性分析，随着网格的细化，关键变量差异变小。如下图中绿线左侧不可靠。和无关性分析类似，后者是指同样的网格密度下，不同的网格拓扑，对结果的影响不大。如果没有实验对照的情况下，这两个分析尤为重要。
51. <img src="Abaqus.assets/image-20200617012032048.png" alt="image-20200617012032048" />
52. 设置global seed时，使用curvature control来设定的最大偏差值（h/L，h为几何与单元之间的最大间隙，L为单元的长度）。该数值越小，直线段就越贴合曲线段，也会划分更多的段数。下方会显示一个圆大约被划分成的段数。
53. <img src="Abaqus.assets/image-20200617211411996.png" alt="image-20200617211411996" />
54. 一个圆孔最少需要3个单元的边来模拟，即构成一个三角形。
55. 全域seed和局部seed显示的颜色不同。全局seed只能对part，不能对region或者cell进行。
56. 应力集中的区域如果要加密的话，需要先进行partition，然后设置较小的edge seed。
57. 6面体和四边形网格的生成算法有两种：advancing front和medial axis。第二种对于圆孔较多的几何能够划分更好，因为它会隐性地对几何进行partition，但是这些不会展示给用户。但是medial axis不支持虚拟拓扑功能。
58. 带圆孔的part建议使用sweep而非structured来划分， 这样圆孔附近的网格畸变小。
59. mesh模块会根据指定的划分网格的方法来为不同的region显示不同的颜色。绿色表示使用结构网格，黄色表示使用扫略，粉色表示使用自由网格，橙色表示划分技术使用不正确。一些几何要经过partition成多个cell后才可以进行结构网格划分。
60. <img src="Abaqus.assets/image-20200616004354927.png" alt="image-20200616004354927"  />
61. 扫掠sweep生成网格时，abaqus会自动选择来源面（可以有多个）和目标面（只能有一个）。
62. 在Assign Mesh Control中指定划分网格的策略。
63. 遇到圆孔，至少应该切分2次，才可以划分成结构网格。结构网格要求：
    1. cell的所有面都必须有3个以上的边，例如半圆柱的两端面只有2个边，因此需要再切分成2个1/4圆柱cell才可以划分结构网格。
    2. cell的每个点必须刚好有3个点交于其上，例如金字塔cell的顶点有4个边相连，将其竖直切分成2个四面体cell就可以划分结构网格了。
    3. 边与边的夹角应该尽可能接近90度，可以利用partition消除超过150度的角。

64. 可以先划分网格，再指定网格类型，不过不建议这么做。
65. 在网格划分中，选择不同的单元，会导致显示的区别，左边是二阶四面体单元，右边是一阶。可以看到左边的单元存在边中节点。这里的几何是一段圆弧，abaqus会将角点和边中节点连接成直线显示，而不是曲线。
66. <img src="Abaqus.assets/image-20241212153416681.png" alt="image-20241212153416681" style="zoom:50%;" />
67. 网格划分完，应进行check，确保没有error，且warning的比例应低于5%。
68. 单元的长宽比不应大于5，这容易出现在使用实体单元对薄壁结构进行离散的问题中，因为厚度方向有时需要4层。
69. 网格质量检查主要是两个方面，单元的形状shape和尺寸size。形状检查最大最小夹角，长宽比，尺寸检查最大最小尺寸，还可以找出稳定时间长度小于某个值的单元（这对于显式分析有帮助）。
70. 划分完网格后，如果不确定单元类型，可以使用Query information→element来查询单元类型，勾选Display detailed report可以以表格方式显示。
71. 也可以使用query information查看shell的法向，beam的切向。
72. Query information→mass properties可以查询单元的体积，质量，face的面积等，可以调整选择工具过滤器，来选择1D，2D，3D。
73. Mesh模块最下边的Edit Mesh可以对节点，单元，网格进行编辑。原生网格的编辑功能比orphan网格要少，因为原生网格出问题的话，首先应该考虑几何是不是出问题了。
74. collapse short edge功能会对网格进行搜索，高亮edge长度小于特定值的单元，由用户觉得是否塌缩，这样可以忽略一些几何细节（例如小台阶），但是能提高网格质量。同时在显式分析中，也可以提高稳定增量大小。修改单元后，需要注意，如果这里涉及到接触或tie约束，需要检查是否已经发生了穿透。collapse short edge只能用在一阶单元上，因此需要先按照一阶单元划分，collapse完成后，再指定为2阶单元。
75. <img src="Abaqus.assets/image-20241213212735651.png" alt="image-20241213212735651" style="zoom:80%;" />
76. 可以将shell的section指定给实体，不过后面mesh时，单元类型就应该是实体壳单元了。这对于变厚度壳的建模很有帮助，因为壳的厚度是由几何参考得到的。实体壳单元的形状和实体单元一样，不过和壳单元不同的是，它的节点只有平动自由度。实体壳对于接触的判定比曲面壳更精确。只有2种单元：SC6R和SC8R可以使用，分别为三角形和四边形的拉伸形状。不能和hyperfoam材料一起使用，如果将其用于非常薄的壳，收敛速度较慢，应该使用传统壳。
77. 变厚度壳的section定义不用指定厚度，在section assignment中选择从几何创建厚度即可。
78. 实体壳也具有top和bottom面，可以使用query information→mesh stack orientation查看。和传统壳一样，不一致的堆叠方向会导致分析时出错。堆叠方向只允许由一层网格。在mesh模块种可以assign mesh stack orientation。
79. Edit mesh可以对节点进行smooth，提高网格质量。可以将四边形，六面体切分成三角形或四面体，反之也可以合并。
80. 也可以merge相近的node来完成共节点操作，或修复网格。
81. 不同的seed在网格模块中显示的方式不同，几何点为方框，表示完全约束，edge上的全局seed为圆形，表示可以可多可少，edge上的local seed为三角形，表示只能增加。在local seed的constraints控制页面上，可以修改local seed的性质，默认是只允许加密不允许变粗，还可以设置让网格划分器完全按照local seed的要求来分段。Advancing Front会完全符合撒点的位置，而Medial Axis为了更高质量的网格，不一定完全符合。
82. 几何点永远都会生成网格节点。因此，应该避免不必要的几何点。
83. 将一个part进行切分之后，如果两个相邻的cell使用不同的网格划分策略，会导致界面上的网格不兼容，这是CAE会自动为界面两侧添加tie约束，这不会显示给用户看。也可以将左侧的结构网格当作扫掠网格划分，此时界面上就会自动共节点。tie约束只是强制运动协调，但不保证力协调，而共节点可以保证后者。
84. <img src="Abaqus.assets/image-20241214105211329.png" alt="image-20241214105211329" />
85. 可以使用query information→mesh gap/intersection来侦测网格间隙和干涉。abaqus不支持几何干涉侦测，只能对划分后的网格进行侦测。
86. Mesh菜单栏中可以将网格保存到part，也就是orphan网格。还可以将网格和几何取消关联，这样就会产生orphan，之后再对几何进行重新划分，会和原有网格重叠。可以使用query diagnostic→Unassociated geometry中高亮显示未关联的。
87. 在划分四面体网格时，默认会将内部的网格密度设置的比表面的粗糙（Mesh control→Tet→Free→Non-standard interior element growth），这是为了减少单元的数量，因为对大部分的材料来说，最大应力位置很大可能出现在外表面。
88. 
89. 

# 自适应网格划分

1. 自适应网格划分Adaptive Remeshing，会在网格划分器和求解器之间迭代进行，直到满足某些收敛标准。根据结果中的error indicator来决定哪些区域需要细化网格，那些区域需要粗化网格。用户需要指定remesh的规则和细化的方式，在mesh模块中。应变高的区域并非应变的error indicator高，后者类似于梯度。
2. <img src="Abaqus.assets/image-20241216234458720.png" alt="image-20241216234458720" />
3. 最好copy原始模型，在新模型上进行自适应网格划分，因为该过程会修改网格。
4. 需要指定自适应网格划分规则应用的区域region和分析步。可以指定需要使用何种撒点方式来细化网格。为了避免过度细化或放大，还应指定网格划分的约束。
5. error indicator可以是单元能量，mises等效应力等变量。
6. remesh过程会创建多个job，仅网格有区别。
7. 可以观察到距离孔较远的区域的网格变粗了，孔附近的网格变细了。
8. <img src="Abaqus.assets/image-20241216235425619.png" alt="image-20241216235425619" />
9. 可以看到随着remesh迭代，error indicator越来越小，单元数量反而没有增大很多。应力也变高了，但是增长速度变慢，趋于收敛。
10. <img src="Abaqus.assets/image-20241216235522506.png" alt="image-20241216235522506" />
11. 目前只支持通过CAE操作，没有keyword。只有Standard可以使用，Explicit不可以。只支持非结构网格，即二维的三角形或quad dominated，三维的四面体网格。
12. 对于问题中某些应力集中的区域，可以设置size的约束或最大单元数量的限制，避免过度细化网格（因为这里始终无法获得收敛的解），也可以将其排除在region之外。
13. 一个模型可以定义多个remesh rule，每次计算结束后，会对每一个rule进行检查，只有都满足才会停止。不同的remesh rule可以对同一个region指定，abaqus会选择最密的网格来施加细化。同一个remesh rule中可以有多个error indicator，abaqus会选择最差的做决定。
14. 不能在同一个remesh rule中既包含solid又包含shell区域。
15. 对于同一个part的相依赖的instance，对其中1个指定，所有都会生效。
16. 一系列remesh迭代结束后，可以在mesh→Adaptivity→Manual Adaptivity Remesh来横向比较每次迭代的细节。同时还可以将指定odb文件的网格还原到当前model中，应用remesh model按键。
17. 其实不进行自适应网格划分，也可以输出error indicator，在field output中。
18. 不同的分析推荐使用不同的error indicator：
    1. 时间历程分析，推荐使用单元能量密度，等效塑性应变。
    2. 时间无关分析，一般会根据最后一个增量来决定如何remesh，建议使用除了上面两个以外的指标，例如mises等效应力。
19. 计算误差指标会提高计算量，每次迭代大约多20%。单元能量密度指标尤其花费时间，因此除非问题是时间相关的，且等效塑性应变不够用时才可以使用单元能量密度指标。
20. 误差指标比例（误差指标/求解得到的基础值）越大，表示网格越粗糙，此时就会细化网格。
21. 根据误差指标比例来调整网格尺寸场的方法sizing method：使得最大最小值满足某个范围约束（迭代后，单元尺寸差距较大，单元数量较多）；使得误差分布更接近平均分布（迭代后，单元尺寸差距不太大，单元数量较少）。
22. 还可以指定bias factor，就是网格过渡的范围，Strong时，过渡范围较小。
23. 不同的error indicator，对应不同的sizing方法。
24. 可以设置只允许细化网格，不允许粗化网格。
25. 不能用常规的创建提交job，而应该在job模块→Create Adaptivity process来创建自适应网格划分过程，需要手动给定一个job的前缀和指定最大迭代次数（默认为3）。submit之后，会逐渐在jobs中产生对应的多个job。迭代完成前不能修改模型，要提前结束迭代可以在manager界面中终止。

# 后处理

1. 求解过程中的信息会输出到jobname.sta，jobname.dat或jobname.msg文件，同时也会显示在monitor框内，最上方的迭代细节保存在.sta文件中。

2. 可以在求解过程中打开odb，查看结果，如果后续又写入frame，不会自动更新，需要按下播放按钮的下一帧来重新载入。

3. increment是求解时的概念，frame是后处理时的概念，一般来说，每个frame都对应某个increment的结果。

4. 如果显式分析中单元尺寸变化不大，则可以认为总时间为：monitor第一行显示的时间*20。因为Explicit中field输出请求默认是均分20段。Standard的默认是每个Increment输出一次。

5. 对于动力分析，可以观察到动能和内能总是此消彼长的，同步反向变化。

6. viewport的legend，title block，status block的显示，字体大小都在Viewport→Viewport Annotation Options中设置。

7. ABAQUS使用canvas画布来摆放多个viewport。

8. 视图中的部分，在打印出图时会用到：

   1. viewport decorations→title border
   2. viewport annotations→legend, state block, title block, view orientation triad, and 3D compass

9. 链接的窗口只能有一个，打开该功能后，勾选需要链接的窗口即可。链接的窗口可以选择要同步的选项。一般来说就同步位置和视角就行了。

10. <img src="Abaqus.assets/image-20210320111520801.png" alt="image-20210320111520801"  />

11. common option 可以设置显示的透明度和是否显示网格。如果网格过于密集，可以取消显示网格，选择visible edges→Feature edge即可，这样会使得云图变亮很多。

12. ODB display option可以显示梁/壳的实际形状，显示边界条件和点单元，显示constraints和coupling，还可以对模型进行镜像或阵列（适用于对称模型），扫掠或拉伸（适用于轴对称或平面应力等）。

13. 如果要同时查看变形和未变形状态，可以先选中 Allow Multiple Plot States，然后再选中变形和未变形的状态。白色表示未变形，绿色表示变形后的状态。

14. symbol可以显示箭头，例如反力大小和方向。还可以用Material Orientation显示材料方向，这样可以确定shell的top和bottom。

15. 在后处理中显示边界条件，View→ODB Display Option→Entity Option。

16. 如果要查看梁/桁架单元的截面合力或合力矩，可以勾选SF（section force and moment）。如果要查看实体或壳单元的节点力，可以勾选NFORC（Nodal forces due to element stress）。

17. View cut可以切开模型，显示内部的云图，这里也可以输出截面合力，合力矩（但是不支持对壳，梁单元输出，它们具有单独的SF场输出），free body plot option设置中可以输出合力或分量形式，分量默认是按照全局坐标系分解，可以设置在自定义坐标系上分解。还可以设置显示群组，只显示一部分构件，这样得到的合力/矩就只和显示的部分有关，否则是所有切开截面的合力。还可以在保持切开的状态下，输出截面合力/矩随时间变化的结果，XY data→Free body。

18. 还可以创建关于当前显示云图的isosurface等值面，如果更换了云图变量，需要进行edit中update变量。这可以用来寻找模型内部不可见的最大应力值的区域。

19. 可以利用显示群组，只显示一部分，然后输出这部分的截面合力，合力矩。

20. 将数据以报告的形式输出到文本文件中，Report→Field Output。

21. 绘图产生的各种数据，可以用Report→XY，将内容输出到rpt文件中，方便导入到专业绘图软件中绘图。

22. 第一次预览动画的时候会卡，因为在同步生成动画，走完整个steptime后就会平顺些。菜单来animation→save as可以保存动画，推荐使用AVI，编码器选择Microsoft Video 1，默认的编码器有问题，质量拉满。实际的帧率由frame rate设置，而非播放的快慢。

23. 动画可以和XY-data同时播放，包括combine后不显含时间的曲线，即在animation options→viewports勾选两个视口，然后播放动画即可同步。

24. 在显式分析的后处理中，位移形状缩放因子默认为1。

25. 有多个零件发生接触时，如果缩放因子过大， 会观察到穿透，这只是显示错误。

26. 如果在通用分析步中间包含频率提取分析步，则在后处理播放动画时，应该将其屏蔽掉，因为他们的物理意义不同。频率提取分析步在后处理中显示的也是mode，其他的都是increment。

27. history会输出位移-时间，应力分量-时间的曲线，如果要输出位移-力的曲线，则应该将二者combine起来。先后选择要作为X和Y的数据，然后右键save as，勾选combine(XY，XY)即可。

28. 也可以先分别save as 保存两个曲线，然后创建一个新的曲线，operate on XY data。这些函数都是对纵坐标值进行运算，如果要对横坐标运算，需要先调用swap函数。这里还可以滤波。

29. 很多导出量（例如应力，应变）都是在积分点上求解出来的，不过还是根据节点的位移求解的，因为使用了高斯积分，因此积分点的导出量的精度更高。积分点在单元内部，单元的node值是从积分点外插得到的。同一个node属于多个element，因此多个单元都在该node有一个外插值，可以设置平均算法来获得node的值。

30. 默认的阈值是75%。表示如果不同单元得到的node值的最大和最小值差异比例小于75%，就平均，否则就不平均。阈值为0%表示无论差异多小，都不会平均，这样会看到云图有间断，100%表示无论差异多大，都会平均。

31. 对于应力集中的区域，应该进行加密，而不是平均，因为平均的结果可信度较低。加密网格后，平均与否对于结果的影响会变小。

32. 应力奇异：随着网格密度的增加，特定位置的应力持续增加无法收敛的情况。经常发生在单点受力，尖锐转角，单点接触，单点约束的情况。尖锐转角可以用圆角过度来缓解。单点受力和约束可以用coupling来缓解。

33. 如果应力奇异发生在不重要的位置，可以忽略，因为它是数值计算造成的，并非真实，可以参考位移场，因为它比应力更可靠。

34. 如果应力奇异的地方很重要，则需要圆角过渡，同时进行子模型分析。先用粗略网格分析，作为奇异部分子模型的边界条件，用细化网格分析，这样可以得到收敛解。

35. <img src="Abaqus.assets/image-20241214121746966.png" alt="image-20241214121746966" />

36. 差异比例的计算方法：(节点上各个单元外插的最大值-节点上各个单元外插的最小值)/(模型区域内最大值-模型区域内最小值)。默认的模型区域是截面性质相同的区域。还可以选择为elementset或显示群组。

37. <img src="Abaqus.assets/image-20200616011552372.png" alt="image-20200616011552372"  />

38. <img src="Abaqus.assets/image-20200616012007640.png" alt="image-20200616012007640"  />

39. Query information→probe value，使用探针查看单元或节点等的数据时，可以在积分点上查看，可以在单元的中心Centroid查看，也可以是单元的节点，也可以是单元的面face。

40. ```shell
    #单元的积分点
    Part Instance  Element ID        Type     Int. Pt.     S, Mises
    ---------------------------------------------------------------------------
        PART-1-1          31       C3D8I            1         12.9
        PART-1-1          31       C3D8I            2         12.7
        PART-1-1          31       C3D8I            3         13.6
        PART-1-1          31       C3D8I            4         13.5
        PART-1-1          31       C3D8I            5         22.8
        PART-1-1          31       C3D8I            6         22.7
        PART-1-1          31       C3D8I            7         23.7
        PART-1-1          31       C3D8I            8         23.6
    #单元中心=积分点的平均值
    Part Instance  Element ID        Type     S, Mises
    ---------------------------------------------------------------------------
        PART-1-1          31       C3D8I         18.2
    #单元的节点
    Part Instance  Element ID        Type         Node     S, Mises
    ---------------------------------------------------------------------------
        PART-1-1          31       C3D8I            1         9.48
        PART-1-1          31       C3D8I            2         9.05
        PART-1-1          31       C3D8I            3         10.7
        PART-1-1          31       C3D8I            4         11.2
        PART-1-1          31       C3D8I            5         24.5
        PART-1-1          31       C3D8I            6         24.4
        PART-1-1          31       C3D8I            7         29.4
        PART-1-1          31       C3D8I            8         29.6
    #单元的面
      Part Instance  Element ID        Type         Face     S, Mises
    ---------------------------------------------------------------------------
        PART-1-1          31       C3D8I            1         9.59
        PART-1-1          31       C3D8I            2         26.9
        PART-1-1          31       C3D8I            3         17.5
        PART-1-1          31       C3D8I            4         18.1
        PART-1-1          31       C3D8I            5         18.9
        PART-1-1          31       C3D8I            6         18.3
    
    ```

41. XYdata输出场变量时，如果勾选积分点，则应选择单元，如果勾选unique nodal，则应勾选节点。

42. Report输出中，Element Nodal表示每个单元的节点，这个是一个二级表单的形式展示的，单元共用的节点会出现多次。Unique Nodal是全局编号，只有一级，和单元无关，不会重复。Centroid表示单元的形心，也不会重复。

43. <img src="Abaqus.assets/image-20210319145101051.png" alt="image-20210319145101051"  />

44. 对于两个相邻的C3D20R单元（一共有2x2x2=8个积分点）来说，element Nodal是按照单元来组织的，2个单元，每个20个，但是其中会有重复的，相邻的face上的所有Node都有重复。而Unique Nodal是不考虑单元，只考虑这些node，不重复出现。一共有2x20-8=32个。

45. 对于壳体，后处理时可以显示section上不同的point，顶部，底部的数据等。如果是多层复合材料，则要选择plies。因为壳在受弯时，一个面受拉，另一个面受压，应选择正确的location显示。

46. <img src="Abaqus.assets/image-20200616011256150.png" alt="image-20200616011256150" />

47. 默认的field输出请求只会输出top和bottom截面点的结果，如果需要特定截面点的值，需要在输出请求中设置，Outputs at shell，beam，and layerd section points→Specify，例如1,2,3,4,5。这里的截面点编号需要在壳或梁的总截面点数量范围内。

48. 后处理中创建的XY表格，都是保存在session中，而不是ODB结果文件中，因为ODB文件一般都是以只读的形式打开的。

49. <img src="Abaqus.assets/image-20210319151834552.png" alt="image-20210319151834552" />

50. ABAQUS可以将用户自己生成XY data存放在当前的session中，不过下次再打开odb文件默认看不见，需要载入之前保存的session。

51. 另一种方法是将数据其存放到odb文件中，右键save as，然后在XY Data Manager中选择Copy to ODB就可以了。但是ABAQUS在打开odb文件时（从job→result打开），默认都是以只读的方式打开，这样能够防止对数据进行错误修改，因此不能存储新的东西。应该重新使用非只读的打开方式。也可以将odb中保存的XYdata load到session中。

52. abaqus提供了插件（Plug-ins→Tools→Excel Utilities），可以将XY data批量导出到Excel中，反之也可以，格式为XYXY……。

53. XY data可以是空间位置的函数，例如创建path（菜单栏→tools→path，可以使用node-list），然后输出随真实距离（或者节点顺序，特定坐标，正规化后的距离）变化的场值。有必要的话，应该勾选Include intersection和Undeformed。

54. XY data可以是关于Thickness的，这是专门为shell服务的，默认会将厚度作为纵轴（默认是0到5，表示第0到5个积分点，0号积分点在SNEG上，也就是bottom面），物理量作为X轴，如果需要反转，可以使用swap函数。

55. 如果要模型的不同部分显示不同的内容，例如被压部分显示应力，压头部分显示为透明的。这是可以将他们分别加入不同的显示群组，然后在odb display group manager中lock锁住状态。

56. view→tool bar→color code可以为不同的part或材料设置不同的颜色，一般在显示多刚体机构运动时使用。

57. view→tool bar→view option可以设置是否开启透视。

58. 后处理中观察等效塑性应变PEEQ，它只能增大，且卸载后不会不会变小。

59. session中可以保存的内容如下，主要是用户创建的东西，或显示的设置，可以将其保存到.xml文件，.cae文件或.odb文件。

60. <img src="Abaqus.assets/image-20241218194405039.png" alt="image-20241218194405039"  />

61. 后处理中输出S11等分量时，对于壳/梁，是将张量在各自的坐标系进行分解，并非一个统一的坐标系。

62. 使用弧长法可以在Standard中追踪结构的软化行为。

63. riks使用弧长法进行分析，是按照弧长arch length输出，而非时间。因此在后处理中，提取的各种变量都是随弧长变化，而非时间，因此无法和其他以时间为横坐标的分析步一同绘制。

64. 实际的荷载等于LPF和施加的参考荷载的乘积，这一点类似于线性屈曲分析。

# 约束

1. constraint约束，模拟点和点之间的运动关系，常用的：

   1. tie，一般用来将两个surface或node region粘在一起，用于连接网格不相容的重合面。
   2. coupling，将参考点ref point和面上的节点耦合，分为kinematic和distributing。
   3. shell to solid，用于连接壳和实体单元。
   4. Rigid body，刚体约束。
   5. Display body，仅显示，不参与计算，和刚体不一样，刚体只是不变形而已，还是会参与计算的。还可以设置它运动与否，方便观察。

2. tie constraint会将两部分永远连接起来，不适合于模型的脆弱部分。

3. <img src="Abaqus.assets/image-20200616101155000.png" alt="image-20200616101155000" />

4. 如果将一个part，切分后，会在边界上生成节点，但是不能确保两个部分的节点分布相同，或者共用节点，这是就可以使用tie来进行粘合。

5. tie的两个面也分为master和slave，会将距离master小于tolerance（可以手动指定或自动计算）的slave面上的节点粘到master上。这里master和tie的选择不像接触那样有一些特定的原则。如果两个面的距离太大，超过了计算或者指定的大小，即使应用了tie约束，也不会生效。有些模型在建模时，就预留了间隙，例如用来上胶，因此可能需要用户手动指定tolerance的大小。

6. 也可以选择将slave节点adjust移动到master面上，不过对于tie来说不太推荐，尤其是两个模型之间存在干涉时，会将slave节点推出master 面，可能造成单元的节点顺序错位，体积为负，干涉也不影响二者的粘合。

7. 不能给tie constraint的slave节点施加边界条件，方程或MPC，因为它的行为已经完全被master控制，这样会造成过约束，求解时报错zero pivot。

8. coupling应用：

   1. 将对模型施加集中力/边界扩展为对一个区域施加，降低应力集中程度。这样做还有一个好处，就是后处理时，可以输出整个截面上的反力，如果没有ref point耦合，则需要输出所有face的反力，然后求和。

   2. 模拟与其他单元的互动，例如connector单元。

9. kinematic是将参考点和所有耦合点之间用刚性梁（不只是二者距离不变，参考点的转动/力矩也会带动耦合节点的平动/集中力）连接。

10. distributing是用平均的方式强化，将荷载通过节点面积加权的方式分配到节点上，比较柔和，参考点和耦合节点之间的距离角度可以改变。分为两种continuum和structural，后者是给结构单元（壳/梁）用的。

11. 求解器会将作用在参考点的集中力和力矩荷载，分配到所有耦合节点上，施加节点力，具体取决于耦合方式，耦合节点的空间分布。

12. 注意，对于实体单元来说，其节点只有平动自由度，而coupling到ref point后，ref point是具有转动自由度的，应该视情况对ref point进行约束和加载。一般会输出参考点的力或位移的history数据，可以绘制力-位移曲线。

13. <img src="Abaqus.assets/image-20200616101859947.png" alt="image-20200616101859947"  />

14. shell to solid 用在这种情况：壳体部分使用shell单元，实体部分使用solid单元。将shell的边和solid的侧面相连。

15. <img src="Abaqus.assets/image-20200616102303335.png" alt="image-20200616102303335"  />

16. 模拟加载实验的支座的垫块时，可以在垫块上建立一个ref point，将对应的surface耦合到该ref point。然后把荷载和位移约束施加到refpoint上，这样可以避免应力集中。也有用Rigid body约束的，后者一般会比较刚硬，不太推荐。

17. 如果要创建ref point的位置没有其他点可以点选，则可以使用datum point或datum csys，它的创建方式比较多。

18. 刚体是节点和单元的集合，其行为可由一个参考点（6个自由度）来控制，由于自由度缩减导致刚体的计算效率较高。荷载和边界条件应施加在参考点上。如果刚体存在旋转，则参考点应放在质心。不需要材料参数和截面性质。

19. 如果多个物体之间有接触关系，其中一个物体的刚度远高于另一个，可以将它设置为刚体，例如金属成型中的模具。

20. 刚体part有两种，离散刚体（可以是各种形状，必须是薄壳，不可是实心的，需要划分网格，使用如下单元，但是不用指定section）和解析刚性面（形状规则，计算较快，不用划分网格，只能用在接触对的设定，如果是explicit中，可以在其上设置surface，使用general contact）。

    ```shell
    2—D:
    	R2D2  #平面线段
    	RAX2  #轴对称薄壳，几何上也是线段
    3-D:
    	R3D3  #三角形薄壳
    	R3D4  #四边形薄壳
    ```

21. 除了创建刚体part，还可以使用rigid body constraint刚体约束。将原本是可变性体的part或其部分变成刚体。这个比刚体part调整更自由，不过需要对这部分刚体划分网格，指定材料和截面。

22. 刚体约束由于可以随时激活和关闭，可以用于简化分析。例如如果确认某一部分变形较小，可以为它设置刚体约束，然后计算，能够运行成功后，再关闭该约束，运行完整的模型。

23. 创建刚体约束，需要指定那些body要被约束，还要指定参考点。将来对刚体的荷载和边界条件都施加在这个参考点上。

24. 如果是动力问题，且刚体part可以自由移动，此时需要给定它的质量和转动惯量，在part→engineering Features→inertia中设置。如果是刚体约束，只需要设置密度即可，abaqus会自动计算质量和转动惯量。

25. 注意如果是通过刚体约束构造的刚体壳，那么赋予shell section时的厚度和offset都会影响接触的具体位置，而不一定是建模的那个surface。

26. ABAQUS可以自动将参考点移动到所选部分的质心。如果想要施加外力或外力矩在刚体上，则不用勾选此选项。

27. <img src="Abaqus.assets/image-20200616103850406.png" alt="image-20200616103850406"  />

28. 刚体的运动（例如位移控制的冲压过程）应该施加在ref point上。

29. 定义surface时，对于解析刚性面，要注意选对面的哪一侧，颜色不同，也可以两侧都参与接触。

30. 拉伸得到的解析刚性面，虽然需要指定拉伸长度，但是它是在z方向无限延伸的。

31. abaqus可以对对称，轴对称，循环对称模型简化分析。

    1. 关于某个坐标平面对称的模型，可以建立1/2模型，如果是关于3个坐标平面对称，可以建立1/8模型，例如立方体。建模使用3Dpart，需要在边界条件中，为这些对称面施加对称约束即可。

    2. 轴对称模型要在建立part中选择axisymmetric，然后建模任意θ面的几何即可，不需要施加边界条件。轴对称问题需要使用专用的单元。

    3. 循环对称模型比较特殊，它类似于轴对称模型，但是它是绕对称轴旋转特定角度（360/整数）才可以重合，轴对称是旋转任意角度都可以重合。建模按照正常的3Dpart进行，需要在interaction→Cyclic symmetry中设置，需要分别选择master和slave surface（就是旋转后能重合的两个面），然后选择转动轴。然后制定多少个sector。

32. abaqus缺少周期性边界条件，也就是平移后可以重合，需要用户手动使用equation约束来施加。

# 接触

1. 除非在interaction模块中指定接触，否则ABAQUS不会自动识别instance之间的力学接触关系。接触只会发生在模型的外表面之间，因此如果模型发生破裂，内部的面暴露出来，但是并不会发生接触。

2. 法向接触和切向摩擦可以看做是非线性约束。定义接触后就可以传递压力和摩擦力。

3. master和slave的选择有3个原则，master会显示为红色，slave为紫色。按照此原则选择结果精度高，计算效率也会高：

   1. 一般将比较硬，变形小的，设置为master，例如刚体。

   2. 一般将网格粗糙的，设置为master。

   3. 一般将分析过程中不会持续改变位置的，设置为master，例如滑块在桌面滑动，桌面应该设置为master。具体来说是，master应该是接触的face不断改变的那个，例如滑块滑动时，滑块上参与接触的始终是同样的face，而桌面上参与接触的face总在变。这样设置接触的搜索更快。

4. ABAQUS提供两种基于surface的接触：

   1. general contact，范围内包含的所有节点和单元之间都可以发生接触，计算机来考量接触行为。越来越多的新功能都是首先加入到general contact，这对用户使用非常友好。
   2. contact pair，需要逐一定义，每次只能定义两个surface之间的接触，分析范围小，搜索速度快。

5. <img src="Abaqus.assets/image-20200616184730505.png" alt="image-20200616184730505"  />

6. 二者的选择取决于定义接触的难度和所需分析的效率。如果接触对难以定义，则使用general contact，如果要求分析效率高，则使用contact pair。

7. 对于接触来说，只有slave surface可以是node based，master不可以，node based surface也只能是slave，接触公式也只能使用node-to-surface。而tie约束则都可以。

8. 推荐在定义接触对前，首先手动定义所有的surface，这样选择起来不容易出错。

9. 以下情况下只有contact pair可以使用。

   1. Standard中的解析刚性面

   2. Explicit中的2D模型

   3. node based surface，网球拍的面就是这种，只有点线，没有面face。

   4. 小滑移

   5. 粗糙或拉格朗日摩擦

10. general contact只能在initial分析步中设置。默认是所有的外表面，也会考虑自接触。也可以排除一些面之间的接触。这里也可以指定一些surface用于general contact，这个和接触对不同的是，它的优先级比较低，可以被覆盖。

11. <img src="Abaqus.assets/image-20200616190020490.png" alt="image-20200616190020490" />

12. 可以指定全局的接触属性，同时也可以为特定的两个surface的接触指定不同的属性，这不会冲突。例如模拟不同粗糙度的表面。

13. <img src="Abaqus.assets/image-20200616195405046.png" alt="image-20200616195405046" />

14. 定义contact pair（surface to surface contact），要设定master（只能是surface）和slave（可以是surface或node region）。

15. 接触行为和荷载边界条件一样，可以在不同的step中开关，在interaction manager中设置。

16. 也可以使用find contact pair来根据指定的tolerance寻找可能的contact pair。这样可以避免使用general contact，提高计算效率。这个工具还可以将寻找找的接触对转换成tie约束。

17. general contact会自动寻找可接触的面，并将其保存为surface，不过需要在后处理的显示群组→surface→internal sets中查看。不过这里看不到哪个是master，哪个是slave，因为general contact是通过网格的粗细来自动判定。

18. master surface的法线方向必须一致，且都指向slave面。

19. <img src="Abaqus.assets/image-20200616200955606.png" alt="image-20200616200955606" />

20. 一般来说接触行为至少包含切向和法向的。如果定义一个空的contact properties，也会有normal和tangential两个属性，默认是hard和frictionless，也可以只定义一个，另一个用默认的。还可以包含粘结行为，接触阻尼，破坏行为。

21. 法向接触默认是hard硬接触（不连续的）。压力的距离的关系如下，未接触时，压力为0，一旦接触，压力可以任意大（随外力变化）。

22. <img src="Abaqus.assets/image-20200616201505088.png" alt="image-20200616201505088" />

23. 除了hard以外都是soft接触。法向行为可以设定接触后是否可以分离。

24. <img src="Abaqus.assets/image-20200616201818598.png" alt="image-20200616201818598"  />

25. 指数形式是为了解决数值计算的收敛问题，在不到0的间隙就开始产生接触压力。

26. <img src="Abaqus.assets/image-20200616201907131.png" alt="image-20200616201907131" />

27. 切向接触行为默认为无摩擦frictionless的。

28. 一般的摩擦行为应该是：达到最大静摩擦力后会滑动，否则不相对滑动。

29. ABAQUS的penalty模式使用coulomb摩擦，临界静摩擦力取决于接触压力$p$。摩擦系数$\mu$可以是相对滑移速度，接触压力等的函数。在发生不可恢复滑动之前，ABAQUS允许少量弹性滑动$\gamma_{cr}$，此时卸载变形会恢复。还可以设置最大的剪应力，超过该值后，无论是否达到临界静摩擦力，都会滑动。

30. <img src="Abaqus.assets/image-20200616210359231.png" alt="image-20200616210359231" />

31. frictionless为完全光滑，rough为完全粗糙，不可滑动（同时也应将normal behavior设置为接触后不分离no separation，取消勾选即可）。不分离并不代表不能滑动，不能滑动不代表不能分离。

32. Standard可以输出到odb中的接触field结果如下，history也有类似的项。输出的量可以是节点的，也可以是surface的。接触应力在master和slave面上都会输出，刚体不输出（作为接触对的离散刚体或刚体约束会输出）。

    ```shell
    #接触相关的数据只会为定义了接触的surface输出数据。
    CSTRESS  #接触应力，包含接触压力CPRESS，摩擦剪应力CSHEAR1和CSHEAR2。对于梁来说，单位是单位长度的力。
    CFORCE   #接触力
    CDISP    #接触位移，包含接触间距COPEN(>0表示没有穿透)，相对切线移动CSLIP1和CSLIP2
    CNAREA   #节点接触面积
    CSTATUS  #接触状态，表明哪些surface发生了接触，接触的面还可以指示是否发生了滑移
    CFORCE   #节点接触力
    CSTRESSERI #接触 error indicator，用来指导是否需要细化网格，如果它的数量级和最大接触应力差不多，则需要细化网格。
    CNAREA   #节点接触面积
    ```

33. 接触分析只能使用线性单元。

34. 菜单栏→interaction中还包含接触初始化，稳定算法和控制。

35. 初始干涉的来源：刻意制造，例如卡扣，它在制造和建模时都是自然状态，而装配后，就会产生干涉；薄壳单元的厚度以及offset；前处理的错误；曲面离散化的结果。下图就是网格划分造成的初始干涉，可以通过增加网格密度来避免。

36. <img src="Abaqus.assets/image-20241215214943205.png" alt="image-20241215214943205"  />

37. 处理方法：

    1. 对于general contact，会将一定范围内的初始干涉作无应变调整（用于解决非刻意的干涉），即移动slave面和master面贴合。
    2. 对于接触对，将初始干涉当作interference fit，默认在第一个增量内试图调整所有的干涉量。

38. 有些零件建模时就是存在干涉，这是为了装配时方便固定，此时不能直接移除干涉，需要使用initialization assignment→contact initialization将overclosure处理为interference fits，如果不处理或者使用adjust自动处理，则会在分析开始时就将干涉推开，不过不会有应变和应力。例如垫圈需要拉伸才可以套入孔洞。

39. surface的类型影响到他是否可以用于特定的分析的master或slave中。不连续是指一个surface的存在两个face不能通过相邻face连接起来，就是不连通。三维中两个face只通过一个node连接起来也算不连续。

40. <img src="Abaqus.assets/image-20241214163934488.png" alt="image-20241214163934488"  />

41. 接触公式包含三个部分：

    1. 离散化，是node to surface（接触发生在离散的node上）还是surface to surface（general contact只能使用这种，比node更平均，推荐使用这个，除非不可用）。
    2. 施加方法，Direct（拉格朗日乘子法，不允许任何穿透，node to surface默认的公式），Penalty法（使用penalty刚度，允许小量部分穿透，surface to surface默认的公式），增强的拉格朗日法（也就是前两种的结合）。Edit Contact Property中施加方法还有一个默认，不同的软硬接触公式下，默认的施加方法不同，推荐选择default。
    3. 接触追踪方法，有限滑移还是小滑移。

42. node to surface是较早发展的算法，就是将node拒止在surface之外。例如下图中，slave中的每个可能接触的node在同一时刻，都只能对应到master上的一个face，而没有对应任何slave node的master face，则可以穿透slave surface。例如下图的箭头指示的2个红色节点。因此如果slave的网格比较稀疏时，node to surface会造成严重的穿透，但是无论如何，slave节点都不会穿透master面，因此要求将网格稀疏的当作master。每个slave node都要沿着master face的法线计算它到master的距离，计算接触力时需要。

43. <img src="Abaqus.assets/image-20241214183408702.png" alt="image-20241214183408702"  />

44. 每个slave节点还会计算node面积，用来将接触力转化成接触应力CPRESS，这个用来当作边界条件。

45. 对于surface to surface，每个slave节点都会对应多个master face，接触通过加权平均处理。此时接触间隙通过slave face的法线，计算到对应的master face的距离。surface to surface的好处有：提高接触应力的准确性（同时接触应力更平滑），减少接触的卡顿（角点被钩住的情况），减少面穿透，降低对master或slave选择的敏感度。

46. <img src="Abaqus.assets/image-20241214205931740.png" alt="image-20241214205931740"  />

47. snag，由于node to surface无法避免master节点对slave surface的穿透，因而造成节点钩住的情况。

48. <img src="Abaqus.assets/image-20241214210628044.png" alt="image-20241214210628044" style="zoom: 50%;" />

49. node to surface只有在小滑移时才会考虑壳/膜的厚度，surface to surface默认都考虑，不过也可以设置不考虑exclude。

50. surface to surface在每次迭代中的计算量比较大，尤其是master的网格比slave精细时，或者是一个surface在某些接触中是master，而在另一些接触中是slave。不过surface to surface对于一个增量，迭代次数不会太多，更容易产生较大的增量。

51. 小滑移会将一开始接触时的face延伸出去，而不去考虑后续和其他face的接触，认为始终和最初的那个face接触，有限滑移会实时更新master面的状态，默认就是有限滑移。小滑移假设会加快计算速度，适用于螺栓紧固的情况，金属冲压成型属于有限滑移，如果使用小滑移计算，则会出问题。大小的确定可以以单元的尺寸为界。通用接触不可以使用小滑移，二者都可以使用有限滑移。由于node to surface是从master face法线寻找接触间隙，因此它和滑移公式也有关系。

52. <img src="Abaqus.assets/image-20241214211928036.png" alt="image-20241214211928036" style="zoom:67%;" />

53. 使用小滑移计算时，需要在节点上输出CSL_NORMALIZED，它等于CSLIPEQ/正规化距离。用来度量滑移量的大小，如果大于0.5则表示该区域不适合使用小滑移。

54. 自接触时，会计算两次，分别当作master和slave，使用平均的结果。

55. Direct（拉格朗日乘子法）会修改待求解的线性方程组，λ是包含所有约束自由度的向量。优点是准确，会完全满足约束条件，缺点是会增加求解成本，增大了系数矩阵的阶数，由于接触刚度的突变会造成潜在的收敛问题。接触约束可能与MPC冲突。

56. <img src="Abaqus.assets/image-20241215210912956.png" alt="image-20241215210912956" style="zoom:50%;" />

57. penalty分为线性和非线性两种，线性可以可以设置一个接触力不为0的起始间隙C0（默认为0），让真正接触之前就产生接触力。接触刚度默认是接触面下单元的刚度的10倍，可以手动调整这个值（如果倍数太大，abaqus会使用拉格朗日乘子，避免病态状况）。非线性的一开始也是线性倾斜上升，然后是二次函数。线性容易收敛，适用于稳定接触的问题。非线性初始刚度低，适用于颤动问题，末端高刚度可以降低穿透，但是会降低收敛性。

58. <img src="Abaqus.assets/image-20241215212158047.png" alt="image-20241215212158047" style="zoom:50%;" />

59. penalty的优点，大幅提高收敛速度，由于没有拉格朗日乘子的额外自由度，因此方程求解成本也较低。缺点，存在微量穿透，某些情况，可能需要调整接触刚度。

60. Direct相当于位移边界条件，penalty相当于弹簧边界。

61. 摩擦是高度非线性问题，非必要不考虑。摩擦行为是非保守的，会使得稀疏矩阵变成非对称的。当摩擦系数>0.2或和接触压力有依赖关系，Standard会自动使用非对称求解器。

62. 摩擦的拉格朗日乘子法只能用于接触对，认为只有当剪应力达到临界时才会滑动，否则没有相对滑动（stick），是理想行为，类似于法向接触行为的direct方法。假设动摩擦因数等于静摩擦因数。会增加计算成本，收敛效率低。

63. 摩擦的Penalty方法允许在剪应力达到临界前产生弹性滑动。

64. 滑动面上自然有一个法向，使用壳的方法来定义其上的局部1，2方向，这样就可以定义各向异性摩擦行为。

65. 涂层和固体或固体之间的胶粘剂剥落模拟，可以有两种方法，参看`https://www.youtube.com/playlist?list=PL0en87H2H2m3KZPz45vzJ_8BizRC-EwmL`：

    1. 对胶粘剂建模，使用实体，而非壳。使用cohesive单元，勾选单元删除技术，设置最大退化值为0.8，将胶粘剂的两个侧面和涂层，固体使用tie绑定到一起，设置胶粘剂材料损伤来模拟剥落。

    2. 不对胶粘剂建模，使用contact property→cohesive behavior。



# 屈曲分析

1. 屈曲主要发生在细长的结构构件中，例如梁（结构柱），壳结构（例如真空罐体），这种结构无论使用实体单元还是结构单元都可能发生屈曲。
2. 屈曲破坏的特点是，前期看不到明显的变形和承载力损失，附加扰动后，结构不会无限制变形下去，这属于稳定平衡阶段。随着荷载的增加，从稳定平衡转化为非稳定平衡。屈曲分析可以寻找分界点的荷载大小，也可以进行稳定平衡（线性屈曲）和非稳定平衡（屈曲后分析post-buckling）的计算。
3. 理想的直柱，在临界载荷作用下，有两种变形方式，一种是保持直线，仅长度变短，另一种是向侧向弯曲。实际结构中，初始缺陷和荷载横向扰动将决定具体的变形方式。
4. 特征屈曲问题虽然和频率提取都是摄动分析，都需要用到特征值分解，但是二者是不同的。
   1. 频率提取是关于质量和刚度矩阵的广义特征值分析。特征值是频率的平方，特征向量为振型。
   2. 特征屈曲问题是关于刚度矩阵和几何刚度矩阵的广义特征值分析。特征值是屈曲载荷因子，特征向量为屈曲模态。

5. 线性屈曲分析，不需要为材料设置密度，但是频率提取就需要设置密度。但是频率提取会忽略荷载，因此是否施加重力加速度没有区别，而线性屈曲分析对荷载是敏感的，==是否能同时施加重力荷载和集中力荷载==。
6. 几何刚度矩阵描述了结构在初始应力作用下，由于变形引起的附加刚度变化。考虑非线性行为，推导过程中不能使用小应变假设。几何刚度矩阵与弹性刚度矩阵不同，后者仅基于材料的弹性性质，而几何刚度矩阵依赖于结构的初始应力状态。
7. Lanczos方法不能用于刚度不确定的特征屈曲问题，此时需要用子空间迭代法。例如：
   1. 包含混合hybrid公式单元
   2. 包含分布耦合单元
   3. 包含接触对或接触单元
   4. 已经被预加载超过分支（屈曲）荷载的模型
   5. 包含刚体模态的模型
8. 在线性屈曲分析中，需要对结构施加一个参考荷载，将来计算得到的是屈曲荷载的系数，乘以参考荷载才是屈曲荷载。一般将参考荷载设置为1，这样屈曲荷载系数就是屈曲荷载。
9. 屈曲模态和参考荷载的方向有关。后处理中的每个屈曲模态都会被归一化，位移的最大幅值均为1。

# 隐式动力学

1. 理论上来说，静力问题也可以当做动力问题来求解，不过这会浪费较多时间。当惯性力（而非外力）不可忽略，且随时间变化较快时，就必须当作动力问题分析。通过结构的自振周期来判断荷载的变化频率是否较快，是否需要当作动态问题考虑，一般认为超过5倍自振周期就可以当作静态问题分析了。冲击荷载至少是静态荷载响应的2倍，因此都需要当作动态问题分析。

2. 有时惯性力较大，但是随时间变化缓慢，可以当作静态问题分析，例如轴对称下的向心力问题，或者考虑重力的问题。

3. 在包含柔性部件的问题中，向心力可能会导致旋风效应（复数特征值）。

4. 运动方程：$M\ddot{u}(t)+C(t)\dot{u}(t)+K(t)u(t)=P(t)$​。M质量矩阵为常数，不随时间变化。C和速度乘积为阻尼力，K和节点位移乘积为结构内力。所有的动力问题都需要定义密度，还有通过显式求解器求解的问题也需要定义密度，即使是准静态问题。

5. 阻尼会导致自由振动（没有外力）的幅值逐渐变小。一般使用线性阻尼假设，即每个质量点都会受到一个和速度方向相反的阻力$f_D=c\dot{u}$。不能通过结构尺寸或单元尺寸计算出阻尼系数，只能通过自由振动或强迫振动试验测量计算得到。动力分析需要设置阻尼来抑制解的噪声。

6. 库仑摩擦力也可以看作阻尼力的一种，$f_D=F_D\times sign(-\dot{u})=\mu W \times sign(-\dot{u})$。$\mu$是摩擦系数，不过此时阻尼力大小为常数，方向只和速度的方向有关。

7. 显式方法只能使用直接积分，耗时较长。

8. 隐式方法需要同时求解一个方程组或计算刚度矩阵，显式方法则不需要。

9. Standard和Explicit的区别：

   1. Standard的时间增量的大小没有限制，通常少于所设定的最大时间增量数，就能完成模拟。

   2. Standard的每个时间增量都是珍贵的，每一次推进都要求解复杂的方程，反复迭代求解。
   3. Standard的每个增量迭代的目的是获得平衡的内外力和收敛的位移。
   4. Explicit的时间增量大小受限制，通常需要更多的时间增量数来完成模拟。
   5. Explicit的每个时间增量相对廉价，因为不需要求解复杂的方程，不需要迭代。
   6. Explicit的计算耗时与否取决于单元的计算。
   7. Explicit使用开始时刻的内外力差来计算开始时刻的加速度，认为整个增量内加速度恒定，因此增量不能太大。

10. Standard使用隐式求解方法，需要求切线刚度矩阵。每个时间点（即一个增量中）时都要进行迭代（下面公式中的i）求出该矩阵。是无条件稳定，只要能收敛即可。
    $$
    \bar{K_i}=\frac{M}{\beta\Delta t^2}+\frac{\gamma}{\beta\Delta t}C+K_i
    $$

11. 隐式时间积分采用HHT方法，是Newmark-β法的正规化（包含了数值阻尼）。该方法是二阶精确的，意味着可以对加速度进行精确求解。

# 显式动力学

1. 显式时间积分也是HHT方法，参数γ=1/2，β=1。先求出当前时刻的加速度（通过内外力之差和质量矩阵的逆），然后积分得到速度和位移。同时一般采用集中质量法（这样质量都集中在节点上），此时M为对角矩阵，因此刚度矩阵也是对角的，所以每次增量计算速度特别快。

2. $$
   \bar{K}=\frac{M}{\Delta t^2}+\frac{C}{2\Delta t}
   $$

3. 显式方法使用中心差分来得出加速度，也就是位移的前向差分和后向差分分别得到半增量时刻的速度，然后再中心差分得到加速度。$\dot{u_i}=\frac{u_{i+1}-u_{i-1}}{2\Delta t}$，$\ddot{u_i}=\frac{u_{i+1}-2u_i+u_{i-1}}{\Delta t^2}$，将左侧公式带入运动方程，可得：$[\frac{M}{\Delta t^2}+\frac{C}{2\Delta t}]u_{i+1}=p_i-[\frac{M}{\Delta t^2}-\frac{C}{2\Delta t}]u_{i-1}-[K-\frac{2M}{\Delta t^2}]u_i$​，可以发现根据过往时刻的状态就可以直接算出下一时刻的状态。

4. <img src="Abaqus.assets/image-20241214124524279.png" alt="image-20241214124524279" style="zoom:67%;" />

5. 显式方法只需建立一次系统的刚度矩阵，不用计算切线刚度矩阵。条件稳定，只有时间增量小于一个临界值，才可以计算出有限解（非发散的）。稳定时间增量取决于最高特征频率$\omega_{\text{max}}$和该模态的临界阻尼$\xi$，阻尼会缩短稳定时间增量，或者用单元尺寸/波速 $\Delta t=L_e/c_d$​，也就是膨胀波穿过任何一个单元所需要的时间，对于弹性问题，$c_d=\sqrt{E/\rho}$​。这也被称为CFL条件。
   $$
   \Delta t_{\min} \le \frac{2}{\omega_{\max}}(\sqrt{1+\xi^2}-\xi)
   $$

6. 降低材料的可压缩性，也可以增大$c_d$​。钢材的波速大约为5000m/s，混凝土的波速大约为3000m/s。因此如果一个钢结构的最小网格尺寸在5mm的量级，那么稳定时间增量为1μs。

7. 可以在verify mesh→size metric中找到尺寸最小的单元，然后使用网格编辑工具，对其附近的单元重新划分，例如合并小的单元。或者使用虚拟拓扑，来忽略细小的特征。

8. 显式求解中，如果增量大小超过了稳定时间增量，一开始不会有问题，随着计算的进行，会偏差越来越大。

9. 隐式求解的基本物理量为节点位移，通过它可以求单元内的应力应变，节点速度，加速度。显式求解的基本物理量为节点加速度，通过它可以求节点速度，位移，然后再求单元内的应力应变。

10. 由于显式求解会产生大量的增量，因此求解时必须开启双精度避免误差累积，在Edit job→precision→Double-analysis+packager。而隐式分析则不用考虑误差累积，因此abaqus只提供了单精度。

11. 使用Explicit模拟准静态问题，需要注意：

    1. 加载速率必须足够慢，使得惯性力可以忽略。对于大多数结构工程，应<5mm/s。

    2. 动能和外力功，内能相比，应该足够小，一般<5%。这可以在后处理中检验。模拟进行中，可以在monitor中观察动能本身，应该在10^-6mJ数量级左右。

12. 如果通过对最小尺寸单元附近重新划分网格后，稳定时间增量依然很小，此时可以使用Edit step→mass scaling。两种方式：直接给定一个大于1的系数来增大密度或者指定稳定时间增量要调整到的值，具体系数由abaqus来计算，默认只对稳定时间增量小于指定值的单元进行调整，这样不会对结构整体有较大影响。

13. 质量缩放建议仅对准静态分析使用，对于动态分析来说，密度会极大影响惯性力。如果增加的太多，则可能产生不稳定的解，导致解出现噪声，结构异常振动。在verify mesh→size metric中可以将稳定时间增量小于某个值的单元都高亮显示，或者保存到set中，这样可以知道具体对多少单元进行了质量缩放。无论如何，不应在材料定义中直接对密度进行缩放，因为这会对所有单元产生影响，造成结果失真。

14. 对于Explicit来说，输出方式常用：Every x units of time，每隔x时长输出一次。

15. 应力波的传播例子，见官方手册1.6.2。

16. ALE和CEL都是Explicit的特有功能，Standard没有：

    1. ALE（Coupled Eulerian Lagrangian），使用ALE技术的自适应网格可以提供高度非线性问题的精确解。网格会根据解答来变化，避免变形造成的过度扭曲。
    2. CEL（Coupled Eulerian Lagrangian），ALE始终是对物质域进行划分网格，而CEL是对空间进行划分，材料在网格内流动，因此永远不会出现网格扭曲的问题。CEL适用于流动问题或高度变形的结构问题。

17. 对于跌落冲击问题，可以不用将模型从头开始释放，而是直接计算出接触时的速度，在initial分析步施加预定义速度场即可，注意不是速度边界条件，而是初始条件。边界条件表示要在任意时刻的速度都是指定的值，冲压问题中需要使用边界条件来实时控制加载速度。不过还是要施加上重力加速度load，因为它也会影响受力。


# 线性动力学

1. 如果M，K和C都是常数，运动方程为常系数PDE，则称之为线性动力学。当存在材料非线性，几何非线性，接触非线性任意一个时，评估结构的动态响应需要使用非线性动力学。如果质量M和加速度乘积足够小，可以简化为静力平衡式。

2. 线性动力学建立在模态叠加法之上（不需要逐步进行时间积分，都是隐式分析），非线性动力学采用直接积分的方法。隐式和显式方法使用不同的时间积分策略。

3. 可以用Standard求解的线性动力问题如下：

   1. 自然频率求取
   2. 模态动力学分析（非周期荷载），在时间域求解，和隐式直接积分不同的是，它求解的是广义坐标的运动。
   3. 稳态分析（周期性荷载，又可以分为简谐与非简谐），在频率域求解
   4. 反应谱分析
   5. 随机振动（荷载不确定）

4. 线性动力学都不需要对时间进行积分，因为它们是在频率域进行的。

5. ABAQUS中模态分析，忽略阻尼，也无法考虑接触行为。如果在模态分析前考虑过几何非线性，是可以接着进行模态分析的。结构可以是未约束的，如果约束的话，会考虑预应力效应。

6. 一般动力学问题中，内力=阻尼力+刚度恢复力。线性动力学问题中，阻尼力=$C\dot{u}+iK_su$（这里包含了一个刚度相关阻尼，也成为虚（imaginary）刚度），恢复力=$Ku$​。

7. 线性动力学中结构的模态是不随外力变化的，结构响应$u=\phi_iq_i$，是模态的叠加，系数为$q_i$，因此$\dot{u}=\phi_i\dot{q}_i$，$\ddot{u}=\phi_i\ddot{q}_i$。或者改写成$u=[\phi]q$，其中$u(t)$和$q(t)$都是列向量（长度和结构的自由度数量相同），而$[\phi]$是常量模态矩阵。将此表达式代入运动方程，然后在方程两侧同时乘以$\phi_j^T$。由于模态向量的正交性，得到的矩阵均为对角矩阵$\phi^TM\phi$，因此上述方程组可以解耦为n个偏微分方程，描述的是模态系数$q_i(t)$​的变化，而非原来的自由度$u$变化。解耦后的每个方程都对应于一个自由度，其m称为该自由度的广义质量（后续计算有效质量占比时会用到）。

8. 有时也将模态系数称为广义坐标（给定该系数，就可以确定结构的构型），其时间导数称为广义速度或加速度。

9. 显式分析中，会使用集中质量矩阵，即对角形式。隐式分析则不使用（质量是分布在整个结构上的），因此方程组时耦合的，不过通过模态分析得到的模态向量可以将方程组解耦。

10. 模态向量是通过质量和刚度得到的正交向量组，因此也对二者正交。模态向量求解是并没有考虑阻尼，而一般认为C和Ks都是对角矩阵，任意的正交向量组都对它们正交，因此考虑阻尼并不会影响解耦。

11. 线性动力学还要求外荷载与结构的速度位移无关，仅是时间的函数，这样运动方程的右侧也可以变成对角矩阵。

12. 单自由度运动方程是存在解析解的（使用Duhamel积分，基于卷积积分，适用于线性时不变系统），或者可以轻易使用数值积分（Newmark-β法，也适用于非线性系统）求得。

13. Abaqus的线性动力学也可以使用子空间投影法来考虑一些中度非线性的问题，此时通过时间积分求解一个降阶的运动方程。它假设非线性问题中M，C，Ks，K的变化不会影响模态，使用同样的方法带入运动方程（非常系数），然后取m阶模态分析，即n阶方阵降阶为m阶。注意此时方程不是解耦的，因为矩阵不是常量。需要用隐式分析的直接积分法求解m个广义坐标的结构，增量步间，M，C，Ks，K是可以变化的。

14. 频率提取时有两种设定方式，只能选一个：
    1. 指定要提取前多少阶模态
    2. 提取指定频率范围内的所有模态。对于未约束模型，还需要给定一个较小的频率下限，来排除频率为0的刚体模态。

15. 单自由度运动方程存在2个频率，一般按照从小到大标记为$1\to n$：
    1. 圆频率$\omega$，单位是$rad/s$。$\omega=\sqrt{\frac{k}{m}}$，它对应的周期为$T=2\pi/\omega$，是往复运动一周所花的时间。

    2. 自然频率$f$，单位是$1/s$。它表示结构单位时间内能够振动的次数，$f=1/T=\omega/2\pi$。

16. 对于多自由度系统，任意的初始扰动下，每个节点的运动形式虽然是周期的，但一般不是简谐的，而是多个简谐组合的。存在多个特殊模式的初始扰动，使得每个点的运动都变成了简谐运动。此时各点的运动是成比例的，始终和初始扰动成倍相似。

17. 由于结构是线性的，因此每个特殊模式的整数倍的初始扰动，也都会得到简谐运动，因此模态一般会做归一化。

18. 频率提取就是求解广义特征值问题，$Ku=\lambda Mu=\omega^2Mu$。由于M和K都是对称正定矩阵，因此特征值均为正实数。由于Standard的频率提取不考虑阻尼，因此只会得到实特征值。之所以有平方，是因为在获得PDE的特征方程时，对位移求了两次导数，会出现$\omega^2$。

19. 大多数情况下，K和M都是对称半正定的，因此$\phi$和$\omega$​都是实数。非对称效应和阻尼效应可能导致复频率问题。

20. 如果模态分析时，结构没有被完全约束住刚体运动，则会得到值为0的特征值，这表示刚体运动。如果结构被过度约束了，会造成预载Preload效应，影响模态分析的结果。

21. 求得特征值后代回方程，可得对应的特征向量，一般都会归一化。他表示各点位移的相对比例，将这个比例的初始扰动释放后，各点唯一的比例始终不变。模态向量的大小没有物理意义，分量之间的相对大小有物理意义。

22. abaqus提供了两种归一化方法，在Edit Step→Other→Normalization中选择：

    1. 每个分量都除以分量的最大值，例如$(1,2,3)\to(1/3,2/3,1)$。

    2. 质量归一化，对特征向量缩放，使得$\phi_i^TM\phi_i=1$。例如计算得到结果为4，则每个分量要除以2。2019版本后，默认都是质量归一化。

23. 如果将模态向量对质量矩阵归一化，则广义刚度为$\phi_i^TK\phi_i=\omega_i^2$，此时对应于该频率的单自由度自由振动运动方程为$\ddot{q}+\omega_i^2q=0$。

24. 对于任意两个不同特征值对应的特征向量$\phi_\alpha,\phi_\beta$，它们对于质量和刚度矩阵分别正交$\phi_\alpha^T M\phi_\beta=0$,，$\phi_\alpha^T K\phi_\beta=0$。注意这里是广义特征值问题，而非普通的特征值问题，因此特征向量构成的矩阵$\Phi$并非是正交矩阵，不过该矩阵关于M和K正交。

25. 可以将这n个模态向量当作1个n维空间的基底，结构的任意位移向量都可以在该基底下展开，$u=\phi_rq_r$，其中$q_r$就是模态坐标或广义坐标。

26. 特征值求解有三种方法：
    1. 直接法，基于矩阵分解和变换技巧，包括Housholder旋转，QR分解和Givens旋转方法。对于小结构，且要求解所有模态来说，非常适合。所有模态都会同时求得。
    2. 迭代法，包括子空间迭代和Lanczos法，适用于只需要少量模态的大型系统（1M个自由度以下），取决于总自由度和要提取的模态数量。推荐勾选使用SIM架构。
    3. 折减法，模型先被投影到一个折减的多级子结构模态空间中，然后求解子结构的模态，最后将该模态扩展到完整结构中。2015版本后加入的，适用于非常大型（1M个自由度以上）模型的大量（500个以上）特征值提取，推荐勾选使用SIM架构。对Standard 2019及以后版本而言，AMS是默认的分析工具。对于1M自由度以下的问题，如果待求的模态数量较多时，也推荐使用。

27. AMS的缺点：
    1. 不能使用压电单元
    2. 无法计算复合模态阻尼比
    3. 无法计算有效模态质量
    4. 当基底运动分析中需要时才会计算参与系数，不过不会输出到文件中
    5. 不能在.fil文件中请求输出
    6. 不支持设计敏感度分析，循环对称边界条件，随机振动分析。

28. Lanczos方法适用性最广，一般比AMS慢一个数量级。

29. 对于线性动力学来说，有2种可用的软件架构：
    1. 传统架构，适用于所有问题。

    2. SIM架构，高性能，更适用于只需要少量模态的大型结构。需要在频率提取时就开启SIM，后续才会使用该架构，也只能使用基于SIM的线性动力学分析步。

30. 频率提取分析步中每个frame就是一个模态。后处理每帧显示的云图内容为位移，最大值为1，它是归一化的。可以在Field Output中指定输出特定阶的模态。推荐输出模态应变能密度ELEN，它和位移一样，都是相对值，不过可以用来确定该阶模态下结构的变形严重的关键区域。刚体运动模态（频率为0）的应变能密度应该都是0。

31. 频率提取的结果可以在.dat文件中查看，每一阶模态会显示Eigenvalue（特征值，$\omega^2$）和Freq（频率$f=\omega/2\pi$，单位是Hz或cycle/time）。二者的关系是$Value=(2\pi\cdot Freq)^2$​​。这里还有广义质量和复合模态阻尼。如果求解时设置了模态向量使用质量进行正规化，则此时每阶模态的广义质量都为1。

    ```shell
                       E I G E N V A L U E    O U T P U T
    
     MODE NO   EIGENVALUE         FREQUENCY    GENERALIZED MASS  COMPOSITE MODAL DAMPING
                           (RAD/TIME) (CYCLES/TIME)
    
           1       1773.4     42.112     6.7023       151.92           0.0000    
           2       7016.8     83.766     13.332       30.206           0.0000    
           3       7644.1     87.431     13.915       90.400           0.0000    
           4       22999.     151.65     24.136       250.64           0.0000    
           ...
    ```

32. 除了频率外，还会输出每阶模态在6个方向上的阵型参与系数（Participation factor），它展示了该模态在哪个全局方向上更容易被激发出来，或者说该阶模态的主方向是什么。$\Gamma_{ij}=\frac{1}{m_i}\phi_i^TMT_j$，$i$为模态编号，$j$为全局方向编号，取值为1-6。$T_j$表示沿全局方向$j$的所有自由度都取1，其余所有方向均为0。可以看成$\phi_i$和$T_j$这两个向量的广义内积。参与系数可以是负数，表示反方向。每一阶模态，都可以找到一个参与系数绝对值最大的方向，该方向就是该阶模态的主方向。

    ```shell
                    P A R T I C I P A T I O N   F A C T O R S
    
     MODE NO     X-COMPONENT     Y-COMPONENT    Z-COMPONENT    X-ROTATION
     Y-ROTATION     Z-ROTATION
    
           1     -6.11696E-04   -6.14521E-03     1.4284        0.71335        -6.0252       -3.37773E-02
           2      0.18470       -0.25677        8.31954E-04    1.68388E-03   -6.05012E-03    -1.6826    
           3     -0.17440         1.5515        4.88123E-03   -8.04039E-03    3.24495E-02     9.2746    
           4     -8.68256E-05   -9.61259E-03    8.23615E-02    0.21604         1.2334       -2.97905E-02
    ...
    ```

33. 模态参与系数的作用：

    1. 可以帮助用户选择，对于特定荷载，应该选择哪些模态来叠加，即主方向和荷载方向重合的模态。
    2. 用来基底运动中的计算模态惯性力。
    3. 在反应谱分析中，用来预估结构在该模态下的最大响应。
    4. 计算该阶模态在每个方向的有效质量。$m_{ij}^{eff}=m_i(\Gamma_{ij})^2$。

34. 还会输出有效质量（effective mass，每阶模态在各个方向上的质量贡献）和总质量（可以在CAE中使用Query→Mass来查询）。观察总质量随模态阶数的变化，可以判定提取的模态阶数是否足够。为了确保使用了足够阶的模态，每个方向的总有效质量应该占模型质量的很大比例（80%以上），如果荷载局限在某个方向，则可以只要求该方向满足80%的要求。然而模型的一些质量与受约束的节点有关。受约束质量约为附着到受约束节点的所有单元质量（使用Query→Mass properties→Select mesh entities选择包含被约束自由度的节点的单元即可）的四分之一。对于平动，模型总质量就是密度*体积，对于转动，模型总质量就是绕过原点（而非重心）的该轴的转动惯量，而Query中只能查询到绕过重心轴的转动惯量，绕过原点轴的转动惯量在.dat文件中有，后者一般比前者大，除非重心就在原点。

    ```shell
                          E F F E C T I V E   M A S S
     MODE NO    X-COMPONENT    Y-COMPONENT    Z-COMPONENT    X-ROTATION
     Y-ROTATION     Z-ROTATION 
    
           1      5.68458E-05    5.73721E-03     309.98         77.309         5515.3        0.17333    
           2       1.0304         1.9915        2.09072E-05    8.56481E-05    1.10567E-03     85.521    
           3       2.7495         217.62        2.15392E-03    5.84420E-03    9.51888E-02     7776.2    
           4      1.88952E-06    2.31599E-02     1.7002         11.699         381.31        0.22244    
    ...
    TOTAL         22.198         378.26         373.69         269.78         8348.4         8518.0
    ```

35. 使用模态叠加法时，不一定要把提取到的模态都使用上，例如荷载主要是y方向，则可以只选择y方向有效质量较大的，凑够80%即可，模态阶数也可以跳着选择。

36. .dat文件中的质量统计信息：

    ```shell
    TOTAL MASS OF MODEL
       414.3422    
    LOCATION OF THE CENTER OF MASS OF THE MODEL
       3.899660          0.4847269         -1.4374247E-03
    MOMENTS OF INERTIA ABOUT THE ORIGIN
           I(XX)               I(YY)               I(ZZ)
       313.1880           8528.429           8539.664    
    PRODUCTS OF INERTIA ABOUT THE ORIGIN
           I(XY)               I(XZ)               I(YZ)
      -1041.909           1.536027         -0.3201855    
    MOMENTS OF INERTIA ABOUT THE CENTER OF MASS
           I(XX)               I(YY)               I(ZZ)
       215.8332           2227.384           2141.265    
    PRODUCTS OF INERTIA ABOUT THE CENTER OF MASS
           I(XY)               I(XZ)               I(YZ)
      -258.6903         -0.7865542         -0.6088819    
    ```

37. 频率提取是扰动分析，它可以基于任意状态来进行，包括预加载的状态。对很多结构来说，荷载会改变刚度，这样也会改变结构的模态，例如一条吉他弦受拉，它的侧向刚度会增加。

38. 扰动分析的边界条件会保持基态的边界条件。

39. 如果特征值都不相同，则每个特征值对应一个唯一的特征向量。如果特征方程存在重根，则重复特征值对应的特征向量不唯一。如果没有约束刚体运动，或结构是平面/轴对称的，都会产生重根情况。这里的对称要求是关于全局坐标系对称才可以。重根会导致在不同操作系统，软件版本上计算的特征向量可能不同。

40. 刚体模态可能是6种基本运动方式的组合，因为特征向量的线性组合还是特征向量。

41. 在进行模态叠加时，需要完整考虑重根（零或非零的都要考虑进去）的情况。

42. 残余模态是伪特征值和特征向量（即不是通过求解广义特征值问题得到的），可以帮助减小由于选取有限阶模态进行模态叠加分析的截断误差，可以在不增加太多消耗的情况下提高精度。

43. 残余模态来源于静态线性扰动分析步的计算。在结构的某个自由度上施加一个单位力，求解方程$KR=P$，可得到结构的位移向量R，将这个作为伪特征向量。R对应的伪特征值是通过瑞利商计算的$\frac{R^TKR}{R^TMR}$，开根号后就是伪频率。之所以这么做，是因为现有的截断模态无法组合出想要的变形模式，就只好自己施加荷载，利用该变形模式了。

44. 如果使用Lanczos进行频率提取，则需要在该分析步之前，添加多个静态线性摄动分析步，每个分析步中只包含1个单位力，该单位力和后续施加某个荷载作用点和方向相同。对于上述每个摄动分析步，都能得到一个残余模态。每个摄动分析的边界条件和频率提取分析步的边界条件都必须相同，且都必须恒为0。

45. 如果使用AMS进行频率提取，则不需要这样的额外分析步，默认会在后续所有基于模态的分析步中，所有施加集中荷载的自由度上计算残余模态。

46. 在Edit Step的最下面可以勾选Include Residual Mode来考虑残余模态。

47. 如果进行频率提取时考虑了残余模态，则后续的模态叠加法中会使用残余模态。

48. 残余模态不支持子空间求解器，不支持循环对称边界条件。

49. 残余模态也会在.dat文件中，和正常模态一同排序，一同输出，在.dat文件的该表格后方会说明哪几个模态是残余模态。Lanczos还会为它输出参与系数，广义质量和有效质量等。

50. Abaqus中考虑阻尼有以下几种方式：

    1. 材料阻尼，在材料属性中设置，包括瑞利（粘滞）阻尼，结构阻尼，粘弹性材料，声波介质。

    2. 阻尼单元，dashpot，spring，connector等。

    3. 全局阻尼，允许为整个结构设置粘滞或结构阻尼。

    4. 模态阻尼，模态叠加法中用到，每个模态可以单独设置。

51. 单自由度有阻尼运动方程，经过简化为$\ddot{u}+2\xi\omega\dot{u}+\omega^2u=0$。定义临界阻尼系数$c_{cr}=2m\omega=2\sqrt{km}=2k/\omega$，和结构的k，m有关，但和c无关。（临界）阻尼比$\xi=c/c_{cr}$。实际上不存在临界阻尼比这一说法， 或者说都应该是1，才成为临界。实际阻尼和临界阻尼的比值称为阻尼比，不建议称为临界阻尼比。

52. 特征方程为$\lambda^2+2\xi\omega\lambda+\omega^2=0$，使用一元二次方程的求根公式，$\lambda_{1,2}=-\xi\omega\pm\omega\sqrt{\xi^2-1}$。

    1. 如果$0\le\xi<1$，则有两个不同的实根，通解为指数和三角函数乘积的形式，周期（$\omega_d=\omega_n\sqrt{1-\xi^2}$，频率降低，周期变长，一般认为二者相等）性衰减。即欠阻尼状态。

    2. 如果$\xi=1$，则有两个相同的实根，通解为指数衰减，无周期性往复。即临界阻尼状态。

    3. 如果$\xi>1$，则有两个不同的虚根，通解同上，不过$\xi$越大，衰减到0所需时间就越长。即过阻尼状态。

53. ![image-20250227102337549](Abaqus.assets/image-20250227102337549.png)

54. 除了和速度相关的粘滞阻尼外，还有位移相关的结构阻尼（虚刚度，Imaginary），在复频率分析中会用到。一般来说，如果阻尼器和摩擦相关，更多表现为位移阻尼，如果阻尼器和材料非线性相关，更多表现为速度阻尼。

55. 材料阻尼和阻尼单元的适用范围：

    1. 传统架构下，直接或基于子空间的稳态动力学

    2. SIM架构下，基于模态的稳态或瞬态动力学

56. 瑞利阻尼是一种设置材料粘滞阻尼的方式，它假设系统的阻尼矩阵$C_m=\alpha_RM+\beta_RK$，$\alpha_R,\beta_R$分别为质量/刚度阻尼系数，它们将作为材料的属性设置（Edit Material→Damping），不随时间，频率或应变率变化。在Edit Material中设置，例如$\alpha_R=10,\beta_R=3e-4$。注意虽然$\beta_R$是刚度阻尼系数，但是瑞利阻尼并不包含结构阻尼，因为C都是要乘以速度的，他们是并列的。

57. 对于一个多自由度系统，如果只使用瑞利阻尼，将C的表达式带入运动方程，可得$\xi=\frac{\alpha_R}{2\omega}+\frac{\beta_R\omega}{2}$。这里假设所有材料的瑞利阻尼系数都相同，质量单元和转动惯量单元都是用同样的$\alpha_R$系数。

58. 如果知道2个模态的$\xi_i$，则可以根据上述公式求得$\alpha_R,\beta_R$。

59. 从上述公式可以看出：

    1. 如果增加$\omega$，则第一项会变小。粘性阻尼相当于将结构放置在粘性流体中，每个有质量的节点都有一个和地面连接的阻尼器。质量阻尼对于Explicit分析中的质量和转动惯量单元不适用。

    2. 如果增加$\omega$，则第二项会变大。代表随着结构构件相对变形而产生应变的能量损失有关。刚度阻尼不适用于弹簧单元。

60. 材料阻尼的另一种形式是结构阻尼（Edit Material→Damping→Structural），一般设置为$s=2\xi$，这是结构阻尼和瑞利阻尼造成的效果相似，用来表示结构的内部摩擦效应。适用于频域动力学分析。

61. 粘弹性材料分为两种：

    1. 用于瞬态分析的时域黏弹性，用来处理应变率效应，使用Prony series公式，可以配合线弹性，超弹性和弹性体泡沫一起使用。
    2. 用于稳态动力学分析的频域黏弹性，使用频率相关的储存和损失模量（会同时影响刚度和粘性行为），假设体积行为和偏（剪切）行为解耦，可以配合各向同性线弹性或超弹性材料。

62. 弹簧的属性可以定义为频率相关的。如果使用复刚度，则可以模拟结构阻尼器。在Interaction模块，菜单栏→Special中设置。

63. 弹簧和阻尼器各有3种：

    1. SPRING1/DAMPER1，在节点和地面之间建立关系，在全局坐标系的固定方向作用。
    2. SPRING2/DAMPER2，在两个节点之间建立关系，在全局坐标系的固定方向作用。可以在每个节点指定不同的方向。
    3. SPRINGA/DAMPERA，在两个节点之间建立关系，作用线是两点连线（局部坐标系），作用线可以在大位移分析中转动。

64. 在CAE中可以定义Connector的粘滞阻尼，而结构阻尼需要在inp文件中修改。

65. 全局阻尼可以包含粘滞阻尼和结构阻尼，在初步分析时可以使用，比较粗糙。通过`*global damping`关键字设置。全局阻尼相当于直接在最终的微分方程组中添加矩阵C，此时的C是对角矩阵。支持场景：

    1. 传统架构下，所有的线性动力学分析都可以使用，基于模态或直接积分的。

    2. SIM架构下，支持稳态动力学，瞬态动力学，反应谱分析，随机响应分析。

66. 模态阻尼允许为每阶模态直接设置阻尼比，瑞利阻尼，结构阻尼或复合模态阻尼，在对应分析步的Edit Step→Damping中可以选择。支持场景：

    1. 传统架构下，所有的线性动力学分析都可以使用，除了基于子空间的稳态动力学
    2. SIM架构下，支持稳态动力学，瞬态动力学，反应谱分析，随机响应分析。

67. 当结构包含多种材料时，复合模态阻尼是有用的。需要在Edit Material→Damping→Composite中设置此材料的阻尼比$\xi_m$和在Edit Step→Damping→Composite中设置起止模态编号。材料的阻尼比会根据材料的质量矩阵加权平均计算每个模态下该材料的阻尼比$\xi_\alpha=\frac{\xi_m}{M_\alpha}\phi_\alpha^TM_m\phi_\alpha$。$\alpha$表示模态阶数，$m$表示材料编号。

68. 可以使用`*damping control`来控制粘性和结构阻尼中哪种阻尼类型生效。四种可能：element，factor，combined，none。例如：

    ```shell
    *damping control, viscous=element, structural=factor #粘滞阻尼考虑单元和材料，结构阻尼考虑全局阻尼。
    *global damping, structural=<>
    ```

69. 测量阻尼比的4种方法：

    1. 对数衰减法，自由振动试验中的幅值衰减$\delta=\ln\frac{u_i}{u_{i+1}}=\frac{2\pi\xi}{\sqrt{1-\xi^2}}\approx 2\pi\xi$。有时候相邻振幅的衰减比较小，可以考虑连续多个振幅来计算$\delta$的平均值$\delta=\frac{1}{j}\ln(\frac{u_i}{u_{i+j}})\approx 2\pi\xi$。

    2. 半功率法，测量强迫振动下频率和幅值的变化，在图中获取最高点对应的频率为$\omega_n$，和最高点的$1/\sqrt{2}$倍水平线（半功率点，因为功率和幅值的平方成正比）和曲线相交的两个点$\omega_a,\omega_b$。则$\xi=\frac{\omega_b-\omega_a}{2\omega_n}$。

    3. 共振实验，测量共振时幅值$A$和静态加载时幅值的比值$u_{st}$，$R_d=\frac{A}{u_{st}}=\frac{1}{2\xi\sqrt{1-\xi^2}}$。因此$\xi\approx \frac{u_{st}}{2A}$。

    4. 循环加载，不同于半功率和共振实验（一般是使用振动台加载），使用作动器在结构的一点加载。可以得到滞回曲线，$\xi=\frac{1}{2\pi}\frac{E_D}{E_S}$，其中$E_D$为某个滞回曲线围成的面积，$E_S$为该滞回曲线右端点和原点连线和x轴构成的三角形面积。

70. 以上方法只对小型简单结构有效，对于大型复杂结构，获得阻尼比是不现实的，可以使用统计得到数值，一般在0.01到0.05之间。

71. 注意，材料和单元阻尼会对阻尼矩阵的非对角线元素产生贡献，而全局和模态阻尼只会对对角线元素产生贡献。

72. ![image-20250303111017815](Abaqus.assets/image-20250303111017815.png)

73. 传统架构支持Lanczos和基于子空间的频率提取，SIM架构支持Lanczos和AMS频率提取。下表的第一列为直接积分法。

74. ![image-20250303111055517](Abaqus.assets/image-20250303111055517.png)

75. ![image-20250303111321274](Abaqus.assets/image-20250303111321274.png)

76. 可以看到，全局阻尼的适应性最广。

77. 基底运动，例如地震对建筑的影响，或路面粗糙造成运动车辆的振动，此时外力不是激励的主要来源，强制运动才是。基底运动一般不是简谐的，同时不同的支撑位置的基底运动也不同。

78. 基底运动问题可以通过直接积分求解（基底运动可以通过幅值曲线或者DISP用户子程序施加），也可以通过模态叠加法求解。后者要求先进行频率提取，基底就是指哪些在频率提取时被约束的自由度。如果所有基底的运动不能用一个运动来表示，则需要多重基底multiple base，例如超长的桥梁，不同基底的运动不同；或者车辆的不同轮子附着在不同的路面条件上。

79. 基底运动激励无法使用子空间投影法来进行瞬态分析。

80. 多重基底运动中，将基底分为了两类：

    1. 主要基底Primary，模型中所有被约束的自由度都是主要基底，此时`*BOUNDARY`不需要使用BASE NAME参数。

    2. 次要基底Secondary，

81. 只有一个自由度方向可以定义为Primary的，其余都是Secondary。

82. 

83. 

84. 

85. 

86. 

87. 

88. 

89. 

90. 

91. 

# 多体动力学与Connector

1. abaqus还可以进行多体动力学的分析，主要应用有两个：

   1. 对机构进行分析，观察是否会产生零件干涉。这个使用静态分析就可以。

   2. 对机构进行动态受力分析，需要给定质量或转动惯量，必须使用动态分析步。
2. 模型由刚体和可变形体连接而成，它们之间使用连接器connector连接起来。有时为了让结果更好看，还会添加display body，它只是显示，不会参与计算。
3. connector可以用来模拟假人各关节的行为，车辆悬挂的行为。只需要在assembly中创建即可，不需要建立part。
4. connector单元可以通过力（液压部件）或位移（齿轮传动）来驱动。加速度计（ACCELEROMETER），活塞油缸（AXIAL），ALIGN（约束转动），球头（JOIN），两个球头（LINK），滑轨（SLOT），铰链（HINGE，门框上用的，相当于JOIN+REVOLUTE），万向节（U-JOINT相当于JOIN+UNIVERSIAL），刚臂（BEAM，相当于JOIN+ALIGN）。
5. <img src="Abaqus.assets/image-20241216164355509.png" alt="image-20241216164355509" style="zoom: 80%;" />
6. 上图都是基本约束，abaqus还为用户构建了组合约束，见下图，这可以在connection category中选择，还可以使用MPC。
7. <img src="Abaqus.assets/image-20241216164610212.png" alt="image-20241216164610212" style="zoom:80%;" />
8. connector可以施加在刚体上的点，而不用施加在刚体的参考点。
9. 一般来说，都要开启几何非线性功能，因为这里涉及到大位移，大转动。如果没有开启，则会倍线性化，例如下图。
10. <img src="Abaqus.assets/image-20241216165155778.png" alt="image-20241216165155778" style="zoom:50%;" />
11. 平面四连杆机构，每个杆都是刚体，通过铰链连接。每个杆有2个平动，1个转动，4个杆一共3x4=12个自由度。beam4固定在地面，完全约束，相当于约束了3个自由度，4个铰链，每个铰链约束2个自由度，因此一共约束3+4x2=11个自由度，还剩一个自由度，正好。
12. ![image-20241216165927972](Abaqus.assets/image-20241216165927972.png)
13. 如果是三维情况，则会导致过约束。一共有4x6=24个自由度，一个铰链约束5个自由度（三个平动，2个转动）。24-6-4x5=-2。abaqus会自动尝试移除过约束，例如将右下角的铰链换成新的约束，只约束两个平动，这样24-6-3x5-2=1。
14. ![image-20241216193829065](Abaqus.assets/image-20241216193829065.png)
15. 注意球铰和铰链不同，球铰只要求平动自由度相同，铰链还约束额外的2个转动自由度。
16. 所有的connector都在interaction→connector builder中构建。
17. builder可以为选定的两个point创建参考点。如果已经手动创建，则不需要勾选。
18. 连接器单元包括类型（例如hinge或link等）和属性（规定活动自由度的范围，也可以设置刚度，阻尼，破坏条件）。一般都需要定义局部坐标系，两端点可以使用不同的坐标系。
19. connector都是约束和释放特定的自由度，这个自由度具体对应哪个方向的运动，需要在connector两端指定局部坐标系来确定。
20. coincident builder类似于connector builder，可以处理共用节点的connector。
21. builder会自动创建wire的set，可以用于output request。
22. 连接器slip ring可以用于模拟滑轮组。需要在边界条件中施加connector material flow，来指定是同一根绳子的运动。一般需要在滑动前添加一个重力作用分析步，此步骤中，固定住绳子的一端，施加重力，这一步绳子中会产生张力。下一步中，释放绳子约束，施加拉力。
23. 后处理中默认是不显示connector的，需要在ODB display options→Entity Display中勾选。
24. 多体动力学的分析一般没有收敛性问题，可以使用fixed时间步长。
25. 如果不关心螺栓本身受力，可以使用connector或beam单元来替代，它比螺栓建模简单，分析快速，收敛程度好。实体螺栓需要先切割一个横截面，作为interior surface来施加预紧力。
26. 注意，螺栓的材料强度，一般远高于普通的刚才，例如8.8级表示极限强度800MPa，屈服强度800*0.8MPa=640MPa。
27. 三种情况的优缺点如下：
    1. 实体模型，优点：最真实，可以使用abaqus的bolt load施加预紧力。缺点：当模型中螺栓数量多时，计算量大。接触行为收敛慢。
    2. 梁模型，优点：建模简单，计算高效，可以输出轴力，用于校验螺栓强度。缺点：无法设置预紧力，除非配合其他单元（例如弹簧），但是麻烦。
    3. 连接器模型，优点：简单，可以输出轴向力，可以施加预紧力。缺点：需要对CAE有足够的认知，才可以选择合适的单元。
28. 不论是哪种模型，都应给定预紧力，这样会和实际相符。且都应该将施加预紧力应该作为initial step后的第一个分析步，然后才可以进行后续的其他分析（有一个特例是，通过参考长度施加的预紧力会在第一个分析步中以step的幅值直接施加，一步到位，因为在builder中并没有指定分析步和幅值。这在Standard中可能会造成收敛问题）。预紧力可以通过bolt load（实体模型）或connector load（连接器模型）施加横截面的轴力或轴向变形，viewport中会显示是拉紧还是放松，注意区分。
29. 新版的bolt load可以在设置时勾选在part级别上施加，这样只需要选择一个螺栓instance的中心面，然后施加载荷，预紧力会在所有同类的instance上都施加。bolt load是可以设置幅值的。
30. bolt load的荷载形式只在standard中存在，Explicit中可以使用如下方法来变相完成：

    1. 进行热力耦合分析，对螺栓施加温度梯度来变相施加预紧力。
    2. 将使用Standard的预紧力步骤的结果作为初始几何缺陷导入到Explicit中，不过这只会导入结点位移，并不会导入应力，但是这并不代表结构在Explicit的开始时刻没有应力，因为不平衡的结点位移会使得结构产生内力，类似于残余应力，不过实际的应力水平要比Standard的最后要小。对于应力不可忽略的情况，例如预应力筋的张拉，不建议使用这个。

       ```shell
       *IMPERFECTION, FILE=job-1, STEP=1
       1, 1
       #这里使用step编号，而非名称。这里数据行的第一个数必须为1，第二个数为缩放倍率。
       #INC参数可以指定要读取的增量编号，如果省略，Abaqus将读取可用的最后一个增量。
       ```
    3. 将使用Standard的预紧力步骤的结果，通过重启动方式，导入到Explicit中继续分析，这种方法会保持应力和位移。

31. 如果在施加预紧力时，bolt load是使用施加力的方式，则需要在该分析步结束后，将其修改为Fix at current length，因为螺栓并非是只能承受特定大小的力，它是一个弹簧，其中的力可以随外荷载变化。
32. 使用connector时，还可以通过设置参考长度来设置预紧力，如果初始长度和参考长度不同，则表示目前connector中存在拉力或压力。当前长度<参考长度时，内力为拉力，对应于预紧力。
33. 一种可行的方法是通过field variable来逐渐提升connector的刚度。并通过predefine variable来控制connector的variable值及其幅值完成。
34. connector模拟螺栓需要先将上下两个螺孔的圆柱面分别耦合到2个参考点上，然后创建connector section，然后使用builder指定即可。也可以用刚体对螺帽和螺母进行建模，螺杆使用connector，螺帽和螺母都和模型有接触行为。
35. 需要先将螺栓的顶底面中和螺帽螺母接触的区域分别和该平面内的ref point耦合。因为创建connector需要ref point来构建wire。
36. 一般使用connector中的translator（只有U1释放，其余约束）或cylindrical（只有U1，UR1释放，其余约束）来模拟螺栓。cylindrical比translator多了个扭转自由度，这个可有可无，因此推荐使用translator。需要添加弹性行为，勾选F1，输入轴向刚度EA/L，也就是力/位移。添加参考长度参数，例如初始的实际长度为28.75mm，参考长度（自然长度）为28.60mm，轴向刚度为237996N/mm，此时connector被拉长了，因此预紧力为（28.75-28.60）x237996=35699.4N。
37. 可以设置输出截面力，来获得等效的螺栓横截面力，来判定螺栓是否会破坏。
38. 点焊和铆钉连接可以使用fastener来模拟，每个fastener都会有一个影响范围，该区域内的节点都会和一个attach point耦合，然后两个相对的attach point通过一个connector连接，可以设置弹性，塑性行为。这个是Mesh-independent的，重新划分网格也不会改变结果。

# SPH

1. Explicit支持SPH分析，只能用于三维模型，可以使用Explicit可以使用的任何材料。可以指定初始条件和边界条件。集中力可以正常施加，但是分布力只能施加重力，因为没有surface。可以考虑接触。

2. 可以在CAE中观察到粒子。可以将常规的拉格朗日网格转化成SPH粒子。粒子都是单节点的单元PC3D。

3. 每个粒子都会对周围的粒子有作用，它也受到周围粒子的作用，影响范围称为光滑长度smooth length。分析开始时确定，使得范围内大概包含30-50个粒子即可，最多140个会终止分析。

4. 可以根据节点之间距离变化等计算应变/应力，得到节点合力，给出节点接下来的运动。

5. 节点之间的连接性不是固定的，因此可以避免严重的畸变（类似于分析中重新划分网格），可以模拟较大的应变梯度。

6. SPH的功能和CEL类似，都可以进行纯欧拉或混合分析。

7. SPH对于射流问题处理更方便，因为不同对外界划分网格。

8. SPH对于高速冲击问题，可能出现粒子飞出的现象，这在CEL中很难出现。

9. SPH的计算效率比拉格朗日网格低，因此可以只将冲击问题的碰撞接触小范围部分建模为SPH，其余部分使用实体拉格朗日单元。注意此时子弹必须建模为拉格朗日单元，因为两个SPH截面不能互相接触，也就是没有node to node接触。

10. 也可以让分析的前半段使用纯拉格朗日网格，后半段将一部分转化为SPH。这个在单元类型的赋予中设置，转换条件可以是应力/应变或时间，可以设置每个单元转换成每个方向上多少个粒子（类似于积分点的个数）。

11. SPH对于受拉问题处理不太好。


# CFD

1. 边界元、有限元或有限差分法最初是最常见的CFD模拟方法之一，但有限体积法在过去20年中得到了突出发展，现在已成为标准。最近，硬件性能的提高意味着格子玻尔兹曼方法LBM也变得可行。
2. 流体运动的控制方程可以有Navier-Stokes方程，LBM方程。Navier-Stokes方法将流体视为连续体，而Lattice-Boltzmann方法将其视为离散粒子。将LBM使用Chapman-Enskog扩展就可以得到N-S方程。在求解上，有限体积法类似于结构求解的隐式方法，LBM类似于结构求解的显式方法。LBM特别适合并行计算。
3. LBM方法：基于气体动力学理论的离散形式，通过离散的空间和时间跟踪流体粒子的微观运动，以模拟气体和液体的流动。流体空间被自动离散化为立方体单元，边界被离散化为曲面，从而消除了传统体积和边界层网格生成的需要，特别适合复杂边界。
4. 流动模拟可以分为3个尺度：
   1. 微观（分子动力学理论，由Hamilton方程控制，需要为每个分子建模，待求量为分子的位置，速度，计算量太大，标况下1L气体包含1mol个分子，也就是6.02x10^23个，不现实）

   2. 介观，LBM使用的方法，既有微观粒子的特性，又有宏观的特性。将一群分子作为研究的基本单位。待求变量是分布函数。

   3. 宏观（由N-S方程控制，一般使用有限体积法，将空间离散为有限体积的cell，待求变量是速度，压力等物理量，它是在一个cell内平均的，它包含大量的粒子，控制方程是在每个cell上被满足的）。
5. LBM中，粒子群的性质由LBE（LB方程）的分布函数表示。相邻时刻的增量推进通过streaming和collision这两个过程完成。LBM认为每个格点（grid point）上有一个粒子群，每个粒子群可以沿空间的8个方向，移动到周围的格点上。
6. 没有适用于所有应用的最佳CFD模拟方法，工程师必须为每个工业工作流程选择合适的工具：
   1. CEL和SPH方法适用于高耦合流固耦合问题，例如不可压缩的液压机械。这些方法在Explicit中实现。

   2. FVM求解器更适合稳定或适度瞬态的流动，例如管道流、热交换器、泵和暖通空调应用中的流动。该方法用于Fluid Dynamics Engineer（FMK）。

   3. 作为一种瞬态技术，LBM更适用于高度瞬态的流动，如空气动力学和气动声学。可以处理复杂几何模型。也可以有效地用于处理多相流动，模型中甚至可以包括任意运动部件。SIMULIA提供两种LBM产品。PowerFLOW是航空航天和汽车行业常见的空气动力学、声学和污染场景的理想选择。XFlow通常用于复杂的运动、多相问题，如润滑、晃动和一些生命科学应用。
7. GPU可用于所有CFD代码，对于LBM模拟尤其有效。
8. 气动声学是研究空气运动和湍流产生和传播声音的学科。气动声学噪声通常产生于运动物体、发动机和风扇的废气或空气与表面的相互作用。它不同于振动声学，振动声学是研究结构内振动和共振产生的噪声。
9. 阻力、升力、下压力和侧风等力会影响轮胎在道路上的抓地力、车辆对转向输入的响应以及车辆对道路或风况变化的稳定性。
10. 水、雪、冰、泥土、岩石和其他碎屑颗粒可能会被轮胎或风从路上扬起，或者由于天气状况而存在。这些颗粒的小尺寸决定了它们受到车辆空气动力学的强烈影响，仔细的设计可以减少它们造成的污染和损坏。
11. 空气动力学设计通过减少风阻和优化通过发动机的气流对燃油效率有着至关重要的影响。
12. 流固耦合分为全耦合（full，也就是双向耦合，结构求解器和流体求解器互相通信）和顺序耦合（sequence，也就是单向耦合，先通过流体求解器计算出稳态或瞬态的结果，将结构面上的压力/温度导出，然后在结构求解器中导入计算即可）。
13. abaqus通过co-simulation功能完成联合计算，可以在abaqus程序或abaqus和第三方程序之间联合。这种耦合方法用于流体结构、共轭传热、电磁结构、电磁热和结构逻辑模拟，以及将Standard和Explicit耦合，用于隐式动态和显式动态之间的相互作用或Abaqus和Simpack之间的耦合。


# 子模型

1. submodel，主要是解决早期电脑的计算能力和存储空间不足才产生的。无法直接对复杂模型进行全局细分网格的分析。Standard和Explicit都支持子模芯特性。
2. 先对母模型划分一个粗糙的网格，进行分析，观察结果，找出需要作为子模型分析的区域。然后将它的解映射到精细化的子模型中，继续求解。子模型需要是对母模型做切分得到的，可以现在母模型上切分好，然后copy model，在子模型的model中删除不需要的部分即可（在part→remove face，选择cell的所有face），或者可以只对子模型的部分划分网格。
3. 在模型上右键Edit model attributes→submodel，指定要读取的母模型odb文件的job名称。
4. 映射分为两种：
   1. 基于node（使用节点的位移），在边界条件→other→submodel中，选择和母模型相连接的surface，输入要耦合的自由度，一般是所有有效的自由度（例如1，2，3），还要输入从母模型的哪个分析步导入。

   2. 基于surface的（使用积分点的应力），在荷载→other→submodel中，选择和母模型相连接的surface，这里不能选择要耦合的力分量，不过同样要输入从母模型的哪个分析步导入。
5. 结果必须以全局直角坐标形式写入才可以传递给子模型。
6. 为了保证不产生数值误差累积，母模型需要输出双精度的节点值。Edit job→Precision→Nodal output precision→full。
7. 对子模型施加的荷载，边界条件和初始条件，需要和母模型一致，否则没有意义。对于只施加在子模型以外部分的荷载于边界条件，应该予以删除。
8. 子模型和母模型可以使用overlay plot方法重叠显示，分别为两个模型创建2个viewport layer。

# 子结构

1. 子结构是消除了内部自由度的单元集合。子结构可以被视为一种特殊类型的单元（有时也被称为超单元）。子结构的保留节点形成了它的连通性。模型中可以出现多个子结构的实例，刚度计算和子结构简化只需进行一次，因此会提高效率。
2. 子结构可以隔离子结构外部的可能变化，以节省重新分析的时间。设计过程中，结构的大部分通常保持不变，不变部分可以用子结构表示，以节省形成结构该部分刚度所涉及的计算工作量。
3. 子结构提供了一种干净简单的共享结构信息的方法。在大型设计项目中，大量工程师必须经常使用相同的结构进行分析。
4. 许多实际结构非常庞大且复杂，以至于完整结构的有限元模型对可用的计算资源提出了过高的要求。如此大的线性问题可以通过建立模型、逐个子结构、逐级堆叠这些结构直到整个结构完成，然后根据需要局部恢复位移和应力来解决。

# 混凝土CDP材料模型

1. 具体细节见`https://www.youtube.com/playlist?list=PLz_XdUL-6Y_k-LgmCKo5ejqRAGpfXPk23`。
2. Abaqus提供了三种不同的本构模型，用于分析低围压（小于单轴压缩载荷下极限压应力的四到五倍）下的混凝土：
   1. smeared crack concrete，Standard可用。适用于混凝土受到基本单调应变且材料点出现拉伸开裂或压缩破碎的应用。压缩中的塑性应变由“压缩”屈服面控制。开裂被认为是该行为最重要的方面，开裂和开裂后各向异性行为的表示在建模中占主导地位。

   2. brittle cracking model，Explicit可用。适用于混凝土的行为主要由拉伸开裂决定，压缩破坏并不重要的应用。考虑了裂纹引起的各向异性。压缩状态下，模型假设具有弹性行为。一个简单的脆性破坏标准可用于从网格中移除单元。

   3. concrete damaged plasticity，均可用。基于塑性的混凝土连续损伤模型，基于标量（也就是各向同性）损伤的假设，专为混凝土承受任意载荷条件（包括循环载荷）的应用而设计。考虑了拉伸和压缩时塑性应变引起的弹性刚度退化（就是损伤）。它还考虑了循环载荷下的刚度恢复（由拉伸进入压缩状态或相反时的特殊情况）效应。
3. 塑性理论模拟了材料在以延性方式经历不可恢复变形时的力学响应。这些理论在金属方面得到了最深入的发展，但它们也适用于土壤、混凝土、岩石、冰、可压碎的泡沫等。它们之间差别很大，例如较大的纯静水压力值会导致金属的非弹性变形很小，但较小的静水压力值可能会导致土壤样本中显著的、不可恢复的体积变化。
4. Abaqus中的大多数塑性模型都是基于增量理论，其中机械应变率被加法分解为弹性部分和塑性（非弹性）部分。增量塑性模型通常用以下公式表示：
   1. 屈服面，将屈服载荷的概念概括为一个测试函数，可用于确定材料在特定应力、温度等状态下是否纯弹性响应

   2. 流动规则，定义了当材料点不再纯粹弹性响应时发生的非弹性变形

   3. 硬化（屈服或流动）随着非弹性变形的演化规律。
5. Standard也有变形塑性模型，即应力由总机械应变定义，也就是Ramberg-Osgood模型，主要用于延性断裂力学应用，通常需要全塑性解决方案。
6. abaqus的中配合塑性材料使用的弹性行为一般都是线弹性。在Explicit中的Mises和Johnson-Cook塑性模型下，弹性行为也可以使用具有关联偏差行为的状态方程来定义。
7. 在有限应变下进行弹塑性分析时，Abaqus假设塑性应变主导变形，弹性应变较小。Abaqus对使用的弹性模型施加了这一限制。这是合理的，因为大多数材料都有一个占杨氏模量的很小百分比（对于金属，大约为1%）的明确屈服点。因此，弹性应变也将小于该百分比，材料的弹性响应可以非常准确地建模为线性。
8. 在Explicit中，报告的弹性应变能是增量更新的，弹性应变能的增量=总应变能的增量-塑性能量耗散的增量，即${\Delta E_{s}} = {{\Delta E_{t}} - {\Delta E_{p}}}$，对于几乎完全塑性的变形，弹性应变能远小于后两者。在求解$\Delta E_{t}$和$\Delta E_{p}$时的近似会导致和真实解出现偏差，这对于它俩可能不重要，但是对$\Delta E_{s}$却很重要。通常，弹性应变能解非常准确，罕见情况下会导致$E_{s}$为负数。这最有可能出现在使用速率依赖塑性的分析中。只要弹性应变能的绝对值与总应变能相比非常小，弹性应变能为负值就不应被视为严重求解问题的指示。
9. 延性行为就是材料产生了大的非弹性应变。
10. 定义塑性材料的硬化行为时，一般需要的是塑性应变，而非总应变。
11. 可以在Abaqus中通过定义初始硬化条件，为使用经典金属塑性或Drucker-Prager塑性的单元指定等效塑性应变的初始值。这样输出的PEEQ（等效塑性应变）就会包含初始值和分析过程中因塑性应变而产生的任何额外等效塑性应变，但是PE（塑性应变张量）只会包含分析过程中变形引起的应变量。
12. 可以模拟混凝土和其他准脆性材料。可用于素混凝土，即使它主要用于分析钢筋混凝土结构，可以与钢筋一起使用，以模拟混凝土钢筋。设计用于混凝土在低围压下承受单调、循环或动态载荷的应用。
13. 在低围压下，混凝土表现出脆性，主要的破坏机制是拉伸开裂和压缩破碎。当围压足够大以防止裂缝扩展时，混凝土的脆性行为消失。此时，失效是由混凝土微孔微观结构的固结和坍塌引起的，导致宏观反应类似于具有加工硬化的延性材料。
14. 裂缝开裂也会耗散能量，类似于摩擦和阻尼。
15. 宏观性质如下：
    1. 拉伸和压缩的屈服强度不同，压缩的初始屈服应力比拉伸的初始屈服强度高10倍或更多

    2. 拉伸软化行为与压缩软化后的初始硬化相反

    3. 拉伸和压缩时弹性刚度的不同退化

    4. 循环加载过程中存在刚度恢复效应

    5. 速率敏感性，特别是峰值强度随应变率的增加而增加
16. 使用各向同性损伤弹性+各向同性拉伸和压缩塑性来表示混凝土的非弹性行为。
17. 与混凝土破坏机制（开裂和压碎）相关的损伤会导致弹性刚度降低。
18. 使用非关联多硬化塑性+标量（各向同性）损伤弹性的组合，用于描述开裂过程中发生的不可逆损伤。
19. 允许用户在循环负载反转期间控制刚度恢复recovery效果。允许根据材料失效标准移除单元。可以定义为对应变率敏感。可以与Standard中本构方程的粘塑性正则化结合使用，以提高软化状态下的收敛速度。
20. 要求材料的弹性行为是各向同性和线性的。
21. 在标量损伤理论的背景下，刚度退化是各向同性的，其特征是单个退化变量d。
22. Concrete damage plasticity的定义分为三部分组成，弹性，塑性和损伤。它假设主要的两种破坏机制是混凝土的拉伸开裂和压缩破碎。屈服（或破坏）表面的演变由两个硬化变量控制：${\overset{\sim}{\varepsilon}}_{t}^{pl}$和${\overset{\sim}{\varepsilon}}_{c}^{pl}$​，等效拉伸/压缩塑性应变，它们分别与拉伸和压缩载荷下的失效机制有关。
23. 模型的假设如下：该模型假设混凝土的单轴拉伸和压缩响应以损伤塑性为特征。下图是单轴拉伸和压缩的响应，虚线为损伤后的卸载路径。
    1. 拉伸情况：初始开裂应力$\sigma_{t0}$​对应着混凝土微裂纹的产生，此后，微裂纹的形成在宏观上表现为软化应力-应变响应，这会导致混凝土结构中的应变局部化（塑性）。
    2. 压缩情况：塑性状态下，压缩响应通常是应力硬化，然后是超过极限应力$\sigma_{cu}$​的应变软化。
24. <img src="Abaqus.assets/cconcretedamaged-uniaxial.png" alt="img" style="zoom:67%;" />
25. ${{\mathbf{\sigma} = {\left( {1 - d} \right)\mathbf{D}_{0}^{el}}}:{\left( {\mathbf{\varepsilon} - \mathbf{\varepsilon}^{pl}} \right) = \mathbf{D}^{el}}:\left( {\mathbf{\varepsilon} - \mathbf{\varepsilon}^{pl}} \right)},$
26. *Concrete Failure关键字是在2019版本中才加入的，只有Explicit可以支持，但是CDP模型对于Standard和Explicit都是可以使用的。
27. 在包含单元删除的模拟中，飞出去的并非是彻底损伤的单元，而是由于彻底损伤的单元被删除，导致一些还没彻底损伤的单元失去了连接，飞了出去。
28. 
29. 对材料模型进行验证时，应该还原材料实验的情况，如果试件端部没有涂抹凡士林，则约束较强，可以将试件端部和参考点耦合，然后约束。如果涂抹了凡士林，则不需要建立参考点，直接将轴向约束施加在端面上。


# 几何缺陷

1. 几何缺陷一般出现在结构构件上，它也是对缺陷敏感的。对于梁来说，存在截面缺陷（非平直，非直角）和长度缺陷（非平直）。各国设计规范对于缺陷的上限都有规定。

2. 在abaqus2023中，可以在CAE中添加几何缺陷了，在interaction→special→imperfection。

3. 几何缺陷是造成结构失稳的重要原因。在Abaqus中使用两步来模拟几何缺陷对失稳的影响：

   1. 对原始结构进行线性屈曲分析，获取多种屈曲模态（局部或整体），需要手动修改model的keyword，来在结果中输出模态的具体位移场：

      ```shell
      #一般在屈曲分析step的*End Step之前添加下面2行
      *NODE FILE, GLOBAL=NO, MODE=1, LASTMODE=2
      U #这行是节点变量的标识，这里U表示结点位移
      #GLOBAL参数仅和使用*TRANSFORM关键字定义了局部坐标系的节点有关。默认是YES，即在全局坐标系中写入张量的分量。此默认值与*NODE PRINT选项上的默认值相反，因为大多数后处理器都假设分量是在全局坐标系中给出的。
      #此选项用于选择的节点变量将写入Standard中的.fil文件或Explicit中的.sel文件。在Explicit中，它必须与*FILE OUTPUT选项结合使用。
      ```

   2. 选择感兴趣的模态（可以是多个），对其缩放，然后附加到原始结构上，获得带特定模态几何缺陷的结构。这里也要Edit keyword：

      ```shell
      #下面内容要添加到model区域，也就是所有step之前。
      *IMPERFECTION, FILE=job-imperfection, step=1
      1,1.5
      2,-1.5
      #指示去job-imperfection.fil中的第1分析步提取节点位移。数据行的第一个数为模态阶数，第二个数为缩放倍数。如果有多个数据行的话，会叠加。
      ```

   3. 对新的结构，进行所需的分析，例如非线性屈曲分析。

4. 有时可以先将模态的缩放倍数设置为较大值，然后再执行计算前，可以在后处理中观察，确认无误后，再设置回合理值提交计算。

# 残余应力

1. 结构在热加工中由于受热或冷却不均匀，导致出现残余应力。下图是热轧工字钢的残余应力分布，都是垂直于横截面，即残余应力在长度方向梯度为0，可以简化为二维。
2. 压缩残余应力在切开后，没有了压应力的约束，会膨胀。一般需要将残余应力作为应力的初始场，然后进行其他计算。
3. 需要注意的是，每个截面的残余应力的合力需要为0，即内力平衡，否则该截面会飞走（可以取一个平行于该截面的薄片，合力不为0），这不符合残余应力的物理事实。实际的结构由于有周围部件的约束，并不会飞走，而是会继续变形，也就是释放残余应力到一个平衡的状态，这时的应力才是真实的残余应力。
4. <img src="Abaqus.assets/无标题.png" alt="无标题" style="zoom:67%;" />
5. 可以对规则划分网格后的单元进行分组，然后按照位置对上述残余应力场的函数进行插值，可以选择单元中心点作为位置的代表值。
6. predefined field→stress，只能在initial步中指定，因为残余应力是在其他荷载施加前就存在的。只对轴向应力对应的σ分量进行设置。可以在后处理中的0增量检查残余应力的施加是否正确，不施加任何荷载或约束，只约束刚体位移即可。
7. 如果边界条件没有足够的约束，则只施加残余应力的结构在不受任何外力下，也会变形。如下图，左端为自由端，右端为固定端，左端就会产生应力重分布，相当于卸载，右端由于约束充分，则不会产生应力重分布。
8. ![无标题](Abaqus.assets/无标题-1735009237910-1.png)



# 常见warning和error

1. 如果在静态standard中使用step模式的幅值，由于会一下子施加上特别大的荷载或位移，可能会造成很多单元过度塑性（The strain increment has exceeded fifty times the strain to cause first yield at 3950 points，就是增量太大，导致3950个点的应变超过了初始屈服应变的50倍）或过度畸变（Excessive distortion）。

2. Displament increment for contact is too big，这常见于初始荷载较大的情况。

3. 非线性分析步中E会自动用LE替代。

   ```
    ***WARNING: OUTPUT REQUEST E IS NOT AVAILABLE IN A NONLINEAR STEP -- LE (LOG 
                STRAIN) WILL BE OUTPUT INSTEAD.
   ```


# 命令

1. 常用的提交命令：

   ```shell
   abaqus job=xx cpus=4 user=aa.for int
   ```

2. 可以将ABAQUS的显示设置保存在文件中，abaqus_v6.14.gpr。放到路径(用户的家目录，对于Windows为 C:\Users\Administrator)中，就可以在打开的时候自动读取。

3. 查找abaqus的安装目录：

   ```shell
   C:\Users\zj\Desktop> abaqus whereami
   Abaqus 2023
   Abaqus Site ID:
   Abaqus is located in the directory D:\SIMULIA\EstProducts\2023 D:\SIMULIA\EstProducts\2023\win_b64 D:\SIMULIA\EstProducts\2023\win_b64\code D:\SIMULIA\EstProducts\2023\win_b64\code\bin D:\SIMULIA\EstProducts\2023\win_b64\code\bin\SMAExternal D:\SIMULIA\EstProducts\2023\win_b64\CAEresources D:\SIMULIA\EstProducts\2023\win_b64\SMA
   Sequence Information:
       D:\SIMULIA\EstProducts\2023\win_b64: 2022_09_29-02.11.55 183150
   ```

4. 在特定目录下打开ABAQUS。切换到该目录，Shift+右键，或者直接在路径栏输入cmd，在此处打开命令窗口，输入：

   ```shell
   abaqus cae=xxx.cae
   ```

5. ABAQUS的两个主要模块为cae和viewer，可以使用如下命令启动。在cae中可以打开.cae和.odb文件，但是在viewer中只能打开.odb文件。replay选项支持一个Python脚本，启动后会立即执行该脚本。

   ```shell
   abaqus cae or viewer 
          [database=database-file]
          [replay=replay-file]
          [recover=journal-file]
          [startup=startup-file]
          [script=script-file]
          [noGUI=[noGUI-file]]
          [noenvstartup]
          [noSavedOptions]
          [noSavedGuiPrefs]
          [noStartupDialog]
          [custom=script-file]
          [guiTester=[GUI-script]]
          [guiRecord]
          [guiNoRecord]
   ```

6. 通过命令行给Python脚本传递参数，这些参数会被CAE忽略，但是会传递给Python解释器。

   ```python
   #python脚本test.py
   import sys
   print sys.argv     #获取所有命令行参数。
   print len(sys.argv) #获取命令行参数的个数。
   #shell命令
   abaqus cae script=test.py -- argument1 argument2  #运行该命令，会打开ABAQUS，在内置的Python输出窗口输出如下
   argv = ['D:\\SIMULIA\\EstProducts\\2023\\win_b64\\code\\bin\\ABQcaeK.exe', '-cae', '-lmlog', 'ON', '-tmpdir', 'C:\\Users\\zj\\AppData\\Local\\Temp', 'argument1', 'argument2'] #因此推荐使用argv[-1]，argv[-2]来获取argument2和argument1。
   8
   ```

7. 不打开ABAQUS图形界面运行，`abaqus cae noGui=checkPartValidity.py`，可以和参数结合使用。

8. ABAQUS会将用户对GUI界面的设置保存在abaqus_v6.14.gpr（或abaqus_2023.gpr对于abaqus2023）文件中，还会将本次的用户的操作保存在abaqus.rpy文件（Python脚本）中，方便用户复现之前的操作。每次打开CAE都会新建一个rpy文件，并将之前存在的rpy文件重命名。

9. 如果启动CAE时，使用了noSavedOptions选项。CAE将不会读取abaqus_v6.14.gpr中的设置。

10. 默认情况下，启动CAE时，会依次读取家目录（Windows下为C:\Users\zj）和启动CAE时的目录中的.gpr文件。关闭CAE时，会自动保存当前的GUI设置到家目录中的文件。也可以删除该文件，来还原默认设置。

11. CAE内部包含了一个非活动的计时器，如果应用长时间不活动，license就会被服务器收回，给其他用户使用。默认时间是60分钟。可以通过修改环境变量文件abaqus_v6.env中的cae_timeout来更改时间。

12. 系统的abaqus_v6.env文件放在/SMA/site（abaqus2023中为EstProducts\2023\win_b64\SMA\site，不过文件名也是abaqus_v6.env）路径下。也可以在用户家目录，启动目录中存放该文件。CAE启动的时候会依次读取。使用的是Python语法。

13. 如果工作目录有空格，则在使用cae提交inp形式的job时，会报错，有两种方案：①修改工作目录，删掉其中的空格，不过可能会触发下一个错误②使用命令行`abaqus job=xxx`，不用.inp的后缀。

    ```shell
    Abaqus Error: Command line option "input" value must not contain whitespace characters.
    Abaqus/Analysis exited with error(s).
    ```

14. 如果修改了工作目录的路径名，下一次启动cae时会报错，这是由于想要在不存在的目录产生一个新的abaqus.rpy文件，因此会报错。此时可以修改快捷方式的起始位置为新的工作目录。

    ```python
    IOError: abaqus.rpy: Permission denied
    
    Abaqus Error: Abaqus/CAE Kernel exited with an error.
    ```

15. 如果不打开cae的话，是不会产生.rpy文件的。例如只使用命令行提交.inp文件。


# User Subroutine配置

1. 可以参考视频https://www.youtube.com/watch?v=qGNAdlDoeTs。

2. 应该先安装VS，再安装Intel Fortran，这样Intel Fortran会自动关联到VS，可以在vs中新建Fortran的项目。

   1. 首先安装VS2019，然后再下载Intel® Fortran Compiler Classic and Intel® Fortran Compiler，下载地址为：`https://www.intel.com/content/www/us/en/developer/articles/tool/oneapi-standalone-components.html#fortran`。
   2. 选择在线或离线包都可以，推荐下载离线版，方便以后使用。
   3. 每个Intel Fortran编译器都有配合的多个VS版本，安装其中一个即可。
   4. 亲测abaqus2023 + vs2019 + Intel oneAPI2024.0可以搭配。

3. ABAQUS的安装顺序可以任意，在配置关系上，它和（VS+Intel Fortran）是相互独立的。

4. Intel Parallel Studio XE 已经不更新了，2020年之后就被新的Intel oneAPI替代了。

   ```shell
   #oneAPI中最常用2个套件为Intel oneAPI Base Toolkit和Intel HPC Toolkit，前者包含C/C++的编译器和MKL库，后者包含了Fortran编译器和MPI库。
   #abaqus在安装时会默认安装微软的MPI库，因此没必要安装Intel的MPI库。MKL库可以加速求解。
   #最精简的安装可以是只安装Fortran编译器。
   https://www.intel.com/content/www/us/en/developer/tools/oneapi/toolkits.html # 下载地址，可以单独下载套件内的每个模块
   ```

5. vs和Microsoft visual studio build tools的区别，前者包含后者，如果只安装后者，则只能使用命令行界面编译。

6. 要想使用Intel Fortran命令行，需要先执行vs的命令行进行配置，然后在其中执行Intel Fortran的命令行，也可以配置环境变量`VS2019INSTALLDIR`为`D:\Program Files (x86)\Microsoft Visual Studio\2019\Community`来替代执行vs命令行，因为Intel Fortran命令行会自动寻找环境变量`VS2019INSTALLDIR`，来执行vs命令行。结果显示如下：

   ```shell
   #VS的命令行
   "D:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvars64.bat"
   #执行结果为
   **********************************************************************
   ** Visual Studio 2019 Developer Command Prompt v16.11.28
   ** Copyright (c) 2021 Microsoft Corporation
   **********************************************************************
   [vcvarsall.bat] Environment initialized for: 'x64'
   #Intel Fortran的命令行
   "D:\Program Files (x86)\Intel\oneAPI\setvars.bat" intel64 vs2019
   #执行结果为
   :: initializing oneAPI environment...
      Initializing Visual Studio command-line environment...
      Visual Studio version 16.11.28 environment configured.
      "D:\Program Files (x86)\Microsoft Visual Studio\2019\Community\"
      Visual Studio command-line environment initialized for: 'x64'
   :  compiler -- latest
   :  debugger -- latest
   :  mpi -- latest
   :: oneAPI environment initialized ::
   ```

7. 和abaqus相关的目录：

   ```shell
   #Solver_install_directory
   D:\SIMULIA\EstProducts\2023\win_b64\SMA\site
   #Cae_install_directory
   D:\SIMULIA\EstProducts\2023\win_b64\code\bin
   #Cae_launcher_directory
   D:\SIMULIA\EstProducts\2023\win_b64\resources\install\cae
   #Commands_directory
   D:\SIMULIA\Commands
   ```

8. 需要修改的文件，可以修改Fortran编译器的默认选项。

   ```shell
   #win86_64.env 在Solver_install_directory，这个文件里的功能是Compile and Link commands for ABAQUS on the Windows 64 Platform。
   compile_fortran=['ifort',
                    '/Qmkl:sequential', #<-- MKL，新加入的，指示使用MKL
                    '/free', #<-- free format Fortran95，新加入的，指示将.for后缀的文件识别为自由格式的。官方的例子都是固定格式的。
                    '/c', '/fpp', '/extend-source', 
   ```

9. 由于abaqus CAE要求子程序使用.for的后缀名，因此如果不加/free的话，编译器会将其识别为固定格式的，此时用户也只能以固定格式来书写代码，不方便。

10. 在abaqus_v6.env（在Solver_install_directory中）末尾追加如下代码，注意不能出现中文，注释也不行：

   ```python
compile_fortran += ['/names:lowercase',] # Solves problem with naming convention。修改编译器的标志，以便在编译器中将外部名称转换为小写。
# 回调函数，初始化时会自动执行，不需要在这里手动执行，只需要定义即可。
def onCaeStartup():
	#设置.rpy文件中的几何编码为坐标，默认是mask，这个效率更高，但是不利于阅读。
	session.journalOptions.setValues(recoverGeometry=COORDINATE)
   ```

11. 修改D:\SIMULIA\Commands\abq2023.bat文件

   ```shell
@echo off
setlocal
set ABA_DRIVERNAME=%~nx0
call "D:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvarsall.bat" x64 #新增加的一行，配置vs环境，需要先执行。
call "D:\Program Files (x86)\Intel\oneAPI\setvars.bat" intel64 vs2019 #新增加的一行，配置Intel Fortran的环境。
"D:\SIMULIA\EstProducts\2023\win_b64\code\bin\SMALauncher.exe" %*
endlocal
   ```

11. 需要在path中添加两个环境变量，用来指示Intel oneAPI和VS的目录（经验证，不加好像也没事，因为上面执行的vs脚本和intel fortran脚本都给定了全部目录）：

    ```shell
    D:\Program Files (x86)\Intel\oneAPI\compiler\2024.0\env
    D:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build
    ```

12. 开始菜单的命令行包含Abaqus Command（一般用这个进行命令行的操作），这个默认是直接打开cmd而不设置环境，可以修改它的快捷方式如下。

    ```shell
    #修改前
    C:\Windows\System32\cmd.exe /k
    #修改后。不过不修改也可以，因为在这里执行的命令都是以abaqus开头的，这条命令会自动载入对应的环境，因此建议只修改abq2023.bat这个文件。
    "D:\Program Files (x86)\Intel\oneAPI\setvars.bat" intel64 vs2019 & C:\Windows\System32\cmd.exe /k
    ```

13. 如果要使用subroutine，在安装时应该安装caaapi（用于子程序开发的库），和sample（因为运行verification需要从中提取例子来验证，如果确信配置没有问题，可以不用安装sample，可以用自己编写的子程序来验证）。

    ```shell
    #验证配置是否成功的命令
    abaqus verify -user_exp #仅显式
    abaqus verify -user_std #仅隐式
    ```

14. 如果想要通过验证，就不能给win86_64.env中的compile_fortran添加/free选项。因为官方例子里的.for文件都是固定格式的，按照自由格式解析会出错。

15. `/Qmkl:sequential`选项，需要安装MKL之后才可以使用，否则会报错。

16. `/free`不能和VUMAT联合使用。

17. 通过命令行提交job，附带子程序。

    ```shell
    abaqus job=Job-2-umat user=umat.for #inp文件中并没有关联子程序的具体文件名，如果不提供子程序的文件名，会报错。user参数的值也可以是编译好的obj目标文件。
    #默认会提交到一个后台进程去计算，然后立即返回，可以添加interactive选项来保持前台，这样会显示log文件的内容。
    ```

18. 如果经常需要相同的用户子程序，可以使用`abaqus make`创建包含用户子程序的共享库，然后在环境文件（abaqus_v6.env即可）中设置`usub_lib_dir`参数即可，例如`usub_lib_dir=r"E:\Abaqus file\Concrete dam"`。这将避免每次需要时都需要重新编译链接。如果分析调用的用户子程序包含在库中，则不需要user选项指定。如果指定了user选项，则不会使用环境文件参数给出的目录中包含的用户库。

19. 当使用double选项运行Explicit分析时，不能使用user选项来指定对象文件，因为Explicit双精度运行需要单精度和双精度对象。此时必须设置环境文件参数，并将单精度和双精度对象文件放置在指定目录中；或者可以提供用户子例程源代码。

20. 如果user没有提供后缀名，则会依次寻找：`xx.f, xx.for, xx.f90, xx.F90, xx.c, xx.C, xx.cpp, xx.c++, xx.obj`。

21. 如果想将子程序提供给他人使用，但不希望他人看到源码，此时可将编译后的obj和dll文件提供给他人，也可以用这个方法来提前检查以下语法错误：

    ```shell
    abaqus make library=umat.for object_type=fortran
    #编译成功后会输出
    Abaqus JOB umat.for
    Begin Compiling Abaqus/Standard User Subroutines
    ...
    End Compiling Abaqus/Standard User Subroutines
    Begin Linking Abaqus/Standard User Subroutines
      正在创建库 standardU.lib 和对象 standardU.exp
    End Linking Abaqus/Standard User Subroutines
    Abaqus JOB umat.for COMPLETED
    #产生两个文件umat-std.obj和standardU.dll，前者是编译的结果，后者是链接后的结果，名称固定。如果使用user参数指定，则只需要.obj就可以。如果使用环境文件参数，则只需要standardU.dll，因为这里无法指定文件名，只能指定路径。
    ```

22. 编译得到的目标文件有一个后缀，指示它是用于Standard（-std）还是Explicit（单精度为-xpl，双精度为-xplD）。链接得到的Standard用户子程序共享库名为standardU.dll，Explicit共享库分别名为explicitU.dll和explicitU-D.dll。如果使用directory选项，并且包含具有所创建共享库适当后缀的对象文件，则这些文件将链接到共享库。

23. 如果发现Intel Fortran的命令行环境配置结果中，没有显示compiler，则可以在卸载程序的地方双击，然后repair该程序。

24. 最简单的例子，各向同性线弹性材料，需要注意的是，官方给的例子第一行SUBROUTINE前面没有空出6个字符（前6个字符是注释内容），当使用固定格式时会报错。这个材料不能用于平面应力问题：

    ```fortran
          SUBROUTINE UMAT(STRESS,STATEV,DDSDDE,SSE,SPD,SCD,
         1 RPL,DDSDDT,DRPLDE,DRPLDT,
         2 STRAN,DSTRAN,TIME,DTIME,TEMP,DTEMP,PREDEF,DPRED,CMNAME,
         3 NDI,NSHR,NTENS,NSTATV,PROPS,NPROPS,COORDS,DROT,PNEWDT,
         4 CELENT,DFGRD0,DFGRD1,NOEL,NPT,LAYER,KSPT,JSTEP,KINC)
    C
          INCLUDE 'ABA_PARAM.INC'
    C
          CHARACTER*80 CMNAME
          DIMENSION STRESS(NTENS),STATEV(NSTATV),
         1 DDSDDE(NTENS,NTENS),DDSDDT(NTENS),DRPLDE(NTENS),
         2 STRAN(NTENS),DSTRAN(NTENS),TIME(2),PREDEF(1),DPRED(1),
         3 PROPS(NPROPS),COORDS(3),DROT(3,3),DFGRD0(3,3),DFGRD1(3,3),
         4 JSTEP(4)
    C --------------------------
    C User Code Begin
    C --------------------------
          E=PROPS(1)
          Nu=PROPS(2)
          Mu=E/(2.D0*(1.D0+Nu))
          Lambda=Nu*E/((1.D0+Nu)*(1-2.D0*Nu))
    C     CALCULATE DDSDDE
          DO K1=1,NDI
    	      DO K2=1,NDI
    	          DDSDDE (K1,K2)=Lambda
    	      END DO
    	      DDSDDE(K1,K1)=Lambda+2.0*Mu
    	  END DO
    
    	  DO K1=NDI+1,NTENS
    	      DDSDDE(K1,K1)=Mu
    	  END DO
    
    C     CALCULATE STRESS
          DO K1=1,NTENS
    	      DO K2=1,NTENS
    	          STRESS(K1)=STRESS(K1)+DDSDDE(K1,K2)*DSTRAN(K2)
              END DO
          END DO
    C --------------------------
    C User Code End
    C --------------------------
          RETURN
          END
    ```

25. <img src="Abaqus.assets/image-20241107225604101.png" alt="image-20241107225604101" style="zoom:50%;" />


# User Subroutine

1. 通过用户子程序，用户可以开发出ABAQUS原来并不具备的材料、单元、载荷等，或者干预ABAQUS的内核计算过程，以满足自身个性化的分析目的和需求。

2. 子程序可以使用C，C++，Fortran编写，因为编译后都是包含汇编指令的目标文件，不过需要注意不同语言间数组的定义，基本数据类型的尺寸兼容，还有函数调用的传参约定。

3. 用C++编写的用户子程序，实际上最终是还是由Fortran调用的（因为abaqus的核心程序是用Fortran编写的），所以C++子程序必须满足Fortran的调用规则：函数名必须表达成Fortran的形式；传入的参数实际上是实参的引用（或者说地址）。因此相当于混合编程。

4. 每个子程序都需要遵从特定的接口定义，这里可以去Verification Guide中寻找对应的官方例子文件的名称，然后fetch出来，复制程序头部即可。

5. 下图为Standard从开始分析到一个分析步结束的总体流程，以及相应的子程序调用的位置。

6. ![基于ABAQUS的有限元子程序开发与应用](Abaqus.assets/基于ABAQUS的有限元子程序开发与应用.png)

7. 下图为上图中应力应变更新和单元刚度计算的详细图：

8. ![基于ABAQUS的有限元子程序开发与应用](Abaqus.assets/基于ABAQUS的有限元子程序开发与应用-1731143195719-2.png)

9. 在一个增量步的第一次迭代时，上面两张图中的每个用户子程序被调用了两次。第一次调用时，通过增量步开始时的构型来计算模型的初始刚度矩阵；第二次调用时，通过更新的构型计算一个新的刚度矩阵。在接下来的每个迭代步中，每个子程序只被调用一次，在这次调用中，总是通过上一个迭代步结束时的模型刚度来修正模型当前构型的刚度。

10. 在子程序中也可以读写外部文件，编号为15-18，以及>100的编号可以在子程序中被用于读写文件；其他编号可能被ABAQUS内部的子程序使用，因此在用户子程序中不要使用。

11. 例如在Standard的子程序中，用户可以向消息文件（.msg，编号为7）或者打印输出文件（.dat，编号为6）写入debug的信息。这些文件在子程序中不需要打开（open），直接写入即可（因为已经被abaqus打开了）。在Explicit中，编号为6的文件被用于指示状态文件（.sta）。

12. 除了输出消息之外，还可以输出求解相关的数据，用于后处理。

13. 当一个文件在用户子程序中被打开时，abaqus默认这个文件位于工作目录中。也可以指定完整路径来在其他位置存储该文件。

14. 可以观察官方的例子，所有函数的参数，都不声明变量类型，只有是数组的时候，才会用DIMENSION声明一下维度，这是因为它使用隐式变量类型声明。通过INCLUDE 'ABA_PARAM.INC'，该语句将Abaqus编写好的数值精度声明包含其中。这个文件位于ABAQUS的默认目录中，不需要人为地去找到它并指定它的路径，ABAQUS会自动找到它，`EstProducts\2023\SMAUsubs\PublicInterfaces`。

    ```fortran
    implicit real*8(a-h,o-z) !声明了数值精度，即以a-h和o-z开头的变量都是双精度，也就是说ijklmn都是整型，除此之外都是浮点数。
    parameter (nprecd=2)
    ```

15. 具体包含3个对应的文件：

    1. aba_param.inc，隐式使用。

    2. vaba_param_dp.inc，显式双精度使用。

    3. vaba_param_sp.inc，显式单精度使用。

16. 测试用户子程序的一些编程技巧：

    1. 尽可能地测试最小的模型。例如，测试UEL时，简历包含一个单元的模型。

    2. 在测试时不要引入其他复杂的特性，如接触，除非它对于测试这个子程序是必须引入的。

    3. 在向子程序中继续加入新的代码之前，测试所有可能的基本的变量，并保证正确。

    4. 数组尽量给定大小，随时检查数组是否越界。这可能发生不可预知的错误。

    5. 按照固定的命名习惯去命名，包括对文档，对象变量和模块的命名。

    6. 将程序编写到多个文件中，每个文件的代码不要太长。不要将所有程序都写进同一个文件，特别是在子程序非常复杂和庞大的情况下。

    7. 在程序的源文件中，为每个主要程序段添加注释，以解释代码的基本逻辑，最好注明程序的构建和修改日期，以及修改的原因。

    8. 定期为程序写说明文档。特别是在程序版本升级之后，一定要更新程序的说明文档。

17. 求解依赖的状态变量SDV有以下几种方式来定义和使用：

    1. UMAT，VUMAT中，每个积分点或节点上的SDV个数通过关键字*DEPVAR定义，可以通过CAE来设置。
    2. UEL，UELMAT和VUEL中，通过关键字*USER ELEMENT定义，只能通过修改inp文件设置。
    3. FRIC，VFRIC中，通过关键字*FRICTION定义。这个在CAE中的Edit Contact Property→Friction Formulation中设置。

18. 有两种方法可以定义SDV的初始值：

    1. 通过关键字*Initial Conditions，Type＝Solution。这个不支持在CAE中设置。

    2. 更加复杂的情况，可使用用户子程序SDVINI来定义。只能在Standard中使用，此时需要在关键字*Initial Conditions，Type＝Solution后面加上参数User。

19. 子程序的调试：

    1. 安装好匹配的VS，Intel Fortran，Abaqus。

    2. 编辑win86_64.env，在compile_fortran中添加/Od和/Zi选项，使得编译器生成调试符号信息。在link_sl和link_exe中添加/debug选项， 使得链接器链接调试符号信息到.obj和.exe文件。

    3. 在子程序开头的位置添加一些可以使进程暂停的代码，例如read或sleep语句。

       ```fortran
       debug = 0 !标志变量，如果需要调试，则将其置为1，这样就会进入下面的语句块，否则置为0。
       if(debug == 1)then
           write(*,*) "Please input an integer."
           read(*,*) tempread !一个临时变量，让程序停在这里
           debug=0 !进入调试后，就恢复debug的值，因为子程序会被反复调用，一旦通过VS附加上进程以后，就可以手动在VS中添加断点了，不用依赖这个。
       endif
       ```

    4. 提交任务`Abaqus job=JobName user=SubroutineName int`。程序运行到请求输入的地方会暂停。

    5. 此时打开VS，调试→附加到进程，然后在任务管理器中寻找对应的进程。隐式计算是standard.exe，显式计算是Package.exe和Explicit.exe。

    6. 在命令行输入一个数字，让程序继续运行。VS会打开一个临时生成的和源文件内容完全相同的临时代码文件，并在设置断点的位置暂停，此时即可开始正常的调试过程。

20. 也可以在子程序中直接使用write来输出调试信息到命令行窗口。

21. 在子程序中可以使用Fortran内置的运算函数来简化运算，避免编写多层循环，例如矩阵乘法，向量内积等函数。

22. 使用子程序来自定义材料，在创建材料的界面中，General→User Material。可以选择力学，传热或热力耦合材料，它们分别会调用名称的不同的子程序，standard下为UMAT和UMATHT，explicit下为VUMAT，此时只支持力学分析。然后在下方的Mechanical Constants中输入需要的参数，它们会被当作UMAT函数的PROPS数组传入，整型参数NPROPS记录PROPS数组的大小。

23. PROPS一般是材料参数，例如弹性模量，线性强化系数，初始屈服应力等，也可以是几何参数，例如板厚度，层厚度。注意，在UMAT中修改这里的数据是无效的，每次UMAT调用都会使用inp文件中定义的值。

24. 使用General→Depvar，来定义求解依赖变量（只能是标量，张量的话，需要自己安排存储方式）的数量，可以用来存储材料的状态，例如等效塑性应变。UMAT函数的整型NSTATEV参数保存这个值，在函数内通过STATEV数组来使用。用户需要自己约定数组的每个元素代表什么含义。在后处理中，以SDV1，SDV2等来表示。SDV是Solution-Dependent State Variables的缩写。

25. Abaqus计算单元的响应（分析步→增量步→迭代步，这些值会作为子程序的参数输入，例如DLOAD就需要它们来计算荷载）时，会在积分点上计算，对于材料属性为user defined的材料，都会调用UMAT，因此UMAT是会被非常频繁地调用的，每次调用之间是没有关系的，因此对于一些有记忆效应的材料，为了记录不同积分点的历史，abaqus会为单元的每个积分点存储状态变量，不同的积分点的状态变量不同，意味着这些点处理不同的应力应变状态，同时每次UMAT返回前，还应该更新状态变量，以便记录历史，下次从此处算起。如果有多种自定义材料，那么在UMAT内需要根据材料名称CMNAME参数来区分，分别引用不同的本构。

26. 如果VUMAT中需要模拟材料的损伤演化，需要据此删除一些单元，可以在增加第二个参数的值。只能在explicit中使用。

27. 创建job时，在General→User subroutine file选择fortran文件即可，只能选择一个文件，这意味着所有的子程序，都要写在该文件中，在不同的子程序内部可以通过材料名称来区分请i去的是哪个材料的响应。也可以卸载其他文件中，但是需要在主文件中使用include语句包含进来，此时子程序的文件名不能重复。

28. 当一个含有用户子程序的分析需要进行重启动分析时，需要重新指定子程序文件的位置。这是因为，在重启动文件（.res）中并没有保存子程序的源代码。

29. abaqus会调用编译器编译子程序文件，然后将其和abaqus的核心程序链接到一起，以便在求解中调用。

30. UMAT只能计算局部响应，也就是根据一点的过去状态，计算该点的现在状态。如果要计算非局部响应，应该使用UGENS，它用于壳单元。


## DFLUX

1. 可以通过DFLUX设置复杂传热传质边界条件（只能在传热或质量扩散分析步中使用，），该程序的主要功能就是定义FLUX数组：
   1. 第一个元素是从当前点（积分点）流入的流量幅值q。在热传导分析中，该流量可以是表面热流或者体积热流；在质量扩散分析中，该流量可以是表面质量流量或者体积质量流量。
   2. 第二个元素是表示流量的变化率，热通量关于温度的导数，或质量通量关于浓度的导数，这个类似于DDSDDE，这个量的值不影响计算结果，但会影响计算的收敛性。

2. 热荷载有三种模式，表面，体积和集中热通量。前两个可以使用DFLUX，最后一个只能是均匀的。

3. 通过DFLUX计算的通量值还会乘以Magnitude和Amplitude。其中Amplitude可以通过子程序来控制，这样可以得到随时间变化的边界条件了。不过DFLUX中也可以设置荷载随时间变化，其中是包含时间参数的。当荷载是空间和时间解耦的，推荐使用Amplitude方式。

4. 质量扩散问题比传热要复杂点，因为他还会在物体中引起等效压应力。同时材料的热传导率一般和浓度无关，但是物质的扩散率可能和温度有关。因此质量扩散时，DFLUX中的TEMP表示温度，PRESS表示等效压应力。而质量扩散和传热问题中，SOL分别表示浓度和温度。


## DLOAD

1. 通常可以用Amplitude来施加随时间变化的荷载。但是当荷载是空间或时间的复杂函数时，一般使用用户自定义荷载：隐式的DLOAD和UTRACLOAD，显式的VDLOAD。

2. DLOAD和VDLOAD用于定义压力载荷和体积力载荷，包括分布线，面和体荷载。

3. UTRACLOAD用于定义表面（surface traction）或边（shell edge load）收到的力，例如表面压力，表面剪切力。

4. 例如壳单元的平面外的压力荷载，通过pressure功能的DLOAD函数定义，壳边缘的分布线荷载使用shell edge load的UTRACLOAD函数定义。

5. 可以通过\*DLOAD或\*DSLOAD在inp文件中指明要使用自定义荷载，也可以通过CAE设置。注意

   ```shell
   *DSLOAD
   Surf-top, PNU, 10.0 #第一个参数表示单元集合标记，第二个参数是LOAD type label，表示由子程序计算的非均匀分布的压力，第三个参数是Magnitude，只对DLOAD起作用，而VDLOAD会忽略它。
   ```

6. 需要注意的是，幅值曲线和自定义荷载子程序不能同时使用。如果分布载荷不止和单元的位置有关，还和单元的变形有关，那么此时自定义载荷子程序也就无法满足要求。这类更复杂的载荷，需要编写用户单元子程序UEL、UELMAT或VUEL。

7. DLOAD函数的主要功能就是给参数`f`赋值，根据载荷类型的不同，单位也不同。

8. 如果在模型中多出都要使用用户自定义压力载荷，则需要在DLOAD函数内根据JLTYPE判断载荷类型，SNAME判断表面名称，然后分别计算目标载荷。

9. 与其他显式子程序类似，VDLOAD会一次性更新nblock个积分点上的载荷，而不是一个，因为显式分析中的增量太多了，如果一次只更新一个，该函数会被调用太多次，会导致函数进入和退出的开销占比较高。数组value则对应于DLOAD中的f，需要在函数内去赋值。和隐式分析不同的是，这里多了积分点的速度，问题模型的维数，面的方向（只对压力载荷有效）等参数。速度和面方向本来是矢量，一维存储即可，但是这里存储的是整个block的数据，因此是二维的，使用`curCoords(k,1)`获取块内第k个节点的x坐标。

10. 在UTRACLOAD中，有两个变量是必须更新的：

    1. alpha，分布载荷的大小。
    2. t_user数组，分布载荷的作用方向。ABAQUS会自动对t_user向量进行正则化（在用户子程序UTRACLOAD的外部），所以无论在函数内赋值的t_user是否为单位向量，函数返回后都会被转换为单位向量。

11. 这里载荷不能以三个分量的形式单独给出，只能按照幅值和方向来给出。

12. 通常情况下，变量alpha和t_user都存储在总体坐标系下，如果这两个变量被定义在局部坐标系下，则它们的值也是在局部坐标系下的。


## USDFLD

1. 如果要定义复杂的材料行为，但又不想使用UMAT或VUMAT，则可以使用USDFLD或VUSDFLD来实现。例如，当某个积分点的应力达到某个阈值后，该积分点失效不再承载。对于这种材料行为，使用USDFLD或VUSDFLD可以方便地实现。场变量还可以通过predefined field来定义。

2. ABAQUS中的大部分材料属性（例如弹性模量，泊松比等）可以定义为场变量$f_i$的函数，而USDFLD和VUSDFLD允许用户在单元的积分点（材料点）上自定义场变量。并且这两个子程序可以在求解过程中访问结果数据，因此，我们可以定义依赖于求解结果的材料属性，$f_i=f_i(\sigma,\varepsilon,\varepsilon^{pl},\cdots)$。

3. 在CAE的edit material→user defined field来指示材料使用USDFLD或VUSDFLD。或者在.inp文件的材料声明内部添加一行`*USER DEFINED FIELD`。

4. 上面的设置只是声明了模型中要用到USDFLD或VUSDFLD，而如果想要是材料属性依赖于场变量的值，还需要通过CAE中的数据表格或其他子程序（例如CREEP）来设置具体的依赖关系。假设材料属性依赖于两个场变量$f_1$和$f_2$。其中材料的杨氏模量只依赖于场变量$f_1$，而热膨胀系数依赖于场变量$f_1$和$f_2$，具体的依赖关系由表格给出，其他值下的依赖关系通过表格中的数据线性插值得到。

5. ![111](Abaqus.assets/111.png)

6. 可以观察到，如果Number of field variables为默认的0，此时弹性属性的表格只能输入一行2列，也就是杨氏模量和泊松比。

7. 如果Number of field variables不为0，则可以添加多行。这个对于温度依赖的材料属性也是一样的。因此可以认为膨胀系数是两个场变量$f_1$和$f_2$的函数，就像认为它是温度的函数一样。温度可以看作是一个特殊的场，Field 0。和温度依赖时的插值一样，对于场边量在其他值下的依赖通过表格中的数据线性插值得到。

8. 在USDFLD或VUSDFLD中，必须使用solution dependent state variables来存储用户自定义的场变量，此时需要定义状态变量的个数，在CAE中使用Depvar，在.inp中使用*DEPVAR，这里类似于UMAT的情况。

9. USDFLD和VUSDFLD可以和（CREEP，UMAT，VUMAT，UHYPEL等）联合使用，前者定义的场变量会传入后者，从而可以定义更加复杂的材料行为。

10. USDFLD，VUSDFLD不能直接使用结果数据，需要通过实用子程序GETVRM和VGETVRM来间接使用。需要注意的是，USDFLD和VUSDFLD都只能在增量开始时能访问积分点的值。因此，以这种方式引入的解是显式的，结果的准确性取决于时间增量的大小。对于Standard，用户可以通过变量PNEWDT来控制USDFLD中的时间增量，以达到求解的准确性。而对于Explicit，这通常不是问题，因为它的稳定时间增量通常足够小，可以确保求解的准确性。

11. GETVRM的接口如下：

    ```fortran
    DIMENSION ARRAY(15), JARRAY(15)
    CHARACTER*3 FLGRAY(15)
    ...
    CALL GETVRM('VAR',ARRAY,JARRAY,FLGRAY,JRCD,JMAC,JMATYP,MATLAYO,LACCFLA)
    !第一个字符串参数是输出变量key，用来标记要访问哪个结果数据变量，例如'S'表示要访问应力张量；'MISES'表示要访问Mises应力。
    !ARRAY参数表示结果数据的浮点型分量
    !JARRAY参数表示结果数据的整型分量
    !FLGARY参数表示结果数据的字符型分量，字符串数组，可以是YES，NO或N/A。
    !以上三个只有一个有效，具体是哪个取决于具体的输出变量的数据类型。
    !JRCD参数表示本次调用成功与否，0表示成功，1表示出错或着请求的所有分量都是0。
    !最后4个参数JMAC,JMATYP,MATLAYO,LACCFLA，直接把USDFLD的对应后4个参数传入即可。
    !对于一维数据，例如向量，按照顺序输出即可。对于二维数据，分两种情况，如果是对称的例如应力张量，按照11，22，33，12，13，23。如果是非对称的例如变形梯度张量，按照11，22，33，12，13，23，21，31，32。
    !例如，对于平面应力单元的应力张量，array变量的存储顺序为:array(1)=S11，array(2)=S22，array(3)=0.0，array(4)=S12，后续的11元素个都是0。
    !无论分析的维度如何，主值的请求总是返回三个值，最小值，中值，最大值。
    ```

12. 注意，并不是所有单元都支持GETVRM。由于它访问的是单元的材料点，因此所有不具有材料点的单元都不支持该子程序，如所有声学单元、接触单元和流体单元。

13. VGETVRM和GETVRM类似，输出变量的顺序相同，例如，对于三维实体单元的应力张量，rData返回的分量为S11、S22、S33、S12、S13、S23，jData返回的全是0，cData返回的都是N/A。

14. 注意，VGETVRM返回的应变分量是应变张量的分量，而GETVRM返回的是工程应变分量。

15. USDFLD：

    ```fortran
    SUBROUTINE USDFLD(FIELD,STATEV,PNEWDT,DIRECT,T,CELENT,
        TIME,DTIME,CMNAME,ORNAME,NFIELD,NSTATV,NOEL,NPT,LAYER,
        KSPT,KSTEP,KINC,NDI,NSHR,COORD,JMAC,JMATYP,MATLAYO,LACCFLA)
    ```

16. 必须定义和更新的变量，`FIELD(NFIELD)`，场变量数组，包含了当前积分点上的所有场变量，进入函数时其值为当前增量步开始时节点上值的插值。更新后的场变量的值会传入以下子程序：CREEP，HETVAL，UEXPAN，UHYPEL，UMAT，UMATHT和UTRS。

17. 可以定义和更新的变量：

    1. `STATEV(NSTATV)`，状态变量数组，包含了所有解依赖的状态变量，其值是当前增量步开始时的状态变量的值。

    2. PNEWDT，时间比， 建议的时间增量与当前使用的时间增量（dtime）的比值。

18. 除了上面提到的三个变量外，其他变量都是只读的，修改它们会出现功能错误。


## URDFIL

1. 用于在求解中读取结果文件。来设置下一步的增量大小，或者控制分析是否停止。会在每个增量结束时调用。必须在其中调用DBFILE工具函数来从结果文件中读取记录。可以调用POSFIL工具函数来从特定step和increment来读取结果，而不是从头开始读取。可以通过变量LSTOP在调用完成时强制分析终止。允许通过变量LOVRWRT覆盖写入结果文件的最后一个增量。

2. 使用场景：进行包含接触行为的结构分析时，为了避免求解不收敛，往往使用位移控制来取代力控制，然后通过输出的反力来获取结构的受力。在加载前是不知道特定的位移加载模式会造成的反力多少，不知道何时停止实验。或者想要知道结构某点发生特定位移或应力值的时候，外荷载的精确值，一般的分析中可能会跳过这个精确相等的点，使用URDFIL可以在快达到极限状态时及时调整下一个增量大小。或者在冲击实验中，不确定何时应该结束计算。

3. 实际上为了获取精确力或位移的情况，完全可以用重启动分析方法来解决，先进行粗糙分析，然后在特定分为内进行细化时间步的分析。相当于自适应网格划分在时间上的应用。

4. Explicit中可以利用field output的filter来监控分析结果，在特定的输出变量达到设定目标时就停止分析。而Standard中没有这个功能，因此可以使用URDFIL子程序来实现。

5. URDFIL从.fil文件中监控反力与位移，因此必须输出该文件。CAE目前不支持这么做，需要手动修改.inp文件或Edit keyword。

   ```shell
   *NODE FILE, FREQ=1, NSET=nsetname #FREQ=1表示在每个时间增量结束后都输出一次结果，这样高频的输出只是为了URDFIL使用，如果只是用户观察，没必要这么高频率。NSET指定为特定节点集合输出，否则会为所有节点输出。
   RF, U
   ```

6. 读写参数：

   1. LSTOP，指示是否应继续分析的标志。如果为1，则分析将终止。否则，分析将继续。

   2. LOVRWRT，表示写入增量结果文件的信息可以被覆盖的标志。

   3. DTIME，此变量允许为自动时间增量算法提供输入（如果选择了自动时间增量）。作为下一个要取的时间增量的值传递，可以更新以增加或减少时间增量，一般没必要修改。可以指定为负值。

   4. NSTEP，通过DBFILE进行文件读取的特定分析步编号。如果为0，则将读取第一个可用步骤。

   5. NINC，通过DBFILE进行文件读取的分析步内的特定增量编号。如果为0，则将读取指定步骤的第一个可用增量。

7. 只读参数：

   1. KSTEP，当前分析步编号。
   2. KINC，当前增量编号。
   3. TIME(1)，增量结束时的step time。
   4. TIME(2)，增量结束时的total time。

8. 如下例子从结果文件中的记录12中读取当前增量的Mises应力值，如果超过2.09×10^8，则终止分析。其中，POSFIL用于在fil文件中定位，来读取当前增量的结果，而非每次从头开始读取。

   ```fortran
   SUBROUTINE URDFIL(LSTOP,LOVRWRT,KSTEP,KINC,DTIME,TIME)
       INCLUDE 'ABA_PARAM.INC'
       DIMENSION ARRAY(513),JRRAY(NPRECD,513),TIME(2)
       EQUIVALENCE (ARRAY(1),JRRAY(1,1))
       PARAMETER(TOL=2.09D8)
   !FIND CURRENT INCREMENT.
       CALL POSFIL(KSTEP,KINC,ARRAY,JRCD) !如果要读取当前增量的结果，就将KSTEP和KINC作为参数传入。
       DO K1=1,999999
          CALL DBFILE(0,ARRAY,JRCD)
          IF (JRCD .NE. 0) GO TO 110
          KEY=JRRAY(1,2)
   !RECORD 12 CONTAINS VALUES FOR SINV
          IF (KEY.EQ.12) THEN
             IF (ARRAY(3).GT.TOL) THEN
                LSTOP=1
                GO TO 110
             END IF
          END IF
       END DO
   110  CONTINUE
       RETURN
       END
   ```


## UEL

1. 单元的性能决定了它可模拟计算的问题和可扩展的空间，ABAQUS为用户提供了用户自定义单元的程序接口，允许用户自定义地实现线性和非线性的单元，可以定义任意复杂度的任何单元，使得用户可以方便地对ABAQUS的功能进行扩展，以满足复杂的个性化求解需求。

2. 对于一些耦合了力学行为的物理过程，载荷和求解的结果有关；在求解的过程中激活控制机制等的问题，ABAQUS现有的单元库还无法满足分析需求，需要我们编写用户子程序来实现。

3. 相比于写一个完整的有限元求解程序，在一些现有程序的基础上（如ABAQUS）编写用户单元可以大大降低开发成本、缩短开发时间，并且可以充分利用ABAQUS提供的强大的前后处理能力。此外，ABAQUS内置的求解器的效率非常高，求解非线性问题具有很好的收敛性，这也使得用户单元子程序具有非常广的应用前景。

4. 多个用户单元可以在单个模型中一起使用，其使用方法与多个UMAT在同一个模型中一起使用是类似的，只需给每个单元一个特定的名称，然后定义其在inp文件中对应的UEL的变量property即可。

5. 定义用户单元的方式：
   1. 线性单元，在Standard中，可以通过直接使用关键字*MATRIX在.inp文件中定义单元的刚度矩阵和质量矩阵，从而可以定义一个线性的用户单元（无须写编用户子程序）。

   2. 任意单元，在Standard中，可通过UEL或UELMAT来定义任意单元；在Explicit中，可通过VUEL来实现非线性单元。

6. 在Standard中，有两个用户单元的接口程序：UELMAT可以直接访问ABAQUS内置的材料模型，这样用户就不需要自己去编写材料的本构关系了。但是，UELMAT支持的分析步类型比UEL少，此时我们只能通过UEL来实现。
7. 在使用UEL或UELMAT之前，需要在.inp文件中定义以下单元信息：
   1. 用户单元的节点数
   2. 每个节点的坐标数
   3. 每个节点激活的自由度
   4. 单元的属性参数的个数
   5. 每个单元中需要存储的解依赖的状态变量（SDV）的个数
   6. 单元可用载荷类型的个数

8. 

## Sensor和UAMP

1. 要想在ABAQUS中建立一个逻辑运算模型，功能类似于matlab的simulink。需要有以下几个部分：

   1. 有一个常规的力学分析的有限元模型，该模型可以独立进行正常的力学计算。
   2. 在该模型的基础上，建立以下三个模块：
      1. 传感器Sensor，用于获取模型的实时状态，将数据输出给控制器。
      2. 控制系统，根据传感器的输入和控制算法来决定激励大小，这部分需要通过UAMP或VUAMP来实现。
      3. 激励器Amplitude，根据控制器来做出指定的动作，例如调整载荷。

2. 传感器数据是控制器的输入，控制器的输出是激励器，利用控制器在传感器和激励器之间建立连接和反馈调整的机制。

3. 应用：

   1. 板件深压成型，根据模具侧边支撑力的大小适时调整冲压力的大小，压力太大容易引起板件撕裂，此时应该减少支撑力，压力太小容易发生褶皱，此时应该增大支撑力。
   2. 倒立摆，根据杆顶部相对与杆底部的位置（需要2个传感器），来决定底部物体的运动或施加其上的荷载。一般要使用PID算法来控制。

4. 通常情况下，可以在一个模型中使用多个传感器，每个传感器都会和一个特定的标量输出（如U1、RF3等）建立关联，同时需要给每个传感器起一个独一无二的名字，以便能够在UAMP中找到它。

5. 每个传感器只能与一个单元（或节点）相关联，也可以是只包含一个单元或节点的集合。

6. 定义Sensor的两种方式：

   1. .inp文件中：

      ```shell
      *OUTPUT, HISTORY, SENSOR, NAME=Horiz_Transl_motion #创建了一个历史输出请求，将它和一个名为Horiz_Transl_motion传感器关联。
      *ELEMENT OUTPUT, ELSET=SR-SS_CnSet #在历史输出内指明要输出单元集合（只能有一个单元）SR-SS_CnSet中单元的数据，此时传感器就和该单元集合建立了关联。
      ```

   2. 在CAE中，Edit History Output Request→勾选Include sensor when avaliable。

7. 定义Amplitude的两种方式：

   1. .inp文件中：

      ```shell
      *AMPLITUDE, DEFINITION=USER, NAME=MOTOR_WITH_STOP_SENSOR, VARIABLES=2, PROPERTIES=3 #定义了一个名为MOTOR_WITH_STOP_SENSOR的AMPLITUDE，指示通过UAMP获取值。该AMPLITUDE有2个状态变量，可以随时间变化，类似于UMAT，但是互相独立。还有2个属性，不能随时间变化，也类似于UMAT。
      7.5d4, 1.0, 5.5e6
      #在*STEP内
      BOUNDARY, TYPE=VELOCITY, AMPLITUDE=MOTOR_WITH_STOP_SENSOR #定义速度边界，幅值使用上边定义的MOTOR_WITH_STOP_SENSOR。
      ```

   2. 在CAE中，Create Amplitude（输入名称）→User，选择合适的变量个数。

8. 定义完成Sensor和Amplitude后，就可以通过UAMP或VUAMP来定义Amplitude的值，从而控制荷载或边界条件了。和普通的Amplitude不同，这里还可以参考Sensor的值来完成反馈控制。

9. UAMP和VUAMP可以完成以下功能：

   1. 定义一个依赖于时间的幅值曲线。
   2. 定义一个依赖于给定数量的状态变量的幅值曲线。
   3. 如果模型中使用了传感器，则可以给出依赖于传感器值得幅值曲线。
   4. 计算幅值曲线的导数和积分，曲线为将所有点用折线连接起来的结果。

10. 传入UAMP的所有信息或要更新的数据都是该增量开始时的值。

11. 例子：

    ```fortran
          SUBROUTINE UAMP( !UAMP的主要功能就是定义AmpValueNew的值，即当前时刻的幅值
        * ampName, time, ampValueOld, dt, nProps, props, nSvars,
        * svars, lFlagsInfo,
        * nSensor, sensorValues, sensorNames, jSensorLookUpTable,
        * AmpValueNew,lFlagsDefine,
        * AmpDerivative, AmpSecDerivative, AmpIncIntegral,AmpDoubleIntegral)
    !定义了一些常数，用于索引数组
          parameter (iInitialization = 1,iRegularInc = 2,iCuts = 3,ikStep = 4,nFlagsInfo = 4) !对lFlagsInfo(nFlagsInfo)数组进行索引
          parameter (iComputeDeriv = 1,iComputeSecDeriv = 2,iComputeInteg = 3,iComputeDoubleInteg = 4,iStopAnalysis = 5,iConcludeStep = 6,nFlagsDefine = 6) !对lFlagsDefine(nFlagsDefine)数组进行索引
    ```

12. 必须更新的变量AmpValueNew。

13. 可以被定义和赋值的变量，`lFlagsDefine(nFlagsDefine)`：整数数组，用于决定是否需要额外计算并提供一些变量的值以及提供分析的连续性需求。该数组中每个值的含义如下：

    1. iComputeDeriv，为1表示子程序的编写者必须提供幅值的导数（AmpDerivative），为0（默认值），则ABAQUS会计算幅值的导数。
    2. iComputeSecDeriv，为1表示子程序的编写者必须提供幅值的二阶导数（AmpSecDerivative），为0（默认值），则ABAQUS会计算幅值的二阶导数。
    3. iComputeInteg，为1表示子程序的编写者必须提供幅值的增量积分（AmpIncIntegral），为0（默认值），则ABAQUS会计算幅值的积分。
    4. iComputeDoubleInteg，为1表示子程序的编写者必须提供幅值的二次积分（AmpDoubleIntegral），为0（默认值），则ABAQUS会计算幅值的积分。
    5. iStopAnalysis，为1表示分析终止，并抛出一个错误信息。为0（默认值），则ABAQUS不会终止分析。
    6. iConcludeStep，为1，则结束当前分析步进入下一个分析步（如果有的话）。为0（默认值），则ABAQUS不会结束当前分析步。

14. 有些时候，abaqus会请求幅值的导数或积分，而非本身（因为只给定特定点的值，不足以刻画出点之间的过渡，这些需要用导数给出，会自动算出），此时会根据lFlagsDefine数组中对应项的设置，来决定使用用户提供的值，还是由abaqus自己计算。

15. ampName为幅值的名称。

16. ampValueOld为上一个增量步开始时的幅值。

17. sensorValues(nSensor)，模型中可用的传感器数据的数组，存储的上一增量步结束时传感器的值，和ampValueOld不同的是，这里是上一步结束时的值，因为上一步已经计算完成了，因此可以得到。

18. 每个传感器值对应于与定义传感器的输出数据库请求相关联的历史输出变量。

19. sensorNames，整个模型中用户定义的传感器名称数组，左对齐。如果定义中使用了小写或大小写混合字符，则所有名称都将转换为大写字符。

20. jSensorLookUpTable，是需要传递给IGETSENSORID和GETSENSORVALUE的参数。

21. svars(nSvars)，存储和这个幅值定义关联的状态变的量数组。

22. props(nProps)，和这个幅值定义关联的常数数组。

23. `lFlagsInfo(nFlagsInfo)`：整数标志数组，包含当前对UAMP调用的信息：

    1. iInitialization，为1表示从第一个分析步骤的初始化阶段调用。
    2. iRegularInc，为1表示在常规增量步中调用。
    3. iCuts，本次增量中的cutback次数。每次的cutback对应一次的不收敛，一般是因为增量步长太大了，这个数据可以用于调整增量大小。
    4. ikStep，分析步编号，因为荷载或边界条件是可以横跨多个分析步的，通过这个参数可以决定在不同的分析步取不同的值。

24. UAMP和VUAMP的接口（子程序参数的名称、顺序和意义）完全相同。

25. 使用GETSENSORVALUE来查询传感器的值，使用IGETSENSORID来查询传感器的ID，这两个函数用于Standard，只能在UAMP中调用：

    ```fortran
    !给定用户定义的传感器名称，此程序可使用高效的搜索技术获得传感器ID或值。
    character*80 mySensorName !要查询的传感器名称
    !第一种使用方式，根据名称找到ID(也就是数组下标)，然后数组中使用ID获取传感器的值。
    iMySensorID = IGETSENSORID(mySensorName, jSensorLookUpTable) !获取传感器的ID，第二个参数是UAMP的参数，指向包含传感器二叉树查找表的对象的指针，直接传入即可。
    dMySensorValue = sensorValues(iMySensorID) !从数组中获取传感器的值。
    !第二种使用方式，根据名称直接查询值，推荐使用。
    dMySensorValue = GETSENSORVALUE(mySensorName, jSensorLookUpTable, sensorValues)
    ```

26. 由于通过传感器，只能获取当前值，不能获取历史值，因此如果要计算传感器值的导数，可以在状态变量中存储每次的值，以便下次使用。

## 用C/C++编写子程序

1. 首先需要在源文件中包含下面的语句。将所有的ABAQUS子程序名包含到FOR_NAME宏中使用。这些用户子程序都通过下面的方法来连接它的接口，进行相应的数据传递。在此以用户子程序UMAT为例，通过下面的代码来访问用户子程序UMAT的C＋＋语言接口：

   ```c++
   #include <aba_for_c.h>
   ```
   
2. Standard和Explicit都支持使用C++语言编写子程序。但是在ABAQUS2020中仍然不支持直接在CAE中指定.cpp扩展名的子程序，因此只能通过命令行的参数`user=xxx.cpp`来指定使用C++子程序。

3. 因此，在编写子程序时需要注意C++语言用户子程序与Fortran语言用户子程序的区别。其中，有两个重要的区别需要特别关注，分别是：

   1. 对于二维数组在内存中的存储，在C++语言中是行优先，而在Fortran语言中则是列优先。
   2. C++语言中数组的下标从0开始计数，而Fortran语言中则从1开始计数。

4. 可以在子程序中使用外部库，安装完库之后，还需要配置，这里以blas和lapack为例：

   1. 修改abaqus_v6.env中的link_sl变量，在其末尾添加两个文件名：blas_win64_MT.lib和lapack_win64_MT.lib。
   2. 将文件blas_win64_MT.lib 和lapack_win64_MT.lib 复制到VS的cpp库中，具体目录为`C:/ProgramFiles(x86)/Microsoft Visual Studio 11.0/VC/lib/amd64`。
   3. 将对应的两个.dll文件复制到system32目录中，或者将所在路径添加到path中。

5. 要想在C++的子程序中调用实用子程序Utility，需要先在用户子程序外部声明被调用的实用子程序Utility。

   ```c++
   extern "C" void NameOfUtility_(parameters)
   ```

6. 对于比较复杂大型的代码，C++语言丰富的库函数非常有优势。

# Mises UMAT

1. 获取官方的例子，在Abaqus Verification Guide的4.1.21，使用

   ```shell
   #分别获取inp文件和对应的UMAT源文件。
   abaqus fetch job=umatmst3.inp
   abaqus fetch job=umatmst3.f
   ```

2. 如下是应用了J2塑性的Prandtl-Reuss模型，有3个基本假设：小变形，增量理论（描述塑性应变增量与应力增量的关系），关联流动法则（塑性应变增量方向与屈服面的法线方向一致，同时塑性势函数g和屈服函数f相同）。

3. 塑性势函数g：用于确定塑性应变增量的方向。$d\varepsilon^p=d\lambda\cdot\frac{\partial g}{\partial \sigma}$​。

4. 屈服函数f：定义了材料在应力空间中开始发生塑性变形的条件。

5. 对于关联流动的情况，屈服函数一般会包含一个常数项，而塑性势函数则不包含，因为前者会具体计算函数值，后者只是求导，因此常数项没有用。

6. 强化法则为各向同性。

7. 总应变可以分解为弹性和塑性部分：$\varepsilon=\varepsilon^e+\varepsilon^p$，其中弹性应变为$\sigma/E$。因此$\sigma=E(\varepsilon-\varepsilon^p)$。

8. 后继屈服段称为应变硬化strain hardening，假定后继屈服应力（流动应力）是塑性应变的函数$\sigma_y=f(\varepsilon^p)$。

9. 理想弹塑性材料，没有硬化段，因为流动应力不会提高，因此对于循环加载，各向同性强化和运动强化没有区别。材料的塑性定义中，只有一行。

10. 双线性（$E$和$E_t$）材料的流动应力复合线性强化模型：$\sigma_y=\sigma_{y0}+H\varepsilon_p$。H为强化参数，$\varepsilon_p$是等效塑性应变。$1/H=1/E_t-1/E$。

11. 单轴拉伸时，只需比较$\sigma$和$\sigma_y$即可确定是否是屈服状态，类比单轴拉伸的情况，多轴时使用等效应力$\sigma_e$代替单轴拉伸的应力，使用等效塑性应变增量$d\varepsilon_p$代替单轴拉伸的塑性应变增量$d\varepsilon^p$。之所以在应变处使用增量或率，是因为要增量地求解问题。

12. 偏应力张量$s=\sigma-pI$，$p=\text{tr}(\sigma)/3$。其第二不变量$J_2=\frac{1}{2}s:s^T=\frac{1}{2}s:s$，因为$s$是对称的。

13. $\sigma_e=\sqrt{\frac{3}{2}s:s}=\sqrt{3J_2}$。等效应力和$J_2$有关，因此也称为$J_2$塑性。系数$\frac{3}{2}$可以通过单轴拉伸的情况来验证，同时将$\sigma_e$取为轴向应力$\sigma$，计算$J_2=\frac{1}{3}\sigma^2$。

14. 由于Mises准则认为材料的塑性变形只有剪切变形，没有体积变形，此时为不可压缩的，塑性应变的泊松比为0.5，因此$d\varepsilon^p$的迹为0，因此累加起来后导致$\text{tr}(\varepsilon^p)=0$，即塑性应变张量是个偏张量。而且该准则适用于拉压性能相同的材料。

15. $d\varepsilon_p = \sqrt{\frac{2}{3}d\varepsilon^p:d\varepsilon^p}$。系数$\frac{2}{3}$可以通过单轴拉伸的情况来验证，注意这里和应力的情况不同，系数为2/3，此时另外两个方向的应变均为-0.5轴向应变，不为0。将这三个量带入最开始的式子，可得$d\varepsilon_p=d\varepsilon^p$。

16. 屈服准则为：$f=\sigma_e-\sigma_y$。其中流动应力$\sigma_y$与等效塑性应变$\varepsilon_p$有关。

17. 使用正交流动假设，获得$d\varepsilon^p$的方向，$d\varepsilon^p=d\lambda \cdot n$，$n_{ij} = \frac{\partial f}{\partial \sigma_{ij}}$，并非单位长度的（因为二阶张量也无法谈论长度），只是一般的梯度。由于$f$的第二项不是$\sigma$的函数，因此$n = \frac{\partial \sigma_e}{\partial \sigma}=\frac{3}{2}\frac{s}{\sigma_e}$，使用链式法则即可，可以看出这里$n$是一个二阶张量。

18. 将$d\varepsilon^p=d\lambda \frac{3}{2}\frac{\acute{\sigma}}{\sigma_e}$，带入$d\varepsilon_p = \sqrt{\frac{2}{3}d\varepsilon^p:d\varepsilon^p}$得：

19. $d\varepsilon_p=\sqrt{\frac{2}{3}d\lambda\frac{3}{2}\frac{s}{\sigma_e}:d\lambda\frac{3}{2}\frac{s}{\sigma_e}}=\frac{d\lambda}{\sigma_e}\sqrt{\frac{3}{2}s:s}=d\lambda$，可得出$d\lambda = d\varepsilon_p$。因此$d\varepsilon^p=d\varepsilon_p \frac{3}{2}\frac{s}{\sigma_e}$。

20. 由一致性条件，可求得$d\varepsilon_p$的大小。$f=\sigma_e(\sigma)-\sigma_y(\varepsilon_p)$。$df(\sigma,\varepsilon_p)= \frac{\partial f}{\partial \sigma}:d\sigma+\frac{\partial f}{\partial \varepsilon_p}d\varepsilon_p=0$。根据线性强化本构关系，$\frac{\partial f}{\partial \varepsilon_p}=H$。根据正交流动假设$\frac{\partial f}{\partial \sigma}=n$。

21. 由$d\sigma = C:d\varepsilon^e=C:(d\varepsilon-d\varepsilon^p)=C:(d\varepsilon-d\varepsilon_p\cdot n)$。

22. 推出，$d\varepsilon_p = \frac{n:C:d\varepsilon}{n:C:n-\frac{\partial f}{\partial \varepsilon_p}}=\frac{n:C:d\varepsilon}{n:C:n-H}$。

23. 数值求解是增量进行的，步骤如下：

    1. 首先已知量为：第$k$步开始时（也是$k-1$步结束时）的总应变$\varepsilon_k$，等效塑性应变$\varepsilon_{p,k}$，总应力$\sigma_k$。还知道下一步的应变增量$\Delta\varepsilon$。需要计算的是第$k+1$步结束时的上述四个量。
    1. 因此需要将应变增量$\Delta\varepsilon$分解为弹性$\Delta\varepsilon^e$和塑性$\Delta\varepsilon^p$部分。使用图返回算法Return Mapping。
    1. 弹性应变增量和应力增量的计算有关，因为$\sigma=C:\varepsilon^e$，这个对弹性和塑性状态都成立，其增量形式也成立：$\Delta\sigma=C:\Delta\varepsilon^e$。
    1. 如果线弹性材料是各向同性的，此时C可以由2个Lame参数确定$\lambda,\mu=G$，带入可得：$\sigma=2G\varepsilon^e+\lambda\text{tr}(\varepsilon^e)I$。
    1. 上式在任何时候都成立，取第$k+1$步开始时刻，$\sigma_{k+1}=2G\varepsilon_{k+1}^e+\lambda\text{tr}(\varepsilon_{k+1}^e)I$。根据增量关系，$\varepsilon_{k+1}^e=\varepsilon_k^e+\Delta\varepsilon^e=\varepsilon_k^e+\Delta\varepsilon-\Delta\varepsilon^p$。将此式子带入前式，由于塑性应变及其增量始终为偏状态张量，即$\text{tr}(\varepsilon^p)=\text{tr}(\Delta\varepsilon^p)=0$。
    1. 因此$\sigma_{k+1}=2G(\varepsilon_k^e+\Delta\varepsilon)+\lambda\text{tr}(\varepsilon_k^e+\Delta\varepsilon)I-2G\Delta\varepsilon^p$。将等号右侧的前两项称为试应力：$\sigma^{tr}=2G(\varepsilon_k^e+\Delta\varepsilon)+\lambda\text{tr}(\varepsilon_k^e+\Delta\varepsilon)I=\sigma_k+C:\Delta\varepsilon$。因为应力关系对于第$k$步开始时刻，也是成立的。等号右侧最后一项被称为塑性纠正项（plastic corrector）。
    1. 之所以称其为试应力（trial stress），或者弹性预测，是因为这里假设应变增量都是弹性的，即$\Delta\varepsilon=\Delta\varepsilon^e$。
    1. 因此$\sigma_{k+1}=\sigma^{tr}-2G\Delta\varepsilon^p$。
    1. 根据正交性假设，$d\varepsilon^p=d\varepsilon_p \frac{3}{2}\frac{s}{\sigma_e}$，将微分变为增量，$\Delta\varepsilon^p=\Delta\varepsilon_p \frac{3}{2}\frac{s}{\sigma_e}$​。
    1. 得到方程$\sigma_{k+1}=\sigma^{tr}-2G\Delta\varepsilon_p \frac{3}{2}\frac{s}{\sigma_e}$。其中$\sigma^{tr}$是已知的，$s,\sigma_e$都和$\sigma_{k+1}$有关。
    1. 分情况讨论：
         1. 如果$\sigma_k$是弹性状态（带入屈服函数，结果$<0$），且$\sigma^{tr}$也是弹性状态，那么说明没有塑性应变，不需要进行塑性纠正，此时$\sigma_{k+1}=\sigma^{tr}$。
         1. 如果$\sigma_k$是弹性或塑性状态，而$\sigma^{tr}$​是塑性状态（屈服面外），此时通过塑性纠正项，将应力点拉回到新的屈服面上。当然这里也要计算屈服面的变化，因此需要迭代计算。
    1. 因为最终状态$\sigma_{k+1}$是在新的屈服面上（带入屈服函数，结果$=0$）。求解第10条的6元方程组就可以得到$\sigma_{k+1}$。但是这里还可以简化为一元方程。
    1. 将方程左侧分解为$\sigma=s+pI$，移项合并后为$(1+3G\frac{\Delta\varepsilon_p}{\sigma_e})s=\sigma^{tr}-pI=s^{tr}$。最后一项偏试应力张量。
    1. 然后对上式两侧进行双缩并然后开平方，利用$A=B\to A:A=B:B$，和试应力的定义$\sigma_e=\sqrt{\frac{3}{2}s:s}$。可得$(1+3G\frac{\Delta\varepsilon_p}{\sigma^e})\sigma_e=\sigma^{tr}_e$，化简为$\sigma_e+3G\Delta\varepsilon_p=\sigma^{tr}_e$。这里还可以得出一个有用的结论，即$\frac{s}{\sigma_e}=\frac{s^{tr}}{\sigma^{tr}_e}$，即可以通过试应力来计算流动方向，因此$\Delta\varepsilon^p=\Delta\varepsilon_p \frac{3}{2}\frac{s^{tr}}{\sigma^{tr}_e}$。
    1. 将上述一元方程带入屈服条件得$f=\sigma_e-\sigma_y=\sigma^{tr}_e-3G\Delta\varepsilon_p-(\sigma_{y0}+H(\varepsilon_{p,k}+\Delta\varepsilon_p))$。其中$\varepsilon_{p,k}$表示$k$时刻开始时的等效塑性应变，运用一致性条件$f=0$，得$\Delta\varepsilon_p=\frac{\sigma^{tr}_e-\sigma_{y0}-H\varepsilon_{p,k}}{3G+H}$。
    1. 对于线性硬化问题，方程为线性（$f'$为常数，等于$-3G-H$​​）的，可以直接求解，不用迭代。
    1. 如果使用牛顿迭代法，为$x_{n+1}=x_n-\frac{f(x_n)}{f'(x_n)}$。这里$f=\sigma^{tr}_e-3G\Delta\varepsilon_p-\sigma_y$。$f'=-3G-H$，这里是对$\Delta\varepsilon_p$求导，因为$d\sigma_y/d\Delta\varepsilon_p=H$​。$x_n$的初始值可以设为0。
    1. 如果是分段线性硬化材料，则需要根据$\sigma$的值，来选择使用哪个$H$。
    1. 计算出等效塑性应变增量$\Delta\varepsilon^p$后，带入$\Delta\varepsilon^p=\Delta\varepsilon_p \frac{3}{2}\frac{s^{tr}}{\sigma^{tr}_e}$，得到塑性应变增量$\Delta\varepsilon^p$，更新塑性应变$\varepsilon^p_{k+1}=\varepsilon^p_k+\Delta\varepsilon^p$。
    1. 然后根据$\Delta\varepsilon^e=\Delta\varepsilon-\Delta\varepsilon^p$，得到弹性应变增量。
    1. 根据$\sigma_{k+1}=\sigma_k+C:\Delta\varepsilon^e$。或者使用试应力+塑性纠正方法计算$\sigma_{k+1}=\sigma^{tr}-2G\Delta\varepsilon^p$。
    1. ![image-20241108184030608](Abaqus.assets/image-20241108184030608.png)

24. 需要从UMAT函数的参数中读取状态变量，这里只有一个有效塑性应变，还有2个材料参数，初始屈服应力和线性强化的斜率参数。

25. UMAT中将应力张量使用voigt标记为列向量：$[\sigma_{11},\sigma_{22},\sigma_{33},\sigma_{12},\sigma_{13},\sigma_{23}]^T$。应变使用的是工程应变张量，即$[\varepsilon_{11},\varepsilon_{22},\varepsilon_{33},\gamma_{12},\gamma_{13},\gamma_{23}]=[\varepsilon_{11},\varepsilon_{22},\varepsilon_{33},2\varepsilon_{12},2\varepsilon_{13},2\varepsilon_{23}]^T$。对于线弹性材料，$\tau=G\gamma$。

26. 在Standard中需要计算雅可比矩阵$\frac{\partial \delta \sigma}{\partial \delta \varepsilon}$（实际是一个四阶张量）表示应变增量的改变对应力增量改变的影响。在UMAT中用二维数组$DDSDDE(i,j)$表示，也就是第i个应力分量的变分对第j个应变分量的变分的偏导数。

27. 使用它来计算刚度矩阵。因此只在standard中需要，在Explicit中，不需要计算DDSDDE。

28. 精确的雅可比矩阵可以使收敛更快。

29. 对于线弹性材料，$\sigma=C:\varepsilon$，变分为$\delta\sigma=C:\delta\varepsilon$。求偏导可得$DDSDDE=C$。

30. 对于各向同性强化的Mises塑性材料，步骤如下：

    1. 对$\sigma=s+pI$进行变分，$\delta\sigma=\delta s+\delta pI$。

    2. $\delta p=K\delta V=K\text{tr}(\delta\varepsilon^e)=K\text{tr}(\delta\varepsilon-\delta\varepsilon^p)$。由于$\text{tr}(\varepsilon^p)=0$，因此$\delta p=K\text{tr}(\delta\varepsilon)$，$\delta\sigma=\delta s+K\text{tr}(\delta\varepsilon)I$​。

    3. 现在寻找$\delta s$和$\delta\varepsilon$的关系，在推导Mises塑性时，获得了$(1+3G\frac{\Delta\varepsilon_p}{\sigma^e})s=s^{tr}$，对此变分可得：$(1+3G\frac{\Delta\varepsilon_p}{\sigma_e})\delta s+3G\frac{\delta\Delta\varepsilon_p}{\sigma_e}s-3G\frac{\Delta\varepsilon_p}{\sigma_e^2}\delta\sigma_es=\delta s^{tr}$。

    4. 还有一个公式，$\sigma_e+3G\Delta\varepsilon_p=\sigma^{tr}_e$，变分为$\delta\sigma_e+3G\delta\Delta\varepsilon_p=\delta\sigma^{tr}_e$。

    5. 根据屈服准则$f=\sigma_e-\sigma_y=0$，变分为$0=\delta f=\delta\sigma_e-H\delta\Delta\varepsilon_p$。

    6. 将$\Delta\varepsilon_p$，$\delta\Delta\varepsilon_p$和$\delta\sigma_e$带入第三步的式子。

31. 代码：

    ```fortran
          SUBROUTINE UMAT(STRESS,STATEV,DDSDDE,SSE,SPD,SCD,
         1 RPL,DDSDDT,DRPLDE,DRPLDT,
         2 STRAN,DSTRAN,TIME,DTIME,TEMP,DTEMP,PREDEF,DPRED,CMNAME,
         3 NDI,NSHR,NTENS,NSTATV,PROPS,NPROPS,COORDS,DROT,PNEWDT,
         4 CELENT,DFGRD0,DFGRD1,NOEL,NPT,LAYER,KSPT,JSTEP,KINC)
    C
          INCLUDE 'ABA_PARAM.INC'
    C
          CHARACTER*80 CMNAME
          DIMENSION STRESS(NTENS),STATEV(NSTATV),
         1 DDSDDE(NTENS,NTENS),DDSDDT(NTENS),DRPLDE(NTENS),
         2 STRAN(NTENS),DSTRAN(NTENS),TIME(2),PREDEF(1),DPRED(1),
         3 PROPS(NPROPS),COORDS(3),DROT(3,3),DFGRD0(3,3),DFGRD1(3,3),
         4 JSTEP(4)
    
    	  DIMENSION FLOW(NTENS),STRESST(NTENS),DPSTRAN(NTENS),DESTRAN(NTENS)
    
    	  PARAMETER (ZERO=0.D0,ONE=1.D0,TWO=2.D0,THREE=3.D0,SIX=6.D0,
    	  NEWTON=10,TOLER=1.0D-6)
    
          EMOD=PROPS(1)
          ENU=PROPS(2)
          EBULK3=EMOD/(ONE-TWO*ENU)
          EG2=EMOD/(ONE+ENU)
          EG=EG2/TWO
          EG3=EG*THREE
          ELAM=(EBULK3-EG2)/THREE
    
    C     CALCULATE DDSDDE
          DO K1=1,NDI
              DO K2=1,NDI
                  DDSDDE (K1,K2)= ELAM
              END DO
              DDSDDE(K1,K1)= ELAM+EG2
          END DO
    	   
          DO K1=NDI+1,NTENS
              DDSDDE(K1,K1)= EG
          END DO
    	   
    C     CALCULATE TRIAL STRESS
          DO K1=1,NTENS
              DO K2=1,NTENS
                   STRESST(K1) = STRESS(K1)+DDSDDE(K1,K2)*DSTRAN(K2)
              END DO
          END DO
    	   
    C     CALCULATE EFFECTIVE TRIAL STRESS
          SMISES = (STRESST(1)-STRESST(2))**2+(STRESST(2)-STRESST(3))**2+(STRESST(3)-STRESST(1))**2
          DO K1=NDI+1,NTENS
    	      SMISES = SMISES +SIX*STRESST(K1)**2
          END DO
          SMISES = SQRT(SMISES/TWO)
    
    C     CALCULATE YIELD FUNCTION ,Read state variable & properties
          EQPLAS = STATEV(1)
          SYIEL0 = PROPS(3)
          HARD = PROPS(4)
          SYIELD = SYIEL0+HARD*EQPLAS
          F = SMISES-SYIELD
          DEQPL=ZERO
    
          IF(F .GT. TOLER*SYIELD)THEN
          SHYDRO = (STRESST(1)+STRESST(2)+STRESST(3))/THREE
    
          DO K1=1,NDI
              FLOW(K1) = (STRESST(K1)-SHYDRO)/SMISES
          END DO
          DO K1=NDI+1,NTENS
              FLOW(K1) = STRESST(K1)/SMISES
          END DO
    C     ITERATIVE CALCULATION OF EFFECTIVE PLASTIC STRAIN INCREMENT
          RHS = SMISES-EG3*DEQPL-SYIELD
          DO WHILE(KEWTON .LT. NEWTON .AND. ABS(RHS) .GT. TOLER*SYIELD)
              SYIELD = SYIELD+HARD*DEQPL
              RHS = SMISES-EG3*DEQPL-SYIELD
              DDEQPL = RHS/(EG3+HARD)
              DEQPL = DEQPL+DDEQPL
              KEWTON = KEWTON+1
          END DO
          END IF
    
    C     UPDATE STRESS TENSOR
          DO K1=1,NTENS
              DPSTRAN(K1) = THREE/TWO*DEQPL*FLOW(K1)
          END DO
          DO K1=1,NTENS
              DESTRAN(K1) = DSTRAN(K1)-DPSTRAN(K1)
          END DO
          DO K1=1,NTENS
              DPSTRAN(K1) = THREE/TWO*DEQPL*FLOW(K1)
          END DO
          DO K1=1,NTENS
              DO K2=1,NTENS
                  STRESS(K1) = STRESS(K1)+DDSDDE(K1,K2)*DESTRAN(K2)
              END DO
          END DO
    
          EQPLAS = EQPLAS+DEQPL
          STATEV(1) = EQPLAS
    C     CALCULATE JACOBIAN MATRIX
          IF(F .GT. TOLER*SYIELD)THEN
              EFFG = EG*SYIELD/SMISES
              EFFG2 = TWO*EFFG
              EFFG3 = EFFG*THREE
              EFFLAM = (EBULK3-EFFG2)/THREE
              EFFHRD = EG3*HARD/(EG3+HARD)-EFFG3
              DO K1=1,NDI
                  DO K2=1,NDI
                      DDSDDE (K1,K2)= EFFLAM
                  END DO
                  DDSDDE(K1,K1)= EFFLAM+EFFG2
              END DO
    
              DO K1=NDI+1,NTENS
                  DDSDDE(K1) = EFFG
              END DO
              DO K1=1,NTENS
                  DO K2=1,NTENS
                      DDSDDE (K2,K1)= DDSDDE(K2,K1)+EFFHRD*FLOW(K2)*FLOW(K1)
                  END DO
              END DO
          END IF
    
          RETURN
          END
    ```

32. $\sigma_{new}=\sigma_{old}+DDSDDE.\Delta\varepsilon$。应力更新公式，矩阵形式的操作。使用初始应力和应变增量来计算结果应力。

# Standard单元库

1. 梁单元：

   ```shell
   #平面，一次梁
   B21    2-node linear beam in a plane
   B21H   2-node linear beam in a plane, hybrid formulation
   #平面，二次梁
   B22    3-node quadratic beam in a plane
   B22H   3-node quadratic beam in a plane, hybrid formulation
   #平面，三次梁
   B23    2-node cubic beam in a plane
   B23H   2-node cubic beam in a plane, hybrid formulation
   #空间，一次梁
   B31    2-node linear beam in space
   B31H   2-node linear beam in space, hybrid formulation
   B31OS  2-node linear open-section beam in space
   B31OSH 2-node linear open-section beam in space, hybrid formulation
   #空间，二次梁
   B32    3-node quadratic beam in space
   B32H   3-node quadratic beam in space, hybrid formulation
   B32OS  3-node quadratic open-section beam in space
   B32OSH 3-node quadratic open-section beam in space, hybrid formulation
   #空间，三次梁
   B33    2-node cubic beam in space
   B33H   2-node cubic beam in space, hybrid formulation
   ```

2. 连续体单元：

   ```shell
   #线性，四面体
   C3D4	4-node linear tetrahedron
   C3D4E	4-node linear piezoelectric tetrahedron
   C3D4H	4-node linear tetrahedron, hybrid, linear pressure
   C3D4P	4-node linear coupled pore pressure element
   C3D4T	4-node thermally coupled tetrahedron, linear displacement and temperature
   #线性，三棱柱
   C3D6	6-node linear triangular prism
   C3D6E	6-node linear piezoelectric triangular prism
   C3D6H	6-node linear triangular prism, hybrid, constant pressure
   C3D6P	6-node linear coupled pore pressure element
   C3D6T	6-node thermally coupled triangular prism, linear displacement and temperature
   #线性，六面体
   C3D8	8-node linear brick
   C3D8E	8-node linear piezoelectric brick
   C3D8H	8-node linear brick, hybrid, constant pressure
   C3D8HT	8-node thermally coupled brick, trilinear displacement and temperature, hybrid, constant pressure
   C3D8I	8-node linear brick, incompatible modes
   C3D8IH	8-node linear brick, hybrid, linear pressure, incompatible modes
   C3D8P	8-node brick, trilinear displacement, trilinear pore pressure
   C3D8PH	8-node brick, trilinear displacement, trilinear pore pressure, hybrid, constant pressure
   C3D8PHT	8-node brick, trilinear displacement, trilinear pore pressure, trilinear temperature, hybrid, constant pressure
   C3D8PT	8-node brick, trilinear displacement, trilinear pore pressure, trilinear temperature
   C3D8R	8-node linear brick, reduced integration, hourglass control
   C3D8RH	8-node linear brick, hybrid, constant pressure, reduced integration, hourglass control
   C3D8RHT	8-node thermally coupled brick, trilinear displacement and temperature, reduced integration, hourglass control, hybrid, constant pressure
   C3D8RP	8-node brick, trilinear displacement, trilinear pore pressure, reduced integration
   C3D8RPH	8-node brick, trilinear displacement, trilinear pore pressure, reduced integration, hybrid, constant pressure
   C3D8RPHT 8-node brick, trilinear displacement, trilinear pore pressure, trilinear temperature, reduced integration, hybrid, constant pressure
   C3D8RPT	8-node brick, trilinear displacement, trilinear pore pressure, trilinear temperature, reduced integration
   C3D8RT	8-node thermally coupled brick, trilinear displacement and temperature, reduced integration, hourglass control
   C3D8T	8-node thermally coupled brick, trilinear displacement and temperature
   #二次，四面体
   C3D10	10-node quadratic tetrahedron
   C3D10E	10-node quadratic piezoelectric tetrahedron
   C3D10H	10-node quadratic tetrahedron, hybrid, constant pressure
   C3D10I	10-node general-purpose quadratic tetrahedron, improved surface stress visualization
   C3D10M	10-node modified tetrahedron, hourglass control
   C3D10MH	10-node modified quadratic tetrahedron, hybrid, linear pressure, hourglass control
   C3D10MHT 10-node thermally coupled modified quadratic tetrahedron, hybrid, linear pressure, hourglass control
   C3D10MP	10-node modified displacement and pore pressure tetrahedron, hourglass control
   C3D10MPH 10-node modified displacement and pore pressure tetrahedron, hybrid, linear pressure, hourglass control
   C3D10MPT 10-node modified displacement, pore pressure, and temperature tetrahedron, linear pressure, hourglass control
   C3D10MT	10-node thermally coupled modified quadratic tetrahedron, hourglass control
   #二次，三棱柱
   C3D15	15-node quadratic triangular prism
   C3D15E	15-node quadratic piezoelectric triangular prism
   C3D15H	15-node quadratic triangular prism, hybrid, linear pressure
   C3D15V	15 to 18-node triangular prism
   C3D15VH	15 to 18-node triangular prism, hybrid, linear pressure
   #二次，六面体
   C3D20	20-node quadratic brick
   C3D20E	20-node quadratic piezoelectric brick
   C3D20H	20-node quadratic brick, hybrid, linear pressure
   C3D20HT	20-node thermally coupled brick, triquadratic displacement, trilinear temperature, hybrid, linear pressure
   C3D20P	20-node brick, triquadratic displacement, trilinear pore pressure
   C3D20PH	20-node brick, triquadratic displacement, trilinear pore pressure, hybrid, linear pressure
   C3D20R	20-node quadratic brick, reduced integration
   C3D20RE	20-node quadratic piezoelectric brick, reduced integration
   C3D20RH	20-node quadratic brick, hybrid, linear pressure, reduced integration
   C3D20RHT 20-node thermally coupled brick, triquadratic displacement, trilinear temperature, hybrid, linear pressure, reduced integration
   C3D20RP	20-node brick, triquadratic displacement, trilinear pore pressure, reduced integration
   C3D20RPH 20-node brick, triquadratic displacement, trilinear pore pressure, hybrid, linear pressure, reduced integration
   C3D20RT	20-node thermally coupled brick, triquadratic displacement, trilinear temperature, reduced integration
   C3D20T	20-node thermally coupled brick, triquadratic displacement, trilinear temperature
   #二次，六面体，节点数量可变
   C3D27	21 to 27-node brick
   C3D27H	21 to 27-node brick, hybrid, linear pressure
   C3D27R	21 to 27-node brick, reduced integration
   C3D27RH	21 to 27-node brick, hybrid, linear pressure, reduced integration
   ```

3. 轴对称单元：

   ```shell
   #线性，三角形
   CAX3	3-node linear axisymmetric triangle
   CAX3E	3-node linear axisymmetric piezoelectric triangle
   CAX3H	3-node linear axisymmetric triangle, hybrid, constant pressure
   CAX3T	3-node axisymmetric thermally coupled triangle, linear displacement and temperature
   #线性，四边形
   CAX4	4-node bilinear axisymmetric quadrilateral
   CAX4E	4-node bilinear axisymmetric piezoelectric quadrilateral
   CAX4H	4-node bilinear axisymmetric quadrilateral, hybrid, constant pressure
   CAX4HT	4-node axisymmetric thermally coupled quadrilateral, bilinear displacement and temperature, hybrid, constant pressure
   CAX4I	4-node bilinear axisymmetric quadrilateral, incompatible modes
   CAX4IH	4-node bilinear axisymmetric quadrilateral, hybrid, linear pressure, incompatible modes
   CAX4P	4-node axisymmetric quadrilateral, bilinear displacement, bilinear pore pressure
   CAX4PH	4-node axisymmetric quadrilateral, bilinear displacement, bilinear pore pressure, hybrid, constant pressure
   CAX4PT	4-node axisymmetric quadrilateral, bilinear displacement, bilinear pore pressure, bilinear temperature
   CAX4R	4-node bilinear axisymmetric quadrilateral, reduced integration, hourglass control
   CAX4RH	4-node bilinear axisymmetric quadrilateral, hybrid, constant pressure, reduced integration, hourglass control
   CAX4RHT	4-node thermally coupled axisymmetric quadrilateral, bilinear displacement and temperature, reduced integration, hourglass control
   CAX4RP	4-node axisymmetric quadrilateral, bilinear displacement, bilinear pore pressure, reduced integration
   CAX4RPH	4-node axisymmetric quadrilateral, bilinear displacement, bilinear pore pressure, hybrid, constant pressure, reduced integration
   CAX4RPHT 4-node axisymmetric quadrilateral, bilinear displacement, bilinear pore pressure, bilinear temperature, hybrid, constant pressure, reduced integration
   CAX4RPT	4-node axisymmetric quadrilateral, bilinear displacement, bilinear pore pressure, bilinear temperature, reduced integration
   CAX4RT	4-node thermally coupled axisymmetric quadrilateral, bilinear displacement and temperature, hybrid, constant pressure, reduced integration, hourglass control
   CAX4T	4-node axisymmetric thermally coupled quadrilateral, bilinear displacement and temperature
   #二次，三角形
   CAX6	6-node quadratic axisymmetric triangle
   CAX6E	6-node quadratic axisymmetric piezoelectric triangle
   CAX6H	6-node quadratic axisymmetric triangle, hybrid, linear pressure
   CAX6M	6-node modified axisymmetric triangle, hourglass control
   CAX6MH	6-node modified quadratic axisymmetric triangle, hybrid, linear pressure, hourglass control
   CAX6MHT	6-node modified axisymmetric thermally coupled triangle, hybrid, linear pressure, hourglass control
   CAX6MP	6-node modified displacement and pore pressure axisymmetric triangle, hourglass control
   CAX6MPH	6-node modified displacement and pore pressure axisymmetric triangle, hybrid, linear pressure, hourglass control
   CAX6MT	6-node modified axisymmetric thermally coupled triangle, linear pressure, hourglass control
   #二次，四边形
   CAX8	8-node biquadratic axisymmetric quadrilateral
   CAX8E	8-node biquadratic axisymmetric piezoelectric quadrilateral
   CAX8H	8-node biquadratic axisymmetric quadrilateral, hybrid, linear pressure
   CAX8HT	8-node axisymmetric thermally coupled quadrilateral, biquadratic displacement, bilinear temperature, hybrid, linear pressure
   CAX8P	8-node axisymmetric quadrilateral, biquadratic displacement, bilinear pore pressure
   CAX8PH	8-node axisymmetric quadrilateral, biquadratic displacement, bilinear pore pressure, hybrid, linear pressure
   CAX8R	8-node biquadratic axisymmetric quadrilateral, reduced integration
   CAX8RE	8-node biquadratic axisymmetric piezoelectric quadrilateral, reduced integration
   CAX8RH	8-node biquadratic axisymmetric quadrilateral, hybrid, linear pressure, reduced integration
   CAX8RHT	8-node axisymmetric thermally coupled quadrilateral, biquadratic displacement, bilinear temperature, hybrid, linear pressure, reduced integration
   CAX8RP	8-node axisymmetric quadrilateral, biquadratic displacement, bilinear pore pressure, reduced integration
   CAX8RPH	8-node axisymmetric quadrilateral, biquadratic displacement, bilinear pore pressure, hybrid, linear pressure, reduced integration
   CAX8RT	8-node axisymmetric thermally coupled quadrilateral, biquadratic displacement, bilinear temperature, reduced integration
   CAX8T	8-node axisymmetric thermally coupled quadrilateral, biquadratic displacement, bilinear temperature
   #非线性轴对称
   CAXA4N     Bilinear asymmetric-axisymmetric, Fourier quadrilateral with 4 nodes per r–z plane
   CAXA4HN    Bilinear asymmetric-axisymmetric, Fourier quadrilateral with 4 nodes per r–z plane, constant Fourier pressure, hybrid
   CAXA4RN    Bilinear asymmetric-axisymmetric, Fourier quadrilateral with 4 nodes per r–z plane, reduced integration in r–z planes, hourglass control
   CAXA4RHN   Bilinear asymmetric-axisymmetric, Fourier quadrilateral with 4 nodes per r–z plane, constant Fourier pressure, hybrid, reduced integration in r–z planes
   CAXA8N     Biquadratic asymmetric-axisymmetric, Fourier quadrilateral with 8 nodes per r–z plane
   CAXA8HN    Biquadratic asymmetric-axisymmetric, Fourier quadrilateral with 8 nodes per r–z plane, linear Fourier pressure, hybrid
   CAXA8PN    Biquadratic asymmetric-axisymmetric, Fourier quadrilateral with 8 nodes per r–z plane, bilinear Fourier pore pressure
   CAXA8RN    Biquadratic asymmetric-axisymmetric, Fourier quadrilateral with 8 nodes per r–z plane, reduced integration in r–z planes
   CAXA8RHN   Biquadratic asymmetric-axisymmetric, Fourier quadrilateral with 8 nodes per r–z plane, linear Fourier pressure, hybrid, reduced integration in r–z planes
   CAXA8RPN   Biquadratic asymmetric-axisymmetric, Fourier quadrilateral with 8 nodes per r–z plane, bilinear Fourier pore pressure, reduced integration in r–z planes
   ```

4. 圆柱棱柱体单元，母线是曲线的棱柱体，分为三棱柱和四棱柱。

   ```shell
   #线性，三角形
   CCL9	9-node cylindrical prism
   CCL9H	9-node cylindrical hybrid prism
   #线性，四边形
   CCL12	12-node cylindrical brick
   CCL12H	12-node cylindrical hybrid brick
   #二次，三角形
   CCL18	18-node cylindrical prism
   CCL18H	18-node cylindrical hybrid prism
   #二次，四边形
   CCL24	24-node cylindrical brick
   CCL24H	24-node cylindrical hybrid brick
   CCL24R	24-node cylindrical brick with reduced integration
   CCL24RH	24-node cylindrical hybrid brick with reduced integration
   ```

5. 包含扭转（广义）的轴对称单元：

   ```shell
   #线性，三角形
   CGAX3	3-node generalized linear axisymmetric triangle, twist
   CGAX3H	3-node generalized linear axisymmetric triangle, hybrid, constant pressure, twist
   CGAX3HT	3-node generalized axisymmetric thermally coupled triangle, hybrid, constant pressure, linear displacement and temperature, twist
   CGAX3T	3-node generalized axisymmetric thermally coupled triangle, linear displacement and temperature, twist
   #线性，四边形
   CGAX4	4-node generalized bilinear axisymmetric quadrilateral, twist
   CGAX4H	4-node generalized bilinear axisymmetric quadrilateral, hybrid, constant pressure, twist
   CGAX4HT	4-node generalized axisymmetric thermally coupled quadrilateral, hybrid, constant pressure, bilinear displacement and temperature, twist
   CGAX4R	4-node generalized bilinear axisymmetric quadrilateral, reduced integration, hourglass control, twist
   CGAX4RH	4-node generalized bilinear axisymmetric quadrilateral, hybrid, constant pressure, reduced integration, hourglass control, twist
   CGAX4RHT	4-node generalized axisymmetric thermally coupled quadrilateral, bilinear displacement and temperature, hybrid, constant pressure, reduced integration, hourglass control, twist
   CGAX4RT	4-node generalized axisymmetric thermally coupled quadrilateral, bilinear displacement and temperature, reduced integration, hourglass control, twist
   CGAX4T	4-node generalized axisymmetric thermally coupled quadrilateral, bilinear displacement and temperature, twist
   #二次，三角形
   CGAX6	6-node generalized quadratic axisymmetric triangle, twist
   CGAX6H	6-node generalized quadratic axisymmetric triangle, hybrid, linear pressure, twist
   CGAX6M	6-node generalized modified axisymmetric triangle, twist, hourglass control
   CGAX6MH	6-node generalized modified axisymmetric triangle, twist, hybrid, linear pressure, hourglass control
   CGAX6MHT	6-node generalized modified thermally coupled axisymmetric triangle, quadratic displacement, linear temperature, hybrid, linear pressure, twist, hourglass control
   CGAX6MT	6-node generalized modified thermally coupled axisymmetric triangle, quadratic displacement, linear temperature, twist, hourglass control
   #二次，四边形
   CGAX8	8-node generalized biquadratic axisymmetric quadrilateral, twist
   CGAX8H	8-node generalized biquadratic axisymmetric quadrilateral, hybrid, linear pressure, twist
   CGAX8HT	8-node generalized axisymmetric thermally coupled quadrilateral, biquadratic displacement, bilinear temperature, hybrid, linear pressure, twist
   CGAX8R	8-node generalized biquadratic axisymmetric quadrilateral, reduced integration, twist
   CGAX8RH	8-node generalized biquadratic axisymmetric quadrilateral, hybrid, linear pressure, reduced integration, twist
   CGAX8RHT	8-node generalized axisymmetric thermally coupled quadrilateral, biquadratic displacement, bilinear temperature, hybrid, linear pressure, reduced integration, twist
   CGAX8RT	8-node generalized axisymmetric thermally coupled quadrilateral, biquadratic displacement, bilinear temperature, reduced integration, twist
   CGAX8T	8-node generalized axisymmetric thermally coupled quadrilateral, biquadratic displacement, bilinear temperature, twist
   ```

6. infinite单元：

   ```shell
   CIN3D8    8-node linear one-way infinite brick
   CIN3D12R  12-node quadratic one-way infinite brick
   CIN3D18R  18-node quadratic one-way infinite brick
   CINAX4    4-node linear axisymmetric one-way infinite quadrilateral
   CINAX5R   5-node quadratic axisymmetric one-way infinite quadrilateral
   CINPE4    4-node linear plane strain one-way infinite quadrilateral
   CINPE5R   5-node quadratic plane strain one-way infinite quadrilateral
   CINPS4    4-node linear plane stress one-way infinite quadrilateral
   CINPS5R   5-node quadratic plane stress one-way infinite quadrilateral
   ```

7. cohesive单元：

   ```shell
   #轴对称
   COHAX4	4-node axisymmetric cohesive element
   COHAX4P	6-node axisymmetric pore pressure cohesive element
   #二维
   COH2D4	4-node two-dimensional cohesive element
   COH2D4P	6-node two-dimensional pore pressure cohesive element
   #三维
   COH3D6	6-node three-dimensional cohesive element
   COH3D6P	9-node three-dimensional pore pressure cohesive element
   COH3D8	8-node three-dimensional cohesive element
   COH3D8P	12-node three-dimensional pore pressure cohesive element
   ```

8. Connector单元：

   ```shell
   CONN2D2 Connector element in a plane between two nodes or ground and a node
   CONN3D2 Connector element in space between two nodes or ground and a node
   ```

9. 平面应变单元：

   ```shell
   #线性，三角形
   CPE3	3-node linear plane strain triangle
   CPE3E	3-node linear plane strain piezoelectric triangle
   CPE3H	3-node linear plane strain triangle, hybrid, constant pressure
   CPE3T	3-node plane strain thermally coupled triangle, linear displacement and temperature
   #线性，四边形
   CPE4	4-node bilinear plane strain quadrilateral
   CPE4E	4-node bilinear plane strain piezoelectric quadrilateral
   CPE4H	4-node bilinear plane strain quadrilateral, hybrid, constant pressure
   CPE4HT	4-node plane strain thermally coupled quadrilateral, bilinear displacement and temperature, hybrid, constant pressure
   CPE4I	4-node bilinear plane strain quadrilateral, incompatible modes
   CPE4IH	4-node bilinear plane strain quadrilateral, hybrid, linear pressure, incompatible modes
   CPE4P	4-node plane strain quadrilateral, bilinear displacement, bilinear pore pressure
   CPE4PH	4-node plane strain quadrilateral, bilinear displacement, bilinear pore pressure, hybrid, constant pressure
   CPE4R	4-node bilinear plane strain quadrilateral, reduced integration, hourglass control
   CPE4RH	4-node bilinear plane strain quadrilateral, hybrid, constant pressure, reduced integration, hourglass control
   CPE4RHT	4-node bilinear plane strain thermally coupled quadrilateral, hybrid, constant pressure, reduced integration, hourglass control
   CPE4RP	4-node plane strain quadrilateral, bilinear displacement, bilinear pore pressure, reduced integration, hourglass control
   CPE4RPH	4-node plane strain quadrilateral, bilinear displacement, bilinear pore pressure, hybrid, constant pressure, reduced integration, hourglass control
   CPE4RT	4-node bilinear plane strain thermally coupled quadrilateral, bilinear displacement and temperature, reduced integration, hourglass control
   CPE4T	4-node plane strain thermally coupled quadrilateral, bilinear displacement and temperature
   #二次，三角形
   CPE6	6-node quadratic plane strain triangle
   CPE6E	6-node quadratic plane strain piezoelectric triangle
   CPE6H	6-node quadratic plane strain triangle, hybrid, linear pressure
   CPE6M	6-node modified quadratic plane strain triangle, hourglass control
   CPE6MH	6-node modified quadratic plane strain triangle, hybrid, linear pressure, hourglass control
   CPE6MHT	6-node modified quadratic plane strain thermally coupled triangle, hybrid, linear pressure, hourglass control
   CPE6MP	6-node modified displacement and pore pressure plane strain triangle, hourglass control
   CPE6MPH	6-node modified displacement and pore pressure plane strain triangle, hybrid, linear pressure, hourglass control
   CPE6MT	6-node modified quadratic plane strain thermally coupled triangle, hourglass control
   #二次，四边形
   CPE8	8-node biquadratic plane strain quadrilateral
   CPE8E	8-node biquadratic plane strain piezoelectric quadrilateral
   CPE8H	8-node biquadratic plane strain quadrilateral, hybrid, linear pressure
   CPE8HT	8-node plane strain thermally coupled quadrilateral, biquadratic displacement, bilinear temperature, hybrid, linear pressure
   CPE8P	8-node plane strain quadrilateral, biquadratic displacement, bilinear pore pressure
   CPE8PH	8-node plane strain quadrilateral, biquadratic displacement, bilinear pore pressure, hybrid, linear pressure stress
   CPE8R	8-node biquadratic plane strain quadrilateral, reduced integration
   CPE8RE	8-node biquadratic plane strain piezoelectric quadrilateral, reduced integration
   CPE8RH	8-node biquadratic plane strain quadrilateral, hybrid, linear pressure, reduced integration
   CPE8RHT	8-node plane strain thermally coupled quadrilateral, biquadratic displacement, bilinear temperature, reduced integration, hybrid, linear pressure
   CPE8RP	8-node plane strain quadrilateral, biquadratic displacement, bilinear pore pressure, reduced integration
   CPE8RPH	8-node biquadratic displacement, bilinear pore pressure, reduced integration, hybrid, linear pressure
   CPE8RT	8-node plane strain thermally coupled quadrilateral, biquadratic displacement, bilinear temperature, reduced integration
   CPE8T	8-node plane strain thermally coupled quadrilateral, biquadratic displacement, bilinear temperature
   ```

10. 广义平面应变：

    ```shell
    #线性，三角形
    CPEG3	3-node linear generalized plane strain triangle
    CPEG3H	3-node linear generalized plane strain triangle, hybrid, constant pressure
    CPEG3HT	3-node generalized plane strain thermally coupled triangle, linear displacement and temperature, hybrid, constant pressure
    CPEG3T	3-node generalized plane strain thermally coupled triangle, linear displacement and temperature
    #线性，四边形
    CPEG4	4-node bilinear generalized plane strain quadrilateral
    CPEG4H	4-node bilinear generalized plane strain quadrilateral, hybrid, constant pressure
    CPEG4HT	4-node generalized plane strain thermally coupled quadrilateral, bilinear displacement and temperature, hybrid, constant pressure
    CPEG4I	4-node bilinear generalized plane strain quadrilateral, incompatible modes
    CPEG4IH	4-node bilinear generalized plane strain quadrilateral, hybrid, linear pressure, incompatible modes
    CPEG4R	4-node bilinear generalized plane strain quadrilateral, reduced integration, hourglass control
    CPEG4RH	4-node bilinear generalized plane strain quadrilateral, hybrid, constant pressure, reduced integration, hourglass control
    CPEG4RHT 4-node generalized plane strain thermally coupled quadrilateral, bilinear displacement and temperature, hybrid, constant pressure, reduced integration, hourglass control
    CPEG4RT	4-node generalized plane strain thermally coupled quadrilateral, bilinear displacement and temperature, reduced integration, hourglass control
    CPEG4T	4-node generalized plane strain thermally coupled quadrilateral, bilinear displacement and temperature
    #二次，三角形
    CPEG6	6-node quadratic generalized plane strain triangle
    CPEG6H	6-node quadratic generalized plane strain triangle, hybrid, linear pressure
    CPEG6M	6-node modified generalized plane strain triangle, hourglass control
    CPEG6MH	6-node modified generalized plane strain triangle, hybrid, linear pressure, hourglass control
    CPEG6MHT	6-node modified generalized plane strain thermally coupled triangle, quadratic displacement, linear temperature, hybrid, constant pressure, hourglass control
    CPEG6MT	6-node modified generalized plane strain thermally coupled triangle, quadratic displacement, linear temperature, hourglass control
    #二次，四边形
    CPEG8	8-node biquadratic generalized plane strain quadrilateral
    CPEG8H	8-node biquadratic generalized plane strain quadrilateral, hybrid, linear pressure
    CPEG8HT	8-node generalized plane strain thermally coupled quadrilateral, biquadratic displacement, bilinear temperature, hybrid, linear pressure
    CPEG8R	8-node biquadratic generalized plane strain quadrilateral, reduced integration
    CPEG8RH	8-node biquadratic generalized plane strain quadrilateral, hybrid, linear pressure, reduced integration
    CPEG8RHT 8-node generalized plane strain thermally coupled quadrilateral, biquadratic displacement, bilinear temperature, hybrid, linear pressure, reduced integration
    CPEG8T	8-node generalized plane strain thermally coupled quadrilateral, biquadratic displacement, bilinear temperature
    ```

11. 平面应力单元：

    ```shell
    #线性，三角形
    CPS3	3-node linear plane stress triangle
    CPS3E	3-node linear plane stress piezoelectric triangle
    CPS3T	3-node plane stress thermally coupled triangle, linear displacement and temperature
    #线性，四边形
    CPS4	4-node bilinear plane stress quadrilateral
    CPS4E	4-node bilinear plane stress piezoelectric quadrilateral
    CPS4I	4-node bilinear plane stress quadrilateral, incompatible modes
    CPS4R	4-node bilinear plane stress quadrilateral, reduced integration, hourglass control
    CPS4RT	4-node plane stress thermally coupled quadrilateral, bilinear displacement and temperature, reduced integration, hourglass control
    CPS4T	4-node plane stress thermally coupled quadrilateral, bilinear displacement and temperature
    #二次，三角形
    CPS6	6-node quadratic plane stress triangle
    CPS6E	6-node quadratic plane stress piezoelectric triangle
    CPS6M	6-node modified second-order plane stress triangle, hourglass control
    CPS6MT	6-node modified second-order plane stress thermally coupled triangle, hourglass control
    #二次，四边形
    CPS8	8-node biquadratic plane stress quadrilateral
    CPS8E	8-node biquadratic plane stress piezoelectric quadrilateral
    CPS8R	8-node biquadratic plane stress quadrilateral, reduced integration
    CPS8RE	8-node biquadratic plane stress piezoelectric quadrilateral, reduced integration
    CPS8RT	8-node plane stress thermally coupled quadrilateral, biquadratic displacement, bilinear temperature, reduced integration
    CPS8T	8-node plane stress thermally coupled quadrilateral, biquadratic displacement, bilinear temperature
    ```

12. 阻尼器单元：

    ```shell
    DASHPOT1	Dashpot between a node and ground, acting in a fixed direction
    DASHPOT2	Dashpot between two nodes, acting in a fixed direction
    DASHPOTA	Axial dashpot between two nodes, whose line of action is the line joining the two nodes
    ```

13. 管道单元：

    ```shell
    #线性，平面
    PIPE21	2-node linear pipe in a plane
    PIPE21H	2-node linear pipe in a plane, hybrid formulation
    #二次，平面
    PIPE22	3-node quadratic pipe in a plane
    PIPE22H	3-node quadratic pipe in a plane, hybrid formulation
    #线性，空间
    PIPE31	2-node linear pipe in space
    PIPE31H	2-node linear pipe in space, hybrid formulation
    #二次，空间
    PIPE32	3-node quadratic pipe in space
    PIPE32H	3-node quadratic pipe in space, hybrid formulation
    ```

14. gap单元：

    ```shell
    GAPCYL    Cylindrical gap between two nodes
    GAPSPHER  Spherical gap between two nodes
    GAPUNI    Unidirectional gap between two nodes
    GAPUNIT   Unidirectional gap and thermal interactions between two nodes
    ```

15. gasket单元：

    ```shell
    #线性，二维
    GK2D2	2-node two-dimensional gasket element
    GK2D2N	2-node two-dimensional gasket element with thickness-direction behavior only
    GK3D2	2-node three-dimensional gasket element
    GK3D2N	2-node three-dimensional gasket element with thickness-direction behavior only
    #线性，三维
    GK3D4L	4-node three-dimensional line gasket element
    GK3D4LN	4-node three-dimensional line gasket element with thickness-direction behavior only
    #
    GK3D6L	6-node three-dimensional line gasket element
    GK3D6LN	6-node three-dimensional line gasket element with thickness-direction behavior only
    GK3D6	6-node three-dimensional gasket element
    GK3D6N	6-node three-dimensional gasket element with thickness-direction behavior only
    
    GK3D8	8-node three-dimensional gasket element
    GK3D8N	8-node three-dimensional gasket element with thickness-direction behavior only
    
    GK3D12M	12-node three-dimensional gasket element
    GK3D12MN	12-node three-dimensional gasket element with thickness-direction behavior only
    
    GK3D18	18-node three-dimensional gasket element
    GK3D18N	18-node three-dimensional gasket element with thickness-direction behavior only
    #轴对称
    GKAX2	2-node axisymmetric gasket element
    GKAX2N	2-node axisymmetric gasket element with thickness-direction behavior only
    GKAX4	4-node axisymmetric gasket element
    GKAX4N	4-node axisymmetric gasket element with thickness-direction behavior only
    GKAX6	6-node axisymmetric gasket element
    GKAX6N	6-node axisymmetric gasket element with thickness-direction behavior only
    #平面应变
    GKPE4	4-node plane strain gasket element
    GKPE6	6-node plane strain gasket element
    #平面应力
    GKPS4	4-node plane stress gasket element
    GKPS4N	4-node two-dimensional gasket element with thickness-direction behavior only
    GKPS6	6-node plane stress gasket element
    GKPS6N	6-node two-dimensional gasket element with thickness-direction behavior only
    ```

16. membrane单元：

    ```shell
    #线性，三角形
    M3D3	3-node triangular membrane
    M3D4	4-node quadrilateral membrane
    #线性，四边形
    M3D4R	4-node quadrilateral membrane, reduced integration, hourglass control
    #二次，三角形
    M3D6	6-node triangular membrane
    #二次，四边形
    M3D8	8-node quadrilateral membrane
    M3D8R	8-node quadrilateral membrane, reduced integration
    #二次，四边形，多了中心节点
    M3D9	9-node quadrilateral membrane
    M3D9R	9-node quadrilateral membrane, reduced integration, hourglass control
    #轴对称
    MAX1	2-node linear axisymmetric membrane
    MAX2	3-node quadratic axisymmetric membrane
    #圆柱
    MCL6	6-node cylindrical membrane
    MCL9	9-node cylindrical membrane
    #考虑扭转的（广义）
    MGAX1	2-node linear axisymmetric membrane, twist
    MGAX2	3-node quadratic axisymmetric membrane, twist
    ```

17. 管土相互作用单元：

    ```
    PSI24	4-node 2D pipe-soil interaction element
    PSI26	6-node 2D pipe-soil interaction element
    PSI34	4-node 3D pipe-soil interaction element
    PSI36	6-node 3D pipe-soil interaction element
    ```

18. rigid单元：

    ```shell
    R2D2	2-node 2D linear rigid link (for use in plane strain or plane stress)
    
    R3D3	3-node 3D rigid triangular facet
    R3D4	4-node 3D bilinear rigid quadrilateral
    
    RAX2	2-node linear axisymmetric rigid link (for use in axisymmetric planar geometries)
    
    RB2D2	2-node 2D rigid beam
    RB3D2	2-node 3D rigid beam
    ```

19. 壳单元：

    ```shell
    #线性，三角形
    S3   3-node triangular general-purpose shell, finite membrane strains
    S3T  3-node thermally coupled triangular general-purpose shell, finite membrane strains
    S3R  3-node triangular general-purpose shell, finite membrane strains
    S3RT 3-node thermally coupled triangular general-purpose shell, finite membrane strains
    #线性，四边形
    S4	4-node general-purpose shell, finite membrane strains
    S4T	4-node thermally coupled general-purpose shell, finite membrane strains
    S4R	4-node general-purpose shell, reduced integration, hourglass control, finite membrane strains
    S4RT 4-node thermally coupled general-purpose shell, reduced integration, hourglass control, finite membrane strains
    S4R5 4-node thin shell, reduced integration, hourglass control, using five degrees of freedom per node
    #二次，四边形
    S8R	8-node doubly curved thick shell, reduced integration
    S8R5 8-node doubly curved thin shell, reduced integration, using five degrees of freedom per node
    S8RT 8-node thermally coupled quadrilateral general thick shell, biquadratic displacement, bilinear temperature in the shell surface
    #二次，四边形，多一个中心节点，每个节点5个自由度。
    S9R5 9-node doubly curved thin shell, reduced integration, using five degrees of freedom per node
    ```

20. 轴对称壳：

    ```shell
    SAX1	2-node linear axisymmetric thin or thick shell
    SAX2	3-node quadratic axisymmetric thin or thick shell
    SAX2T	3-node axisymmetric thermally coupled thin or thick shell, quadratic displacement, linear temperature in the shell surface
    SAXA1N	Linear asymmetric-axisymmetric, Fourier shell element with 2 nodes in the generator direction and N Fourier modes
    SAXA2N	Quadratic asymmetric-axisymmetric, Fourier shell element with 3 nodes in the generator direction and N Fourier modes
    ```

21. 连续体壳单元：

    ```shell
    #结构单元
    SC6R	6-node triangular in-plane continuum shell wedge, general-purpose continuum shell, finite membrane strains.
    SC8R	8-node quadrilateral in-plane general-purpose continuum shell, reduced integration with hourglass control, finite membrane strains.
    #考虑温度
    SC6RT	6-node linear displacement and temperature, triangular in-plane continuum shell wedge, general-purpose continuum shell, finite membrane strains.
    SC8RT	8-node linear displacement and temperature, quadrilateral in-plane general-purpose continuum shell, reduced integration with hourglass control, finite membrane strains.
    ```

22. surface单元：

    ```shell
    #线性，三角形
    SFM3D3	3-node triangular surface element
    #线性，四边形
    SFM3D4	4-node quadrilateral surface element
    SFM3D4R	4-node quadrilateral surface element, reduced integration
    #二次，三角形
    SFM3D6	6-node triangular surface element
    #二次，四边形
    SFM3D8	8-node quadrilateral surface element
    SFM3D8R	8-node quadrilateral surface element, reduced integration
    #线性，轴对称
    SFMAX1	2-node linear axisymmetric surface element
    #二次，轴对称
    SFMAX2	3-node quadratic axisymmetric surface element
    #圆柱
    SFMCL6	6-node cylindrical surface element
    SFMCL9	9-node cylindrical surface element
    #考虑扭转的轴对称
    SFMGAX1	2-node linear axisymmetric surface element, twist
    SFMGAX2	3-node quadratic axisymmetric surface element, twist
    ```

23. 弹簧单元：

    ```shell
    SPRING1	Spring between a node and ground, acting in a fixed direction
    SPRING2	Spring between two nodes, acting in a fixed direction
    SPRINGA	Axial spring between two nodes, whose line of action is the line joining the two nodes. This line of action may rotate in large-displacement analysis.
    ```

24. 桁架单元：

    ```shell
    #线性，平面
    T2D2	2-node linear 2D truss
    T2D2E	2-node 2D piezoelectric truss
    T2D2H	2-node linear 2D truss, hybrid
    T2D2T	2-node 2D thermally coupled truss
    #二次，平面
    T2D3	3-node quadratic 2D truss
    T2D3E	3-node 2D piezoelectric truss
    T2D3H	3-node quadratic 2D truss, hybrid
    T2D3T	3-node 2D thermally coupled truss
    #线性，空间
    T3D2	2-node linear 3D truss
    T3D2E	2-node 3D piezoelectric truss
    T3D2H	2-node linear 3D truss, hybrid
    T3D2T	2-node 3D thermally coupled truss
    #二次，空间
    T3D3	3-node quadratic 3D truss
    T3D3E	3-node 3D piezoelectric truss
    T3D3H	3-node quadratic 3D truss, hybrid
    T3D3T	3-node 3D thermally coupled truss
    ```

25. 杂项：

    ```shell
    DCOUP2D	Two-dimensional distributing coupling element
    DCOUP3D	Three-dimensional distributing coupling element
    
    DRAG2D  2D drag chain, for use in cases where only horizontal motion is being studied
    DRAG3D  3D drag chain
    
    FRAME2D 2-node two-dimensional straight frame element
    FRAME3D 2-node three-dimensional straight frame element
    
    IRS21A  Axisymmetric rigid surface eleme
    IRS22A  Axisymmetric rigid surface eleme
    
    ISL21A	2-node axisymmetric slide line eleme
    ISL22A	3-node axisymmetric slide line eleme
    
    ITSCYL	Cylindrical geometry tube support interaction element
    ITSUNI	Unidirectional tube support interaction element
    
    ITT21	Tube-tube element for use with first-order, 2D beam and pipe elements
    ITT31	Tube-tube element for use with first-order, 3D beam and pipe elements
    
    JOINTC	Three-dimensional joint interaction element
    
    LS3S	3-node second-order line spring for use on a symmetry plane
    LS6	6-node general second-order line spring. This element can be used only with linear elastic material behavior.
    
    MASS	Point mass
    
    ROTARYI	Rotary inertia at a point
    
    STRI3	3-node triangular facet thin shell
    STRI65	6-node triangular thin shell, using five degrees of freedom per node
    
    WARP2D3	3-node linear 2D warping element
    WARP2D4	4-node bilinear 2D warping element
    ```

# Explicit单元库

1. 显式分析单元库

   ```shell
   AC2D3	3-node linear 2D acoustic triangle
   AC2D4R	4-node linear 2D acoustic quadrilateral, reduced integration, hourglass control
   AC3D4	4-node linear acoustic tetrahedron
   AC3D6	6-node linear acoustic triangular prism
   AC3D8R	8-node linear acoustic brick, reduced integration, hourglass control
   ACAX3	3-node linear axisymmetric acoustic triangle
   ACAX4R	4-node linear axisymmetric acoustic quadrilateral, reduced integration, hourglass control
   ACIN2D2	2-node linear 2D acoustic infinite element
   ACIN3D3	3-node linear 3D acoustic infinite element
   ACIN3D4	4-node linear 3D acoustic infinite element
   ACINAX2	2-node linear axisymmetric acoustic infinite element
   B21	2-node linear beam in a plane
   B22	3-node quadratic beam in a plane
   B31	2-node linear beam in space
   B32	3-node quadratic beam in space
   C3D4	4-node linear tetrahedron
   C3D4T	4-node thermally coupled tetrahedron, linear displacement and temperature
   C3D6	6-node linear triangular prism, reduced integration, hourglass control
   C3D6T	6-node thermally coupled triangular prism, linear displacement and temperature, reduced integration, hourglass control
   C3D8	8-node linear brick
   C3D8I	8-node linear brick, incompatible modes
   C3D8R	8-node linear brick, reduced integration, hourglass control
   C3D8T	8-node thermally coupled brick, trilinear displacement and temperature
   C3D8RT	8-node thermally coupled brick, trilinear displacement and temperature, reduced integration, hourglass control
   C3D10M	10-node modified second-order tetrahedron
   C3D10MT	10-node modified thermally coupled second-order tetrahedron
   CAX3	3-node linear axisymmetric triangle
   CAX3T	3-node thermally coupled axisymmetric triangle, linear displacement and temperature
   CAX4R	4-node bilinear axisymmetric quadrilateral, reduced integration, hourglass control
   CAX4RT	4-node thermally coupled axisymmetric quadrilateral, bilinear displacement and temperature, hybrid, constant pressure, reduced integration, hourglass control
   CAX6M	6-node modified second-order axisymmetric triangle
   CAX6MT	6-node modified second-order axisymmetric thermally coupled triangle
   CIN3D8	8-node linear one-way infinite brick
   CINAX4	4-node linear axisymmetric one-way infinite quadrilateral
   CINPE4	4-node linear plane strain one-way infinite quadrilateral
   CINPS4	4-node linear plane stress one-way infinite quadrilateral
   COHAX4	4-node axisymmetric cohesive element
   COH2D4	4-node two-dimensional cohesive element
   COH3D6	6-node three-dimensional cohesive element
   COH3D8	8-node three-dimensional cohesive element
   CONN2D2	Connector element in a plane between two nodes or ground and a node
   CONN3D2	Connector element in space between two nodes or ground and a node
   CPE3	3-node linear plane strain triangle
   CPE3T	3-node plane strain thermally coupled triangle, linear displacement and temperature
   CPE4R	4-node bilinear plane strain quadrilateral, reduced integration, hourglass control
   CPE4RT	4-node bilinear plane strain thermally coupled quadrilateral, bilinear displacement and temperature, reduced integration, hourglass control
   CPE6M	6-node modified second-order plane strain triangle
   CPE6MT	6-node modified second-order plane strain thermally coupled triangle
   CPS3	3-node linear plane stress triangle
   CPS3T	3-node plane stress thermally coupled triangle, linear displacement and temperature
   CPS4R	4-node bilinear plane stress quadrilateral, reduced integration, hourglass control
   CPS4RT	4-node plane stress thermally coupled quadrilateral, bilinear displacement and temperature, reduced integration, hourglass control
   CPS6M	6-node modified second-order plane stress triangle
   CPS6MT	6-node modified second-order plane stress thermally coupled triangle
   DASHPOTA	Axial dashpot between two nodes
   EC3D8R	8-node linear multi-material Eulerian brick, reduced integration, hourglass control
   EC3D8RT	8-node thermally coupled linear multi-material Eulerian brick, reduced integration, hourglass control
   HEATCAP	Point heat capacitance
   M3D3	3-node triangular membrane
   M3D4	4-node quadrilateral membrane
   M3D4R	4-node quadrilateral membrane, reduced integration, hourglass control
   MASS	Point mass
   PC3D	1-node continuum particle element
   PD3D	1-node continuum particle element
   PIPE21	2-node linear pipe in a plane
   PIPE31	2-node linear pipe in space
   R2D2	2-node 2D linear rigid link (for use in plane strain or plane stress)
   R3D3	3-node 3D rigid triangular facet
   R3D4	4-node 3D bilinear rigid quadrilateral
   RAX2	2-node linear axisymmetric rigid link (for use in axisymmetric geometries)
   ROTARYI	Rotary inertia at a point
   S3R	3-node triangular shell, finite membrane strains
   S3RS	3-node triangular shell, small membrane strains
   S3RT	3-node thermally-coupled triangular shell, finite membrane strains
   S4	4-node general-purpose shell, finite membrane strains
   S4R	4-node shell, reduced integration, hourglass control, finite membrane strains
   S4RS	4-node shell, reduced integration, hourglass control, small membrane strains
   S4RSW	4-node shell, reduced integration, hourglass control, small membrane strains, warping considered in small-strain formulation
   S4RT	4-node thermally-coupled shell, reduced integration, hourglass control, finite membrane strains
   SAX1	2-node linear axisymmetric shell
   SC6R	6-node triangular in-plane continuum shell wedge, general-purpose continuum shell, finite membrane strains.
   SC8R	8-node quadrilateral in-plane general-purpose continuum shell, reduced integration with hourglass control, finite membrane strains.
   SC6RT	6-node thermally coupled triangular in-plane continuum shell wedge, general-purpose continuum shell, finite membrane strains.
   SC8RT	8-node thermally coupled quadrilateral in-plane general-purpose continuum shell, reduced integration with hourglass control, finite membrane strains.
   SFM3D3	3-node triangular surface element
   SFM3D4R	4-node quadrilateral surface element, reduced integration
   SPRINGA	Axial spring between two nodes
   T2D2	2-node linear 2D truss
   T3D2	2-node linear 3D truss
   ```
