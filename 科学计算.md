# 数值程序

1. 概念区分：
   1. BLAS（Basic linear algebra subroutine）是规定了一系列基本线性代数运算函数接口的标准，类似于OpenGL，并没有实际实现，最初发布于1979年，三个Level是逐步发布的。BLAS 的官方版本是Netlib。这个版本的 BLAS 被称为 reference BLAS，运行速度较慢，不过使用完全自由免费，通常被其他版本用于衡量性能。为提高性能，各软硬件厂商则针对其产品对BLAS接口实现进行高度优化。LINPACK基准测试在很大程度上依赖BLAS中的gemm子程序的性能。
   2. LAPACK（Linear Algebra PACKage）也是一个接口标准，Netlib最初用Fortran77实现了个参考版本，后改为Fortran95，底层是BLAS，提供了更高阶的功能，例如多元线性方程组的求解，特征向量，矩阵的分解等。Netlib也提供基于Fortran95实现的LAPACK95。LAPACK是作为LINPACK（线性方程组和线性最小二乘求解，主要利用了现代CPU的向量指令）和ESIPACK（矩阵的特征值和特征向量的求解）的继任者出现的，比前者的进步主要体现在对cache的利用。LINPACK和ESIPACK的底层也都是BLAS。并行的LINPACK基准可以用于测试超级计算机的速度。
   3. CBLAS和CLAPCK是Netlib对Fortran版本BLAS和LAPACK的C/C++封装。
   4. 
   5. 
   6. MKL（Math Kernel Library），Intel提出的，只在Intel的CPU上可以使用，其中包含了BLAS，LAPACK等的高效实现，使用OpenMP实现了线程化。在Intel CPU上性能最高的是Intel 的 MKL中的BLAS实现，不过它不是开源的，但是免费的。
2. OpenBLAS是中科院软件所开发的，基于GotoBLAS。包含BLAS和LAPACK两部分的高效实现。
3. 早期Fortran标准中标识符都只有6个字符的长度限制。因此BLAS和LAPACK中的子程序名都是高度缩写的。

## BLAS

1. BLAS 被广泛用于科学计算和工业界，已成为业界标准．在更高级的语言和库中，即使我们不直接使用 BLAS 接口，它们也是通过调用 BLAS 来实现的（如 Matlab 中的各种矩阵运算）。
2. BLAS实现都一般利用了存储器的层次结构进行优化，使数据在缓存重用，TLB命中等方面优化进而提高运算性能。现在处理器都支持向量指令，可以利用SIMD（单指令多数据）来优化。
3. 
4. 三个级别：
   1. Level1，向量-向量计算：向量内积，向量范数，
5. 
6. 三个级别的时间复杂度分别为线性，平方和立方。

# ARPACK

1. 使用Fortran77编写的，用于求解大规模特征值（对称，非对称，广义）问题。特别适合仅求解少量特征值和对应的特征向量的问题，特别适合于处理稀疏矩阵或结构化矩阵。

2. 结构化矩阵的含义是，n阶矩阵向量乘法A\*x所需要浮点操作次数和n同阶，而非和n^2同阶。

3. 软件的算法基于Arnoldi过程的一个变体，Implicitly Restarted Lanczos Method (IRLM)，隐式重启动Lanczos方法。

4. 求解n阶矩阵的少量k个特征值可以是如下特征，最大实部或者最大幅值。空间复杂度为n*k。

5. 软件的源代码分为arpack96.tar.gz和后续的补丁文件patch.tar.gz。

   ```shell
   tar -xvf arpack96.tar.gz
   tar -xvf patch.tar.gz #将会在当前目录下创建一个文件夹ARPACK
   ```

6. 

7. 


# GSL

1. GSL（GNU Scientific Library）是一个应用广泛的C/C++科学计算库，其包含了大量高效的数学函数。GSL的接口被统一设计成C的风格而不是C++的风格，清晰而优雅。以C89标准，没有使用任何标准外的扩展。

2. 在Ubuntu 22.04中安装和使用GSL：

   ```shell
   sudo apt install gsl-bin #这个包依赖于libgsl27和libgslcblas0。
   #sl-bin包，包括可执行文件gsl-histogram(从标准输入获取数据，输出直方图)和gsl-randist(从特定分布中生成随机样本)
   #libgsl27包，包括软连接libgsl.so.27和对应文件libgsl.so.27.0.0
   #libgslcblas0包，包括软连接libgslcblas.so.0和对应文件libgslcblas.so.0.0.0
   sudo apt install libgsl-dev #这个包依赖于libgsl27和libgslcblas0。
   #libgsl-dev包，包括编程所需的头文件(在/usr/include/gsl目录中)和gsl-config配置工具，2个符号链接文件libgsl.so(指向libgsl.so.27.0.0)，libgslcblas.so(指向libgslcblas.so.0.0.0)。还有2个对应的静态库libgsl.a和libgslcblas.a
   ###编译链接
   gcc main.c -o main -lgsl -lgslcblas -lm //使用-static选项来使用静态链接。
   ```

3. 为了避免名字冲突，所有的导出的函数，变量都有`gsl_`前缀，导出的宏都有`GSL_`前缀。

4. 覆盖的功能如下：

   ```c
   //复数          多项式求根           特殊函数
   //向量和矩阵     排列                组合
   //排序           BLAS库             线性代数
   //CBLAS库        快速傅里叶变换FFT   特征值系统
   //随机数         高斯积分            随机分布
   //准随机序列     直方图              统计
   //蒙特卡洛积分    N元组              微分方程
   //模拟退火       数值微分            插值
   //级数加速       切比雪夫近似        求根
   //离散汉克尔变换  最小二乘拟合        最小化
   //IEEE浮点数     物理常量            B样条
   //小波变换       稀疏BLAS库          稀疏线性代数
   ```

5. 某些代码是GSL根据已有的库（例如FFTPACK，QUADPACK），使用现代C语言习惯重写的。

6. 所有的gsl头文件都在gsl目录下，以gsl_开头。

7. 由于C89中没有inline关键字，但是在C99出来之前，很多编译器就提供inline扩展了。因此GSL使用条件编译的方式加入了可选的内联版本的函数。可以通过在使用时定义HAVE_INLINE宏来使用。在gsl_inline.h中定义：

   ```c
   #ifdef HAVE_INLINE
   	#if defined(__GNUC_STDC_INLINE__) ||defined(GSL_C99_INLINE)||defined(HAVE_C99_INLINE) //使用GCC的C99及以上标准编译时，__GNUC_STDC_INLINE__会被define为1，因此如果定义了HAVE_INLINE，则会走这一条分支。如果使用其他编译器的C99及以上标准，定义GSL_C99_INLINE为1即可。
   		#define INLINE_DECL inline  /* 使用 C99 inline */
   		#define INLINE_FUN inline /* 函数声明和定义前的关键字都是inline */
   	#else
   		#define INLINE_DECL         /* 使用GNU extern inline */
   		#define INLINE_FUN extern inline
   	#endif
   #else
   	#define INLINE_DECL /*定义为空字符串*/
   #endif
   ```

8. 内联函数的例子：

   ```c
   #include <gsl/gsl_inline.h> //先包含头文件
   
   INLINE_DECL gsl_complex gsl_complex_rect (double x, double y);//声明
   
   #ifdef HAVE_INLINE
       INLINE_FUN gsl_complex gsl_complex_rect (double x, double y){ //定义
         gsl_complex z;
         GSL_SET_COMPLEX (&z, x, y);
         return z;
       }
   #endif
   ```

9. GSL中会依赖CBLAS库，GSL安装时会默认安装GSL的CBLAS实现，如果由其他的实现，也可以使用，例如使用ATLAS库提供了高性能的BLAS操作和对应的CBLAS接口，使用 -lcblas -latlas。

   ```shell
   sudo apt install libatlas3-base #其中包含atlas/libblas.so.3、atlas/liblapack.so.3、libatlas.so.3、libcblas.so.3、libf77blas.so.3、liblapack_atlas.so.3。
   #blas和lapack库由于可能存在其他库的实现，所以放在atlas文件夹中。
   ```

10. 大部分的算法都是以double进行计算的，因此输入的long double也会被转化为double。这是因为IEEE只是规定了long double的最小精度，具体实现依赖于平台，而double对于所有平台都是一样的。由于有时必须要和外界的long double数据进行交互，所以向量和矩阵也都有long double版本。

11. printf和scanf中并没有对long double进行适配，因此可能会导致编译前的configure阶段就将某些依赖于这些行为的函数去除掉了。如果非要读写long double数据，应该先将其转化为double类型。

12. GSL库可以被多线程程序使用，所有的函数都是线程安全的，这意味着它不适用静态变量。workspace对象作为临时存储，总是按线程进行分配；table对象作为只读的，总是const的，可以被多个线程同时读取。

13. 有时，某些函数的定义需要被改变或删除，那么会先声明为deprecated，然后再下一个版本中再予以删除。可以定义GSL_DISABLE_DEPRECATED，以检测出是否使用了deprecated的函数，这样避免下一个版本中，就无法使用该函数了。

14. 整个库被设计为模块间低耦合，可以尝试将单个模块抽取出来编译使用，可能需要定义一些类似于GSL_ERROR的宏，删除一些#include语句。

15. GSL函数通过返回值标识调用是否出错，非零标识出错。返回值可以通过gsl_strerror(status)转化成出错字符串。也可以自定义出错处理函数，来捕捉特定的错误。

16. GSL使用切比雪夫展开计算sin、cos等三角函数。这些函数在CRT中也有。使用autoconf配置项目时，可以选择使用哪个。

17. 基本数学函数：

    ```c
    //定义在gsl_math.h中，首先是一些常数，例如e,根号2，根号3，pi，欧拉常数等。还有无穷大和NaN和3个函数，分别判断是否是无穷大和NaN
    int gsl_isnan(const double x); //若x为NaN，返回1
    int gsl_isinf(const double x); //若x为正无穷，返回1，为负无穷，返回-1
    int gsl_finite(const double x);//若x为实数，返回1，为无穷大或NaN，返回0
    //为了高效完成某些任务，GSl提供了一些细分的函数：
    double gsl_pow_int(double x, int n); //计算一个浮点数的整数次幂，math库中只有最通用的浮点数次幂。这个效率较高，例如x^8会被当作((x^2)^2)^2，也就是3次乘法。
    double gsl_pow_2(const double x);//也有一些特别的小整数幂的函数，这种函数传参少，且过程经过优化，速度比上一个更快。如果定义了HAVE_INLINE宏，这些函数会被内联以加快速度。
    //测试宏
    GSL_SIGN(x) //测试变量的符号，正数或0为1，负数为-1
    GSL_IS_ODD(n) //测试整数的奇偶性，奇数返回1，偶数返回0
    
    GSL_MAX(a, b) //宏，返回二者中较大的那个，注意该函数会对参数多次求值，因此参数对于多次求值应该是稳定的，例如随机数生成器多次求值就不稳定。
    extern inline double GSL_MAX_DBL(double a, double b); //内联函数，使用函数的话会进行参数类型检查，更安全。如果不支持内敛的话，会自动用GSL_MAX替换。
    //浮点数的近似比较
    int gsl_fcmp(double x, double y, double epsilon); //判断x和y在相对精度位epsilon下是否相等或比大小。如果|x-y|<2δ，δ=2^kε，其中k为使用gsl_frexp分别对x和y计算，取较大的那个指数作为k。例如x=22.3，ε=0.01，k=5,δ=2^5*0.01=0.32，所以y在(22.3-0.32,22.3+0.32)内时，函数返回0，认为二者近似相等。
    double gsl_frexp(double x, int *e);//用2的幂将x归一化为f，并返回f。使得f=x/2^e，其中f在[0.5,1)中。例如
    int e = 0, x = 22.3;double f = gsl_frexp(x, &e); //结果e=5，f=0.696875。若x=16，则e=5，e=0.50000。
    ```

18. GSL中使用结构体实现复数，配备了一堆操作函数。复数运算会出现多值函数，例如$\sqrt{i}$，此时会使用支割线将复平面剪开，从而分出单值分支：

    ```c
    //复数类型定义在gsl_complex.h中，相关的函数和算术操作都定义在gsl_complex_math.h中。之所以分离，就是为了降低耦合，其他模块如果想要使用复数，但不使用它自带的操作时，可以只包含gsl_complex.h。
    //由于C99中定义了原生的复数类型，C11中又增加了一些额外的功能，因此如果想要使用原生复数类型的话，可以在#include<gsl/gsl_complex.h>前加上#include<complex.h>。这样gsl_complex就会使用原生的附属类型，即typedef double complex gsl_complex。这样就可以使用直接赋值了，例如gsl_complex = 3+4*I。
    //解开各种宏后，复数结构体如下，有一个成员，该成员位一个数组，包含2个double元素。第一个为实部，第二个为虚部，紧密排列。
    typedef struct { double dat[2]; } gsl_complex; //定义了一个匿名结构体，然后这个结构体被typedef为gsl_complex。
    
    GSL_REAL(z);//获取实部和虚部的宏，可读可写。也可以用z.dat[0]。
    GSL_IMAG(z);
    GSL_SET_COMPLEX(ptr_z, x, y) //同时设置复数z的实部和虚部，ptr_z是复数z的指针。
    gsl_complex gsl_complex_rect(double x, double y);//构造一个复数，实部为x，虚部为y，并返回
    gsl_complex gsl_complex_polar(double r, double theta); //构造一个复数，幅值为r，辐角为theta(弧度)，并返回。
    double gsl_complex_arg(gsl_complex z); //返回复数z的辐角，结果在(-π,π]。
    double gsl_complex_abs(gsl_complex z); //返回复数z的幅值
    double gsl_complex_logabs(gsl_complex z);//返回复数z的幅值的自然对数，当幅值接近于1时，直接求解log(gsl_complex_abs(z))误差可能较大，推荐使用这个函数。
    //例子：
    gsl_complex a;
    GSL_SET_COMPLEX(&a, 0.5999999999999999, 0.80000000000000001);
    printf("%.19f\n", gsl_complex_abs(a));//结果为1.00000000000000000
    printf("%.19f\n%.19f\n", gsl_complex_logabs(a), log(gsl_complex_abs(a)));//第一个为-0.0000000000000000555，0.0000000000000000000。不过只有到10的负十几次方后才可以发现二者差异。
    //基本算数函数有：add,sub,mul,div,add_real...,add_imag...,conjugate(共轭),inverse(倒数),negative(相反数)，都是(gsl_complex_前缀)。...省略的是加减乘除。
    gsl_complex gsl_complex_sqrt_real(double x); //计算实数x的平方根，x可能为负数，当x=-4时，结果为0+2i。
    gsl_complex gsl_complex_pow(gsl_complex z, gsl_complex a);//计算复数z的复数a次幂z^a，会转化成e^(a*log(z))，即自然指数和自然对数。
    gsl_complex gsl_complex_log(gsl_complex z);//自然对数是多值函数，这里取支割线为负实轴。
    gsl_complex gsl_complex_log_b(gsl_complex z, gsl_complex b);//计算以b为底z的对数log_b(z)，利用换底公式，转换为log(z)/log(b)。
    //基础三角函数使用欧拉公式转化为指数计算sin(z)=(exp(iz)-exp(-iz))/2i。而推到的三角函数，则使用诱导公式计算，例如tan(z)=sin(z)/cos(z)。有的函数如果是多函数，则会由两个版本，例如gsl_complex_arcsin和gsl_complex_arcsin_real。
    gsl_complex gsl_complex_arcsin(gsl_complex z);//计算复数z的正弦支割线在实轴上，范围为[-1,1]。
    gsl_complex gsl_complex_arcsin_real(double z);//计算实数z的反正弦，此时为单值函数。当z在[-1,1]中，结果为实数，在[-π/2,π/2]内。当z<-1，结果为复数，实部为-π/2，虚部>0;当z>1，结果为复数，实部为π/2，虚部<0。
    //双曲三角函数也会转化为指数函数，sinh(z)=(exp(z)-exp(-z))/2。
    ```

19. GSL的多项式操作定义在`gsl_poly.h`，包括多项式求值，

    ```c
    //形状为P(x)=c[0]+c[1]x+c[2]x2+...+c[len-1]x^(len-1)，使用Horner方法来保证稳定性，
    double gsl_poly_eval(const double c[], const int len, const double x);//数组c有len项，下标从0到len-1，多项式是len-1次的。
    double x[] = { 1, 2, 3 };
    double a = gsl_poly_eval(x, sizeof(x) / sizeof(x[1]), 2);//P(x)=1+2x+3x^2，则P(2)=17.000
    gsl_poly_complex_eval;//实多项式在复数点的取值
    gsl_complex_poly_complex_eval;//复多项式在复数点的取值
    int gsl_poly_eval_derivs(const double c[], const size_t lenc, const double x, double res[], const size_t lenres);//计算多项式c在x点的0到lenres-1阶导数，结果放在res中。
    double c[] = { 1, 2, 3, 4, 5 };
    double res[3];
    double a = gsl_poly_eval_derivs(c, 5, 1, res, 3); //P(x)=1+2x+3x^2+4x^3+5x^4。求0-2阶导数，0阶导函数就是P(x)，P(1)=15，1阶导函数为2+6x+12x^2+20x^3，P'(1)=40，2阶导函数为6+24x+60x^2，P''(1)=90。
    //多项式的差商，给定f(x)可以构造n阶插值多项式P_n(x)，P_n(x)和f(x)在n+1个不同点x_0,...,x_n的函数值都相等。
    int gsl_poly_dd_init(double dd[], const double xa[], const double ya[], size_t size);//size个坐标点的x,y坐标放在xa和ya数组，计算[x0,...,xk]作为dd[k]存储。
    int gsl_poly_solve_quadratic(double a, double b, double c, double *x0, double *x1);//求多项式ax^2+bx+c=0的根，返回值为根的数量。如果没有实根，则x0,x1不变，如果只有1个实根，则放在x0中，如果有2个实根，则x0<x1。根的数量取决于判别式b^2-4ac，可能受到浮点数计算的舍入，抵消误差和系数误差的影响。然而对于小整数的系数，判别式的计算总是精确的。gsl_poly_complex_solve_quadratic可以计算复数根，
    //五次及以上方程没有解析解，更高次的方程需要使用迭代法求解。
    ```

20. GSL的矩阵以及向量操作，不推荐直接操作结构体的数据部分，而是使用get/set函数读写。

    ```c
    #include <gsl/gsl_vector.h>
    #include <gsl/gsl_matrix.h>
    #include <stdio.h>
    #include <math.h>
    int main(int argc, char** argv) {
        gsl_vector* x = gsl_vector_alloc(3); //在堆上分配内存，必须使用专用的向量分配函数
        for (size_t i = 0; i < 3; i++) {
            double n = rand() / (double)RAND_MAX * 2.0 - 1.0; //生成[-1,1]的浮点数
            gsl_vector_set(x, i, n); //给x[i]赋值n。不支持直接使用x[i]。
        }
        gsl_vector_fprintf(stdout, x, "%f");//向量专属的输出函数，类似于fprintf
        gsl_vector_free(x);//使用完毕及时释放内存，避免发生内存泄漏
        x = NULL;//然后立刻将指针置为NULL，避免成为野指针
        
        gsl_matrix* m = gsl_matrix_calloc(2, 3);//2行3列矩阵
        gsl_matrix_set_identity(m);//将矩阵m赋值为单位矩阵
        for (size_t i = 0; i < 2; i++) {
            for (size_t j = 0; j < 3; j++) {
                double n = rand() / (double)RAND_MAX;
                gsl_matrix_set(m, i, j, n);
            }
        }
        gsl_matrix_free(m);
        m = NULL;
        return 0;
    }
    ```

21. GSL中实现了包括UNIX上的许多随机数生成器，一般使用CRT中自带的rand函数就足够：

    ```c
    #include <gsl/gsl_rng.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>
    int main(int argc, char** argv) {
        gsl_rng* rng = gsl_rng_alloc(gsl_rng_rand48);//获取随机数生成器
        for (int i = 0; i < 10; i++) {
            printf("%lu\t%f\n", gsl_rng_get(rng), gsl_rng_uniform(rng));//根据生成器获取随机数
        }
        gsl_rng_free(rng);//使用完毕后释放随机数生成器
        rng = NULL;
        return 0;
    }
    ```

22. 常见的矩阵操作：

    ```c
    #include <gsl/gsl_linalg.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>
    int main(int argc, char** argv) {
        double n[9] = { 3,-1,-1,4,-2,-1,-3,2,1 };//用来存储3行3列矩阵的数据
        int k = 0;
        gsl_matrix* m = gsl_matrix_alloc(3, 3);
        gsl_matrix* mi = gsl_matrix_alloc(3, 3);
        for (size_t i = 0; i < 3; i++) {
            for (size_t j = 0; j < 3; j++) {
                gsl_matrix_set(m, i, j, n[k]);//完成3行3列矩阵的赋值
                k++;
            }
        }
        //LU分解
        int sig = 0;
        gsl_permutation* perm = gsl_permutation_alloc(3);
        gsl_linalg_LU_decomp(m, perm, &sig);
        printf("%s\n", "LU");
        for (size_t i = 0; i < 3; i++) {
            for (size_t j = 0; j < 3; j++) {
                printf("%f\t", gsl_matrix_get(m, i, j));
            }
            printf("\n");
        }
        //求逆
        printf("\n%s\n", "Inverse");
        gsl_linalg_LU_invert(m, perm, mi);//逆矩阵存储在mi中
        for (size_t i = 0; i < 3; i++) {
            for (size_t j = 0; j < 3; j++) {
                printf("%f\t", gsl_matrix_get(mi, i, j));
            }
            printf("\n");
        }
        //SVD奇异值分解
        gsl_matrix* v = gsl_matrix_alloc(3, 3);
        gsl_vector* s = gsl_vector_alloc(3), * work = gsl_vector_alloc(3);
        gsl_linalg_SV_decomp(m, v, s, work);
        printf("\nSVD - V\n");
        for (size_t i = 0; i < 3; i++) {
            for (size_t j = 0; j < 3; j++) {
                printf("%f\t", gsl_matrix_get(v, i, j));
            }
            printf("\n");
        }
        printf("SVD - S [%f\t%f\t%f]\n", gsl_vector_get(s, 0), gsl_vector_get(s, 1), gsl_vector_get(s, 2));
        printf("SVD - Work [%f\t%f\t%f]\n", gsl_vector_get(work, 0), gsl_vector_get(work, 1), gsl_vector_get(work, 2));
        gsl_matrix_free(m);
        gsl_matrix_free(mi);
        gsl_matrix_free(v);
        gsl_vector_free(s);
        gsl_vector_free(work);
        return 0;
    }
    ```

23. 蒙特卡洛积分：

24. 插值功能：
