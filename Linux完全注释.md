# 概述

1. 目前 Linux 内核源代码量已经非常大（例如 2.2.20版已有 268 万行代码！）。而0.12内核也就2万行左右。
2. 《Linux 内核源代码分析》基本上是面对 Linux 中高级水平的读者。
3. MINIX 系统是一种基于消息传递的内核实现机制，与 Linux 内核的实现有所区别。
4. 早期内核源代码几乎就是目前所使用的较新内核的一个精简版本，已经包括了目前新版本中几乎所有的基本功能原理。
5. ucLinux是嵌入式linux的典范之作，和标准linux最主要的区别就是这些嵌入式设备往往没有MMU，其多任务的实现需要一定技巧。
6. 早期内核版本不包含对虚拟文件系统 **VFS** 的支持、对**网络系统**的支持、仅支持 **a.out** 执行文件和对其他一些现有内核中复杂子系统的说明。
7. RTFSC – Read The Fucking Source Code  --Linux创始人
8. 目前Linux 系统上所使用的 Ext3 文件系统是在内核1.x 之后开发的。而Linux 内核0.12 版上当时仅包含最为简单的MINIX 1.0 文件系统。
9. Linux 操作系统的诞生、发展和成长过程依赖于以下五个重要支柱：**UNIX 操作系统、MINIX 操作系统、GNU 计划、POSIX 标准和 Internet 网络**。
10. Linux 内核版本中第二个数字如果是奇数，则表示是正在开发的版本，不保证稳定性。
11. UNIX 操作系统是美国贝尔实验室的Ken.Thompson 和Dennis Ritchie 于1969 年夏在DEC PDP-7 小型计算机上开发的一个分时操作系统。当时使用的是 BCPL 语言（基本组合编程语言），后经 Dennis Ritchie 于 1972 年用移植性很强的 C语言进行了改写。
12. MINIX 系统是由Andrew S. Tanenbaum（AST）开发的，主要用于学生学习操作系统原理。为了保持 MINIX 的小型化，能让学生在一个学期内就能学完，因而教授没有接纳全世界许多人对 MINIX的扩展要求。这也激发了 Linus 编写Linux 系统。
13. 作为一个操作系统，MINIX 并不是优秀者，但它同时提供了用C 语言和汇编语言编写的系统源代码。这是**第一次**使得有抱负的程序员或 hacker 能够阅读操作系统的源代码。
14. GNU 计划和自由软件基金会FSF(the Free Software Foundation)是由Richard M. Stallman 于1984 年一手创办的。旨在开发一个类似 UNIX 并且是自由软件的完整操作系统。
15. 到上世纪 90 年代初，GNU 项目已经开发出许多高质量的免费软件，其中包括有名的 emacs 编辑系统、bash shell 程序、gcc 系列编译程序、gdb 调试程序等等。这些软件为Linux 操作系统的开发创造了一个合适的环境。Stallman认为linux系统应该被称作 GNU/Linux系统。
16. POSIX（Portable Operating System Interface for Computing Systems）是由 IEEE 和 ISO/IEC 开发的一簇标准。基于现有的UNIX 实践和经验，描述了操作系统的调用服务接口。用于保证编制的应用程序可以在**源代码一级**上在多种操作系统上**移植**和运行。最早是试图将Unix的两大分支：AT&T 的System V 操作系统和Berkeley CSRG 的BSD 操作系统的调用接口之间的区别重新调和集成。
17. 最早的POSIX标准在1988年通过，称为POSIX.1标准，仅规定了系统调用的接口。后来又制定了命令与工具标准(POSIX.2)，测试方法标准（POSIX.3），实时API（POSIX.4）。1990年左右就完成了这些标准的制定。
18. Linux内核在早期开发阶段就注重与POSIX标准进行对接。在Linux 0.01 版内核的/include/unistd.h文件中就已经定义了几个有关POSXI 标准要求的符号常数。
19. 在1981 年，IBM 公司推出了享誉全球的微型计算机 IBM PC。在1981-1991 年间，MS-DOS 操作系统一直是微型计算机操作系统的主宰。而UNIX操作系统大多时间应用在服务器领域，在个人机上应用较少，价格太贵了。
20. 1991年10月5日，最早的linux内核公开。Linus最早进行操作系统测试就是让他在屏幕上轮流打印出A和B，测试多任务的切换。
21. 第一个正式版1.0发布于1994年。Linux 0.12 是Linus 比较满意的内核版本，也是一个更稳定的内核。
22. 从0.95 版开始，对内核的许多改进工作（提供补丁程序）均以其他人为主了，而 Linus 的主要任务开始变成对内核的维护和决定是否采用某个补丁程序。
23. 要贡献者的具体名单可参见 Linux 内核中的CREDITS 文件
24. Linux-0.12 版本发布于 1992 年 1 月15 日。在发布时包括以下文件：
25. ![image-20200823160828203](Linux完全注释.assets/image-20200823160828203.png)
26. bootimage 是引导启动Image文件，其中主要包括**磁盘引导扇区代码**、**操作系统加载程序**和**内核执行代码**。
27. PC 机启动时 **ROM BIOS**中的程序会把默认启动驱动器上的引导扇区代码和数据读入内存，而引导扇区代码则负责把操作系统加载程序和内核执行代码读入内存中，然后把控制权交给操作系统加载程序去进一步准备内核的初始化操作，最终**加载程序会把控制权交给内核代码**。
28. 内核代码若要正常运行就需要文件系统的支持。rootimage就是用于向内核提供最基本支持的根文件系统，其中包括操作系统最起码的一些**配置文件和命令执行程序**。对于 Linux 系统中使用的 UNIX 类文件系统，其中主要包括一些规定的目录、配置文件、设备驱动程序、开发程序以及所有其他用户数据或文本文件等。这两个盘合起来就相当于一张**可启动的DOS 操作系统盘**。 
29. as86.tar.Z 是 16 位汇编器链接程序软件包。linux-0.12.tar.Z 是压缩的 Linux 0.12 内核源代码。 INSTALL-0.11 是Linux 0.11 系统的简单安装说明文档。
30. 该内核版本中尚不包括有关专门的进程等待队列、 TCP/IP 网络等方面的一些当前非常重要的代码，对内存的分配和使用与现今的内核也有所区别。但好在Linux 中的网络代码基本上是自成一体的，与内核机制关系不是非常大。
# 微型计算机组成结构
1. 任何一个系统都可以有下图左边的四个部分组成，能源部分为其余三个部分供给能量。计算机系统可以进行简化，它的输入的输出部分往往是共用的。
2. ![image-20200825202107634](Linux完全注释.assets/image-20200825202107634.png)
3. 早期的微型计算机，IBM推出的IBM PC，打在微软的操作系统，运行在Intel80x86处理器平台上。
4. CPU 通过地址线、数据线和控制信号线组成的**本地总线**（或称为内部总线）与系统其他部分进行数据通信。
5. 地址线用于提供内存或I/O设备的地址，即**指明需要读/写数据的具体位置**。数据线用于在 CPU 和内存或 I/O 设备之间提供**数据传输的通道**，而控制线则负责**指挥执行的具体读/写操作**。
6. 对于80386CPU来说，地址线有32根，即32位，因此寻址空间为$2^{32}$字节，即4GB。
7. ![image-20200825202738627](Linux完全注释.assets/image-20200825202738627.png)
8. 图中**上部控制器和存储器接口**通常都集成在计算机主板上，这些控制器分别都是以一块大规模集成电路芯片为主组成的功能电路。每个都由一个专门的芯片来控制。
9. 图中下方的控制卡（或者称为适配器）则是通过扩展插槽与主板上系统总线连接。现在较为流行的技术是PCIE总线。
10. 随着计算机技术的发展，很多原来使用控制卡来完成的功能（例如硬盘控制器功能）都已经**集成**在计算机主机板上少数几个超大规模集成电路芯片中。
11. 为了让系统的不同部分都能达到其最高传输速率，总线结构也发生了很大变化。
12. 现代 PC 机的组成结构通常可以使用下图来描述，除了CPU以外，现在PC机主要是用两个超大规模芯片构成的芯片组组成，北桥芯片和南桥芯片。
13. ![image-20200825203916700](Linux完全注释.assets/image-20200825203916700.png)
14. 北桥芯片用于与 CPU、内存和 AGP 视频接口，这些接口具有很高的传输速率。桥芯片还起着存储器控制作用，因此Intel 把该芯片标号为MCH（Memory Controller Hub）芯片。
15. 南桥芯片用来管理低、中速的组件，例如， PCI 总线、IDE 硬盘接口、USB 端口等，因此南桥芯片的名称为ICH（I/O Controller Hub）。
16. 之所以用“南、北”桥来分别统称这两个芯片，是由于在Intel 公司公布的典型PC 机主板上，它们分别位于主版的下端和上端（即地图上的南部和北部）位置，并起着与CPU 进行通道桥接的作用。
17. 北桥芯片一般距离CPU更近，由于数据吞吐量大，发热量大，所以一般都会有覆盖散热片。现代的主板上已经看不到北桥芯片了，因为他已经被整合到了CPU内部。显卡内存可以直接和CPU进行通信。
18. 在 CPU 和 I/O 适配器之间开始传输数据时，首先需要确定适配器的 I/O 位置，即端口地址。
19. 通常一个 I/O 控制器包含访问数据的**数据端口**、输出命令的**命令端口**和访问控制器执行状态的**状态端口**。端口地址的设置方法一般有两种：统一编址和独立编址。 
20. 统一编址的原理是把 I/O 控制器中的端口地址归入存储器寻址地址空间范围内。因此这种编址方式也成为存储器映像编址。CPU 访问一个端口的操作与访问内存的操作一样，也使用访问内存的指令。
21. 独立编址的方法是把 I/O 控制器和控制卡的寻址空间单独作为一个独立的地址空间对待，称为 I/O 地址空间。每个端口有一个 I/O 地址与之对应，并且使用专门的 I/O 指令来访问端口。
22. IBM PC 及其兼容微机主要使用独立编址方式，使用 ISA 总线结构的传统PC 机其I/O 地址空间范围是0x000 -- 0x3FF，有1024 个I/O端口地址可供使用。
23. 另外，IBM PC 机也部分地使用了统一编址方式。例如，CGA 显示卡上显示内存的地址就直接占用了存储器地址空间 0xB800 -- 0xBC00 范围。因此若要让一个字符显示在屏幕上，可以直接使用内存操作指令往这个内存区域执行写操作。 
24. <img src="Linux完全注释.assets/image-20200825210437109.png" alt="image-20200825210437109" style="zoom:50%;" />
25. 现代计算机择优64K（0x0000-0xffff）的 I/O地址空间可以用来寻址，在linux中可以使用 cat /proc/ioports来查看对应的端口和控制器。
26. PC 机I/O 接口数据传输控制方式一般可采用程序循环查询方式、中断处理方式和DMA 传输方式。
    1. **循环查询方式**是指 CPU 通过在程序中循环查询指定设备控制器中的状态来判断是否可以与设备进行数据交换。这种方式不需要过多硬件支持，使用和编程都比较简单，但是特别耗费 CPU 宝贵时间。因此在多任务操作系统中除非等待时间极短或必须，否则就不应该使用这种方式。在 Linux 操作系统中，只有在设备或控制器能够立刻返回信息时才会在很少的几个地方采用这种方式。 
    2. **中断处理控制方式**需要有**中断控制器**的支持。在这种控制方式下，只有当 I/O 设备**通过中断向 CPU 提出处理请求**时，CPU 才会暂时中断当前执行的程序转而去执行相应的 I/O 中断处理服务过程。当执行完该中断处理服务过程后，CPU 又会继续执行刚才被中断的程序。在 I/O 控制器或设备发出中断请求时，CPU通过使用**中断向量表**（或中断描述符表）来寻址相应的**中断处理服务过程**的入口地址。因此采用中断控制方式时需要首先设置好中断向量表，并编制好相应的中断处理服务过程。Linux 操作系统中大多数设备I/O控制都采用中断处理方式。 
    3. **直接存储器访问**DMA（Direct Memory Access）方式用于 **I/O 设备与系统内存之间**进行批量数据传送，整个操作过程需要使用专门的DMA 控制器来进行而**无需 CPU 插手**。由于在传输过程中无须软件介入，因此操作效率很高。在 Linux 操作系统中，软盘驱动程序使用中断和 DMA 方式配合来实现数据的传输工作。
27. 典型 PC 机上通常含有三种类型的存储器，一种是用来**运行程序和临时保存数据的内存存储器RAM**，一种是**存放着系统开机诊断和初始化硬件程序（BIOS）的 ROM**，另一种是用来存放计算机**实时时钟信息和系统硬件配置信息**的少量 CMOS 存储器。 
28. 1981 年IBM PC 机刚推出时系统只带有640KB 的 内存。而当时采用的8088/8086 CPU 有20 根地址线，寻址范围最高为1024KB（1MB）。
29. 随着技术的发展，现在32位CPU的寻址能力已经达到4GB。但是为了与原来的PC机在软件上兼容，系统1MB以下的物理内存使用分配上仍然保持与原来的PC机一致。只是原来系统 ROM 中的基本输入输出程序 BIOS 一直处于 CPU 能寻址的内存最高端位置处。
30. 当计算机上电初始化时，物理内存被设置成从地址0开始的连续区域。除了地址从0xA0000 到0xFFFFF （**640K 到 1M** 共 384K）和 0xFFFE0000 到 0xFFFFFFFF（**4G 处的最后一 64K**）范围以外的所有内存都可用作系统内存。这两个范围被用作I/O设备和BIOS程序。
31. <img src="Linux完全注释.assets/image-20200825213136779.png" alt="image-20200825213136779" style="zoom:50%;" />
32. 0--640K 将被用作存放内核代码和数据。Linux 内核不使用 BIOS 功能，也不使用 BIOS 设置的中断向量表。
33. 存放在 ROM 中的系统 BIOS 程序主要用于计算机开机时执行系统各部分的自检，建立起操作系统需要使用的各种配置表，例如中断向量表、硬盘参数表。并且把处理器和系统其余部分初始化到一个已知状态。
34. 由于BIOS 提供的这些服务不具备**可重入性**（即其中程序不可并发运行），并且从访问效率方面考虑，因此除了在初始化时会利用BIOS 提供一些系统参数以外，Linux 操作系统在运行时并不使用BIOS 中的功能。
35. 当计算机上电时，CPU会将代码段寄存器CS和IP分别设置为0xFFFF和0xFFF0。（这里以32位平台为例，段长度为64KB，CS<<16+IP）。此时CPU 代码指针指向 0xFFFFFFF0 处，即 4G 空间最后一个64K 的最后 16 字节处。这里正是系统ROM BIOS存放的位置。并且 BIOS 会在这里存放一条跳转指令 JMP 跳转到BIOS 代码中 64KB 范围内的某一条指令开始执行。
36. 由于目前PC/AT 微机中BIOS 容量大多有1MB 到2MB，并存储在闪存（Flash Memory）ROM中。因此为了能够访问到BIOS中超过 64KB 范围而又远远不在 0--1M 地址空间中的其他 BIOS 代码或数据。BIOS 程序会首先使用 32 位访问方式把数据段寄存器的访问范围设置成 4G（而非原来的 64K），这样 CPU 就可以在 0 到 4G 范围内执行和操作数据。此后，BIOS 在执行了一系列硬件检测和初始化操作之后，就会把与原来PC 机兼容的 64KB BIOS 代码和数据复制到内存低端1M 末端的 64K 处，然后跳转到这个地方并让CPU 真正运行在**实地址模式**下，如下图所示。最后BIOS 就会从硬盘或其他块设备把**操作系统引导程序**加载到内存**0x7c00** 处，并跳转到这个地方继续执行引导程序。 
37. <img src="Linux完全注释.assets/image-20200825215446850.png" alt="image-20200825215446850" style="zoom:50%;" />
38. 除了内存和ROM BIOS 以外，还使用只有**很少存储容量**的（只有 64 或128 字节）CMOS（Complementary Metal Oxide Semiconductor，互补金属氧化物半导体）存储器来存放计算机的**实时时钟信息和系统硬件配置信息**。这部分内存通常和实时时钟芯片（Real Time Chip）做在一块集成块中。 CMOS 内存的地址空间在基本内存地址空间之**外**，需要使用 I/O 指令来访问。 
39. 一台 PC 中包含多种控制卡和控制器，用来传输数据和控制计算机运行。这里，控制器是指**集成在计算机主板**上的控制部件，而控制卡则是指通过**扩展槽**插入计算机的控制卡部件。随着主板的集成度提高，控制卡慢慢地转化为控制器。
40. IBM PC/AT 80X86 兼容微机使用两片级联的 8259A 可编程中断控制芯片组成一个中断控制器，1个有8个端口，2个一共可以为15个设备提供独立中断控制功能。在计算机初始化期间，BIOS会对这两个芯片进行初始化，把这15个中断分配给对应的设备。同时在内存开始处0x000-0xfff建立一个中断向量表，并把这些中断请求映射到从0x08开始的中断向量号上。但是由于Intel将中断号0x00-0x1f专门保留给了CPU，所以出现了冲突，因此Linux不会直接使用这些BIOS默认设置好的中断，而是在内核初始化期间，又重新对该中断控制芯片进行了设置。将所有的系统硬件中断号都映射到了0x20及以上。
41. ![image-20200825224001240](Linux完全注释.assets/image-20200825224001240.png)
42. ![image-20200825224040352](Linux完全注释.assets/image-20200825224040352.png)
43. 计算机中使用可编程定时/计数器来处理精确延时，例如在软件中可以使用循环语句来进行延时，但是这样做很耗费CPU资源，如果机器中存在这种芯片，则可以在计数器中设置一个延时，在延时到后，计数器会向CPU发送一个中断信号。
44. Linux0.12内核借助计时器的100Hz中断，来定时切换当前的任务和统计每个任务使用的时间。
45. 我们现在使用的键盘是 IBM 公司于1984 年PC/AT 微机的兼容键盘，通常称为 AT-PS/2 兼容键盘并具有 101 到104 个按键。键盘上有一个称为**键盘编码器**的处理器（Intel 8048 或兼容芯片）专门用来扫描收集**所有按键按下和松开的状态信息**（即扫描码），并发送到主机主板上键盘控制器中。
46. 当一个键被按下时，和一个被按下的键放开时都会发送不同的扫描码（接通码+断开码）。**主机键盘控制器**专门用来对接收到的键盘扫描码进行解码，并把解码后的数据发送到操作系统的键盘数据队列中。
47. 将键盘上所有键的接通码和断开码组合到一起就构成了键盘的一个扫描码集。目前来说，有3套扫描码集可供使用，现代键盘（AT）默认使用第2套，虽然如此，但是主机键盘控制器为了和PC/XT机兼容，仍然会把所有收到的第二套扫描码转化为第一套扫描码。
48. 现在的PC 机都已经将键盘控制器集成在主板芯片组中。键盘控制器接收键盘发送来的11 位串行格式数据。其中第1 位是起始位，第 2--9 位是8 位键盘扫描码，第 10 位是奇校验校验位，第 11 位是停止位。键盘控制器在收到 11 位的串行数据后就将键盘扫描码转换成PC/XT 标准键盘兼容的系统扫描码，然后通过中断控制器 IRQ1 引脚向 CPU 发送中断请求。当 CPU 响应该中断请求后，就会调用**键盘中断处理程序**来读取控制器中的 XT 键盘扫描码。
49. XT键盘扫描码（一个字节宽度）中，一个键的接通码+0x80就是这个键的断开码。而一个字节的宽度只能编码PC/XT标准83键键盘。$2^8>2\times 83$。
50. 对于那些 PC/XT 标准 83 键键盘以后新添加的（“扩展的”）AT 键盘上的按键（例如**右边的 Ctrl键和右边的 Alt 键**等），则其接通和断开扫描码通常有2 到 4 个字节，并且第1 个字节一定是0xE0。
51. 例如，按下左边的非扩展 Ctrl 键时会产生 1 字节接通码 0x1D，而按下右边的 Ctrl 键时就会产生扩展的 2 字节接通码 0xE0、0x1D。对应的断开码是 0xE0、0x9D。
52. 计算机之间通信要遵循相同的协议，该协议规定了传送一个有效数据长度单位的格式，一般称为“帧”。帧的头部一般为同步和通信控制信息，帧的结尾处一般为校验信息。
53. 串行通信是指在线路上以比特位数据流**一次一个比特**进行传输的通信方式。串行通信可分为**异步和同步**串行通信两种类型。
54. 它们之间的主要区别在于传输时同步的通信单位或**帧的长度不同**。异步串行通信以一个字符作为一个通信单位或一帧进行传输，而同步串行通信则以多个字符或字节组成的序列作为一帧数据进行传输。
55. 当无数据传输时，发送方处于传号（MARK）状态，持续发送 1。若需要发送数据，则发送方需要首先发送一个比特位间隔时间的空号起始位。接收方收到空号后，就开始与发送方同步，然后接收随后的数据。
56. 起始位起同步作用，值恒为 0。数据位是传输的实际数据，即一个字符的代码。其长度可以是 5--8个比特。奇偶校验位可有可无，由程序设定。停止位恒为 1，可由程序设定为1、1.5 或2 个比特位。
57. <img src="Linux完全注释.assets/image-20200826121153957.png" alt="image-20200826121153957" style="zoom:50%;" />
58. Linux0.1x只支持文本显示方式。它把屏幕分为行列的矩形方格，每个方格内可以填充一个字符。每个字符还带有一个属性字节。例如MDA显示标准支持80列x25行，一共可以显示2000个ASCII字符。每个字符占据1B，再加上1B的属性，所以总共占据4KB，显示一屏的内容需要4KB。其中偶地址字节存放字符代码，奇地址字节存放显示属性。MDA卡配置有8KB显示内存。在 PC机内存寻址范围中占用从 0xb0000开始的 8KB空间（0xb0000 -- 0xb2000）。
59. 通过设置属性字节的各个位，可以是该字符呈现出多种样式，白底黑字，黑底白字，闪烁，下划线，高亮等。
60. CGA显示标准，CGA卡标配有 16KB显示内存（占用内存地址范围 0xb8000 -- 0xbc000），因此其中共可存放 4帧显示信息。在每一帧 4KB显示内存中，偶地址字节存放字符代码，奇地址字节存放字符显示属性。
61. <img src="Linux完全注释.assets/image-20200826124128508.png" alt="image-20200826124128508" style="zoom:50%;" />
62. 比特位D6、D5、D4和 D2、D1、D0 可以分别组合出 8 种颜色。黑色+高亮度=深灰
63. 后续的增强型图形适配器EGA（Enhanced Grpahics Adapter）和视频图形阵列VGA（Video Graphics Adapter）都兼容或支持 MDA 和 CGA 的显示方式。
64. 硬盘和软盘都是有盘片和驱动器构成。软盘是纯盘片，驱动器是在PC机上，而硬盘是将盘片固定在驱动器中，不可拆卸。二者都是利用盘片表面的一层磁性介质在磁化后的剩磁状态来存储信息的。
65. 软盘通常使用聚酯薄膜作基片，而硬盘片则通常使用金属铝合金作基片。一张软盘中含有一张聚酯薄膜圆盘片，使用上下两个磁头在盘片两面读写数据，盘片旋转速率大约在 300 转/分钟。常见的为3.5寸1.44MB，80个磁道，每个磁道18个扇区，2个盘面。数据传输速率在几百Kbps。
66. 硬盘中的盘片一般较多，因此读写头也多，每个盘面配置一个读写头，例如4个盘片就有8个读写头。
67. <img src="Linux完全注释.assets/image-20200826125306671.png" alt="image-20200826125306671" style="zoom:50%;" />
68. 每个读写头上都有一个读线圈和写线圈，读数据时，盘片旋转，线圈在变化的磁场下，获得变化的电流，因而可以分辨出存储的0和1。
69. GAP 是间隔字段，用于起隔离作用。通常 GAP是 12 字节的0。每个扇区地址场的地址字段存放着相关扇区的柱面号、磁头号（面号）和扇区号，因此通过读取地址场中的地址信息就可以唯一地确定一个扇区。因此一个扇区存储的有效数据为512B，而其占用的空间＞该值的。
70. <img src="Linux完全注释.assets/image-20200826141629602.png" alt="image-20200826141629602" style="zoom:50%;" />
71. 磁盘控制器是 CPU 与驱动器之间的逻辑接口电路，它从 CPU 接收请求命令，向驱动器发送寻道、读/写和控制信号，并且控制和转换数据流形式。控制器必须从实际读/写数据中分离出这些地址信息和一些编码、解码等控制信息。
72. 对磁盘控制器的编程过程就是通过 I/O 端口设置控制器中的相关寄存器内容，并通过寄存器获取操作的结果信息。
73. 由于软盘片比较容易遭到损坏（发霉或划伤），因此目前计算机中已经逐渐开始不配置软盘驱动器。

# 内核编程语言和环境

1. 高级语言编译会产生一些效率不是很高的代码，所以对一些运行效率要求高或性能影响较大的部分代码通常就会直接使用汇编语言来编写，或者对高级语言编译产生的汇编程序再进行人工修改优化处理。

2. 在 Linux 0.1x 系统中使用了两种汇编器（Assembler）。一种是能产生 16 位代码的 **as86** 汇编器，使用配套的 ld86 链接器；另一种是 GNU 的汇编器**gas**（as），使用 GNU ld 链接器来链接产生的目标文件。

3. as86 的语法是基于MINIX 系统的汇编语言语法，使用Intel汇编语法，操作数的次序和AT&T汇编语法相反。Linux 系统仅用它来创建16位的启动引导扇区程序 boot/bootsect.s 和实模式下初始设置程序 boot/setup.s 的二进制执行代码。该编译器快速小巧，并具有一些 GNU gas 所没有的特性，例如宏以及更多的错误检测手段。

4. 现代 Linux 系统上可以直接安装包含 as86/ld86 的 RPM 软件包，例如 dev86-0.16.3-8.i386.rpm。

5. 汇编器专门用来把低级汇编语言程序（由换行符结尾的一系列文本行组成）编译成含机器码的二进制程序或目标文件。

6. 虽然 GNU as 可使用分号在一行上包含多个语句，但通常在编制汇编语言程序时每行只包含一条语句。

7. 汇编语句有如下几类：

   1. 空白行：只包含空格，换行符，制表符。
   2. 赋值语句：例如BOOTSEG = 0x07C0，=左端为标识符。
   3. 伪操作符语句：给汇编器看的，它通常并不会产生任何代码。由伪操作码和 0 个或多个操作数组成。每个操作码都由一个点字符'.'开始。点字符'.'本身是一个特殊的符号，它表示编译过程中的位置计数器，也就是偏移地址。其值是点符号出现处机器指令第1 个字节的地址。 例如.text   .data等。
   4. 机器指令语句：可执行机器指令的助记符，它由操作码和 0 个或多个操作数构成。例如 mov ax, bx
   5. 标号是由一个标识符后跟一个冒号':'组成。在编译过程中，当汇编器遇到一个标号，那么当前位置计数器的值就会赋值给这个标号。例如 bgtext:

8. 在as86汇编程序中，！或；后面均为注释语句。可以单独一行，也可以放在语句行的末尾。

9. <img src="Linux完全注释.assets/image-20200826170444489.png" alt="image-20200826170444489" style="zoom: 50%;" />

10. ".globl"操作符用于定义随后的标号标识符是外部的或全局的，并且即使不使用也强制引入。类似于全局变量，链接的时候要用到。

11. 5-11行的作用是，定义并切换到每个段内，分别定义标号，最后切换到.text段内开始编写随后的代码。

12. 目标文件一般都包含3个段，即正文段.text 、数据段.data 和未初始化数据段.bss。正文段（代码段）和数据段都是已经初始化了，这里的初始化是指在可执行文件中为其分配了空间，未初始化的段在被加载到内存时，操作系统会将该段的内容全部初始化为0。

13. 赋值语句可以使用十进制，八进制，十六进制。

14. entry是关键字，用于迫使链接器 ld86 在生成的可执行文件中包括进其后指定的标号'start'。通常在**链接多个目标文件生成一个可执行文件**时应该在其中一个汇编源程序中用关键词 entry 指定一个入口标号，以便于调试。

    ```assembly
    entry start ; 告知链接程序，程序从start标号处开始执行。标号名可以是任意的。
    start:
    	jmpi go, BOOTSEG
    ```

15. 开机时，BIOS从硬盘的第一个扇区加载到物理内存0x7c00处。此时CPU还在实模式下工作，都是直接访问物理内存。然后设置CS=0，IP=0x7c00，之后开始执行。linux内核并不需要entry这个入口标号，因为BIOS默认从内核镜像的最开始执行。这个地址可以是0:7c00，也可以是7c0:0，因为段地址左移4位+偏移地址都等于0x7c00。之所以进行段间跳转是为了切换段寄存器，这样偏移地址就可以从0开始了。

    ```assembly
    start:
        jmpi go,BOOTSEG ; 段间跳转。BOOTSEG 指出跳转段地址，标号go 是偏移地址。
    go: mov ax,cs ; cs->ax，将ds和es也调整为和cs相同。
        mov ds,ax
        mov es,ax
        mov [msg1+17],ah ; 0x07-->替换字符串中1 个点符号，喇叭将会鸣一声。
    ...
        int 0x10 ; BIOS 中断调用0x10，功能0x13，子功能01。这里还只能调用BIOS中断。
    loop1: jmp loop1 ; 死循环。
    msg1: .ascii "Loading system ..."  ;定义字符数组，.asciz会在默认补上'\0'。
        .byte 13,10  ;定义\r\n两个字符。
        .org 510 ; 表示以后语句从地址510(0x1FE)开始存放。
        .word 0xAA55  #魔数，BIOS通过检测第一个扇区的最后两个字节是否是55和AA来判断是否是有效的引导扇区。
    ```

16. 立即数用#开头，间接寻址用[ ]包围起来。标号默认是间接寻址。

    ```assembly
    mov [bx],ax ;将寄存器ax的值存入到寄存器bx指向的内存单元中。
    jmp [bx]    ;寄存器bx指向的内存单元的值作为要跳转的地址。
    
    mov ax,#1234       ;将立即数1234赋值给ax寄存器。
    mov ax,#msg1       ;将msg1标号偏移地址值赋值给ax寄存器。此时ax的值应该为几十左右，也就是msg1相对于.text的偏移量
    
    mov ax,1234        ;将地址为1234的内存单元的内容赋值给ax寄存器。
    mov ax,msg1        ;将msg1标号偏移地址指向的内存单元赋值给ax寄存器。此时ah的值为'o'，al的值为'L'。
    mov ax,[msg1]      ;等价于上面
    ```

23. 