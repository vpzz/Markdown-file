# 基础

1. 发展历史：
   1. 1960年，ALGOL语言产生，称作A语言。
   2. 1963年，剑桥大学对A语言进行修改提升，发布CPL语言。
   3. 1967年，CPL->BCPL语言。
   4. 1970年，贝尔实验室的肯·汤普森对BCPL语言提升，称作B语言，用B语言+汇编写出了最早的Unix系统。
   5. 1973年，丹尼斯·里奇改进B语言，称为C语言，并重写了Unix系统。
2. 特点：
   1. 特别基础，语法简洁，方便灵活。
   2. 运算符和数据结构丰富。
   3. 结构化的语言，可以进行模块化编程。
   4. 移植性好。诞生的目的就是为了解决各家不同的汇编平台不兼容的问题。一次书写，多次编译即可。
   5. 允许直接对硬件进行操作。可以书写驱动和操作系统内核。嵌入式开发中非常常用。
3. C语言适合于系统级开发，用它来开发应用程序有点大材小用。
4. C标准一开始没有定义void类型，所以最早的main函数的返回值为int，至于main函数的参数，如果不要传参可以留空，或只写void，需要传参则用   int argc, char **argv或char *argv[]。
5. 程序需要指定一个入口，人为地把main函数特殊化了，也可以修改成其他函数。
6. 某些标识符具有链接属性，即它会和其他不在同一个作用域或翻译单元内的标识符引用同一个实体。
7. 函数的定义包含了语句和声明的序列，某些还包含表达式。
8. 声明和表达式会创建，销毁，访问，操作对象。每个对象，函数和表达式都和一个类型相关联。
9. 常见的英文单词：

   ```c
   definition    //定义
   declaration   //声明
   expression    //表达式
   statement     //语句
   identifier    //标识符
   keyword       //关键字
   scope         //作用域
   literal       //字面量
   constant      //常量
   ```

10. 编译器如何处理C源文件：

    1. 将源文件中的每一个字节（可能包含多字节字符）映射到源代码字符集中的字符（这一步和具体实现有关）。同时操作系统相关的行尾指示符会被统一替换为new line，即LF。三联符也会被替换为对应的单个字符。

       ```c
       // 源代码字符集包含基本源代码字符集+LF，一共96个字符。其中一共包含5个空白字符：空格，水平制表符，竖直制表符，换页，换行。
       ```

    2. 若反斜杠\后面紧接着就是LF字符，则将二者都删除，这会将2个物理源代码行合并为1个逻辑源代码行。这一操作是单程的，只会从前到后执行一遍。如果这一步完事后，一个非空的源文件不是以LF结尾，则行为是未定义的。

       ```c
       // 也就是说如果出现两个反斜杠后面为一个空行即\\LFLF，不会作用2次，把这4个字符都删除。
       ```

    3. 源代码被分解为注释，空白字符序列，预处理标记。注释会被替换为单个空格，LF会被保留，非LF空白字符序列可能会被压缩成单个空格（取决于具体的实现）。

       ```c
       //预处理标记包含：
       //1. 头文件名称：例如<stdio.h>或"myfile.h"；
       //2. 标识符；
       //3. 预处理数字：例如整型或浮点型常量，也包含一些无效的标记，例如1..E+3.foo或0JBK；
       //4. 字符常量和字符串字面量
       //5. 运算符和标点符号，例如+ <<= <%或者##
       //6. 不属于其他任何类别的单个非空白字符
       
       //在将源代码解析为预处理标记时，会执行最大贪婪匹配，即使这将导致后续分析失败。例如
       int foo = 1;
       int bar = 0xE+foo;   // error: invalid preprocessing number 0xE+foo
       int baz = 0xE + foo; // OK
       int pub = bar+++baz;   // OK: bar++ + baz
       int ham = bar++-++baz; // OK: bar++ - ++baz
       int qux = bar+++++baz; //=右侧会被解析为bar++ ++ baz
       ```

    4. 预处理器工作，每个由#include引入的文件，也会先执行上面的1-3步，递归地进行。这一阶段结束后，所有的预处理指令都被移除。

    5. 字符常量和字符串字面量中的所有字符和转义字符被从源代码字符集中转化到执行字符集中。

    6. 相邻的字符串字面量被拼接

    7. 执行编译，标记被从语法和语义层面分析，转化为翻译单元。

    8. 执行链接

11. 在64位系统上使用-m32选项来编译生成32位程序，可能会报以下错误，是因为没有安装32位的头文件和库，安装gcc-multilib库即可：

    ```shell
    zj@hit:~/linux_c/process$ gcc test.c -o test -m32
    In file included from test.c:1:
    /usr/include/stdio.h:27:10: fatal error: bits/libc-header-start.h: No such file or directory
       27 | #include <bits/libc-header-start.h>
          |          ^~~~~~~~~~~~~~~~~~~~~~~~~~
    compilation terminated.
    ```

12. -m32：int，long，指针都是32位的。-m64：int是32位，long，指针都是64位的。

13. 在以前的老式键盘中，某些符号是无法直接打出来的，因此就有了用三联符来表示一个字符的做法，类似于现在\转义字符。一共有9个。默认情况下，C预处理器忽略三联符，如果使用了-std或-trigraphs选项，则会处理，如果gcc使用了-Wtrigraphs选项，则会报warning。三联符可以和转义字符联合使用，例如''??/n'表示'\n'，也就是换行符。

    ```
    ??(	           [
    ??)	           ]
    ??<	           {
    ??>	           }
    ??=	           #
    ??/	           \
    ??!	           |
    ??'	           ^
    ??-	           ~
    ```

14. 三联符在C++17中被删除了。

15. 基本字符集（也称为基本源代码字符集）包含95个字符，分为4个不可打印的字符和几段连续的字符。

    ```c
    U+0009 //水平制表符，等价于\t
    U+000B //竖直制表符
    U+000C //换页符，打字机遇到该字符时，会跳到下一页的开头
    U+0020 //空格
    U+0021-U+0023 //少了个U+0024即$
    U+0025-U+003F //少了个U+0040即@
    U+0041-U+005F //少了个U+0060即`，抑音符
    U+0061-U+007E //少了个U+007F即删除符
    
    //C++语言的基本字符集比C语言的多个U+000A,即LF
    ```

16. 基本执行字符集是在基本字符集的基础上再加上5个额外的字符：

    ```c
    U+0000	// Null，空字符，一般作为字符串的结尾标识
    U+0007	// Bell，会触发响铃
    U+0008	// Backspace，效果和退格键一样
    U+000A	// Line feed (LF)
    U+000D	// Carriage return (CR)
    ```

17. CR，LF，FF：

    ```c
    CR //Carriage Return的缩写，表示仅回车不换行。字符为\r，0xD。
    LF //Line Feed的缩写，表示仅换行不回车，字符为\n，0xA。也被称为New Line。feed在这里当作投喂，放入的意思，也就是将一个行放入到机器中。
    FF //Form feed的缩写，表示分页。字符为\f,0xC。
    
    printf("stackoverflow\rnine") //仅回车的话，不同编译器的结果可能不同。
    ninekoverflow //有的编译器会导致覆盖同行的开头部分字符。
    nine //GCC会删除掉同行的所有字符再输出后续的字符。
    printf("stackoverflow\nnine") //被理解为回车+换行
    stackoverflow
    nine
    printf("stackoverflow\fnine") //被理解为仅换行不回车
    stackoverflow
                 nine
    ```

18. 函数的声明和实现应该分开，声明应该都放在开头。

19. main函数的返回值（退出码）是给它的父进程看的。如果是在shell中运行的，它的父进程就是shell，可以用echo $?查看。

20. C语言内的函数返回值人为习惯设置：成功为零，失败为非零，而shell脚本中返回值是成功，true（1）和失败，false（0），正好相反。

21. 如下main函数没有设置返回值，默认他会把printf函数的返回值当做自己的返回值返回，即成功输出的字符个数。

22. ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    int main (){
        printf("HaHa");
    }
    ```

23. 注释可以看作是代码内的文档：

    ```c
    /*
    * 多行注释，称为C风格注释
    */
    
    // 单行注释，C99标准引入，也称为C++风格注释
    
    // 如果/*或//出现在字符常量，字符串字面量或注释中，它不会表现出注释行为
    '/*'  '//'   这样并不会报错，他们是多字节字符常量，会被当作int类型
    "/*"  "//"
    /* /* */    // //
    // /*       /* // */
    
    //C风格注释无法嵌套使用，此时会报错，提示第一个/*没有对应的结束*/，而C++风格注释可以嵌套
    /*  /* */  */
    // //
    
    // C++风格的注释的范围不包括末尾的换行符，因此替换注释时不会把末尾的换行符替换掉。
    // 在处理注释时，会检测如果/*不再字符常量，字符串字面量，注释中是，会尝试逐个判断其后的字符（包括多字节字符），直到发现一个*/字符序列，中间的内容则是注释，//会检测行尾。
    //两种注释可以相互嵌套
    //  y = f(x);   /* invoke algorithm */
    /*
        y = f(x);   // invoke algorithms
        z = g(x);
    */
    ```

24. 特殊的注释：

    ```c
    //可以使用条件恒为0的条件编译来进行注释
    #if 0
    	注释内容
    #endif
    //也可以使用条件恒为0的if语句
    if(0) {
        puts("这句话会被编译，但是不会被执行");
        /* no conflict with C-style comments */
        // no conflict with C++-style comments
    }
    ```

25. C99中引入的//注释方法，可能会对某些C89的代码造成影响：

    ```c
    a = b //*divisor:*/ c
    + d;
    
    /* C89 会当作 a = b / c + d;
       C99 会当作 a = b + d;
       为了避免这种情况，不应将语句跨行，且/**/注释应该单独列一行
    */
    //这是因为C语言的表达式和语句允许跨行书写，因为语句和表达式是以分号为界的，换行只是为了美观，甚至可以将整个源代码写到一行中。例如
    int a;
    a = 1 +
        2;
    printf("%d\n", a); //输出3
    //以下代码也是合法的
    int a; a = 1 + 2; printf("%d\n", a);
    ```

26. 函数的注释可以用如下方式书写：

    ```c
    /**
     * list_add - add a new entry                 函数简介
     * @new: new entry to be added                逐个介绍参数
     * @head:list head to add it after
     *
     * Insert a new entry after the specified head.        长介绍
     * This is good for implementing stacks
     */
    static inline void list_add(struct list_head *new, struct list_head *head){
    	}
    ```

27. 防止写越界，防止内存泄露，谁打开谁关闭，谁申请谁释放。

# 基本数据类型，运算符，表达式

## 基本数据类型

1. C语言中的数据类型：下表不包含C99标准中的bool类型。

   ```c
   1. 基本数据类型：
      1. 数值类型：
         1. 整型：
            1. 短整型 short
            2. 整型 int
            3. 长整型 long
         2. 浮点型：
            1. 单精度 float
            2. 双精度 double
      2. 字符类型 char
   2. 构造类型：
      1. 数组 []
      2. 结构体 struct
      3. 共用体 union
      4. 枚举类型 enum
   3. 指针类型：
   4. 空类型：void
   ```

2. 基本数据类型所占的字节数和机器的硬件有关，标准C中并没有规定基本数据类型的字节数，标准C中之规定了类型之间的字节数关系。通常来说，int，float和long类型都占一个字长大小。对于32位的机器，一个字长是4个字节。

3. C语言的变量赋值只能识别10,8,16进制，不识别二进制。254的2,8,16进制表示分别为B11111110 0376 0xFE。

### 整数的存储

1. 负整数在计算机中的表示，很容想到用一位来表示符号位，该位为0表示正数，为1表示负数。而具体的实现要比这个复杂，整型数值在计算机中都是按照补码形式存储的。整数的补码是他本身，负数的补码是相反数的二进制取反+1。例如：
2. 4字节的int类型变量254，它的二进制为$(00000000\quad00000000\quad00000000\quad11111110)_2$。补码也是这个。
3. 4字节的int类型变量-254，相反数254的二进制位$(00000000\quad00000000\quad00000000\quad11111110)_2$。取反为$(11111111\quad11111111\quad11111111\quad00000001)_2$。然后再加$(1)_2$，得到-254的补码为$(11111111\quad11111111\quad11111111\quad00000010)_2$。
4. 如果将0当做正数，那么补码为0，如果当做负数，补码也是0，因为相反数取反后为全1，再加1就溢出得到全0。
5. 使用补码的原因是，所有的加法运算可以用同一种电路完成。即正数+正数，正数+负数，还有负数+负数都可以直接按位相加即可。例如254+（-254）=$(00000000\quad00000000\quad00000000\quad11111110)_2+(11111111\quad11111111\quad11111111\quad00000010)_2=(0)2$。
6. 最高位的溢出会自动舍去。补码的本质实际上是小学算数中的借位，以8位的整数为例，-8=0-8，而$(00000000)_2<(00001000)_2$，因此需要问上一位借1，即$(100000000)_2-(00001000)_2=(11111000)_2$。而$(100000000)_2=(11111111)_2+1$，而$(11111111)_2$减任何数就相当于该数按位取反，因为它减任何数总是够减的。
7. 如果已知一个负数的补码，它对应的正数的补码可以按照“取反+1”的方法求得。
8. 引入补码后，计算机只需要有补码电路和加法电路就可以完成所有整数的加法了。

### 浮点数的存储

1. 浮点数的存储分为三部分，符号位，幂次，有效数字。例如$0.00789 -> 0.789*10^-2$。
2. ASCII码表的前128是标准C中规定的，后面128个成为扩展ASCII码表，主要增加了一些欧洲国家的字母。
3. 字符串末尾的'\0'就是ASCII码的第一个字符，称作空字符。
4. 0-9，A-Z，a-z在ASCII码表中不是连续的。
5. 标准C中没有定义char型是有符号还是无符号。如果怕出错可以用int类型来替代，因为char型的出现就是当做一个精简的int来使用的。大部分编译器都当做他是一个有符号的，范围从-128~127。由于char型的数据范围较小，有些函数的传参一般用int来替代。
6. 浮点数不应该用==来判断数值，因为它本身就不是一个精确的值，应该做减法，观察是否小于某一个可以忽略的数，来判断是否相等。
7. 浮点数可以用科学计数法的形式输入，例如double a = 2.1e5表示$2.1\times 10^5$。

### 不同类型的数据之间转换

1. 浮点数转化为整数时，会丢失精度，扔掉小数部分，而不是四舍五入。
2. 类型转化分为两种：
   1. 隐式：小范围的类型和大范围的类型做运算时，小范围的类型会自动转化为大范围的。例如char+int       int+double   float+double。
   2. 显式：强制类型转化。

### 特殊情况

1. 应该加入头文件<stdbool.h>。可以用int来代替。取值有true和false。
2. 不同形式的零：
   1. 0，整型数值0。
   2. '0'，单个字符，ASCII码为48。
   3. "0"，字符串，实际上是'0'+'\0'的组合。
   4. '\0'，空字符，ASCII码表的第一个字符。

## 常量

1. 常量就是在程序执行过程中不会发生变化的量。

2. 数组名就是一个典型的常量，就是记录着数字起始位置的内存地址。修改他的值就像是运行   1=2 这样的运算一样。

3. 常量的分类：
   1. 整型，类似于1,2,3之类的数，标准上没有规定类型。大多数编译器会将它看做是int类型。编译器会将123L和123LL看做是long和long long类型。对于结果可能越界的数值，应该加上类型，例如：

      ```c
      long long a = 1024*1024*1024*3;    //会提示越界，因为=右侧的计算默认是按照int来的，得出的结果超过了int的范围。
      long long a = 1024LL*1024*1024*3;  //给第一个或所有的操作数都加上LL则不会发生溢出，给第一个加上，因为运算顺序是从左到右，因此后面的都会依次转化为long long类型。不过还是都加上的比较稳妥。
      ```

      1. MSVC直接将整型常量当做int类型，3LL当做long long类型的

   2. 实型，类似于1.2,3.2之类的数，还可以用科学计数法来表示 3.2e3，3.2E3，标准上没有规定类型。大多数编译器会将它看做是double类型。MSVC直接将实数常量当做double类型，123.456会被当作(double)(123.4560000000000031)。

   3. 字符常量，由单引号包括的单个字符或转义字符，例如'a'   '\n' 之所以用转义字符，是因为这些字符是无法显示或无法输入的。程序会自动替换为对应的ASCII字符。还有就是可以用转义的方法来表示其余的ASCII字符，例如：
      1. 三位八进制数，'\015'表示ASCII编码$(015)_8$的字符，即\n''。==待验证==
      2. 两位十六进制数，'\x5c'表示ASCII编码为$(5c)_{16}$，即'\'。
   
   4. 字符串常量，由双引号包含的一个或多个字符组成的序列。例如 ""    "ab"。""表示空字符串，只有一个字符'\0'。"a\n\015"有4个字符组成。字符串常量没有对应的类型，只能借助数组来保存。

   5. 标识常量 #define PI 3.14    宏名习惯使用大写。

4. 还有一种特殊的字符常量，即多字节字符常量：

   ```c
   'ab' == 24930; //结果为true
   ```

## 变量的存储类型

1. 变量的定义如下，数据类型可以是基本数据类型或构造类型。

   ```c
   [存储类型] 数据类型 标识名;
   ```

2. 存储类型有：

   1. auto，如果没有指定存储类型，默认是auto。空间是自动分配，自动回收。放在栈空间中。一般不会自动初始化，不过有的编译器会初始化。

   2. static，静态类型，会将变量自动初始化为0值或空值。变量的值具有继承性，例子：

      ```c
      #include <stdio.h>
      #include <stdlib.h>
      
      void fun1 (){
          int x = 0;
          x = x + 1;
          printf("%p->%d\n",&x,x);     //%p会将内容按照指针的形式输出。
      }
      void fun2(){
          static int x = 0;
          x = x + 1;
          printf("%p->%d\n",&x,x);
      }
      int main (){
          fun1();
          fun1();   //调用两次fun1函数，会看到每次输出的局部变量x的地址都不相同。实际上在这个例子中，会输出相同的地址，因为栈的空间是连续分配的，第一次调用func1结束后，栈又恢复到了原来的样子。第二次调用的时候会再分配原来的地址。
          fun2();
          fun2();  //可以看到每次的x都是同一个地址。第二次调用的时候并不会再开辟新的内存空间用于存放，而是继续使用原来的地方，也不会进行初始化赋值。因此两次分别输出1和2。
      	exit(0);
      }
      ```

   3. static用来修饰全局变量或函数时，还表明该变量或函数只能在当前.c文件中被使用。例子见《static 修饰全局变量或函数》一节。

   4. register，寄存器类型，操作速度特别快，适合于经常操作的数据，只能用于定义局部变量。这个类型是建议型的（类似于内联函数inline关键字），即程序员建议编译器将该变量放到寄存器中，但是决定权在编译器手中。寄存器没有地址，且不能是double，float，long类型。
   
   5. extern，前三种是定义型，这个是说明型。说明当前变量是定义在其他地方的，因此不能改变被说明的变量的值或类型，只能进行使用。

## 变量的生命周期和作用范围

1. 全局变量是定义在所有函数以外的变量。作用范围是从定义的位置开始直到当前程序结束。

2. 局部变量的作用范围是从声明的地方开始，到最内层的块结束。

3. 内部的变量会屏蔽外部的，但是不会覆盖，例如：

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   
   func(){
       printf("%d\n",i);  //会报错，提示找不到标识符。将该函数，移动到全局变量i下面声明，即可运行通过。
   }
   
   int i = 100;   //作用范围是8-25行。
   
   int main (){
   	printf("%d\n",i);   //输出为100。使用的是全局变量i。
   	int i = 3;  //作用范围是12-25行。
   	{
   		printf("%d\n",i);    //输出为3。使用的是第12行的局部变量i。
   		i++;
           int i = 10;   //作用范围是16-19行。
           i++;
           printf("%d\n",i);   //输出为11.
   	}
   	printf("%d\n",i);    //输出为4。这里的i是第12行定义的变量。
       printf("%s\n",__FUNCTION__);  //输出main。
   }
   
   /*循环初始化变量的作用域*/
   int main(){
       for (int j = 0;j < n; j++) {  //变量j的有效范围就是在循环内。在循环外就失效了。
   		a++;
   	}
       i++;  //编译错误，提示未定义。
   }
   ```

4. 函数的{}和单纯的语句块{}是一样的，都是界定内外变量。如果没有{}，则int i =3；会发生重复定义的错误。

5. 全局变量容易造成空间污染，也容易泄露重要信息。

6. 循环和递归中的变量：

   ```c++
   for (int i = 0; i < 10; i++){
       int a = 3;   //第一次执行该语句时会声明，然后赋值，之后再执行，只会赋值。不过一般不应再循环中声明新的变量，容易混淆。
       a++;
       printf("%p\n",&a);  //输出是相同的。
   }
   void fun() {
   	int a = 3;   //每次递归都会创建新的变量，会暂时屏蔽掉之前的变量。
   	a++;
   	printf("%p\n", &a);  //每次输出的地址都不同。
   	fun();
   }
   void fun() {
   	static int a = 3;   //第一次运行的时候会分配空间，之后再执行，就不分配新的空间了，只进行赋值。
   	a++;
   	printf("%p\n", &a);  //每次输出的地址都是一样的。
   	fun();
   }
   ```

7. static修饰局部变量，是之成为静态变量，存储在静态区域，它和全局变量的区别就是作用于被限制了，只有在定义它的函数内才可以使用，而全局变量是任意地方都可以使用。

8. 可以让利用gcc自带的宏，来打印当前语句所在的函数体的名字，\_\_FUNCTION\_\_。还有如下几个宏：

   ```c
   __LINE__    //在源代码中插入当前所在的行号
   __FILE__    //在源代码中插入当前文件名
   __DATE__    //编译日期
   __TIME__    //编译时间
   __STDC__    //当要求程序严格遵循ANSI C标准时，可以给此值赋为1
   __cppplus   //当编写C++程序时，此值会自动被赋值为1
   ```

## static 修饰全局变量或函数

1. 如下还有名。变量和函数，使得他们只能在当前.c中被访问，这个就像Java或C++中的private修饰符，函数也可以看作是全局变量。例如：

2. main.c

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include  "proj.h"
   
   int a = 100;
   int main(){
       func();
       printf("[%s]\n",__FUNCTION__);
       return 0;
   }
   ```

3. proj.c

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include  "proj.h"
   
   static int a = 5;
   static void func(){
       printf("[%s]\n",__FUNCTION__);
   }
   ```

4. proj.h

   ```c
   #ifndef PROJ_H
   #define PROJ_H
   
   static void func();
   
   #endif
   ```

5. 加上static之后，编译时会出现如下警告：proj.h:4:13表示 proj.h文件的第4行，第13列的字符处。链接时会报错提示找不到func的定义。

   ```shell
   [zj@ZJ ~]$ gcc main.c proj.c
   In file included from main.c:1:0:
   proj.h:4:13: 警告 'func'使用过但从未定义 [默认启用]
    static void func();
                ^
   /tmp/ccJpDVSv.o: 在函数'main'中:
   main.c:(.text+0xa): 对'func'未定义的引用
   collect2: 错误: ld 返回 1
   ```

6. 多个文件可以一起指定给gcc(gcc *.c)，也可以逐个编译，然后一起链接(gcc *.o)。实际上gcc在编译工程时，也是一个一个.c文件编译，然后再链接到一起的。在上面的例子中，编译main.c文件时，发现使用到的func函数在当前文件中有了声明（预处理引入的），就不会报编译错误。而链接时，由于该函数时static修饰的，因此只会在当前.o文件中查找函数的实现。结果并没有找到，所以会报未定义的错误。

8. ```shell
   [zj@ZJ ~]$ gcc -c proj.c
   [zj@ZJ ~]$ gcc -c main.c
   [zj@ZJ ~]$ ls
   main.c  main.o  proj.c  proj.h  proj.o
   [zj@ZJ ~]$ gcc main.o proj.o -o main
   [zj@ZJ ~]$ ./main
   [func]
   [main]
   [zj@ZJ ~]$
   ```

9. 函数和变量的修饰在 头文件(proj.h)中的定义，和源文件(proj.c)中的实现要相同。源文件中可以包含自己的头文件，也可以不包含。如果在一个.c文件中要使用其他.h文件中的定义，一般将该.h文件包含在自己的.h文件中。

10. 如果proj.c和main.c文件中的全局变量i命名相同，且都没有static，那么链接时会发生报如下错误，提示发现了全局变量的重复定义，并给出了这两次定义的地方。

11. 关于全局变量的问题，编译时，两个文件中都有对应的定义，不会报错。链接时，如果没有加static，那么链接器就会在所有的.o文件中查找，结果发现两个文件中都定义了全局变量i，因此会报错。

    ```shell
    [zj@ZJ ~]$ gcc main.c prpj.c
    /tmp/ccbuFNz4.o:(.data+0x0): a 的多重定义
    /tmp/cclmAWLs.o:(.data+0x0): 第一次再次定义
    collect2: 错误:ld 返回 1
    ```

12. 从上面可以看出来，使用static修饰全局变量或函数，可以对他们进行隐藏，也可以避免发生命名冲突。

14. 更进一步，可以对.c文件中的函数和变量进行封装，提供统一的访问接口，例如：

15. main.c

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include  "proj.h"
    
    int a = 100;
    int main(){
        call_func();
        printf("[%s]\n",__FUNCTION__);
        return 0;
    }
    ```

16. proj.c

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include  "proj.h"
    
    static int a = 5;
    static void func(){
        printf("[%s]\n",__FUNCTION__);
    }
    void call_func(){
        func();
    }
    ```

17. proj.h

    ```c
    #ifndef PROJ_H
    #define PROJ_H
    
    void call_func();
    
    #endif
    ```

18. 用户使用.h文件时，只会发现提供好的调用接口call_func，不会发现背后的func函数。

## extern 修饰符

1. extern修饰的变量表示该变量定义在其他文件中，编译时不要报错，链接时自然会找到。有时候当前.c需要使用其他.c文件中定义的全局变量。就可以在当前.c中用extern修饰一下声明，例如：
2. 在当前.c中不声明会导致编译出错：

   ```shell
   [zj@ZJ ~]$ gcc *.c
   proj.c: 在函数'func'中:
   proj.c:9:37: 错误: 'a'未声明(在此函数内第一次使用)
        printf("[%s],%d\n",__FUNCTION__,a);
   
   proj.c:9:37: 附注: 每个未声明的标识符在其出现的函数内只报告一次
   ```
3. 如果使用extern声明的同时，进行初始化，例如：extern int a =100;  则编译时会报警告，链接时会报错误：

   ```shell
   [zj@ZJ ~]$ gcc *.c
   proj.c:7:12: 警告: 'a'已初始化，却又被声明为'extern' [默认启用]
    extern int a = 5;
               ^
   /tmp/ccSMBrqN.o:(.data+0x0): a 的多重定义
   /tmp/ccJY3QtF.o:(.data+0x0): 第一次在此定义
   collect2: 错误: ld 返回 1
   ```
5. extern生命的变量不能进行初始化，类型也不能选错。不写类型也是可以的，例如extern i;

## 运算符和表达式

1. 语句=表达式+分号。

2. 运算符的种类：

   ```c
   算术运算符: + - * / % ++ --
   关系运算符: < <= == > >= !=
   逻辑运算符: ! && ||
   位运算符:   << >> ~ | ^ &
   赋值运算符: =及其扩展
   条件运算符: ?:
   逗号运算符: ,
   指针运算符: * &
   求字节数:   sizeof
   强制类型转换: (类型)
   成员运算符: . ->
   下标运算符: []
   其他:       ()
   ```

3. 运算符的优先级和结合性：

   ```c
   //优先级从高到低排列
   结合性     运算符
   从左到右   ()、[]、.  //分别为函数调用，数组索引，结构体成员
   从右到左   !、+、-、~、++、--       //都是一元运算符，+和-为正负号
   从左到右   *、/、%
   从左到右   +、-      //二元运算符，加和减
   从左到右   <<、>>、>>>     //最后一个是无符号右移，高位补0
   从左到右   <、<=、>、>=、instanceof 
   从左到右   ==、!=
   从左到右   &    //按位与
   从左到右   ^
   从左到右   |
   从左到右   &&
   从左到右   ||
   从右到左   ?:
   从右到左   =  //=的扩展也包含在内，例如+=，-=
   ```

4. *，()，[ ]的优先级

   ```c
   //函数调用符()和数组作用符[]的优先级是相同的，都高于解引用符*
   char *p[3];  //[]高于*，因此为char* (p[3])，定义了一个数组，有三个元素，每个元素都是char*
   char (*p)[3] //定义了一个指针，指向一个包含3个char的数组
   void *f(double) //()高于*，因此为void *(f(double))，定义了一个函数，参数为double，返回一个void*
   void (*f)(double) //定义了一个指针，指向一个函数，参数为double，返回一个void
   ```

7. *和++的优先级：

   ```c
   // ++高于*
   const char* p = "abc"; 
   int a = *p++;  //等价于int a = *(p++); 结果a='a'
   //可以拆分为 const char* tmp = p; p = p+1; int a = *tmp;
   ```

8. 整型除法结果还是整型，取余数运算%的操作数必须是整型：

   ```c
   5/2;    //结果为2。
   5.0/2;  //结果为2.50..  double类型。
   5%2;    //结果为1。
   ```

9. 常量不能做自增，因为自增中包含赋值。不同的编译器对复杂的自增运算表达式结果不同，不建议使用。

   ```c
   int i=1, j=5, value;
   value = i++ + ++j;      //表达式的核心是加法，先做j=j+1，在做i+j，最后做i=i+1。因此value=7,i=2,j=6。
   ```

10. 关系运算符得出的结果是逻辑值，true或false。非零为真，零为假。

11. 逻辑运算符具有短路特性：

    ```c
    int a =0;
    (1>2)&&(a=1);      //左侧的表达式结果为false，因此整个逻辑表达式的值也就为false，没必要计算右侧表达式的值，因此a不会被赋值为1，还等于0。
    ```

12. 赋值表达式的值就是=左侧的变量赋值后的值，例如(a=3)的值为3。

    ```c
    int a =6;
    a -= a +=3;  //从右往左计算，先计算 a = a+3，结果a=9; 在计算a = a-9；此时a也等于9，因此a=9-9=0，最终a=0。
    ```

13. 条件运算符(三目运算符)，如果表达式1的值为true，则计算表达式2，并当做整个表达式的值，而表达式3并不会被计算，反之同理。表达式可以是逗号表达式或赋值表达式。等价于一个if语句：

    ```c++
    //表达式1?表达式2:表达式3           只能是表达式，不可以是break或continue之类的关键字。
    if (a>b){
    	return a;
    }else{
    	return b;
    }
    ```

14. 逗号表达式的值是最后一项的值，a=1,b=3的值为3。但是前几项都会进行计算，从左往右依次计算。

15. sizeof是一个运算符，而不是关键字。求变量或类型所占的字节数，结果为整数。

16. 强制类型转化并不会修改原来的值，程序中一般不应使用强制类型转换。：

    ```c
    double a = 1.3;
    int c = 0;
    c = (int)a;     //a还是1.3。
    ```

17. 位运算一般用来操作硬件，嵌入式开发中，内存较小，将一些小范围的数据存储在某些位上即可。例如可以将bool类型的数据存在一位上，或者将一个取值范围为0-3的变量用2位存储。文件的权限也是用位来存储的。

18. 左移空出来的位置会补0，右移空出来的位置，有符号数会补充符号位，无符号数补充0。不超范围的时候，相当于乘除2。左移操作比乘法操作快的多。除不尽时，相当于向小的方向取整，即-∞。

    ```c
    int a = -25 >> 4;  //a=-2
    a = -2 >> 4;       //a=-1
    a = 18 >> 4;       //a=1
    unsigned short n3 = 0xffe0;
    n3>>=4;   //结果为0x0ffe,左边补0
    ```

19. |是按位或，&是按位与，~表示按位取反，^表示异或，相同为0，不同为1。都具有交换律。

20. 包含负数的位运算都是用补码来计算的。即内存中实际的存储形式。

21. 将某个数的第n位置为1：

    ```c
    num = num | (1<<n);   //num为整数。
    1<<n后的结果为：000...00100...000; 第n位为1,其余都是0。从0开始计数。
        任意位和0或,结果都是他自己，和1或,结果都是1。
    ```

22. 将某个数的第n为置为0：

    ```c
    num = num & (!(1<<n));
    !(1<<n)的结果为：111...11011...111; 第n位为0,其余都是1。从0开始计数。
    	任意位和1与,结果都是他自己，和0与,结果都是0。
    ```

23. 测试一个数的第n位是0还是1。

    ```c
    sig = num &(1<<n);    如果num的第n位为0，结果为0；如果为1，结果为1。
    ```

24. 从一个数中取出某几位，例如第3-4位：

    ```c
    result = num &(11<<3)
        11<<3 结果为000..011000  按位与的结果的范围在0-3之间。分别表示00 01 10 11这4种情况。
    ```

25. 有两个int型整数，a和n，其中0<=n<=31，要求写出一个表达式，使之等于a的第n位。

    ```c
    (a>>n) & 1
    ```

26. 异或操作具有取反的功能，例如将一个int型数据的低8位取反，其余位不变：

    ```c
    num ^= 0xff; //1和0异或为1,1和1异或为0。相当于取反。任何数和0异或都是他本身。
    ```

27. 异或运算的特点：如果a\^b=c，那么b\^c=a，c\^a=b。可以利用这个特性来做简单的加密和解密，例如a为明文，b为密钥，则c为密文。

28. 异或运算可以不通过临时变量来交换两个变量的值。

    ```c
    int a=5,b=7;
    a = a^b;
    b = a^b;
    a = a^b;
    ```

# 标准输入输出

## printf

1. 格式化输出和输入函数都是变参函数：

   ```c
   int printf(const char *format, ...);      //printf自己也不知道有多少个参数，因此参数和格式字符不对应也可以。format被称为格式/模式字符串，可以是多字节字符序列。
   %[修饰符]格式字符 //通过这个格式标记，实际上是将变量或字面量转化为特定的字符串，然后将所有的字符串拼接到一起，再进行输出。
   //打开GCC的-Wformat选项，还可以让编译器进行参数检查，检查格式字符串和后续参数的数量，类型对应关系。如果参数比格式字符串中的多，则多余参数会被忽略，反之，可能会造成意外结果。
   ```

2. 格式字符串的语法，以下两种都可以：

   ```c
   % [ param-no $] flags width [ . precision ] type conversion//例如"%-10.8ld"，flag标志为-，width最小域宽度为10，precision精度为8，type类型修饰符为l，conversion格式字符为d。意思是将一个long int参数以10进制整数输出，在10位的空间内左对齐，最少占用8位。
   //width是最小域宽度，即如果正常转换后，输出的位数小于这个值，则会填充空格，如果超过这个值，则不会截断。转换后的字符串在域内默认是右对齐。
   //precision对于浮点数来说就是小数点后的位数，对于整数来说，如果precision<实际位数，则正常输出不截断，反之则补0。
   % [ param-no $] flags width . * [ param-no $] type conversion
   ```

3. width和precision还可以是\*，此时当前格式符对应的前一个参数会被当作width或precision，需要是int类型，如果是负数，对于width则表示左对齐，最小域宽度为该数的绝对值，对于precision则表示precision失效。如果一个格式符中同时给width和precision都指定成了\*，则field在precision之前。某些C库可能不认识这种语法。

   ```c
   #include <stdio.h>
   int main() {
       int a = 5;
       int b = 3;
       printf("X%*dX\n", b, a); //输出为"X  5X"，若b=-3，则输出"X5  X"。
       printf("X%*.*dX\n", -5, b, a);//width为-5，因此最少5位，左对齐，precision为3，由于a为1位，所以会补0，输出为"X005  X"。
       return 0;
   }
   ```

4. 格式字符如下：

   ```c
   d i //带符号十进制方式输出整数，d和i在printf时相同，但是在scanf时不同。
   u   //无符号十进制方式输出整数
   b B //无符号二进制方式输出整数，区别是，当存在#flag时，%b会导致数字的前导为0b，而%B会使用0B，类似于%x和%X的区别。不过%b为ISO C2X的特征，%B为ISO C2X的可选特征。C2X为2016年开始为预计发布于202X年的下一代C标准所起的名字。现在新一代标准已经发布，就是C23。不过在gcc11.4中使用--std=c2x也会报warning，unknown conversion type character ‘B’ in format。
   o    //无符号八进制方式输出整数
   x X  //十六进制方式输出整数
   f F  //小数形式输出浮点数，类似于[-]ddd.ddd，%f输出小写，%F输出大写
   e E  //指数形式输出浮点数，[-]d.ddde[+|-]dd，指数部分最少为2位，%e输出小写，%E输出大写
   g G  //当写成指数时，指数部分<-4或>=precision，则以指数输出，否则以小数输出。0精度会被当作1精度，%g输出小写，%G输出大写。小数部分的末尾0会被删除，只有小数点后确实有数字才会出现小数点。
   a A  //十六进制分数记号，类似于[-]0xh.hhhp[+|-]dd，例如0.25会被输出为"0x1p-2"。这个是为了以文本形式表示浮点数，以方便在不同程序或及其之间传递。小数点左侧只有1位，
   c    //单个字符
   C    //等价于%lc，为了兼容Unix标准
   s    //字符串
   p    //指针
   m    //输出errno对应的出错字符串。
   %    //%%会输出%本身，比较特殊，不是使用\转义
   ```

5. flag：

   ```c
   -  //指定输出数据在域内左对齐，默认为右对齐。
   +  //指定在%d和%i输出正数时，显示正号+，默认不显示。("%d\n",+15)也不会输出+15
    //这里的flag为一个空格，指定在%d和%i输出时，如果结果不带正负号，则添加一个空格的前缀
   0  //输出数值时指定左侧未使用的空位，用0填充。如果flag指定为-或提供了precision，则忽略这个flag
   #  //在二进制，八进制和十六进制数前显示前导0b,0或0x。对于%m，则输出十进制的error数。对于浮点数，表示始终包含小数点，即使其后没有数字。
   '  //根据LC_NUMERIC环境变量，将数值分组
   ```

6. 整型修饰字符：

   ```c
   //如果没有修饰字符，那么%d和%i会将参数当成int类型，%b,%B,%o,%u,%x和%X会将参数当作unsigned int
   //char和short类型的参数会被直接隐式转化为int
   hh //会使得char或unsigned char不隐式地转化为int
   h  //会使得short或unsigned short不隐式地转化为int
   j  //指明对应的参数是intmax_t或uintmax_t
   l  //如果修饰整型，指明对应的参数是long int或unsigned long int类型，如果修饰字符型，则表示宽字符(串)
   L  //等价于ll和q，指明对应的参数是long long int。之所以用q，是因为long long int也被称为quad int。
   t  //指明参数是ptrdiff_t
   z Z //指明参数是size_t类型。z是C99引入的，Z是GNU扩展支持的。
   //有符号数的例子
   printf("|%5d|%-5d|%+5d|%+-5d|% 5d|%05d|%5.0d|%5.2d|%d|\n",a);  //a分别为0,1,-1,100000。
   |    0|0    |   +0|+0   |    0|00000|     |   00|0|
   |    1|1    |   +1|+1   |    1|00001|    1|   01|1|
   |   -1|-1   |   -1|-1   |   -1|-0001|   -1|  -01|-1|
   |100000|100000|+100000|+100000| 100000|100000|100000|100000|100000|
   //无符号数的例子
   printf("|%5u|%5o|%5x|%5X|%#5o|%#5x|%#5X|%#10.8x|\n",a); //a分别为0,1,100000。
   |    0|    0|    0|    0|    0|    0|    0|  00000000|
   |    1|    1|    1|    1|   01|  0x1|  0X1|0x00000001|
   |100000|303240|186a0|186A0|0303240|0x186a0|0X186A0|0x000186a0|
   ```

7. 浮点型修饰字符：

   ```c
   //当没有修饰字符时，浮点数参数默认当作double类型，默认情况下float类型的值会被隐式转换为double。
   L  //指明参数为long double。
   //例子：
   printf("|%13.4a|%13.4f|%13.4e|%13.4g|\n",a);
   |  0x0.0000p+0|       0.0000|   0.0000e+00|            0|
   |  0x1.0000p-1|       0.5000|   5.0000e-01|          0.5|
   |  0x1.0000p+0|       1.0000|   1.0000e+00|            1|
   | -0x1.0000p+0|      -1.0000|  -1.0000e+00|           -1|
   |  0x1.9000p+6|     100.0000|   1.0000e+02|          100|
   |  0x1.f400p+9|    1000.0000|   1.0000e+03|         1000|
   | 0x1.3880p+13|   10000.0000|   1.0000e+04|        1e+04|
   | 0x1.81c8p+13|   12345.0000|   1.2345e+04|    1.234e+04|
   | 0x1.86a0p+16|  100000.0000|   1.0000e+05|        1e+05|
   | 0x1.e240p+16|  123456.0000|   1.2346e+05|    1.235e+05|
   ```

8. 例子：

   ```c
   int i = 23456;
   printf("%4d",i);    //输出为"23456"。     4<数据宽度=5，因此按照实际输出。
   printf("%8d",i);    //输出为"   23456",左侧默认补充3个空格，右对齐。
   
   float a = 123.456;
   printf("%f",a);     //输出为。"123.456001" 默认是6位小数，之所以出现末尾的1是因为将123.456赋值给单精度浮点类型的a,会丢失精度。如果想要不丢失精度输出，那就应该用double类型接受，然后使用%lf输出。%f只适合于输出float类型的值。
   printf("%.1f",a);   //输出为"123.5"。
   printf("%6.1f",a);  //输出为" 123.5"。 .1后整体宽度为5(小数点也算在内),因此左侧会补1个空格。
   
   char str[] = "HelloWorld";
   printf("%.5s",str);      //输出为"Hello"，只输出字符串的前5位。
   printf("%8.5s",str);      //输出为"   Hello"，只输出字符串的前5位,左侧补空格。
   printf("%-8.5s",str);      //输出为"Hello   "，只输出字符串的前5位,右侧补空格。负号要求加载数字的前面。
   
   int cc = 255;
   printf("%#x",a);    //输出为"0xff"。
   printf("%#o",a);    //输出为"0377"。
   ```

9. 如果将数值0，以precision=0输出，则什么也不会输出。

   ```c
   #include <stdio.h>
   int main() {
       printf("X%.0dX\n", 0); //输出为"XX"
       return 0;
   }
   ```

10. 如果带输出的值是无穷大或NaN，那么输出结果会是[-]inf或nan，或者[-]INF或NAN。

11. 有符号变量使用%u输出时，变量的值应该是正数。无符号变量使用%d输出时，应该在有符号数的范围内。

12. 对于浮点数，precision默认为6，如果设为0，则小数点也不输出了。

13. 对于%g和%G，precision表示有效数字的个数，有效数字从小数点前的第一位开始。

14. %f默认保留6位小数，不够的补0，多余的截去。实际是float精度，%lf是double精度。

15. 要读入double类型，必须要用%lf来读入，以免精度丢失。而输出，由于printf中并无对%lf的严格定义，故使用%lf不一定会出现想要的结果。由于c语言中的默认参数提升规则，%f输出的不论是float还是double都会被提升到双精度进行输出，并不会有精度丢失。

    ```fortran
    int main() {
        float a;
        double b;
        scanf("%f %lf", &a, &b); !f lf必须和float double对应，否则gcc会报warning
        printf("%f %lf\n", a, b); !两个%后跟f和lf都可以，都可以输出浮点数
    }
    如果强行改为scanf("%f %f", &a, &b); 输入2.5 5.2后，此时b为0.0
    ```

## scanf

1. scanf的format中的格式字符和printf的相同。不同的是，后面的变参数为地址表。scanf的提示一般使用用printf输出。如果需要接受多项输入，应该提示用户每项之间的分隔符。系统会将用户的输入去和scanf的format参数比对，因此该参数中不应有\n，只有格式字符和分隔符就好了。例如：

   ```c
   int i,j;
   printf("请输入身高体重(整数)，用空格分隔");
   scanf("%d %d",&i,&j);   //用户输入可以是 "175 75"。输入完毕后敲回车，回车符会被shell理解为EOF。
   ```

2. scanf之所以要传地址，是因为要在函数内修改i和j的值，如果传的是i和j，由于值传递，在函数给i和j赋值后，并不会影响外边的i和j。这是典型的将结果当做输入参数的例子。

3. 如果format中的多个参数之间不加分隔符，那么用户输入时，可以用回车，tab键，空格三个中的任意一个。

   ```c
   int i,j;
   printf("请输入身高体重(整数)，用空格分隔");
   scanf("%d%d",&i,&j);   //用户输入可以是 "175 75"或"175[Enter]75"或"175	75"。
   ```

4. scanf中使用%s来接受一个字符串是非常危险的，因为程序为接受该字符串开辟的空间可能不够，进而发生溢出，覆盖掉有用的区域。

5. scanf使用%s来接受字符串时，用户的输入中间不能有空格，否则会只取第一段。要想读入有空格的字符串，可以用sscanf。

6. printf如果成功，返回输出的字符个数，不包括字符串的尾零。scanf如果成功，返回成功读取匹配到的项数。

7. 一般情况下，应该校验scanf的成功与否，然后才可以使用读取到的变量。

8. 字符输入输出函数（putc getc），字符串输入输出函数（gets puts）见系统编程中的描述。尽量不要使用gets函数，因为该函数不检查缓冲区溢出，用fgets，它会检查输入的长度，如果超过了size参数，就会提示错误。这样只能保证不出错，并不能保证接受用户的所有输入。

9. 在GNU C中，存在getline函数，可以获取用户输入的一行数据，因为使用了动态内存技术，因此能保证接受用户的所有输入。

# 流程控制

1. 三大结构：顺序，选择，循环。

2. 由于if可以没有else，因此else只和它最近的没有闭合的if匹配，例如：

   ```c
   if ()
   	if()
   		xxx;
   else				//这个else其实是和第2行的if匹配的。
   	xxx;
   ```

3. 上面的例子如果就是想要else和第一个if匹配，可以通过加{}来完成。

   ```c
   if (){
       if()
   		xxx;
   }else				//这个else其实是和第2行的if匹配的。
   	xxx;
   ```

4. 因此建议所有的if和else都要加上{}，不加{}只管1行。例如：

   ```c
   if (){
   	if(){
   		xxx;
       }
   }else{
   	xxx;   //这个else其实是和第2行的if匹配的。
   }
   ```

5. switch-case语句，case之间不加break的时候，则会继续执行下个case，直到遇见break。

6. ```c
   switch(要判断的变量){
   	case 常量表达式:       //不能是范围判断，如果想要判断整型变量在80-89之间，可以用变量/10 == 8来判断。
   		要执行的语句;
   		break;  //跳出当前的switch。
       case 常量表达式:
       	要执行的语句;
       	break;
       default:
       	
   }
   ```

7. while和do-while：    都是满足条件才会进入下一次循环。do-while的末尾要加上一个分号，而while不用。

   ```c
   while(循环进行的条件){		//最少执行0次。
   	loop;
   }
   
   do{			//最少执行1次。
   	loop
   }while(循环进行的条件);
   ```

8. for循环：

   ```c
   for (表达式1;表达式2;表达式3){  //表达式1只在第一次循环的时候执行，一般是初始化的操作，每次循环(包括第一次)前都要执行并判断表达式2,如果为真，执行循环体，否则退出循环。循环结束后执行表达式3（一般是自增），再执行并判断表达式2。 可能的情况：1 2 loop 3 2 loop 3 2 loop 3 2 退出。for循环可能一次不执行循环体就跳过。
       loop;
   }
   for (;;){	//三个表达式都可以省略，但是分号不可以省略。初始化可以写在循环外，判断和自增之类的操作可以放在循环内。
   }
   ```

9. for循环的汇编分析：

   ```assembly
       40: 	int n = 5;
   00BA70E8 C7 45 F8 05 00 00 00 mov         dword ptr [n],5  
       41: 	int a = 2;
   00BA70EF C7 45 EC 02 00 00 00 mov         dword ptr [a],2  
       42: 	for (int i = 0;i < n; i++) {  //赋值语句的结果就是左值
   00BA70F6 C7 45 E0 00 00 00 00 mov         dword ptr [ebp-20h],0  #第一步,执行表达式1
   00BA70FD EB 09                jmp         main+48h (0BA7108h)  
   00BA70FF 8B 45 E0             mov         eax,dword ptr [ebp-20h]  #第四步,执行表达式3
   00BA7102 83 C0 01             add         eax,1  
   00BA7105 89 45 E0             mov         dword ptr [ebp-20h],eax  
   00BA7108 8B 45 E0             mov         eax,dword ptr [ebp-20h]  #第二步,执行表达式2
   00BA710B 3B 45 F8             cmp         eax,dword ptr [n]  
   00BA710E 7D 0B                jge         main+5Bh (0BA711Bh)  #第三步,如果表达式2的结果为假，则跳出循环。反之执行循环体。
       43: 		a++;
   00BA7110 8B 45 EC             mov         eax,dword ptr [a]  
   00BA7113 83 C0 01             add         eax,1  
   00BA7116 89 45 EC             mov         dword ptr [a],eax  
       44: 	}
   00BA7119 EB E4                jmp         main+3Fh (0BA70FFh)  #跳转回去
       50: 	return 0;
   00BA711B 33 C0                xor         eax,eax  
   ```

10. if-goto也可以构成循环，goto可以实现无条件跳转。会破坏结构化编程，且不能跨函数跳转。

    ```c
    i = LEFT;
    loop:
    	sum += i;
    	i++;
    if(i <= RIGHT){
        goto loop;
    }
    ```

11. 常见的死循环写法：

    ```c
    while(1){
    
    }
    for(;;){
        
    }
    ```

12. break（跳出本层循环）和continue（跳出本次循环）只在循环或switch-case语句中才有用。


# 数组

1. 数组是一个构造类型。特点是内存中连续存放。

## 一维数组

1. 数组的定义：

   ```c
   [存储类型] 数据类型 标识符 [长度]      存储类型和之前的变量的存储类型一样。
   int arr[5];  //数组有5个元素，但是下标为0-4，下标从0开始。
   sizeof(arr)=元素的个数*sizeof(arr[0]);
   ```

2. 定义时数组的长度需要是常量表达式，不能是变量。C99中允许产生变长的数组，但是需要编译器支持。

   ```c
   int i = 5;
   int arr[i];  //变长的数组。
   ```

3. 未初始化的数组中默认是随机值。可以用{}对数组进行初始化：

   ```c
   int arr[5]={1,2,3,4,5};  //按照下标顺序赋值。可以部分初始化或全部初始化。没有被赋值的元素，默认被修改为0。
   static int arr[5];       //使用static修饰，数组也会被初始化为全0。不过这样的变量也会具有继承性。
   int arr[]={1,2,3,4,5};   //如果在定义的同时初始化，可以不写元素个数。
   ```

4. 数组名等于数组首个元素的地址，是一个常量，存储的是地址，打印使用%p。因此使用数组名的赋值只能出现在初始化中，例如：

   ```c
   arr == &arr[0];
   
   int arr[5] = {1,2,3,4,5};     //定义的同时初始化。
   int arr[5];					//定义的同时没有初始化。
   arr = {1,2,3,4,5};   		 //此时不能进行初始化了。等号左端是一个常量。
   ```

5. 编译器和运行时并不会检查数组越界。根据下标来获得数组元素是基于指针的偏移原理的。即使越界访问后，使用sizeof获得的数组所占空间大小也不会变。

## 二维数组

1. 二维数组的第一个下标为行，第二个为列。在内存中是连续存储的，一行一行地存储。

   ```c
   int arr[2][3];  //在内存中存储顺序为a[0][0]->a[0][1]->a[0][2]->a[1][0]->a[1][1]->a[1][2]
   arr = &arr[0][0];  //数组名仍然是起始元素的地址。
   arr[1] == &arr[1][0];    //arr[1]也是一个常量
   ```

2. 因此对于高维数组，也是按照下标的顺序从前到后存储的。

3. 二维数组的初始化：

   ```c
   int arr[][]={{1,2,3},{4,5,6}};      //会报错，只有一维数组才可以不写大小。
   int arr[2][3]={{1,2,3},{4,5,6}};    //可以正确赋值。
   int arr[2][3] = {1,2,3,4,5,6};      //会按照一行一行的顺序赋值。
   ```

4. 二维数组int arr\[2\]\[3\]实际上也是一维数组（两个元素，arr[0]和arr[1]），不过该一维数组的元素仍然是数组，例如arr[0]的类型为int [3]。

# 字符串

1. 字符数组是特殊的一维数组，初始化：

   ```c
   char str [] = {'a','b','c'};    //单个字符初始化，不会天然存在尾零。类型为char[3]
   char str [] = "abc";  //使用字符串常量初始化。字符串常量天生自带尾零。类型为char[4]
   ```

2. 字符串并不等于字符数组。字符数组并不一定有尾零。

3. ISO C提供了字符串连接功能，两个字符串序列会自动拼接，例如：

    ```c
    "abc" "def"  //等价于 "abcdef"
    ```

4. sizeof和strlen：

    ```c
    int main() {
        char str[] = "abc";
        printf("sizeof: %lu\n", sizeof(str)); //结果为4
        printf("strlen: %lu\n", strlen(str)); //结果为3
        char str1[10];
        strcpy(str1, "abc");
        printf("sizeof: %lu\n", sizeof(str1)); //结果为10
        printf("strlen: %lu\n", strlen(str1)); //结果为3
        exit(0);
    }
    //strlen计算字符的个数，不包括末尾的'\0'。sizeof则包括。sizeof是在编译阶段计算，strlen是函数调用。
    ```

5. 标准C头文件 <string.h>提供了字符串的操作函数。

6. 字符串长度计算 strlen：

   ```c
   size_t strlen(const char *s);  //计算字符串s的大小，不包括尾零。
   strlen("hello\0abc"); //结果为5。遇到\0就停止。
   sizeof("hello\0abc"); //结果为10。sizeof(s)会计算尾零。
   ```

7. 字符串拷贝 strcpy：

   ```c
   char *strcpy(char *dest, const char *src); //可以将一个字符串常量或一个字符数组逐字符拷贝给一个字符数组，包括尾零。由于数组名是一个常量，因此只能在初始化的时候进行赋值。
   strcpy(dest, "hello");      //该函数不检查数组是否越界，可以使用strncpy来防止越界。
   char dest[STRSIZE];
   strncpy(dest, "hello", STRSIZE);
   ```

8. 字符串拼接 strcat：

    ```c
    char *strcat(char *dest, const char *src);   将src的内容附加到dest的末尾。src不会被改变，dest会被改变。会覆盖掉dest原来的尾零，添加新的尾零。该函数容易覆盖dest后面的内容，可以用strncat来避免越界。
    ```

9. 字符串比较 strcmp：

     ```c
     int strcmp(const char *s1, const char *s2);    //实际是逐个进行ASCII码的比较。返回值为第一个不等的字符差距，＜0表示前一个小。
     strcmp("ab","aa"); //结果为1。       可以用strncmp来设定比较前n个字符。
     ```

10. 字符串分隔strtok，strsep：

      ```c
     char *strtok(char *str, const char *delim); //将一个字符串str通过分隔符delim拆分为0个或多个非空的子串。第一次调用时，str应为对应的字符串，如果后续要处理同一个串，则str应为NULL。这个函数应该被包含在一个循环内，delim可以包含多个分割字符，每次的分割中可以使用不同的分隔符。返回值为被分割出来的以'\0'结尾的子串，该子串不包含分隔符。
     //如果后续字符串非空，且找不到分隔符，则返回整个后续字符串。如果对空字符串或全是分隔符的字符串调用strtok，则会返回NULL。
     //多个连续的分隔符会被一并掠过，因为strtok的返回值总是非空的字符串，除非遇到了字符串的结尾。例如用";,"来分割"aaa;;bbb,"。首先得到"aaa"，然后是"bbb"，最后是一个NULL。
     //该函数会修改str，它直接将字符串str或后续待处理的字符串中的分隔字符，替换为'\0'。
     char *strtok_r(char *str, const char *delim, char **saveptr); //可重入版本的strtok,其中saveptr是指向char*的指针，存储着上一次分割后剩下的字符串，也就是同一个线程多次调用之间的上下文。这样函数被其他线程调用时，就不会覆盖掉之前一个调用的上下文了。在非可重入版本中，该上下文存储在函数的静态区内。
     char *strsep(char **stringp, const char *delim);//从*stringp中用delim分隔符分成两段，第一段字符串存储在返回值中。*stringp被修改为第二段字符串。如果没有找到分隔符，那么会返回整个字符串，且*stringp被赋值为NULL。如果stringp为NULL，则返回NULL，什么也不做。该函数不会出错，也不会设置errno。
     //该函数的用法为反复调用即可。不用像strtok一样区分第一次和后续调用。天然就是线程安全的。
     //如果第一个字符就是分隔符，那就返回空字符串，然后*stringp向后移动一个字符。
     //strsep是用来替换strtok的，因为strtok无法处理空的，但是strtok是C标准库函数，而strsep是BSD4.4的函数，移植性差。
      ```

11. strtok_r的例子：

       ```c
      #include <stdio.h>
      #include <stdlib.h>
      #include <string.h>
      #include <stdbool.h>
      int main(int argc, char* argv[]) {
          char* str1, * str2, * token, * subtoken;
          char* saveptr1, * saveptr2;
          if (argc != 4) {
              fprintf(stderr, "Usage: %s string delim subdelim\n", argv[0]);
              exit(EXIT_FAILURE);
          }
          str1 = argv[1];
          for (int j = 1; ;j++) {
              token = strtok_r(str1, argv[2], &saveptr1);
              if (token == NULL)
                  break;
              printf("%d: %s\n", j, token);
              str2 = token;
              while (true) {
                  subtoken = strtok_r(str2, argv[3], &saveptr2);
                  if (subtoken == NULL)
                      break;
                  printf(" --> %s\n", subtoken);
                  str2 = NULL;
              }
              str1 = NULL;
          }
          exit(EXIT_SUCCESS);
      }
      //程序被编译链接为sep 执行命令为  ./sep "a/bbb///cc;xxx:yyy:" ":;" /
      //之所以要为第二和第三个参数加上双引号(单引号也行)，是因为;在shell中被认为是多个命令之间的分割，例如 ls;date 会被认为是两个命令写在了一行中。
      //在vscode调试时，需要在launch.json中添加命令行参数，只用添加./sep以后的参数，且都应该用" "包裹起来，因此原来的" "可以用' '代替。例如 "args": ["'a/bbb///cc;xxx:yyy:'", "':;'", "'/'"]
      //程序运行的结果为：
      1: a/bbb///cc
       --> a
       --> bbb
       --> cc
      2: xxx
       --> xxx
      3: yyy
       --> yyy
       ```

12. strsep的例子：

       ```c
      #include <stdio.h>
      #include <stdlib.h>
      #include <glob.h>
      #include <string.h>
      #include <stdbool.h>
      int main() {
          char* linebuffer = NULL;
          size_t linebuf_size = 0;
          char* tok = NULL;
          int i = 0;
          if (getline(&linebuffer, &linebuf_size, stdin) < 0) { //从命令行获取一行输入,会包含\n
              perror("getline()");
              exit(1);
          }
          linebuffer[strlen(linebuffer) - 1] = 0;   //去除末尾的\n
          while (true) {   //反复调用
              tok = strsep(&linebuffer, " \t\n");   //三个分隔符，空格，制表符，换行
              printf("[%d]:tok=[%s]\tlinebuffer=[%s]\n", i, tok, linebuffer);
              if (tok == 0)
                  break;
              i++;
          }
          exit(0);
      }
      //输入为"ls -l   /etc" 输出为:
      [0]:tok=[ls]     linebuffer=[-l   /etc]
      [1]:tok=[-l]     linebuffer=[  /etc]
      [2]:tok=[]       linebuffer=[ /etc]
      [3]:tok=[]       linebuffer=[/etc]
      [4]:tok=[/etc]   linebuffer=[(null)]
      [5]:tok=[(null)] linebuffer=[(null)]
       ```

# 指针

1. 指针就是地址值。指针≠指针变量。使用指针传递参数是最省开销的。变量名是给程序员看的，而程序是使用地址来进行索引的。

2. 指针变量是用来存储指针的。

   1. 可以通过变量名i来访问修改对应内存空间内的值，这是直接访问。
   2. 也可以通过地址0x2000来访问修改对应内存空间内的值，这是间接访问。为了方便使用，将这个地址存储在一个变量p中，称这个地址为指针，称这个变量为指针变量。

   ```c
   int i = 4;   //假设&i = 0x2000
   int *p = &i; // sizeof(i)等于4。 sizeof(p)和机器字长有关，表示内存地址的长度，和指针的类型无关。
   ```

3. ```c
   int i = 4;
   int *p = &i;   //指针变量中存储的都是地址。
   int **q = &p;  //q变量存储的是一个指针变量p的地址值，int **表示该指针变量指向的空间存储着一个int *的变量，即一个指针。
   ```

4. *和&操作符：

   ```c
   *p, &p//对于任意一个变量，*p表示将该变量看做一个指针变量，去p的值表示的内存空间中找到数据。&p表示获取当前变量在内存中的空间位置。
   *(&p) == p;  //取地址符和取值符是一对互逆的操作。
   ```

5. 指针变量的初始化：

   ```c
   int *p = &i;   //不是将&i赋值给了*p,而是赋值给了p。 因为指针变量为p，类型是int *。之所以习惯上将*和p靠近，是因为要提示变量p是一个指针类型。
   int *p = NULL; //一般在定义指针的时候就应该初始化，如果没有合适的地址，就应该置为NULL（防止野指针的出现）。NULL是定义的一个宏，值为0。如果操作该指针会提示段错误，因为0地址是内核空间。
   ```

6. 指针的类型：指针变量中只存储了一个32位或64位的地址，这个地址只是一段空间的开头，指针变量无法记录该地址指向的空间有多大，因此需要在指针变量上记录下该指针指向的空间存储的是那个类型的值，从而决定读取多少个连续的字节，解释为何种数据类型。 int \*表示这个指针变量指向的空间存储着一个int类型数据。这也是\*p是要从该地址开始解析sizeof(int)个字节，当做int类型的数据。

7. void \*类型是万金油，任何类型都可以和它互转(和函数指针转换时，C99中属于未定义行为)，不用强转，不会报警告和错误。当不知道指针的类型时，一般会使用void \*。例如：

   ```c
   void *memcpy(void *dest, const void *src, size_t n);   //逐个字节拷贝，不必考虑指针指向的空间是何种数据类型。
   ```

8. 从一维数组来看，arr[i] 是对数组元素的直接访问，*(arr+i)是对数组元素的间接访问。arr+i是int *类型的，表示是一个指向int类型值的指针。

   ```c
   int arr[] = { 1,2,3,4 };
   int *p = arr;     //将一个int[4]类型的值赋值给一个int *类型的值，会进行隐式转换。
   int *p = &arr[0]; //将一个变量的地址值赋值给一个指针变量。
   p[0] == arr[0];  //也可以对指针进行下标运算，这回自动将指针转化为一个数组。数组内存放是指针指向的类型。
   *arr == arr[0];  //*arr会先将arr转化为一个指针，然后再取值。
   
   //VS中查看的结果为
   名称      值                     类型
   arr       0x003cfc78{1,2,3,4}   int[4]
   arr+1     0x003cfc7c{2}         int*
   arr+0     0x003cfc78{1}         int*
   &arr      0x003cfc78{1,2,3,4}   int[4]*
   ```

9. 数组名不是指针，因为他们分别是数组和指针这两大派生类型的实例。在进行数组名+1这样的运算时，会自动将数组名转化为指针类型，然后进行指针的运算。因此数组名≠指针，但是在一定条件下，可以转化为指针。

10. 后续的函数传参都是用指针的，数组的传递也会转化为指针。

11. 从数组名arr转化为指针p的过程中，会丢失掉细节，因为仅从指针p中，无法得知原来的数组的元素个数。数组名可以自动转化为指向该数组的第一个元素的指针。对数组名取地址就是对数组的第一个元素取地址。

12. 因此对于二维数组arr[2] [3]来说，arr[0]的类型是int[3]，是一个数组。可以将arr转化为一个指向第一个元素的指针，即指向一个int[3]的指针，即int[3] *。int *的指针+1会跳过一个int类型的大小，int[3] *的指针+1会跳过int[3]类型的大小。 

    ```c
    int arr[2][3] = { 1,2,3,4 };
    int(*p)[3] = arr;     // arr[i][j] == p[i][j] == *(*(p+i)+j)。  //二维数组索引和指针运算。arr[i] == *(p+i)。
    ```

13. arr[0]是int[3]类型的一个数组，因此可以自动转化为一个int*类型指针。arr[0]+1跳过的也就是一个int的长度。

14. arr和arr[1]都是数组类型，一个二维int [2] [3]，一个一维int [3]。而arr[0]+1和arr + 1由于进行了算数运算，都自动转化成了指针类型。arr和arr[0]还有arr[0] [0]在数值上是相同的。如果使用==比较，编译时会报警告，提示间接级别不同。

    ```c
    //VS中查看的结果为
    名称      值                                                  类型
    arr[0]+1  0x0078fac0{0}                                       int*
    arr+1     0x0078fac8{0,0,0}                                   int[3]*
    arr[1]    0x0078fac8{0,0,0}                                   int[3]
    arr       0x0078fabc{0x0078fabc{1,0,0,},0x0078fac8{0,0,0}}    int[2][3]
    ```

15. 数组名和下标可以交换顺序：

    ```c
    arr[1] == 1[arr];   //arr[1]等价于*(arr+1),而1[arr]等价于*(1+arr),因此二者是相等的
    ```

17. 数组名不能是左值，即不能给数组名赋值：

    ```c
    int arr[] = { 1,2,3,4 };
    int c = 4;
    arr++;     //不成立。
    arr = &c;  //将arr看做指针，也不能赋值。
    ```

18. 使用指针指向一个匿名数组。

    ```c
    int *p = (int[]) { 1, 2, 3 };
    ```

## 数组指针和指针数组

1. 数组指针，类似于整型指针，字符指针，表示它首先是一个指针，指向的内容是一个数组。

   ```c
   int a[3] ;
   int (*p)[3]; //定义一个数组指针，指向的数组为int[3]，包含3个int数据，括号不能省略，因为数组下标运算符[]的优先级高于解引用符*
   p = a;   //会报错，数组指针却不能用数组名给他赋值，因为数组名转化为指针后类型为int *，前者int(*)[3]可以看作2级指针，后者int*为1级。
   int (*p)[3] = &a;  //这样就不会报警。对数组名取地址得到的类型是int[3]*,不过他的值仍然是a。
   ```

2. 指针数组和字符数组类似，只是数组内存储的元素都是指针。

   ```c
   int a, b;
   int* p[2] = {&a, &b};   //p的类型为int *[2];
   
   int arr[2][3] = { 1,2,3,4 };
   int * p[2] = {arr[0], arr[1]};
   ```

3. 数组指针和指针数组就差一个括号。后面的那个词表示实际的类型，例如"指针"之于"数组指针"。

4. 数组指针的定义可以使用typedef，这样更清晰：

   ```c
    typedef int int_array[3]; //int_array的类型为int[3]，但是不能写成typedef int[3] int_array
    int_array *ptr = data; //ptr为int_array类型的指针
   ```

## 字符数组

1. 字符数组的名字可以看做一个字符指针。

   ```c
   char str [] = "hello";  //在栈上开辟了6个字节的空间，用来存储hello\0这6个字符。
   str = "world";          //会报错，因为str不能做左值。
   strcpy(str,"world");    //正确,将world\0这6个字符依次拷贝到str[0]~str[5]中。
   
   char *str = "hello";    //在栈上开辟了4个字节（32位下），用于存放地址。在常量中开辟了6个字节，存放着"hello"。
   strcpy(str, "world");   //会报错，因为尝试修改str[i],而str[i]在常量上，规定了不可以被修改。
   str = "world";          //正确，改变str的指向，指向常量上的另一块空间。
   ```

2. 字符数组存储在栈上，可以修改。字符串存储在常量区，不可修改。

## const与指针

1. const是把修饰的内容常量化。可以用宏来保存常量，但是宏不检查语法。使用const修饰变量可以将变量常量化，防止运行时被修改。

   ```c
   const int a = 4;  //此时a不能再是左值了。a的类型为const int。必须在定义的时候初始化。
   ```

2. 常量指针和指针常量，念法是从左到右，先遇到const，就是常量指针。：

   ```c
   const int *p;  //常量指针，const修饰的是指针指向的内容,即不能通过*p来修改指针指向的内容。p可以变,*p不可以变。
   int const *p;  //常量指针，同上
   int *const p;  //指针常量，const修饰的是指针变量p,即该指针的指向不能变，但是指向的值可以变。p不可以变,*p可以变。
   ```

3. 常量指针中，const 修饰的其实是*p，指针常量中const修饰的其实是p。

4. const修饰一个量，表示不能通过该量进行修改，但是可以通过其他指针来进行修改，例如：

   ```c
   const int a = 3;
   int *p = &a;  //编译的时候会报警告，因为&a是 const int * 赋值给 int * 会损失const的限定。
   *p = 5;   //可以进行修改。
   
   const int *p = &a;  //编译没有警告。通过*p也不能修改a的值。
   ```

5. 讲一个int \*的值赋值给const int \*，并不会报警告。

   ```c
   int i = 10;
   const int *p1 = &a;
   i = 5;   //正确
   *p1 = 0; //错误
   ```

## 多级指针

1. 二级指针和二维数组的关系：

   ```c
   /* 二维数组的情况 */
       int matrix[2][3] = { {1,2,3},{4,5,6} }; //二维数组按行存储，当作矩阵看时第一行为1 2 3，第二行为4 5 6
       sizeof(matrix) / sizeof(matrix[0]);//结果为24UL/12UL=2UL，64位环境下Unsigned Long为64位，sizeof(数组)等于该数组所有元素占据的字节数。由于sizeof是编译时就给出结果，因此它可以区分数组名和多级指针。
       sizeof(matrix[0]) / sizeof(matrix[0][0]));//结果为12UL/4UL=3UL
   /* 二级指针的情况 */
       int **ptr2 = matrix; // -Wall时会报warning:initialization of ‘int **’ from incompatible pointer type ‘int (*)[3]
       sizeof(ptr2) / sizeof(ptr2[0]); //结果为8UL/8UL=1UL，ptr2为2级指针，ptr2[0]为1级指针，64位环境下指针都为64位。
       sizeof(ptr2[0]) / sizeof(ptr2[0][0]);//结果为8UL/4UL=2UL。因为ptr2[0][0]已经不是指针了，而是int类型。
   ```

2. 二维数组作为实参，形参可以有两种情况：

   ```c
   #include <stdio.h> //输出row行column列的2维数组data
   //二级指针 int**
   void print_matrixA(int** matrix, int row, int column){
       for (int i = 0;i < row; ++i){
           for (int j = 0;j < column;++j){
               printf("%d ", matrix[i][j]); //运行时可能会发生段错误，因为在取matrix[0]时就已经获得了数组内容的第一个值，即1，而matrix[0][0]时相当于把1开头的8个字节0x0000000200000001当作一个指针去解引用，这自然会触发非法内存访问。
           }
           printf("\n");
       }
   }
   //数组指针 int(*)[3]
   void print_matrixB(int(*matrix)[3], int row, int column){
       for (int i = 0;i < row; ++i){
           for (int j = 0;j < column;++j){
               printf("%d ", matrix[i][j]);
           }
           printf("\n");
       }
   }
   int main(){
       int matrix[2][3] = { {1,2,3},{4,5,6} };
       print_matrixA(matrix, 2, 3); //实参matrix会隐式转化为形参类型二级指针，因此编译会报warning
       print_matrixB(matrix, 2, 3); //参数传递不会发生隐式类型转化
       return 0;
   }
   /******************************************/
   //内存示意
   printf("%p",matrix); //结果为0x7fffffffdeb0
   //对于二级指针
   for (int i = 0;i < 2 * 3;i++) {
       printf("%d ", ((int*)matrix)[i]); //输出1 2 3 4 5 6。外侧的括号必须加，因为下标运算符[]的优先级比强制类型转换(int*)高。这里转化成一级指针，当作一维数组来输出数据。
   }
   //第一个字节的地址为(int**)matrix的值，即0x7fffffffdeb0。
   //  内存地址           一行8个字节
   0x7fffffffdeb0 | 01 00 00 00 02 00 00 00
   0x7fffffffdeb8 | 03 00 00 00 04 00 00 00
   0x7fffffffdec0 | 05 00 00 00 06 00 00 00
   //对于二维数组和二级指针使用[i][j]，编译器会做出不一样的解释。会涉及到指针的加减法，而指针的加减法的结果可能会根据指针指向对象的大小而变化。
   //对于2行3列的二维数组matrix来说，matrix[i][j]会被解释为(*(matrix+i))[j]，到此为止，不会再拆开[j]了。matrix的类型为int (*)[3]，所以matrix+1的值比matrix大sizeof(int[3])=12UL。matrix[0]的类型为int[3]，所以matrix[0][j]为该数组的第j个元素。
   //需要说明的是，matrix+1的类型和matrix一样，还是int(*)[3]，对其解引用的结果是int[3]类型，即一个3维数组，而不是一个int*。
   //对于二级指针ptr2来说，ptr2[i][j]会被解释为(*(ptr2+i))[j]=*(*(ptr2+i)+j)。ptr2的类型为int**，所以ptr2+1的值比ptr2大sizeof(int*)=8UL，（64位情况下），ptr[0]的类型为int*，所以ptr[0]+1比ptr[0]大sizeof(int)=4UL。
   //使用二级指针来解释上面的数据中的ptr[0][0]，结果为*(*(ptr2+0)+0)，ptr2+0为0x7fffffffdeb0，*(ptr+0)为0x0000000200000001，之所以是8个字节，是因为*(ptr+0)是int*类型，64位环境下占8个字节。*(*(ptr2+0)+0)即为内存0x200000001处的4字节整数，之所以是4个字节，是因为该类型为int。这样非常有可能产生内存非法访问。
   ```

3. 也可以在被调函数内将二级指针转化为二维数组：

   ```c
   int(*ptr2)[3] = matrix; //ptr[i][j]中i的有效范围未知，j的有效范围为0到2
   int ptr2[][3] = matrix; //ptr2的类型也是int(*)[3]，效果同上
   ```

4. 二级指针与指针数组：

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   void print_matrix(int** matrix, int row, int column) {//输出row行column列的2维数组data
       for (int i = 0;i < row; ++i) {
           for (int j = 0;j < column;++j) {
               printf("%d ", matrix[i][j]); //matrix[i][j]是通过2级指针查找
           }
           printf("\n");
       }
   }
   int main() {
       int *ptr_arr[2]; //数组元素都是int*，由于数组名是指向数组首元素的指针，所以ptr_arr为int**类型
       for(int i = 0;i < 2;++ i){
           ptr_arr[i] = new int [3];//new返回void*类型指针，后面[3]只是用于说明空间大小，并非返回void(*)[3]类型，同时也不存在因为该指针解引用后，是一个包含3个void类型的数组，由于void类型大小不定，所以不能声明void[3]。
           ptr_arr[i] = (int*)malloc(3 * sizeof(int)); //这句可以替代上面的new语句，需要注意的是，malloc的返回值为void*，在C语言中可以隐式转化为任何指针类型，但是在C++中需要强制转换。new不需要强制转换的原因可能是C++编译器自己处理了。
           for(int j = 0;j < 3;++ j)
               ptr_arr[i][j] = i + j;
       }
       fun(ptr_arr,2,3); //将指针数组名传递给二级指针，不用进行任何隐式的类型转换，而且在函数内，可以直接使用[i][j]来索引数组元素。
       return 0;
   }
   ```

5. 综上二级指针和指针数组等价，二维数组和数组指针等价。二维数组的数据一般是按行连续存储在一块的，也可以看作一维数组，但是二级指针的数据分为两部分，一个是指针数组本身连续存放，一个是每个指针指向的数组的数据连续存放。命令行参数的argv就是一个二级指针：

   ```c
   #include <stdio.h>
   int main(int argc, char *argv[]){//也可以写成char**argv，前者为字符指针数组，看上去更好理解，每个数组元素都是一个字符指针。一个字符指针就可以确定一个字符串，很多C语言的字符串处理函数，都是接收字符指针为参数的。
       printf("argv = %p, &argv = %p",argv,&argv); //argv是一个变量可以获取其地址。
       for (int i = 0;i<argc;i++){
           printf("&(argv[%d]) = %p, argv[%d] = %s\n",i,&(argv[i]),i,argv[i]);
       }
   }
   zj@zj-hit:~/test/F$ ./main ab cc 123 //argc=4，输出为
   argv = 0x7ffdd00420f8, &argv = 0x7ffdd0041fc0
   &(argv[0]) = 0x7ffdd00420f8, argv[0] = 0x7ffdd004432f, argv[0] = ./main
   &(argv[1]) = 0x7ffdd0042100, argv[1] = 0x7ffdd0044336, argv[1] = ab
   &(argv[2]) = 0x7ffdd0042108, argv[2] = 0x7ffdd0044339, argv[2] = cc
   &(argv[3]) = 0x7ffdd0042110, argv[3] = 0x7ffdd004433c, argv[3] = 123
   //内存分布示意：
   0x7ffdd0041fc0 | f8 20 04 d0 fd 7f 00 00
   ...
   0x7ffdd00420f8 | 2f 43 04 d0 fd 7f 00 00
   0x7ffdd0042100 | 36 43 04 d0 fd 7f 00 00
   0x7ffdd0042108 | 39 43 04 d0 fd 7f 00 00
   0x7ffdd0042110 | 3c 43 04 d0 fd 7f 00 00
   ...                                      //ASCII表示，*表示0x00
   0x7ffdd0044328 | 00 00 00 00 00 00 00 2e | * * * * * * * .
   0x7ffdd0044330 | 2f 6d 61 69 6e 00 61 62 | / m a i n * a b
   0x7ffdd0044338 | 00 63 63 00 31 32 33    | * 1 2 3 * * * *
   ```

# 函数

1. 函数的形参会在调用函数的时候进行定义并初始化，因此不用再函数内部再进行定义了。形参的作用域为函数内。

2. 以下两个函数用来交换两个变量的值：

3. ```c
   void swap1(int a, int b){      //不使用指针，
       int tmp = a;
       a = b;
       b = tmp;
   }
   void swap2(int *pa, int *pb){
       int tmp = *pa;
       *pa=*pb;
       *pb = tmp;
   }
   int i = 5,j = 6;
   swap1(i,j);   //会将i和j的值赋值给形参a和b,然后函数内的a,b修改是不用影响到函数外的i和j的。
   swap2(&i,&j); //将i和j的地址赋值给pa和pb,然后在函数内根据地址修改i和j的值，可以达到交换变量值的功能。
   ```
   
4. C语言中，都是赋值传参，指针传参的本质也是赋值。有了指针，就可以在任何地点中访问和修改任何变量的值。

5. 一个进程的返回状态时给他的父进程看的，一般使用的时候，就是shell。

6. 接受main函数的参数：

   ```c
   int main (int argc, char *argv []);  //argc是包含可执行文件本身的。argv是一个字符指针数组。也可以说是字符串数组，即数组中的元素都是字符串。其实argv[argc]始终为NULL，虽然它不是输入的参数。
   test abc 123  //这样一个命令，test是可执行文件，argc为3,argv[0]到argv[2]分别为"test" "abc" "123"。
   test *.c      //argc不是2，因为shell会解析通配符。
   ```

7. 对于一个不需要返回值，也不需要传参的函数，可以不写，也可以写void。

   ```c
   void test(void){}
   test(){}
   ```

8. 函数的声明和实现可以分开，一般将声明写在.h头文件中，实现写在.c源文件中。

9. 被调函数的生命或实现必须在主调函数之前。这样编译才不会报错。只有声明，没有实现的函数，在链接时会报错。当函数的声明和实现分开时，声明部分的形参可以不写变量名，只有类型，不过不推荐这么写。

10. ```c
    void test(void);  //函数的声明
    int main(){}
    void test(void){  //函数的实现
    }
    ```
    
11. 递归是一个函数直接或间接地调用自己，为了避免死循环的出现，需要在函数内验证退出条件。每次调用函数，都会进行压栈保存当前环境，如果递归次数过多，可能会发生栈溢出。

12. 求阶乘和斐波那契数列都可以用递归方便实现。

13. 数组和函数传参，函数的形参一般都是指针类型，很少用数组作为形参类型，即使形参定义为int p[ ]之类的，函数内还是会将p当做指针。因此之前的形参argv虽然定义为char * [ ]，实际还是char\*\*类型的。

    ```c
    int sum(int * p, int n) {}   //没有必要用指针常量来接受数组名。数组名的特点是，不能使得arr指向其他的空间，但是形参是可以指向其他的空间的。
    int arr[] = {1,2,3};
    sum(arr,sizeof(arr)/sizeof(*arr));
    ```

14. 使用指针来接受数组时，还需要在另一个参数中给出数组的元素个数。

15. 函数和指针，函数指针可以当做函数名一样用，加括号调用。定义时，形参名可以省略。

    ```c
    int * test(int a, int b);   //指针函数，就是返回值是一个指针的函数。
    int (*test)(int, int);  //函数指针，就是一个存放函数入口地址的指针，指向一个函数。可以将一个函数名赋值给函数指针。函数名类似于数组名，不能修改他的指向。
    int (*arr[2])(int, int);   //函数指针数组，该数组有两个元素，每个元素都是一个函数指针。这两个函数指针是同类型的，指向的函数的参数和返回值类型相同。
    ```

# 结构体

1. 数组只能存放同类型的数据，不能满足需求。可以将不同类型的数据存放到一块。

2. 结构体的定义：

   ```c
   struct 结构体名{
     数据类型 成员1,成员2;   //数据类型一样，可以用逗号隔开。
     数据类型 成员3;
   };   //最后的分号不可以省略。
   ```

3. 结构体的类型描述是不占任何空间的，因此不能再定义的时候给成员赋值。下面的这段话相当于定义了一个新的类型 struct MyStruct，还没有一个实例存在，只能给实例赋值。

   ```c
   struct MyStruct
   {
       int a =5;  //会报错
   };
   ```

4. 结构体一般放在函数外。结构体可以嵌套定义：

   ```c
   struct st{    //先定义后使用。
       int year,month,day;
       char *name;
   };
   struct MyStruct
   {
       char *name ;
       struct st st1;   //类型是struct st，变量名是st1。
   };
   ```

5. 嵌套定义也可以是：

   ```c
   struct MyStruct
   {
       char *name ;
       struct st{
       	int year,month,day;
           char *name;
   	}st1;         //struct MyStruct结构体有两个成员name和st1，st1是struct st类型的。
   };
   ```

6. 定义一个结构体变量，可以定义的同时初始化，逗号分隔：

   ```c
   struct st st1 = {1,2,3,"hha"};   //st1是结构体变量，类型是struct st。
   struct st st1 = {.month=2};      //部分初始化。
   ```

7. 可以用一个指向结构体的指针来接受结构体的地址：

   ```c
   struct st *p = &st1;
   st1.year == p->year;  //结构体成员的引用。指针索引使用->  结构体变量名索引使用。
   st1.year == (*p).year;
   ```

8. 结构体数组：

   ```c
   struct st st1[2] = { {1,2,3,"ha"},{4,5,6,"ho"} };
   ```

9. 结构体在内存中存放一般会进行对齐到一定的字节数，读写效率会提高。字，双字，半字存储这几种模式。例如：

   ```c
   struct st{ //整个结构体一共占用4(一个int)+4(两个char)+4(一个float)+4(一个char)=16个字节。
   	int year;   //在32位环境下，一个字长为32位，结构体的存储也会对齐到4B。不够的也会占用4B。因此将ch3移动到ch2的下面定义，会让整个结构体节省4个字节的空间。
   	char ch1;   //除了结构体内部会产生孔隙外，结构体的起始位置也有讲究，addr%sizeof(第一个成员) == 0
       char ch2;
       float f;
       char ch3;
   };
   ```

10. 在socket程序中，有时为了在不同的操作系统之间传递数据，为了不弄错对齐方式，而会选择不进行对齐，也就是紧密排列，有以下两种方法，其中\_\_attribute\_\_ 机制是GNU C 的一大特色，可以用来设置函数，变量，类型属性。

    ```c
    #pragme pack(4)   //全局声明，对当前.c文件的所有结构体都有效。这个#pragma是编译器识别的，gcc和msvc都支持。
    struct st {
        int year;
        char ch1;
    //  char ch2;
        float f;
        char ch3;
    }__attribute__((packed));  //局部声明,会覆盖全局声明。占用10个字节。
    struct stu {
        int year;
        char ch1;
    };  //使用全局声明，占用8个字节。
    ```

11. 结构体传参一般使用指针，否则会在函数内创建临时结构体，对结构体的所有变量进行值传递。使用指针传参高效，也可以修改实参的成员。

12. 可以使用临时结构体类型：

    ```c
    struct{
        int a;
    }st1,st2,*p; //在定义的时候需要一次性就把所有的实例和指针都定义完。
    ```


# 共用体

1. 产生的原因是早期内存不足。可以定义多个成员，但是在任一时刻只有一个成员是有意义的，就是最近赋值的那个。定义：

   ```c
   union 共用体名{
     数据类型 成员1;
     数据类型 成员2;
   };
   ```

2. 结构体所占的空间是所有变量中最大的那个：

   ```c
   union st{
       int id;
       double score;
       char name[6];
   };
   union st st1;     //类型是union st,共用体st1所占的内存空间为sizeof(st1)==8个字节。
   st1.score = 84.5;    //此时将&st1开头的8个字节赋值为一个double数据。
   printf("%d\n", st1.id);   //此时是将以&st1开头的4个字节解析为一个整数，得到的是无意义的数据。
   ```

3. 位域是以位为存储单位。不过在大小端相反的两个平台之间没有使用意义。

   ```c
   union {    //共用体占用1个字节，un1.st1.a为un1.c的最低1位,un1.st1.b为un1.c的2-4位,un1.st1.c为un1.c的5-8位。对于un1.st1.c，可以从0000-1111，即可以表示0-15这16个数。
   	struct  {
   		unsigned char a : 1;  //占据1位,从一个字节的低位开始排起。
   		unsigned char b : 3;
   		unsigned char c : 4;
   	}st1;
   	unsigned char c;
   }un1={.c = 0x2f};
   ```

4. 位域中不同的位的顺序和大小端没有关系，大小端指的是多字节的数据中不同字节存储高低位数据的问题。

# 枚举

1. 常用来表示有限的分类情况，会顺次排列成员的数值。枚举类型的变量只能取特定的几个值。定义：

   ```c
   enum day    //定义了一个枚举类型 enum day,
   {
   	Mon = 1,   //如果指定枚举量的值，则默认从前往后，依次为0 1 2 ...
   	Tue,       //2
   	Wed,       //3
   	Thr,       //4
   	Fri = 1,   //覆盖掉默认排列的5.
   	Sat,       //2
   	Sun        //3
   };
   enum day d1 = Mon;  //定义了一个枚举类型的变量，变量的值只能取以上的7个值中的一个。
   int x = Sun;        //x的值会被赋予为3,从种类看Sun好像一个宏，不过他是有类型的。
   ```

2. 枚举类型可以作为一系列宏定义的替代。例如上面的枚举类型可以用下面的宏替代。定义宏或枚举类型都是为了编程的方便。区别是宏会在预处理后被替换，enum不会被替换。宏的优点是可以传参，枚举类型不行。

   ```c
   #define Mon (1)
   #define Tue (2)
   ...
   ```


# 动态内存管理

1. 大部分的变量的内存空间都是编译器自动管理的。有时候需要的内存空间并不能在编译时确定。

2. 相关函数：

   ```c
   void *malloc(size_t size);  //memory allocate 内存分配函数,开辟size个字节的空间，将起始地址返回。因为函数只知道要分配多少个字节，并不知道将来用来存储何种类型的数据，因此返回值指针为void*。
   void *calloc(size_t nmemb, size_t size); //连续开辟size个大小为nmemb个大小的内存空间。等价于malloc(size*nmemb)，还有一点不同就是，malloc分配的内存没有初始化，calloc的分配的内存都初始化为0。
   void free(void *ptr);  //释放空间。从这里可以看出OS是记录着ptr当初malloc了多少个字节的。
   void *realloc(void *ptr, size_t size); //在ptr的地址上扩充或缩小内存空间，如果在原来的地址上剩余的可用空间不够，则会在其他地方开辟空间，并将现在的数据复制过去，同时会释放掉旧的空间，返回值为新的空间地址（如果不发生后一种情况的话，返回值等于第一个参数）。
   ```

3. 谁申请，谁释放；谁打开，谁关闭。防止内存泄露（有一块内存虽然已经不用了，但是OS不知道，还不能回收，再分配）。进程结束的时候，OS会回收所有的资源。但是服务器程序一般都是运行很长时间都不关闭的，这期间如果只申请，不释放，很快就会达到OS的上限。

4. 其他的高级语言，例如Java，Python等会提供自动的内存管理，减轻程序员的负担，这被称为“垃圾回收机制GC”。最常用的方法就是引用计数，Java虚拟机或Python解释器会维护一张引用表，保存了各种资源的引用次数，当这个值为0时，就表示它不再被用到了，就进行内存释放。

5. 以上三个申请内存的函数失败时都是返回NULL，应该校验，因此定义指针的时候都应立即置为NULL，防止和后续的申请失败的返回值混淆。如果申请失败，是没有必要释放的，标准规定，free空指针时，什么也不做，也不会报错。

6. 用malloc实现的变长度数组是可靠的，直接定义的变长度数组有的编译器不支持。

7. ```c
   void func(int **p, int n){
       *p = malloc(n);     //如果使用一级指针传参，那么令p=malloc(n),只是将形参和分配的地址关联起来，main函数中的p还是NULL。同时当func函数返回后，malloc的空间就变成了内存泄露，因为没有指针指向它了。因为此时需要修改的是p的值,所以需要传入p的地址&p,所以用二级指针接受。
       if(*p == NULL)
           exit(1);
       return;
   }
   int main(){
       int *p = NULL;
       func(&p,10);  
       free(p);
       return;
   }
   ```

8. 对于上面的问题，还有一种解决方法，就是通过返回值来接受：

   ```c
   void *func(int *p, int n){
       p = malloc(n);
       if(p == NULL)
           exit(1);
       return p;
   }
   int main(){
       int *p = NULL;
       p = func(p,10);   //此时形参p没必要存在。
       free(p);
       return;
   }
   ```

9. 调用函数的传参是从主调到被调，而函数的返回值是从被调到主调，正好形成一个闭环。

10. free一个指针，只是告诉OS，当前程序不再使用该块内存了。free函数并不会将p的值设为NULL，因为只有传入的是&p，free才能修改p。如果此时还向p的地方写入内容，并不会报错，但是会发生危险。因此在每次free后，都应该手动将p置为NULL。


# typedef 关键字

1. typedef是为已有的数据类型(基本和构造)定义新名字，使用这个关键字的目的是为了以后程序的扩展和方便使用复杂的类型。例如：

   ```c
   typedef int INT;  //书写可移植的程序时需要使用这种方法，例如从32位机器到16位机器上，就可以修改typedef int16_t INT;
   INT a; //相当于定义了int a;
   ```

2. 使用宏定义 #define INT int也能完成类型的整体替换，不同的是：

   ```c
   #define INT int*;
   INT p,q;    //等价于  int *p,q;
   typedef int* INT;
   INT p,q;    //等价于 int *p, *q;
   ```

3. 可以定义为复杂的数据类型定义简单的别名：

   ```c
   typedef int ARR[6];    //将ARR定义为int [6]。
   ARR a; //等价于int a[6];   将上一句的ARR替换为a，忽略typedef关键字，即可得到 int a[6];
   
   typedef struct node_st{       //node_st可以省略。
   	int a;    
   }NODE;
   
   typedef struct{
       int a;
   }NODE, *NODEP;      //定义了两个数据类型，NODE为该结构体类型，NODEP为指向该结构体的指针类型。实际上一般只要给结构体类型定义别名就够了，因为NODEP类型一眼不容易看出来是指针，可以用NODE *来定义。
   ```

4. 常量表达式2*3在编译时就计算出来了，这样会加快运行时。例如：

   ```assembly
         int a = 2 * 3;
   000E1718  mov    dword ptr [a],6
   ```

# 变参函数

1. 可变参数的每个参数并没有实际的名称与之相对应，但是使用起来很灵活。

2. 变参函数至少需要一个固定参数，且放在最开头，例如：

   ```c
   int func(int dwFixedArg,...);      //函数的声明，其中...是占位符。
   ```

3. 堆栈生长方向和参数入栈特点，从最靠近第一个可变参数的固定参数开始，依次获取每个可变参数的地址。主要依靠以下几个定义在<stdarg.h>中的函数宏来完成：

   ```c
   va_list pArgs;  //定义va_list类型的变量pArgs，用于存储可变参数块的信息，并不是指针，不能初始化为NULL。
   va_start(pArgs, dwFixedArg); //初始化pArgs变量，使其指向第一个可变参数。第二个参数是变参列表的前一个参数，即最后一个固定参数。
   int dwVarArg = va_arg(pArgs, int); //该宏返回变参列表中的当前变参值并使pArgs指向列表中的下个变参。该宏第二个参数是要返回的当前变参类型，会用该类型去解析这个参数。若函数有多个可变参数，则依次调用va_arg宏获取各个变参，类似于文件的位置指针。
   va_end(pArgs);  //将指针pArgs置为无效，结束变参的获取，一般和va_start配套使用。
   ```

4. 变参宏无法智能识别可变参数的数目和类型，因此变参函数体内需自行判断可变参数的数目和类型。例如可以约定，如果遇到参数结果为-1，就表示参数读取到最后了。也可以用变参函数的一个固定参数来指定可变参数的个数。或者像printf一样，从format参数中解析出来%d或%s的个数和参数类型，逐个解析。

   ```c
   func(3,1,2,3); //第一个参数3为固定参数，表示可变参数有3个。
   func(0,1,2,3,-1); //此时第一个参数无意义，在有效可变参数的末尾加上一个-1，以标识结束。
   ```

5. 例如：

   ```c
   func(int a,...) {  //函数定义
   	va_list pArgs;
   	va_start(pArgs, a);
   	int b = va_arg(pArgs, int);  //b=2
   	int c = va_arg(pArgs, int);  //c=3
   	int d = va_arg(pArgs, int);  //d=4
   }
   func(1, 2, 3, 4);   //固定参数为1，可变参数有3个。
   ```

6. 可以通过将初始化后的va_list传递给其他的函数，来一次传递多个参数。这样可以将一个变参函数的 的参数分步处理：

   ```c
   #include <stdio.h>
   #include <stdarg.h>
   int func2(va_list pArgs);
   int func1(int a, ...) {
       va_list pArgs;
       va_start(pArgs, a);
       printf("%d\n", va_arg(pArgs, int));  //func1函数处理第一个可变参数
       func2(pArgs); //将后续的可变参数交给func2来处理
   }
   int func2(va_list pArgs) { //这里不用再进行初始化pArgs了
       printf("%d\n", va_arg(pArgs, int));
       printf("%d\n", va_arg(pArgs, int));
   }
   int main() {
       func1(3, 11, 22, 33);  //func1中会输出11，func2中会输出22和33
   }
   ```

7. 局限性是，无法将va_list直接传递给用省略号定义的可变参数。也无法通过可变数量个变量来直接构造va_list。因此如果函数的参数中还有va_list，那它只能被用省略号定义的变参函数调用。

8. C语言中没有重载，如果出现名称相同的函数，则是用变参来实现的(不一定写出来...)。如下的两个函数，可以用多传参数调用的情况来验证是C语言中的变参还是C++中的重载。

   ```c
   int open(const char *pathname, int flags);
   int open(const char *pathname, int flags, mode_t mode);
   open("tmpfile",O_RDWR | O_CREAT, S_IRWXU, 1);  //如果编译时报语法error，则表明是C++的重载，因为找不到一个接受4个参数的函数原型。如果不报错，则表明是C的变参函数，因为该函数可以传递任意多个参数。
   ```

9. 以下两个函数是不同的：

   ```c
   func();        //参数列表为空，等价于func(...),给函数传参也不会报警告。
   func(void);    //void表示函数不接受任何参数，给该函数传参，编译时会报警告。
   ```

# 数据结构

1. 数组的访问效率是所有数据结构中最高的。
2. 线性表的存储方式可以有顺序和链式存储。链表分为单向和双向。链表还可以分为循环和不循环的。有头结点和无头结点。
3. 双向环形链表是开发中常用的。
4. 实际开发中，对于递归是比较慎重的，因为对栈的压力比较大，一般会检测，如果递归的深度过大，会提前退出。
5. 树又称为有向无环图。
6. 顺序存储的缺点是增加和删除比较费劲，需要复制很多数据。因为顺序存储使用的是一块连续的内存空间。

# GCC

1. C源文件→预处理→编译→汇编→链接→可执行文件。
2. 一般来说，文件的后缀名是无所谓的，但是编译器会根据不同的后缀名选择不同的操作，因此还是要写对后缀名。后缀为.c的，gcc把它当作是C源程序，而g++当作是c++源程序；后缀为.cpp的，两者都会认为是c++程序，建议遵守默认的后缀名规则。

3. #pragma命令是用来设定编译器的状态，指定编译器完成一些特定的动作。

   ```c
   #pragmat pack([n]) //指示结构体和联合成员的对齐方式
   #pragmat message("string") //输出编译信息
   #pragma warning  //有选择地改变编译器的警告信息行为
   #pragma once //在头文件中加入这条指令，可以防止被重复包含，可以替代条件编译宏的方法。
   ```

4. 广义的编译指的是源程序→可执行文件，狭义的编译指的是预处理后的文件→汇编文件。

5. 汇编过程是将汇编文件转化为机器代码的目标文件。

6. 链接是将使用到的外部库的函数实现找到，静态链接会将函数实现复制到可执行文件中，动态则不会。

7. ```shell
   gcc -E hello.c > hello.i  //预处理，默认输出到屏幕上，可以重定向到文件中。
   gcc -S hello.i   //编译，默认产生.s文件。得到汇编语言书写的文件，即文本文件。
   gcc -c hello.s   //汇编，默认产生.o的目标文件，二进制的，
   gcc hello.o -o hello  //链接成可执行文件，并重命名为hello。默认产生可执行文件名为是a.out。
   ```

8. 使用`--verbose`选项，可以使GCC打印出具体调用的命令细节，collect2程序是对ld链接器的一个封装。

9. 可以用make来编译一个文件，例如`make hello`，会执行 `gcc hello.c -o hello`。

10. -Wall 选项可以打开gcc的所有警告和报错开关，最严格的模式。一般来说，应该尽可能修改程序到所有的警告都消失，或者说是可控的警告。

11. 如果想要抑制某个warning，可以使用类似的编译选项`-Wno-unused-dummy-argument`。这个选项在-Wall时也有用。

12. 使用任何的外部的函数都要包含头文件的定义，例如：

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    int main(void){
        int *p = NULL;
        p = malloc(sizeof(int));
        if(p == NULL)
            return -1;
    }
    ```

    1. 上面的代码编译不会报任何警告，即使开启了Wall。但是如果不包含malloc函数的头文件，即stdlib.h，那么就会报一个警告，提示malloc函数的返回值类型和用于接受的变量类型不匹配。
    2. 因为对于未定义的函数，gcc就会认为返回值的类型为int，因此在第5行将一个int类型的返回值赋值给int *类型的变量是不合理的，才会报这样的错误。
    3. 有些人认为只要将malloc的返回值强制转化为int\*之后，在复制就没问题了，即用`(int\*) malloc(sizeof(int));`实则不然，因为这种强制类型转化，在gcc看来，也是warning。解决办法就是包含上头文件即可。
    4. 实际上malloc的返回值 void \*是一个特殊的类型，他可以赋值给任何类型的指针，也可以将任何类型的指针复制给他，编译器都不会报警告。其实也有一个例外，==就是==

13. 有时候出现段错误的原因就隐藏在没有解决的警告中。例如下面的程序如果去掉对string.h的包含，编译时没有任何警告，运行时会报段错误。如果打开-Wall选项后，编译时会报警告，提示strerror的返回值和用于接受的变量类型不匹配，包含上该头文件就没事了。

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <errno.h>
    #include <string.h>
    int main (){
        FILE *fp;
        fp = fopen("tmp", "r");
        if (fp == NULL){
            fprintf(stderr, "fopen:%s\n", strerror(errno));
            exit(-1);
        }
        fclose(fp);
        exit(0);
    }
    ```

14. 如果编译的工程中有多个.c文件中都存在main函数，gcc也会报错。

15. 链接选项：

    ```c
    //默认是动态链接，带--static前缀-l是静态链接
    -lm //数学库math
    -lstdc++ //标准c++库
    -lc  //标准c库，由于gcc默认编译c文件和链接标准c库，因此可以省略
    -lpthread //多线程库 pthread
    ```

16. 

17. 

# 预处理器相关

1. C预处理器(C preprocessor)，简写为cpp，是一个宏处理器，会被C编译器在编译前自动调用。它的目的是只是为了处理C、C++、Objective-C源代码，不过也被滥用为一个通用的文本处理器，而当输入文本不符合类C语言的语法时，C预处理器会报错退出。不能那它来处理Makefile，因为所有的制表符都会被删除，这样Makefile就不能正常工作了。

2. 如果需要真正的通用文本处理器，可以使用GNU M4，他是Autoconf体系的一部分。

3. 预处理指令都是以#开头的，然后是预处理指令，再接着是参数（可能没有），最后是换行符。

4. 如果一行中只有一个#和换行符，则是空指令，没有任何作用。

5. 功能如下：
   1. 条件编译源文件的一部分，通过：`#if #else #elif #endif #ifdef #ifndef #elifdef #elifndef`完成。后两个是C23新增的。

   2. 文本替换，通过：`#define #undef # ##`。后两个是引用和连接运算符。

   3. 引入其他文件，通过：`#include __has_include `。后一个是C23新增的可以用来检测是否include了。

   4. 产生错误或警告，通过：`#error #warning`。后一个是C23新增的。

   5. 由实现定义的行为，通过`#pragma _Pragma`。后一个是运算符，在C99增加的。

   6. 文件名和行信息，通过：`#line`。

6. 其他以#开头，但是不属于上面的行，产生的行为可能是被编译器忽略，或者报错。

## 条件编译

1. 语法：

   ```c
   #if expression
   
   #ifdef identifier
   
   #ifndef identifier
   
   #elif expression
   
   #elifdef identifier		(since C23)
   
   #elifndef identifier		(since C23)
   
   #else
   
   #endif
   ```

2. #else最多只有一个，#endif有且只有一个。

3. 和if相关的，后面是表达式，和def相关的，后面是标识符。

4. 表达式只能使用常量或#define定义的标识符来构成，还可以使用一些逻辑运算符。

5. 如果经过了所有的宏替换，最终还不是常数，则会被当作0，这里边包括没有被定义的标识符。

6. 任何非字面值的包括没有定义的标识符都会被当作0。不过C23中新增了，将true当作1。

7. 一元操作符，用来检查标识符是否被#define定义过：`defined identifier`或`defined identifier`，结果是1或0。

8. 组合的指令：

   ```c
   #ifdef identifier    等价于   #if defined identifier
   #ifndef identifier   等价于   #if !defined identifier
   #elifdef identifier  等价于   #elif defined identifier
   #elifndef identifier 等价于   #elif !defined identifier
   ```

9. 例子：

   ```c
   #define ABCD 2
   #include <stdio.h>
   int main(void){
   #ifdef ABCD  //因为前面定义了这个宏，因此结果为真
       printf("1: yes\n"); //执行这行
   #else
       printf("1: no\n");
   #endif
   
   #ifndef ABCD  //结果为假
       printf("2: no1\n");
   #elif ABCD == 2 //继续判断这个，通过宏替换，然后判断2==2为真，因此结果为真
       printf("2: yes\n"); //会执行这行
   #else
       printf("2: no2\n");
   #endif
    
   #if !defined(DCBA) && (ABCD < 2 * 4 - 3) //两个部分，第一个部分DCBA没有被定义过，因此!defined(DCBA)为真，因此继续判断第二部分，计算得到2<5为真，因此总的为真，
       printf("3: yes\n"); //会执行这行
   #endif
   // C23 directives #elifdef #elifndef
   #ifdef CPU  //因为没有定义CPU标识符，因此为假
       printf("4: no1\n");
   #elifdef GPU //继续判断这个，也为假
       printf("4: no2\n");
   #elifndef RAM //继续判断这个，为真
       printf("4: yes\n"); //会执行这行
   #else
       printf("4: no3\n"); // may be selected in pre-C23 mode
   #endif
   }
   ```


## 文本替换

1. 语法：

   ```c
   #define identifier replacement-list (optional)
   #define identifier (parameters) replacement-list
   #define identifier (parameters, ...) replacement-list  //(since C99)
   #define identifier (...) replacement-list //(since C99)
   #undef identifier
   ```

2. 对一个已经定义的标识符，重新定义，除非定义的替换列表相同，否则会报错。

3. 程序中所有以#开头的部分(头文件的包含，条件编译等)都是在预处理中完成替换。

4. 条件编译的主要目的是为了兼容不同的平台和处理器架构，最大程度复用代码。

5. 有了预处理这个构成，就可以使用宏，使得编程方便，可以使用头文件，进行模块化。

6. 预处理过程：

   ```c
   头文件展开 //将#include包含的文件插入到该指令的位置
   宏展开    //展开所有的宏定义，并删除#define
   条件编译  //处理所有的条件编译指令 #if #ifdef #ifndef #else #endif
   删除注释
   添加行号和文件名标识 //编译调试时可以显式行号信息
   保留#pragma编译器指令
   ```

7. 条件编译的宏名取法：如果文件名为xx.h，宏一般为`XX_H__`或`__XX_H`。因为内核中的头文件一般是前加下划线，用户程序使用后加下划线是为了防止和内核发生冲突。

8. #include 头文件的时候，<>包含的文件会直接去系统指定的目录中寻找，而" "包含的文件会先在当前路径下寻找，如果没找到，再去系统目录下寻找。

9. GNU C 预处理器提供了ISO C标准的一个超集。默认情况下，不严格按照标准的行为来。

   ```shell
   #如果要严格按照ISO C的标准来处理，可以使用如下选项之一:
   -std=c90
   -std=c99
   -std=c11
   -std=c17
   #如果要做所有的强制诊断，需要使用如下选项:
   -pedantic
   ```

10. 源代码的字符集处理十分复杂，C标准讨论了2种，但是常用的最少有4种。源文件可以是任意字符集的，C预处理器在一开始会先进行把源文件的字符集转化为ISO 10646。也就是Unicode字符集。C预处理器使用utf-8编码的Unicode字符集。C预处理器的输出也是utf-8编码的。超出ASCII表示范围的字符，可以用\u或\U来转义表示或者用户直接输入。

    ```shell
    #设定源文件使用的字符集
    -finput-charset=
    ```

11. 输入文件会被读入到内存中，然后按照行进行分割。不同的系统使用不同的习惯来标识一行的末尾，常见的有有如下三种ASCII控制序列。C预处理器会自动处理这些，因此用户可以在不同平台之间相互拷贝源代码而不用考虑这些问题。不过当不同电脑通过NFS修改共享的文件时，可能会导致一个文件中出现不一致的行尾标记，这可能导致行号功能出问题。

    ```shell
    LF        # Unix
    CR LF     # DOS和VMS
    CR        # 经典Mac OS(在OS X之前)
    ```

12. 通常情况下，文件最后一行末尾也应该有一个行尾标记，否则gcc会报warning。

13. 可以用来定义标识常量，即该常量在程序的多处用到，后期有可能进行修改，例如3.14。也可以定义没有宏体的宏，这种宏一般用来做条件编译的占位。

14. ```c
    #define PI 3.14        //宏名+宏体
    #define __STDIO__
    ```

15. 预处理结束后，宏名会被替换为宏体，并不做语法检查。

16. ```c
    #define ADD 2+3
    
    ADD * ADD;       //结果并不是5*5，标识常量的使用应该在外边加上括号。
    ```

17. 带参数的宏，参数也应该加上括号，防止替换后的参数改变运算顺序。

    ```c
    #define MAX(a,b)  ((a) > (b) ? (a) : (b))
    int i = 3,j = 5;
    MAX(i,j);      //预处理后为(i > j ? i : j)
    ```

18. 带参数的宏可以用函数来替代，宏的使用会减小运行时的消耗，因为他的工作在编译时就完成了。内核的代码中有很多宏的应用。但是宏的应用容易出错。内核中使用宏非常多，因为这里的代码运行频率很高。

19. 调用函数是有开销的，需要将当前的运行环境入栈，在函数调用完毕后再恢复。

20. 宏毕竟不是函数，直接进行替换容易出现问题，例如：

21. ```c
    #define MAX(a,b)  ((a) > (b) ? (a) : (b))
    int max(int a, int b){
        return a > b ? a : b;
    }
    int main (){
    	int i = 3,j = 5;
    	
    	printf("i=%d,j=%d\n",i,j);
    	printf("%s\n",MAX(i++,j++));     //此时输出6。因为宏替换后为((i++) > (j++) ? (i++) : (j++))。
    	printf("i=%d,j=%d\n",i,j);
    }
    ```

22. 我们期望MAX达到的功能应该是函数max一样的，返回i和j中较大的那个数，然后对i和j分别自增1。第9行应该输出5，第10行应该输出4和6。而实际上第9行输出的是6，第10行输出的是4和7。这是因为较大的那个数在宏替换后还多进行了一次自增。出现这一问题的原因是因为宏参数没有被适当的变量接收。

23. 进行大小比较的时候j=5，比较完的时候j就变成了6，i变成了4。然后返回6，第9行结束的时候j就变成了7。

24. 对于函数max，实参分别为3和5。函数调用完毕返回后，i和j才会自增1。整个过程中i和j只自增了一次。

25. 这个问题在标准C下无解，在linux下编程使用的是GNU C，他是标准C的扩展，使用glibc库，可以使用变量接受来解决该问题。

    ```c
    #define MAX(a,b)   ({typeof(a) A=(a),B=(b);((A)>(B)?(A):(B));})
    
    MAX(i,j);  //({int A=(i++),B=(j++);((A)>(B)?(A):(B));})  A=(i++)是先赋值再自增。
    ```

26. 宏被替换成了一个语句块，其中有两行语句，语句块的值为最后一行语句执行的结果。最外层加上一个大括号也是为了隔绝内外代码。

27. 使用string.h中的strcpy函数时，会提示该函数不安全，推荐使用strcpy_s或者定义_CRT_SECURE_NO_WARNINGS 这个宏。定义该宏时，需要放在头文件string.h的包含之前才有用。或者使用编译器的命令行参数来配置。

28. 每条注释都会被替换为一个空格，这一过程发生在预处理阶段前，因此无法无法使用宏来形成注释：

    ```c
    #ifndef DEBUG
        #define PRINTF //
    #else
        #define PRINTF printf
    #endif
    ...  
    PRINTF("Error in file %s at line %i\n", __FILE__, __LINE__); //作者的本意是想在没有定义DEBUG时将PRINTF替换为//，将这句话作为一个注释，在定义了DEBUG后，把PRINTF替换为printf，这样就可以输出行号和文件号了。
    //但是会事与愿违，因为在宏替换前，//就会被替换为一个空格，第二行变成了"#define PRINTF  \n"，因此在宏替换时PRINTF会被替换为一个空格。因此当没有定义DEBUG时，第7行会变为一个逗号表达式(-Wall时会报warning，提示逗号左侧的操作数没有效果)，结果就是最右侧的操作数的结果，即行号7，不过这样也能起到不输出的作用。
    ```

29. ISO C提供了字符创建运算符(#@)，字符串创建运算符(#)，拼接操作(##)，

    ```c
    #define ToChar(x) #@x      //由于C语言字符串和字符的引号不同，因此需要分开处理
    char a = ToChar(1); // 被替换为 char a = '1';
    
    #define doit(name) pr_limit(#name, name)
    doit(RLIMIT_CORE);  //被替换为 pr_limit("RLIMIT_CORE", RLIMIT_CORE);
    
    #define Conn(x,y) x##y 
    int  n = Conn(123,456);   // 被替换为 int n = 123456;
    char* str = Conn("asdf", "adf")  // 被替换为 char* str = "asdf""adf";由于ISO C会再进行拼接因此为"asdfadf"
    ```

30. 使用##还有一个特点，就是当##对应的参数为空时，会删除前面的逗号：

    ```c
    #define LOG(_STRING, ...)   printf(__STRING, ##__VA_ARGS__)  //...表示可变参数，对应到__VA_ARGS__
    
    log_info("cout");  //__STRING为"cout"，__VA_ARGS__为空，因此结果为 printf("cout"); 由于__VA_ARGS__为空，因此删除了前面的逗号
    log_info("cout: %d", count); //被替换为 printf("cout count: %d", count);
    ```

31. 可变参数的宏在C99中才可以使用。

32. gcc提供-D选项来进行编译时宏定义：

    ```shell
    gcc -DDEBUG #相当于 #define DEBUG 1
    gcc -DDEBUG=DEFN #相当于 #define DEBUG DEFN
    ```

33. vs在debug，x86编译时，分别会自动定义对应的宏，\_DEBUG，\_WIN64。如果没有对应的就是release或x64。

34. 有时候需要在程序关键地方设置prinf打印信息，而在程序发布的时候又需要取消这些功能，实际上不用删除。只要用条件编译即可，不过需要重新编译整个软件才可以：

    ```c
    #ifdef _DEBUG
    	printf("调试中");
    #endif // _DEBUG
    ```

35. 高端的写法：

    ```c
    #include <stdio.h>
    #define _DEBUG
    //推荐使用_DEBUG，这样可以就不用手动#define了，通过项目的设置就可以自动开关调试。
    #ifdef _DEBUG
    	#define DEBUGLOG(fmt, ...) ((void)printf("[File:%s] [Line:%d] " fmt "\n", __FILE__,__LINE__,__VA_ARGS__))
    #else
    	#define DEBUGLOG(fmt,...) ((void)0)
    #endif
    
    int main() {
    	printf("12\n");
    	DEBUGLOG("ab=%d", 5);
    	printf("12\n");
    }
    ```

36. 上面使用(void(0))的原因：一方面，为了保持debug和release模式下代码的一致，assert表达式也必须起到占位的作用(如用作逗号表达式时)，所以不能直接定义为空；另一方面，因为其用作断言功能，理论上不应返回任何值，所以C/C++标准规定其必须返回void值，从而也防止了其产生副作用。

37. 如果使用的是gcc之类的命令行工具，可以在编译时手动加上对应的宏。

38. 还可以设定不同的目标下使用不同的库。

    ```c
    #ifdef _DEBUG
        #ifndef _WIN64 //64位
        	#pragma comment(lib,"json/json_mtd.lib") //结尾的d表示debug
        #else
        	#pragma comment(lib,"json/json_mtd_x64.lib")
        #endif
    #else   //release
        #ifndef _WIN64
        	#pragma comment(lib,"json/json_mt.lib")
        #else
        	#pragma comment(lib,"json/json_mt_x64.lib")
        #endif
    #endif
    ```
    
39. 替换是多轮进行的，每次只会展开一层，可以查看https://www.bilibili.com/video/BV1BB4y1v7F8。

# GDB

1. 使用GCC编译时，需要加入-g选项，才会在编译的时候加入符号表（源代码，行号等），从而可以调试。可以再发布给用户时，使用strip命令将这些调试信息都去掉，可以保证安全，同时也减小可执行文件的体积。

2. 有些项目在编译代码时候，会加上-O/-O2/-O3等选项来让编译器对代码进行优化，但这样做的后果可能会过滤掉部分或者全部的调试信息，甚至获取到的调试信息不是程序真正异常的地方，很容易被误导。所以，在debug程序时候，可以去掉这些编译参数。

3. GDB常用命令：

    ```shell
    set args xxx  #传递参数xxx
    set var       #修改变量的值
    file xxx      #载入目标程序xxx
    attach pid    #通过PID链接程序
    start/s       #启动运行 程序会停在main()函数的开始处
    continue/c    #继续运行
    run/r         #运行程序
    quit/q        #退出gdb
    ```

4. ![image-20210521135200025](C语言.assets/image-20210521135200025.png)

5. p命令可以执行函数，最后不用加；s命令需要有源程序才可以进入。list命令可以显示源代码。使用info命令来查看寄存器，内存等。

6. 使用ulimit -a查看coredump文件的大小限制，默认是0，表示出错时不生成转储文件。修改后，再出错则会生成转储文件，文件名为 core.进程号 。使用gdb调试core文件：

   ```shell
   gdb book core.11231
   ```

7. 此时会直接到出错的行，显示如下：

8. ![image-20210521140537479](C语言.assets/image-20210521140537479.png)

9. 使用bt命令查看函数的调用栈。

10. ![image-20210521140617711](C语言.assets/image-20210521140617711.png)

11. 调试正在运行的程序：

      ```shell
      gdb book1 -p 21495      #进程号为21495。 book1为可执行文件的路径。
      ```

12. ![image-20210521141037081](C语言.assets/image-20210521141037081.png)

13. 调试多进程程序：

      ```shell
      set follow-fork-mode parent   #调试父进程，默认
      set follow-fork-mode child    #调试子进程，默认
      
      set detach-on-fork [on|off]  #表示调试当前进程时，其他进程是否继续运行。默认是on
      
      info inferiors   #查看当前调试的进程
      inferior 进程ID  #切换要调试的进程，这个ID不是PID而是gdb给进程的编号。
      ```

14. ![image-20210521142233955](C语言.assets/image-20210521142233955.png)

15. 调试多线程程序：https://www.bilibili.com/video/BV1ei4y1V758?p=5

16. ps -aL 可以查看当前运行的轻量级进程，也就是线程。pstree -p 主线程ID。

      ```shell
      zj@zjhit:~$ ps aux| grep rand
      zj     2931  0.0  0.0 445036   632 pts/2    Sl+  15:17   0:00 ./rand_thread
      zj     3238  0.0  0.0   6304   744 pts/1    S+   15:17   0:00 grep --color=auto rand
      
      zj@zjhit:~$ ps -aL |grep rand
         2931    2931 pts/2    00:00:00 rand_thread    #主线程,线程ID和进程ID相同，这里的线程实际上是一种轻量级进程LWP。
         2931    2932 pts/2    00:00:00 rand_thread
         2931    2933 pts/2    00:00:00 rand_thread
         2931    2934 pts/2    00:00:00 rand_thread
         2931    2935 pts/2    00:00:00 rand_thread
         2931    2936 pts/2    00:00:00 rand_thread
         2931    2937 pts/2    00:00:00 rand_thread
      ```

17. 相关命令：

      ```shell
      info threads  #查看所有线程
      (gdb) info threads
        Id   Target Id                                      Frame
        1    Thread 0x7ffff7d95740 (LWP 3334) "rand_thread" clone ()
          at ../sysdeps/unix/sysv/linux/x86_64/clone.S:78
      * 2    Thread 0x7ffff7d94700 (LWP 3338) "rand_thread" producer (     # *表示当前正在运行的线程。
          ptr=0x0) at rand_thread.c:19
        3    Thread 0x7ffff7593700 (LWP 3339) "rand_thread" clone ()
          at ../sysdeps/unix/sysv/linux/x86_64/clone.S:78
      thread 1    #切换到ID为1的线程。
      set scheduler-locking on #设置只运行当前线程
      set scheduler-locking on #设置运行所有线程
      thread apply 2 n         #指定ID为2的线程执行gdb命令n。
      thread apply all n       #指定所有线程执行gdb命令n。
      ```

18. 设置断点或单步跟踪会严重干扰多进（线）程之间的竞争状态，导致调试的过程和实际运行的不一致。

19. 屏幕输出日志的缺点：如果日志很多，屏幕会很乱。没有记录。应该讲日志写入到文件中比较好。

20. 使用vscode remote插件进行远程调试时，可以在地下窗口的"调试控制台"中输入gdb的命令，不过要加上-exec的前缀：

      ```shell
      -exec info breakpoints #和下面一行等价
      `info breakpoints 
      ```


# 调用图

1. 使用工具生成函数调用图可以更直观地理解一个新的项目。

2. 它既不分析源代码，也不绘制图表。相反，它将源代码分析留给GCC，将图形布局留给Graphviz，这两者在各自的工作中都比Egypt要好。egypt只是一个将这些现有工具粘合在一起的小型Perl脚本。因此需要安装gcc，Perl，Graphviz。

3. egypt是一个perl脚本，它会调用graphviz来生成调用图（静态代码分析），步骤如下：

    1. 使用`-fdump-rtl-expand`编译所有的源代码，这会生成对应的`.c.229r.expand`文件。

    2. 使用egypt处理所有的.expand文件，它会生成DOT语言的代码。

    3. 使用graphviz工具库的dot命令，读取上述DOT代码，绘制图片，这一步可以和上一步使用管道连接。

        ```shell
        egypt *.expand | dot -Gsize=3000,3000 -Grankdir=LR -Tpng -o callgraph.png #表示生成一个3000*3000像素的png图片，LR表示从左到右，也可以为BT，从上到下。
        egypt *.expand | dot -Gsize=8.5,11 -Grankdir=LR -Tpdf -o callgraph.pdf #也可以生成pdf，8.5英寸*11英寸
        #以下选项都是egypt的
        --callees getnewline #仅显示getnewline调用的函数，多个函数可以用逗号分隔。
        --callers getnewline #仅显示调用getnewline的函数，可以和上面的--callees同时使用。
        --omit flux #忽略flux函数，也就是将它从图中删除。
        --summarize-callers 5 #如果一个函数被调用≥5次，则不显示箭头，只显示一个数字标记，推荐使用，来减少显示对工具函数的调用。
        #例如：
        egypt *.expand --summarize-callers 5 | dot -Gsize=8.5,11 -Grankdir=LR -Tpdf -o callgraph.pdf
        ```

4. egypt的安装：

    ```shell
    wget https://www.gson.org/egypt/download/egypt-1.11.tar.gz #下载源代码
    x egypt-1.11.tar.gz #解压
    cd egypt-1.11
    perl Makefile.PL
    make
    make install
    ```

5. 节点表示函数，实线表示直接调用，虚线表示使用指针调用。

6. 不过这个对于大项目来说，生成的图片过于复杂，不太实用。虽然egypt说可以处理C程序，实际上任何语言都可以处理，因为GCC在编译时，会产生中间表示IR，egypt是利用改描述来生成调用关系的。IR是和具体语言没关系的。

7. caller为调用者，主动发起调用；callee为被调用者。

8. 可以看到，大部分的函数都由main函数调用，但是也有一些函数不和任何函数相关联，这一般有两种情况：

    1. 该函数实际上也不会被调用。可能只是一个无关的函数，或者是被注释了。

    2. 嵌入式代码的中断服务例程。

9. 由于调用图不会显示全局变量，因此通过全局变量传递参数的情况，则无法在图中表示。这会导致调试困难，因此不建议使用使用全局变量传递参数。

10. 另一个可以使用的是cflow，不太推荐使用，她不是使用IR，因此一些编译指令或选项对于他来说无效，例如-D的宏设置。

# Valgrind

1. Valgrind 是一个基于仿真技术的内存调试、内存泄漏检测和性能分析的开源工具。代码在编译时最好都加上`-g`选项进行编译（用来在结果中输出行号）。

2. 如果程序是用优化选项（如 `-O2` 或 `-O3`）编译的，某些优化可能会使得行号信息变得不准确。如果可能，应该在没有优化的情况下编译程序进行内存泄漏检测。

3. Valgrind的不同工具（如 Memcheck、Callgrind、Massif 等）不能同时运行。每次运行Valgrind时，你必须选择一个要使用的工具。这是因为每个工具都有自己的特定目标和方法，它们不能同时应用于同一个程序运行实例。如果你想同时进行内存泄漏检测和性能分析，你需要分别运行两次Valgrind，一次使用 Memcheck，一次使用Callgrind。

4. 使用 `kill -9` 杀死正在运行的 Valgrind 进程会影响检测结果。`kill -9` 会立即终止进程，不给它机会进行任何清理工作。在 Valgrind 的情况下，这意味着它可能无法生成完整的报告，因为它通常在被检测的程序正常结束时生成报告。

5. 如果你需要在 Valgrind 运行时停止它，最好的方法是尝试使用 `kill` 命令（没有 `-9` 选项）发送一个 TERM 信号。这将请求 Valgrind 优雅地终止，它应该能够生成一个报告，然后退出。

6. Valgrind 默认在程序结束时报告内存泄漏和其他问题。然而，如果你的程序是一个长时间运行的服务或者你希望在运行过程中查看报告，你可以使用 Valgrind 的 gdbserver 模式，这允许你在运行时与 Valgrind 交互。

    ```shell
    #首先使用 --vgdb=yes 选项(也可以省略，因为默认就是yes)来启动valgrind。vgdb是Valgrind to GDB。
    #然后在另一个终端中，使用gdb连接到valgrind，使用gdb prog启动gdb
    #在gdb内执行命令target remote | vgdb
    ```

7. 常用的功能有：

     ```shell
     memcheck #检查程序中的内存问题，如泄漏、越界、非法指针等。--tool=选项的默认值
     callgrind #检测程序代码的运行时间和调用过程，以及分析程序性能。
     cachegrind #Cache分析器，它模拟CPU中的一级缓存和二级缓存，能够精确地指出程序中cache的丢失和命中。如果需要，它还能够为我们提供cache丢失次数，内存引用次数，以及每行代码，每个函数，每个模块，整个程序产生的指令数。这对优化程序有很大的帮助。
     helgrind #它主要用来检查多线程程序中出现的竞争问题。Helgrind寻找内存中被多个线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致难以发觉的错误。不过，Helgrind仍然处于实验状态。
     massif #堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。Massif能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。
     ```

8. 用法：

     ```shell
     valgrind [options] prog-and-args # prog-and-args是直接运行程序时的名称和命令行参数
     --trace-children # 是否跟踪子进程，默认值为no;
     --track-fds # 是否追踪打开的文件描述符，默认为no
     --log-file=<file> # 指定将消息打印到某个文件，可以避免和程序本身的输出
     ```

9. memcheck，所有对内存的读写都会被检测到，一切对`malloc`、`free`、`new`、`delete`的调用都会被捕获。能够检测如下问题：

     ```shell
     1、使用未初始化的内存。如果在定义一个变量时没有赋初始值，后边即使赋值了，使用这个变量的时候Memcheck也会报"uninitialised value"错误。使用中会发现，valgrind提示很多这个错误，由于关注的是内存泄漏问题，所以可以用--undef-value-errors=选项把这个错误提示屏蔽掉，具体可以看后面的选项解释。
     2、读/写释放后的内存块；
     3、内存读写越界（数组访问越界／访问已经释放的内存),读/写超出malloc分配的内存块；
     4、读/写不适当的栈中内存块；
     5、内存泄漏，指向一块内存的指针永远丢失；
     6、不正确的malloc/free或new/delete匹配（重复释放／使用不匹配的分配和释放函数）；
     7、内存覆盖，memcpy()相关函数中的dst和src指针重叠。
     ```

10. 例子：

      ```cpp
      #include <string.h>
      void func() {
          char* ptr = new char[10];//分配了1块，10个字节
          ptr[10] = 'a';   //内存越界，可用下标为0-9
          memcpy(ptr + 1, ptr, 5);   // 踩内存
          delete[]ptr;
          delete[]ptr; // 重复释放
          char* p;
          *p = 1;   // 非法指针，未初始化p就使用了，即读写*p。
      }
      int main() {
          func();
          return 0;
      }
      ```

11. memcheck结果为：

      ```shell
      g++ -g -o main main.cpp #编译
      valgrind --tool=memcheck --leak-check=full ./main
      --leak-check=yes #会告诉 Valgrind 进行内存泄漏检测，但它只会提供每个泄漏点的总体信息，例如泄漏的总字节数和泄漏的块数。
      --leak-check=full #则会提供更详细的信息。除了泄漏点的总体信息，它还会显示每个单独的泄漏块的信息，包括它的大小和分配它的函数的堆栈跟踪。这可以帮助你更准确地定位内存泄漏的位置。
      
      ==8686== Command: ./main#运行的命令行，8686为进程号
      #第一个内存错误如下：
      ==8686== Invalid write of size 1 #非法写入一个字节
      ==8686==    at 0x1091AB: func() (main.cpp:4) #出错的位置，调用栈为main→func
      ==8686==    by 0x109206: main (main.cpp:12)
      ==8686==  Address 0x4ddec8a is 0 bytes after a block of size 10 alloc'd #所写的内存地址为0x4ddec8a，是在一块分配了的为10字节的块之后写入。
      ==8686==    at 0x484A2F3: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so) #这个内存块分配的细节，调用栈为main→func→operator new[]。
      ==8686==    by 0x10919E: func() (main.cpp:3)
      ==8686==    by 0x109206: main (main.cpp:12)
      #到此一个内存错误结束。
      ==8686== Invalid free() / delete / delete[] / realloc() #非法释放，删除(数组)或重新分配。
      ==8686==    at 0x484CA8F: operator delete[](void*) (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)#非法释放的调用栈
      ==8686==    by 0x1091EF: func() (main.cpp:7)
      ==8686==    by 0x109206: main (main.cpp:12)
      ==8686==  Address 0x4ddec80 is 0 bytes inside a block of size 10 free'd #正常释放的调用栈
      ==8686==    at 0x484CA8F: operator delete[](void*) (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
      ==8686==    by 0x1091DC: func() (main.cpp:6)
      ==8686==    by 0x109206: main (main.cpp:12)
      ==8686==  Block was alloc'd at #内存块申请的调用栈
      ==8686==    at 0x484A2F3: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
      ==8686==    by 0x10919E: func() (main.cpp:3)
      ==8686==    by 0x109206: main (main.cpp:12)
      #综上，第3行申请，第6行释放，第7行又重新释放，因此产生错误
      ==8686== Use of uninitialised value of size 8 #使用了未初始化的值，大小为8字节。读或写都会报这个错误。
      ==8686==    at 0x1091F4: func() (main.cpp:9)
      ==8686==    by 0x109206: main (main.cpp:12)
      ==8686== 
      ==8686== Invalid write of size 1
      ==8686==    at 0x1091F4: func() (main.cpp:9) #非法写入
      ==8686==    by 0x109206: main (main.cpp:12)
      ==8686==  Address 0x0 is not stack'd, malloc'd or (recently) free'd #内存地址为0，既不是栈上，也不在堆上，也不是
      ==8686== 
      ==8686== Process terminating with default action of signal 11 (SIGSEGV) #进程收到段错误的信号而终止。
      ==8686==  Access not within mapped region at address 0x0
      ==8686==    at 0x1091F4: func() (main.cpp:9)
      ==8686==    by 0x109206: main (main.cpp:12)
      ==8686==  If you believe this happened as a result of a stack
      ==8686==  overflow in your program's main thread (unlikely but
      ==8686==  possible), you can try to increase the size of the
      ==8686==  main thread stack using the --main-stacksize= flag. #如果认为是由于栈溢出造成的错误，可以在编译时设置一个较大的栈。
      ==8686==  The main thread stack size used in this run was 8388608. #当前主线程的栈大小。
      ==8686== 
      ==8686== HEAP SUMMARY:#堆总结，程序在堆上分配内存的情况
      ==8686==     in use at exit: 72,704 bytes in 1 blocks #退出时还在使用
      ==8686==   total heap usage: 2 allocs, 2 frees, 72,714 bytes allocated #一共2此分配，1次free
      ==8686== LEAK SUMMARY:#泄露汇总
      ==8686==    definitely lost: 0 bytes in 0 blocks #必定泄露的，应尽快修复。当程序结束时如果一块动态分配的内存没有被释放并且通过程序内的指针变量均无法访问这块内存（泄露），则会报这个错误；
      ==8686==    indirectly lost: 0 bytes in 0 blocks #非直接泄露，当使用了含有指针成员的类或结构体时可能会报这个错误。无需直接修复，它们总是与definitely lost一起出现，只要修复definitely lost即可。
      ==8686==      possibly lost: 0 bytes in 0 blocks #可能泄露，也需要认真处理。当程序结束时如果一块动态分配的内存没有被释放并且通过程序内的指针变量均无法访问这块内存的起始地址，但可以访问其中的某一部分数据，则会报这个错误。例如程序让一个指针指向一块动态分配的内存（但不是这块内存的起始地址），然后通过运算得到这块内存的起始地址，再释放它。
      ==8686==    still reachable: 72,704 bytes in 1 blocks #可以访问，未丢失但也未释放。如果程序是正常结束的，那么它可能不会造成程序崩溃，但长时间运行有可能耗尽系统资源。
      ==8686==         suppressed: 0 bytes in 0 blocks #抑制
      ==8686== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0) #错误总结
      Segmentation fault (core dumped) #最后发生了段错误，因为非法的内存写入
      ```

12. 丢失意味着，不存在任何一个指针指向该内存块，即没法利用，也没法释放了。

13. callgrind：收集程序运行时的一些数据，建立函数调用关系图，还可以有选择地进行`cache`模拟。在运行结束时，它会把分析数据写入一个文件。和`gprof`类似的分析工具，但它对程序的运行观察更为入微，能给我们提供更多的信息。和`gprof`不同的是，它不需要在编译源代码时附加特殊选项，但还是推荐加上调试选项`-g`。

       ```shell
       valgrind --tool=callgrind --compress-strings=no --compress-pos=no --collect-jumps=yes ./ccx_2.20 -i ../test/beamp
       ```

14. `callgrind_annotate`可以把这个文件的内容转化成可读的形式，也可以使用`Kcachegrind`来进行可视化分析。如果代码中包含很多递归调用，则必须使用`Kcachegrind`，因为`callgrind_annotate`不会进行循环检测。

15. 例子：

    ```c
     #include <stdio.h>
     #include <unistd.h>
     void test() {
         sleep(1);
     }
     void func() {
         for (int i = 0; i < 10; i++) {
             test();
         }
     }
     int main() {
         func();
         printf("process is over!\n");
         return 0;
     }
    ```

16. callgrind：

      ```shell
      g++ -g -o main main.cpp #编译
      valgrind --tool=callgrind ./main #结果都写入到了callgrind.out.9172中，命令行输出的内容较少。9k多行
      ```

17. 每个函数都会有一个统计数据：

         ```shell
         Incl.     Self  Called   Function   Location
         124593089 13392   1       main      ccx_2.20:ccx_2.20.c
         #Incl. 表示inclusive cost，也就是由该函数产生所有后续调用的总开销，数字表示的是执行指令数量。也可以用百分比的角度来查看。
         #Self  表示该函数本身调用的开销，不包含由它产生的对其他函数的调用。
         #Called 表示该函数被调用的次数
         #Function 表示函数名
         #Location 表示该函数的位置在ccx_2.20模块的ccx_2.20.c文件。有的函数位于动态库中
         ```

19. 一般来说main的includsive cost会占据大头，也不一定是100%，尤其是多线程应用中，因为main只是主线程，其他线程也会产生开销。

20. 另外，main执行前还会有一些其他开销，例如链接器初始化，C++全局对象的构造等事宜。

21. 包括函数调用次数、指令读取次数等。然而，它并不直接测量函数的执行时间。虽然指令读取次数和函数调用次数可以提供一些关于程序性能的信息，但它们并不能直接告诉你哪些函数是耗时的

22. 

23. 指令读取次数"是一个度量，它表示在程序执行过程中，一个特定函数中的指令被读取（并可能被执行）的次数。这个度量可以帮助你了解哪些函数在你的程序中被频繁地执行

24. 

25. 然而，指令读取次数并不直接等于函数的执行时间。一个函数可能有很多指令，但如果这些指令都很快地执行，那么这个函数的执行时间可能仍然很短。另一方面，一个函数可能只有少量的指令，但如果这些指令需要很长时间来执行（例如，如果它们包含了磁盘 I/O 或网络通信），那么这个函数的执行时间可能会很长。

26. 磁盘 I/O 或网络通信

27. `--collect-jumps=yes`：这个选项让 Callgrind 收集程序中的跳转信息。这可以帮助你了解你的程序的控制流，但也会使 Callgrind 运行得更慢，并生成更大的输出文件。

28. "Ir" 代表 "Instruction read"，也就是读取的指令数。这个数字表示在程序执行过程中，处理器读取了多少条指令。这个度量可以帮助你了解你的程序的性能瓶颈在哪里。如果一个函数的指令读取次数占比很高，那么这可能意味着这个函数是你的程序的一个热点，你可能需要优化这个函数以提高程序的性能。

29. Massif只能测量堆内存的使用情况，不能测量栈内存或其他类型的内存。

      ```bash
      --pages-as-heap=yes #这个选项会让Massif把所有的内存页都当作堆来处理，这可以让你看到所有的内存分配，而不仅仅是通过malloc、new等函数分配的内存。
      ```

# 标准库实现

1. libc是指C标准。
2. glibc指的是libc of GNU，也就是gnu组织对C标准的实现，它除了包含ISO C中规定的，还包含一些POSIX（类Unix操作系统都遵守）规定的和GNU（linux遵守）规定的。通过yum install glibc安装。
3. 关于libc，glib，glibc，eglibc，libc++，libstdc++，gcc，g++：
   1. libc是Linux下原来的标准C库，也就是当初写hello world时包含的头文件#include < stdio.h> 定义的地方。
   2. 后来逐渐被glibc取代，也就是传说中的GNU C Library,在此之前除了有libc，还有klibc,uclibc。现在只要知道用的最多的是glibc就行了，主流的一些linux操作系统如 Debian, Ubuntu，Redhat等用的都是glibc（或者其变种，下面会说到)。
   3. glibc是Linux系统中最底层的API，几乎其它任何的运行库都要依赖glibc。 glibc最主要的功能就是对系统调用的封装。glibc自身也提供了一些上层应用函数必要的功能,如string,malloc,stdlib,linuxthreads,locale,signal等等。
   4. eglibc又是什么？ 这里的e是Embedded的意思，主要特性是为了更好的支持嵌入式架构，可以支持不同的shell(包括嵌入式)，但它是二进制兼容glibc的，就是说如果你的代码之前依赖eglibc库，那么换成glibc后也不需要重新编译。ubuntu系统用的就是eglibc（而不是glibc）。
   5. 还有一个glib看起来也很相似，那它又是什么呢？glib也是个c程序库，不过比较轻量级，glib将C语言中的数据类型统一封装成自己的数据类型，提供了C语言常用的数据结构的定义以及处理函数，有趣的宏以及可移植的封装等(注：glib是可移植的，说明你可以在linux下，也可以在windows下使用它）。那它跟glibc有什么关系吗？其实并没有。著名的GTK+和Gnome底层用的都是glib库。
   6. linux系统的ls,cd,mv,ps等等全都得依赖它，很多人在更换/升级都有过惨痛的教训，甚至让整个系统奔溃无法启动。所以，强烈不建议更换/升级这些库！
   7. libc++和libstdc++，两个都是C++标准库。libc++是针对clang编译器特别重写的C++标准库，那libstdc++自然就是gcc的事儿了。libstdc++与gcc是捆绑在一起的，也就是说安装gcc的时候会把libstdc++装上。

4. libstdc++虽然提供了c++程序的标准库，但它并不与内核打交道。对于系统级别的事件，libstdc++首先是会与glibc交互，才能和内核通信。
5. 标准C库是由操作系统提供，系统调用也会以C语言形式给出，操作系统某些代码也会用到标准C库。标准C++库一般由C++编译器提供。
6. clang是LLVM编译器工具集的一个用于编译C、C++、Objective-C的前端。LLVM项目的目标是提供一个GNU编译器套装（gcc）的替代品，由苹果公司的赞助开发。
7. 直接使用gcc编译cpp文件，会报错，使用 -lstdc++链接即可。或者用g++编译。

# C和C++兼容

1. 如果某个库是C语言编写的，那么它的头文件中应该同时应对被C语言编译器和C++编译器编译的情况，因为头文件要和使用它的源文件一起编译，GNU的库中一般做法如下，以test.h为例：

   ```c
   #ifndef __TEST_H__ //防止头文件重复包含
   #define __TEST_H__
   
   ... //#include语句放在这里
   
   #undef __BEGIN_DECLS //防止用户自定义的宏干扰
   #undef __END_DECLS
   #ifdef __cplusplus //如果该头文件被c++编译器编译，则预处理器会定义__cplusplus宏
   # define __BEGIN_DECLS extern "C" {
   # define __END_DECLS }
   #else
   # define __BEGIN_DECLS //宏值为空
   # define __END_DECLS
   #endif
   
   __BEGIN_DECLS //如果是C编译器，则被替换为空，如果是C++编译器，则被替换为 extern "C" {
   ... //实际头文件中的代码
   __END_DECLS   //如果是C编译器，则被替换为空，如果是C++编译器，则被替换为 }
   
   #endif /* __TEST_H__ */
   ```
2. 在C++编译器中用extern "C" { }包含起来的名称，都不会使用C++的修饰，而是使用C的修饰，也就是什么也不修饰。这样才可以顺利链接C源文件编译的库。

## 使用clang-format格式化代码

1. 可以统一代码风格，方便git管理。该工具和IDE自带的格式化工具相比，支持在命令行使用，可以在提交代码前，对整个工程应用。

2. 步骤：

   1. 可以在VSCode中安装Clang-Format扩展，可以更好地控制其行为，但是没必要安装。

   2. 在远程机上安装clang-format。实际上C/C++扩展中也包含一个clang-format的可执行文件，在`C:\Users\zj\.vscode\extensions\ms-vscode.cpptools-1.19.4-win32-x64\LLVM\bin/clang-format`和`/home/zj/.vscode/extensions/ms-vscode.cpptools-1.19.1-linux-x64/LLVM/bin/clang-format`。不过推荐单独安装，会优先使用path中找到的。

      ```shell
      sudo apt install clang-format #不同版本的clang-format程序略有差异
      ```

   3. 设置vscode的选项：

      ```shell
      Editor: Default Formatter #设置为Clang-Format，这样可以设置默认的格式化器
      Editor: Format On Save #一般推荐勾选上，这样就可以在保存文件时自动格式化
      ```

3. 在工程目录下生成一个默认的`.clang-format`文件：

   ```shell
   clang-format -style=google -dump-config > .clang-format #基于Google的风格
   ```

4. 如果源码文件中有一部分不希望被格式化，可以使用如下特定注释包含起来：

   ```c#
   some code
   // clang-format off
   不希望被格式化的代码
   // clang-format on
   some code
   ```
