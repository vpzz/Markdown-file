# 基础

1. LSTC公司在2019年被ANSYS公司收购，更名为ANSYS LST公司，LS-DYNA源自LLNL的John O. Hallquist博士于1976年开发的3D有限元分析程序DYNA3D。LSTC公司就在LLNL实验室的北面，都在加州的Livermore。LLNL是美国的核武器研制单位。DYNA3D是为了模拟全引信选项或可调当量核弹在低空释放（撞击速度约为40m/s）时的撞击而开发的。1978年，应法国的要求，DYNA3D源代码被无限制地发布到公共领域。

2. 1988年底，LSTC公司成立，以更专注的方式继续开发DYNA3D，从而产生了LS-DYNA3D（后来缩写为LS-DYNA）。因此，DYNA3D的发布和支持被停止。LS-NIKE是DYNA的隐式版本。

3. 最开始只有LS-POST，后来为其添加了前处理功能，才有了LS-PrePost。

4. 2008年5月推出971版本，后续都只是在此基础上更新小版本。

5. DYNA的授权方式不是分模组的，而是统计并行节点，即使购买几个节点的证书，也可以使用该软件的全部分析功能。

6. LS-DYNA的授权方式：依据软件同时可以运行的核心数量。例如一个8核的许可证允许以下任何一种情况（以及更多）：

   1. 用户在8个核心上并行运行一个任务；

   2. 用户并行运行两个任务，每个使用4个核心；

   3. 用户运行8个任务，每个使用1个核心。

7. CAE软件的授权和其他软件不同，普通软件一般就是需要一个序列号就能激活一台计算机，然后无限制使用。而CAE需要更复杂的授权管理系统，需要能在网络内分发和收回授权，或只授权部分模块。

8. 可以在ANSYS License Manager Center中View FlexNet Debug Log查看证书的使用情况，下面是使用了4个核心计算的日志输出：

   ```shell
   22:08:15 (ansyslmd) OUT: "dyna" zj@DESKTOP-R2R1L2Q  [2288] #OUT表示借用
   22:08:15 (ansyslmd) OUT: "dysmp" zj@DESKTOP-R2R1L2Q  [2288] (3 licenses) 
   22:08:21 (ansyslmd) IN: "dysmp" zj@DESKTOP-R2R1L2Q  [2288] (3 licenses) #IN表示归还
   22:08:21 (ansyslmd) IN: "dyna" zj@DESKTOP-R2R1L2Q  [2288]
   ```

9. LS-DYNA主要的应用方面：汽车碰撞和乘员安全，金属钣金成型，飞机鸟击，爆炸侵彻，液晃分析，跌落测试。

10. LS-DYNA垄断了国内外汽车厂商的碰撞安全分析应用，全球80%的汽车制造商将它作为首选的碰撞分析工具。Occupant（乘员）是汽车行业中车内人员的专用称呼。

11. DYNA提供了汽车设计的特殊功能，例如焊点，安全带，滑环，预紧器，牵引器，传感器，加速度计，气囊，假人模型，壁障模型等，可以模拟碰撞仿真，气囊从折叠到膨胀展开的全过程。

12. 人体由许多构件组成，每个构件要用单元网格构造准确的几何，假人的质量，质心位置，转动惯量，特别是各个关节的弹性连接和阻尼特性要和真人匹配。通常需要大量的试验才可以确定参数，汽车厂家会从假人制造公司或软件公司购买相应的模型数据，导入LS-DYNA使用。

13. 行业专用的分析软件可以在通用软件上开发得到，例如DYNAFORM是在LS-DYNA上开发的。

14. DYNA提供了板料冲压成形模拟的功能，同时也基于这些功能开发专业的软件LS-FORM。

15. DYNA可以交替使用隐式和显式求解器，例如进行薄板冲压成型的回弹分析。

16. 对于实际的对称结构，由于天然或人造材料性质的不均匀分布，不一定产生对称的响应，而在FEM中，如果不手动指定不同的材料性质，则必定只会产生对称的响应，因此使用对称模型计算，不会有任何危险，只有收益。
17. 战斗部为弹药行业中对毁伤目标的最终毁伤单元的专用称呼。
18. 内弹道发射是指炮弹在炮管内发射，外弹道是指导弹直接发射。

19. 进行汽车碰撞模拟时，可以为每个车轮定义一个刚性墙，这样可以获得每个车轮的反力。
20. 汽车模型中，轮胎也可以使用airbag来模拟。
21. 如果模拟中包含假人，可以在history中输出hic（head injury criteria）。
22. Part，Material，Section，EOS，Hourglass都有对应的ID，分别为PID，MID，SID，EOSID，HID。同一个Part内的单元具有相同的以上所有属性。可以在Model→PartData中查看，赋予Part相关的信息，这个比直接在Keyword中修改方便些。
23. 和Abaqus不同，Part关键字在LS-DYNA中是必不可少的，它将材料，截面，沙漏控制等关键字联合起来。Abaqus是通过截面将材料和单元集合关联起来的。因此LS-DYNA中刚体材料关键字`*MAT_RIGID`中是可以设置是否约束使用此材料的part的质心的运动的，当然也支持使用constrained来约束。

24. 和Abaqus不同的是，DYNA使用ID而不是名称来索引，名称可有可无，仅为了让人能看懂。建立起引用的ID，如果修改了其中一个，引用也会自动更新，这也是可以任意Renumber的基础。

25. 只有同类型的单元才可以处于同一个part中。因为他们要共享相同的单元公式。

26. 鉴于此，推荐为每个Part都创建一个材料编号，即使它和其他part使用相同的材料。这样使得每个Part的所有ID编号都一样，方便纠错。

27. 钢和铝的波速为$5mm/μs$，也就是说，如果网格尺寸为5mm，则稳定时间步长就是1μs。

28. 如果模拟中存在比其他部分明显更硬的物体，建议设置为刚体，而不是提高其弹性模量，因为后者会降低稳定时间步长。

29. 由于显式分析不需要形成刚度矩阵，因此也就不需要进行带宽优化了。

30. 显式算法的过程：
    1. 先计算节点内力和外力矢量，内力=单元应力在节点的等效力+沙漏阻力+接触力。外力=施加的外力+体积力。
    2. 节点加速度=(外力-内力)/节点质量。
    3. 通过显式时间积分，求中间时刻速度和结束时刻位移。加速度和位移都是在整时间间隔上求得的，速度是在中间时刻求得的。
    4. 由上一步的几何构型叠加上新的位移矢量，就得到下一步的几何构型。
31. 负体积问题可能的原因：

    1. 网格品质差，例如长宽比过大，一旦受力，节点容易沿短边跑到另一侧。

    2. 所选材料模型不合适或参数不合理，造成冲击瞬间，结构发生很大变形。

    3. 如果给与模型过大的冲击速度或力量，也会造成很大变形。可以检查并修改contact中的scale factor。

    4. 较薄零件若无缓冲效果，例如胶结，可以不对胶结建模，直接使用tiebreak contact将两边零件tie住。
32. DYNA中用于模拟气囊展开的方法：控制体积CV法，ALE流固耦合，S-ALE流固耦合，微粒法，CESE流固耦合，SPH法。其中控制体积法使用最广泛，计算速度最快。气囊采用壳单元和纤维材料。
33. LS-DYNA中的交互式材料模型驱动程序允许计算材料对指定应变路径的本构响应（纯材料计算，不需要建模节点和单元）。由于LS-DYNA中的本构模型子程序是由该驱动程序直接调用的，因此本构模型的行为正是实际应用中可以预期的。在当前的实现中，可以检查壳单元和实体单元的本构子程序，相当于只调用UMAT了。K文件中通常仅包含：
    1. *KEYWORD
    2. *DATABASE_BINARY_D3PLOT
    3. *CONTROL_TERMINATION
    4. \*PART，\*MAT，\*SECTION
    5. \*DEFINE_CURVE，描述应变路径的九条载荷曲线，定义了9个位移梯度分量的时间历程。
34. 关键字`*SENSOR`提供了一种方便的方法来激活和停用边界条件、安全气囊、离散单元、接头、接触、刚性墙、SPC和受约束节点。传感器功能自971版本的第二个版本起可用，如安全气囊的开展需要车头某一区域的加速度达到某个阈值才可以触发展开。
35. 要定义和使用传感器，需要三类传感器关键字命令。
    1. 使用`*SENSOR_DEFINE`定义传感器。传感器提供模型响应的时间历程，可由`*SENSOR_SWITCH`作为切换标准。任何传感器的时间历程都可以使用`*DEFINE_CURVE_FUNCTION`和`*DATABASE_CURVOUT`中的SENSORD功能输出。`*SENSOR_DEFINE_CALC-MATH`，`*SENSOR_DEFINE_FUNCTION`定义值是一个涉及其他传感器值数学表达式的传感器。
    2. `*SENSOR_SWITCH`系列关键字定义了传感器切换标准。`*SENSOR_SWITCH`可以与逻辑计算命令`*SENSO_SWITCH_CALC-LOGIC`结合使用，以获得更复杂的定义。这类命令产生的逻辑值可由`*SENSOR_CONTROL`参考，以确定是否满足状态切换条件。
       1. `*SENSOR_SWITCH`将`*SENSOR_DEFINE`或`*SENSOR_DEFINE_CALC-MATH`的数值与给定标准进行比较，以查看是否满足切换条件。
       2. `*SENSOR_SWITCH_CALC-LOGIC`对来自`*SENSOR_SWITCH`的信息执行逻辑计算。

    3. `*SENSOR_CONTROL`根据`*SENSOR_switch`或`*SENSOR_SWITCH_CALC_LOGIC`的逻辑值确定如何切换以及切换什么。

36. 具体关联方式可以查看这张图：
37. <img src="LS-DYNA.assets/image-20250221102928068.png" alt="image-20250221102928068" style="zoom: 50%;" />
38. 对于大多数本构模型，DYNA会将`*DEFINE_CURVE`定义的曲线在横坐标上以相等间隔进行内部再离散化，以便快速确定取值，以达到O（1）时间取值。在评估压力、集中力或位移边界条件等载荷条件时，不使用再离散化。
39. 由于输入错误和错误结果有时与负载曲线使用有关，因此在读取所有输入后，d3hsp文件中会打印一个`Load curve usage`表。应检查此表，以确保每条曲线ID都被正确引用。

    ```shell
     Load curve usage 
    
     load curve # 1
     *MAT_CRUSHABLE_FOAM    PID=1
    
     load curve # 2
     *BOUNDARY_PRESCRIBED_MOTION_... r.b. displacement
    ```
40. 曲线的横纵坐标可以分别进行平移+缩放，然后再组合成曲线.

    1. 横坐标，Abscissa value = SFA × (Defined value + OFFA)，左加右减，也就是OFFA>0表示将曲线向左平移
    2. 纵坐标，Ordinate value = SFO × (Defined value + OFFO)，上加下减

41. 有效effective应力和等效equivalent应力是一样的。

42. DYNA可以进行子结构分析，通过`*INTERFACE_COMPONENT_option`设置子结构的边界，可以用Node或Segment标识。通过`*INTERFACE_COMPONENT_FILE`输出边界状态到文件或者在命令行添加Z=infmak设置。通过`*INTERFACE_LINKING_option`在子结构中读入边界状态文件或在命令行添加L=infmak设置。

43. DYNA支持通过命令行选项pgpkey对K文件使用pgp密钥进行加密，密钥会输出到lstc_pgpkey.asc。

44. 某些时候接触力可能会波动很大，这是因为模拟默认是没有滤波的，而实验中采集结果是受到采样频率限制的。


# 数值方法

1. 在固体力学中，差分法是有限元法出现前的主要的数值方法，差分法对于复杂边界适用较差。爆炸软件AUTODYN和岩土工程软件FLAC就是使用差分法。
2. 有限元法的缺点是难以处理有极大单元变形的情况，预估产生的误差比较困难。
3. 有限体积法基于积分形式的守恒方程，而非微分方程。
4. 拉格朗日算法的网格会随着变形的增大，逐渐降低精度，优点是能够非常精确地描述结构边界的运动，适用于中等变形问题。
5. 欧拉算法由于网格不变形，因此精度不变，缺点是边界捕捉困难，适用于流体动力学，极大变形的问题。
6. 为了使得拉格朗日算法能够处理大变形问题，提出了自适应网格重划分（Adaptive Remesh）方法，它根据计算结果估计误差，按需重新划分网格，将旧网格中的物理量映射到新的高质量网格上，继续计算，这样一直循环。缺点：每次重划分会导致一些物质扩散和历史纪录的丢失。通常用于薄板冲压，薄壁结构受压屈曲，三维锻压等大变形问题，不适合于纯流体问题。除此之外，DYNA还有无网格伽辽金EFG和ALE自适应网格重划分方法。
7. 欧拉分析和ALE分析都可以克服拉格朗日算法在网格畸变时数值求解困难的问题，易处理大变形问题，也可以进行流固耦合分析。缺点：难以获得材料场变量的时间历程。难以跟踪材料界面。因为ALE会将变形后网格中单元变量映射到ALE网格中，因此也会产生误差。
8. ALE算法最初出现于用于模拟流体动力学的有限差分法中。具有拉格朗日算法和欧拉算法两者的优点。在结构边界运动的处理上使用了拉格朗日算法的特点，能够有效追踪边界运动。其次内部网格的划分上又吸收了欧拉算法的特点，即使内部网格独立于物质实体而存在，但又不完全和欧拉网格相同，网格之间的物质是可以流动的。网格可以根据定义的参数在求解过程中适当调整位置，使得其不出现严重畸变。
9. ALE最大的特点是允许光滑变形网格，而不执行完全网格重划分。
10. 边界元法只在求解域的边界上划分单元，用满足控制方程的函数去逼近边界条件。基本思想是利用格林定理，将全域的控制方程转化为边界上的积分方程。与有限元方法相比，降低了问题的维数和自由度数量。通过引用问题的基本解，而具有解析和离散相结合的特点，使得计算精度较高。缺点是需要存在相应微分算子的基本解，对于非均匀介质等问题难以应用，适用范围远不如有限元法。DYNA的声学和电磁学计算支持边界元功能。用于求解流体绕刚体或变形体的稳态或瞬态流动问题，局限性较大，仅用于非粘性及不可压缩流动。确定结构和周围流体介质对随时间正弦（谐波）变化的载荷和激励的频率响应。
11. 离散元法起源于分子动力学，是为了研究岩体等非连续介质而发展起来的。离散的单元本身为刚体，单元间的相对位移等行为由联接节点间的变形元件来实现，允许单元间的相对运动，不必满足位移连续和变形协调条件。适用于模拟节理系统或离散颗粒混合，分离，输运等过程。
12. SPH法是一种无网格的纯拉格朗日算法，为解决天体物理中涉及的流体质团在三维空间无边界情况下的任意流动拉格朗日问题而开发的，后来发现对于模拟连续结构的解体，断裂等问题或大变形流动非常有效。SPH适合用来求解具有大变形，复杂边界和物质交界面等复杂单相，多相流体动力学问题，是最早的无网格法。
13. SPH使用一系列的粒子来表示求解域，粒子具有质量，速度，温度，粒子之间不需要任何连接，具有无网格特性。理论基础是插值理论，通过一种称之为核函数的积分核进行插值近似，将流体力学微分方程组转化为SPH代数方程组。SPH的近似过程不受网格限制，可以避免网格极度大变形时的精度下降问题。缺点是：拉伸不稳定会引起数值断裂，需要复杂的接触算法。SPH可以模拟金属切削，不存在网格畸变性和单元失效问题，因为它没有网格。PrePost使用SPH Generation来创建SPH的part，只需要提供表面网格即可，内部不用划分网格。
14. 电磁场（EM）模块通过求解麦克斯韦方程模拟涡电流，感应加热，电阻加热等问题，可以与结构，热分析耦合。
15. DYNA是唯一引入近场动力学（PD）的商业软件，基于非连续伽辽金有限元来模拟脆性材料的三维断裂。
16. 光滑粒子伽辽金（SPG）是DYNA独有的，适用于弹塑性及半脆性材料的失效与破坏分析。由于材料的失效导致传统的有限元仿真变得困难，SPG算法区别于其他失效与破坏算法的特点是它可以不删除失效的单元，并且计算结果对失效准则敏感度不高。该算法还可以用于多尺度分析。
17. 传统有限元在模拟结构的破坏时，裂纹位置必须沿着单元的边界，同时在裂纹尖端附近的节点位置也必须特别处理，当裂纹成长时，网格也必须随之重建，建模工作繁琐，可信度不高。
18. 扩展有限元法（XFEM），联合了连续-间断有限元法，由于其位移场通过单位分解引入了强间断，因此能够有效模拟材料破坏引起的结构从连续到间断的状态改变。采用虚拟节点积分法，引入间断的单元可以分解为2个相同类型的虚拟单元。很适合模拟板壳结构的破坏失效和动态裂纹扩展分析。裂纹可以穿过单元内部来扩展，极大地减少了网格离散和网格取向对裂纹扩展的影响。
19. 结构化ALE（S-ALE）能够在DYNA计算开始时，在求解器种自动生成正交结构化ALE网格，可以简化建模过程，提高流固耦合求解的稳定性，降低求解所需内存和时间。
20. 从971R5开始，DYNA陆续增加了一些频域内振动和声学分析计算功能，例如频率响应函数，稳态震动，随机振动和随机疲劳。反应谱分析，有限元声学和边界元声学。
21. 等几何分析IGA，是Hughes提出的一种能够直接在CAD几何模型上进行分析的方法，2014年开始DYNA开发基于IGA的壳单元，实体单元，修剪壳单元等。减少了网格划分的复杂工作，同时也减少了离散造成的误差。修改完CAD之后，就可以直接进行分析，便于进行优化分析。目前大部分的等几何研究都采用非均匀有理B样条曲线（NURBS）作为基函数。
22. ICFD求解不可压缩流动，要求马赫数<0.3，使用隐式算法，960版本增加的。可以采用ALE网格运动方法或网格自适应技术解决流体和结构之间的强弱耦合。
23. 时-空守恒元CESE，是高精度，单流体，可压缩显式求解器，采用欧拉网格，能够精确捕捉非等熵问题的细节，可用于超音速分析。在其上还开发了精度更高，更稳定的DUALCESE求解器，可用于多相流计算。
24. 微粒法是用相互作用的颗粒来模拟安全气囊展开过程中气体及气囊响应的数值方法。研发的最初动力来自于离位状态气囊展开模拟的需要。乘客处在理想位置且只与充分展开的气囊有接触的情况下，控制体积（CV）方法能满足模拟需要。但对于气囊在未充分展开状态下的响应和乘客在离位状态下的气囊响应，经验表明，在气囊展开早期气体流动对此有重要影响。然而控制体积法因为等压等温假设的限制，无法得出可靠的结果。新的气囊折叠方法和排气孔设计也要求更精确的计算方法。ALE方法因为计算成本高昂和稳定性的限制，也不是最佳选择。
25. CPM基于分子运动理论（Kinetic Molecular Theory，KMT），有如下假设：
    1. 气体由大量分子构成，每个颗粒的运动都遵循牛顿第二运动定律。
    2. 气体达到了热力学平衡，也就是分子处在随机运动状态。
    3. 分析之间距离远大于分子直径。
    4. 分子与分子之间，分子与容器之间的相互作用仅限于完全弹性碰撞，没有其他形式的吸引或排斥。

26. 基于以上假设，可以从描述分子运动的微观量推导处气压，温度等宏观量。实际工程中，由于计算能力的限制，对于分子动理论的直接模拟被局限于微小的空间和时间尺度。CPM进行了进一步的粗粒化处理，用一个颗粒代表一大批分子。颗粒的假设：
    1. 颗粒简化为理想球形，接触计算简单高效。
    2. 颗粒之间以及颗粒与结构的碰撞为理想弹性。
    3. 颗粒既有平动能也有转动能，比例关系由热容量决定。

27. 在此基础上，研发的PBM方法还可以用于地雷爆炸对装甲车的毁伤计算以及岩土爆破计算。

# 求解器

1. 求解器最开始输出的预估计算时间不太准确，一般会偏大，可以在开始输出几帧后，按Ctrl+C，输入sw2（也可以通过LS-RUN发送），此时输出的预估计算时间更为准确。

2. 一般来说动态分析使用单精度就够了，隐式或准静态使用双精度（因为存在很多矩阵操作）。双精度运行时间将比单精度运行时间长约30%（因平台而异）。

3. 显式求解对于内存的需求比隐式小得多，一般几百M就够了。

4. 求解过程中的信息保存在message文件中。有些重复性的消息并不会全部输出到命令行窗口，但是都会记录在message文件中。

5. 求解过程中，在命令行界面，按Ctrl+C可以中断求解器，提示Enter sense switch。可选的有：

   ```shell
   quit    #终止求解器
   stop    #同上
   sw1.    #输出重启动文件d3dump，然后终止求解
   sw2.    #输出预估的剩余计算时间，实际时间一般会比这个值要低，然后继续求解
   sw3.    #输出重启动文件d3dump，然后继续求解
   sw4.    #输出一个d3plot文件，然后继续求解
   swa.    #刷新ls-dyna的所有输出IO缓存
   swb.    #输出dynain文件，然后继续求解
   swc.    #输出重启动和dynain文件，然后继续求解
   swd.    #输出重启动和dynain文件，然后终止求解
   swe.    #停止动态松弛，就像达到收敛一样
   endtime=time #修改终止时间
   lpri    #开关隐式线性代数求解器输出
   nlpr    #开关隐式非线性代数求解器输出
   iter    #开关隐式输出到d3iter数据库
   prof    #输出时间信息到messag，然后继续求解
   conv    #强迫当前时间步的隐式非线性求解收敛
   ttrm    #终止隐式时间步长，缩短时间步长，重试时间步长
   rtrm    #在当前时间步终止隐式求解
   ```

6. LS-RUN通过在输入文件目录中创建感测开关文件（d3kil），可以在模拟期间将LS-DYNA感测开关发送到所选作业。

7. 重复运行时，建议每次运行前，将之前的d3plot文件都删除掉，否则可能会将2次的结果串接起来，造成混淆。使用LS-RUN运行时，会提示是否覆盖。

8. Windows下的DYNA没有Linux下的稳定性强。

9. 初始化时的输出如下：

   ```shell
   initialization completed
         1 t 0.0000E+00 dt 7.83E-04 flush i/o buffers            02/10/25 08:32:40
         1 t 0.0000E+00 dt 7.83E-04 write d3plot file            02/10/25 08:32:40
   cpu time per zone cycle............         0 nanoseconds
   average cpu time per zone cycle....         0 nanoseconds
   average clock time per zone cycle..       470 nanoseconds
   #根据初始化第一个分析步所需的时间，节点总数，总共的分析步数量，来估算实际所需的时间470*5876*8/(7.83e-4)/1e9=28.21s。
   estimated total cpu time          =         1 sec (       0 hrs  0 mins)
   estimated cpu time to complete    =         0 sec (       0 hrs  0 mins)
   estimated total clock time        =        27 sec (       0 hrs  0 mins)
   estimated clock time to complete  =        26 sec (       0 hrs  0 mins)
   termination time                  = 8.000E+00
   ```

10. 求解结束后的输出：

   ```shell
    Problem time       =    1.0000E+01 #control termination的时间
    Problem cycle      =      9599 #时间步数量
    Total CPU time     =       404 seconds (   0 hours  6 minutes 44 seconds)#总耗时
    CPU time per zone cycle  =       1370.757 nanoseconds #每个单元，每个时间步推进所需要的现实时间。
    Clock time per zone cycle=       1371.994 nanoseconds
   
    Number of CPU's    4
    NLQ used/max     136/  136
    Start time   02/15/2025 10:20:59  
    End time     02/15/2025 10:27:43  
    Elapsed time     404 seconds for    9599 cycles using  4 SMP threads
                (      0 hour   6 minutes 44 seconds)
   
    N o r m a l    t e r m i n a t i o n                         02/15/25 10:27:43
   ```

11. 不能将某个d3plotxx修改为d3plot，然后通过PrePost打开，会直接闪退。只能打开第一个d3plot。

12. 求解器在命令行的输出会被保存到message中，但是预估的时间会存储到status.out中。

13. LS-RUN生成的命令行脚本如下，先设置环境变量，然后调用求解器程序。

    ```bat
    call "C:\Program Files\ANSYS Inc\v221\ansys\bin\winx64\LSPrePost47\LSDYNAmsvar.bat" && "C:\Program Files\ANSYS Inc\v221\ansys\bin\winx64\LSDYNA_dp.exe" i=D:\LS-DYN~1\BALL_P~1.K ncpu=4 memory=20m
    @echo off
    echo job finished > LSrunjobid5
    pause
    ```

14. 命令行中的`BALL_P~1.K`是8.3格式，这是古早Windows版本的文件命名格式，表示以BALL_P开头的，后缀为.k的第1个文件。可以通过修改注册表来关闭这种功能。

15. 命令行输出中的信息记录了求解器的版本。

    ```shell
    Version : smp d R12  #表示SMP双精度，R12求解器版本
    ```

16. LS-RUN可以添加任务队列，设置任务之间的依赖，这样任务会先后完成。在添加任务的三角形按钮右侧可以设置使要添加的任务依赖于某个编号的任务，如果依赖号为0，则表示不依赖任何任务，如果为-1，则表示依赖于最近添加的那个。

17. 旧版本的求解器会要求K文件路径中不能有空格，否则会报错 invalid option on the command line : A。这个A是指路径中空格后的第一个字母，求解器将空格作为命令和参数的分隔了，因此会认为A是选项。

18. DYNA的求解器就是一个静态链接的可执行文件：`LS-DYNA_smp_d_R11_1_0_winx64_ifort160.exe`。smp表示对称多处理，就是共享内存，使用OpenMP的。d表示双精度，R11_1_0表示求解器为11.1.0版本，ifort160表示Intel Fortran Compiler版本，这是Windows平台推荐的编译器。

19. 16核以下建议使用共享内存SMP版本，16-512核心建议使用大规模并行MPP版本，512核心以上建议使用HYBRID（CPU内使用SMP，CPU间使用MPP）。

20. 使用共享内存并行（Shared Memory Parallel）处理时，计算可能会以不同的顺序执行，具体取决于CPU可用性和每个CPU的工作负载。因此当多次运行同一作业时，可能会看到结果略有不同。为了避免这些差异，您可以将CPU的数量指定为负数以保持一致性。保持一致性可能会导致CPU时间增加15%。使用SMP不需要任何额外的操作。

21. 大规模并行处理（MPP）功能允许在一组机器上运行LS-DYNA求解器，或在一台机器上使用多个处理器。在使用MPP运行分析之前，必须正确安装了受支持的MPI软件（Intel或MS的，这两个在ANSYS的安装程序中都可以选择），并且必须正确配置运行MPI的机器。MPP生成的输出文件是标准的LS-DYNA输出文件，与Ansys不兼容。因此必须使用LS-DYNA后处理器来查看结果。

22. DYNA求解器可以接受K文件或DYN文件，其中全部由以*开头的关键字组成。

23. DYNA在求解不同K文件时，默认情况下，求解产生的文件都是同名的，这点和Abaqus不一样，因此一个文件夹中，建议只保存一个K文件及其结果，要不会覆盖。不过这个是可以修改的，两种方法，都可以为输出文件名添加前缀，这允许在一个目录中进行多次模拟，因为不同的前缀可以防止文件被覆盖：

    1. 使用`*KEYWORD_ID`或`*KEYWORD_JOBID`，为所有输出和暂存文件名添加前缀。如果使用ID选项，则前缀由三个用户指定的字符串构成，用下划线字符分隔。

       ```shell
       #应该手动从K文件中删除*KEYWORD_ID的参数memory=和memory2=，否则会报错
       *KEYWORD_ID
       PROJECT            NUM                   STAGE
       #或者
       *KEYWORD_JOBID
       PROJECT_NUM_STAGE
       ```

    2. 可以在命令行中包含`jobid=`来指定输出文件名前缀，这可以在LS-RUN中添加。例如`lsdyna i=input.k jobid=PROJECT_NUM_STAGE`会输出PROJECT_NUM_STAGE.d3plot。这种方法的优先级比上一种高。


# PrePost技巧

1. LSTC还开发了自己的预处理器和后处理器LS-PrePost，它是免费分发的，无需许可证即可运行。PrePost的开发工作目前由大连富坤科技公司负责，界面使用WxWidget GUI库和OpenGL图形库，几何引擎使用OpenCascade库。
2. 在PrePost的2.4~4.6版本期间，新旧界面同时存在，可以按F11进行切换。4.7及以后版本，只保留新界面。配置文件为`C:\Users\zj\AppData\Roaming\LSTC\LS-PrePost4.11\lsppconf`。
3. 按下F1键可以设置快捷键，按下Shift+Fn键，可以直接运行对应的Fn.cfile文件，会先在配置文件中functionkey_path变量（一般为空）指定的目录下查找，然后在当前工作目录，最后在配置文件所在的目录。
4. cfile文件又称为session file。可以在系统命令行启动PrePost时，使之读取cfile：

   ```shell
   LS-PrePost c=commandfile #可以加入-nographics，不启动GUI，但仍以批处理模式执行命令
   ```
5. 按Ctrl+O可以输出PrePost自己的信息到文件LS-PrePost_info.txt。

6. 多边形选取时，单击左键添加角点，单击右键结束选择。
7. 当PrePost提示选择几何或单元时，也可以直接在模型树上点击来选择。
8. 选择矩形四边所有节点的技巧：设置显示模式为Edge，然后选择Active（即当前可见的部分）即可，可以快速选中矩形板的四边。也可以使用By Edge，勾选prop。
9. 通过By Element进行Propagate选择时，只会将Attach的单元，且在合适夹角范围内的单元的节点选中。通过Detach分离的不会自动Propagate过去，即使满足夹角条件。不同的Part，只要是Attach在一起的，也会属于选择范围内。
10. 获得一个实心结构的外表面单元构成的网格的技巧：可以先通过By Part选择内外所有单元，然后使用prop技术从中删除表面单元。
11. PrePost支持将选择的东西临时save起来，后续可以load进来。
12. 在节点上单击鼠标中键可以将其设置为旋转中心，再次单击中键，可以取消设置。这对于ALE的物质网格无效，而且还会闪退，因为这些网格是没有节点的，用户看到的节点只是只是物质网格中的界面和背景网格的交点。
13. 一般按住Shift+左键可以平移，按住Ctrl+左键可以以edge模式查看的同时进行平移，此时所有的free edge都会显示，这有助于查看是否需要merge node。
14. PrePost支持一边计算，一边后处理，点击File→Update可以更新读取结果文件。PrePost可以处理全部格式的LS-DYNA计算结果文件。
15. PrePost中显示云图的功能名为Fringe，这个单词为条纹的意思。通过颜色条纹或边缘过渡来展示物理量的分布。
16. PrePost中的Resultant Displacement是指位移向量的幅值。
17. 菜单栏→View→Beam Prism可以查看梁单元的截面。Model→Appearance→Thick，点击Allvis即可查看壳单元的厚度。
18. Model→Views中可以保存视图，以便后续查看。
19. Element Tool→Dup Nodes可以设置容差，来检查是否有节点重合，顺便Merge它们。也可以用它检查是否存在Free Edge，这个是网格层面，而非几何层面的。实际就是不相容的单元，例如一条线两侧的单元的节点不重合，这个可以用Node Edit→Replace来处理。
20. Element Tool→Detach可以将选中的单元与和他相连的单元分离，会生成额外的节点，相当于merge的相反操作。
21. Node Edit的align功能，可以将节点对齐到一条线上。
22. 在PrePost中open一个新的K文件，并不会导致关闭旧的，两个都会保持打开，可以在Model→Model Selection中选择，还可以比较两个K文件中的关键字。
23. 可以使用Solid→Thick来将由几何表面构成的壳变厚，这是纯几何操作。
25. 在PrePost的Surf中没有fillet倒角的功能，不过可以使用Solid的fillet倒角功能，结果是一样的。
26. 复制实体几何时，需要确保filter中只有实体，否则容易选择到它的表面。
27. 可以使用stich功能将水密的多个面缝合构造成一个实体，勾选Try to Make Solid。
28. Geometry Tool→Model Management可以查看特定ID对应的几何或删除它。
29. Element Tool→Move or Copy的功能是将某些单元复制或移动到目标part中。
30. 可以在PrePost的Post→ASCII→GLSTAT中查看到，GLSTAT最多可以输出33个变量，但是默认并非所有都输出（默认为19个），能量相关的可以在`*CONTROL_ENERGY`中开启，例如沙漏能量。
31. PrePost中有些设置可以选择Part或Part Set等，这个取决于该参数后面的STYPE参数，PrePost会自动根据后面的参数来决定点击前面参数右上角的实心圆点时会弹出的窗口。
32. 获取part的质量时，使用Measure有2种方式：
    1. 获取Part，使用by part选择。推荐这种，计算效率高。

    2. 获取Element，使用by part选择。
33. 有时要获取某个Part包含单元或节点数量，可以Blank其他Part，然后点击菜单栏→View→Model info→Active Entities。也可以在Model→Part Data→show中查看。
34. 提交计算前，应该在Node Edit→Delete中删除所有未被引用的节点（2种）或单元，并清理模型。然后对模型进行Renumber，压缩编号。
35. 有时可能发现，在PrePost的模型树中，开关显示某个Part时，图形区域并不会有变化，这是因为没有单元属于该Part，也就是这是一个空Part（有时在模型树中根本不会看到该part），可以在Model→Part Data→#Elems来查看单元数量。提交求解前应该删除这种part，否则会报错。
36. 在`*DEFINE_CURVE`中如果对横纵坐标轴进行了缩放，在Plot时也会体现出来。
37. 某些关键字需要给定cureve ID，如果点击了NewKeyword，则会跳转到Keyword Manager的curve区域，需要手动选择并双击对应的curve关键字。有时不用手动选择，例如创建section时，因为它没有选择的必要。
38. 每次Copy单元之后，都应该进行Dup Node检查，并合并节点。
39. 从某个面拉伸生长出来的单元，会和该面的单元共享节点。
40. 使用PrePost的Element Generation中shell from solid face功能，可以创建和实体单元表面共节点的壳单元。一般还需要将二者进行分离，可以使用Detach或将壳单元移动并复制出去一份，然后删除原来的，然后再移动回来。
41. Element Tool→Morph工具可以对网格进行变形（类似于等参元的母子单元映射），例如将矩形正交网格，通过一边拉伸得到梯形网格。选择母实体和子节点，点击constrained，然后移动母实体的节点和边就会同步修改子节点的位置，最后记得回到该工具取消约束。
42. 使用`*ELEMENT_DISCRETE`创建的离散弹簧单元，默认不会在PrePost左侧的模型树中显示的。可以在Model→Select Part中选择Discrete即可显示，或者保存然后重新打开PrePost。这是PrePost的bug。
43. Keyword Manager左上角的NewID只是新增一个ID，不会修改其余的参数内容，而右上角的Add则还会用默认值填充参数内容。二者都不是对已有项的修改。
44. 通过观察Keyword Manager右侧，是否选中了某个项，来分辨当前是在创建新的项，还是修改旧的。

# K文件

1. K文件以`*KEYWORD`开头（会显示在PrePost中），以`*END`结尾（不会显示在PrePost中），DYNA只会处理二者之间的部分。其中`*END`可以省略，此时会读取到文件末尾。被`*INCLUDE`包含的关键字文件，可以省略`*KEYWORD`和`*END`。

2. 输入文件可以分为多个子文件。.dyn是主文件，可以将一系列子文件串联起来。

3. 可以将模型文件（只包含`*NODE`，`*ELEMENT_option`，`*SET_option`，不过还有`*KEYWORD`和`*END`）单独保存，而将其余文件存在另一个文件中，在后者中使用如下语句引用：

   ```
   *INCLUDE
   model.k
   ```

4. 使用`*INCLUDE`关键字包含文件，会被当作多个子系统subsystem，后续在PrePost中添加关键字时，会自动存放在current subsystem中。在PrePost中新建子系统时，可以顺便指定它将来要存储的文件名。

5. 如果文件是以包含子系统的形式打开的，则保存时默认会勾选By Subsystem。如果取消勾选，则会保存成一个文件。

6. 使用`*INCLUDE_TRANSFORM`引入K文件时，可以在TRANID参数处引用`*DEFINE_TRANSFORMATION`定义的变换，来对子模型进行位置变换和缩放，变换可以是一个序列，依次执行。

7. K文件中不允许有空行，因为它会被认为是某个关键字的一个数据行。

8. 在PrePost中保存的时候，可以勾选压缩为gz或zip文件。因为K文件只能以ASCII形式保存，因此体积较大，压缩一下便于传输，一般压缩比例还是很高的。这里如果勾选By Subsystem，则会输出多个压缩包。

9. 可以在Select Part中设置，只显示部分part等，然后在File→Save As→Save Active Keyword As来只保存显示部分的关键字，不过这样会导致引用未显示部分的关键字出错。

10. LS-DYNA将每个关键字卡视为一种命令（或函数或子例程），其数据行相当于参数。

11. 每个关键字前的*必须在第一列，数据行紧跟在关键字行之后，直到遇到下一个关键字行为止。关键字不区分大小写。

12. 第一列中的$表示，该行为为注释行。

13. 除了以下关键字的顺序之外，其余所有关键字的顺序可以任意：

    1. *KEYWORD定义开头。
    2. *END定义结尾。
    3. `*DEFINE_TABLE`后面必须紧跟`*DEFINE_CURVE`。因为表格就是多条曲线的组合，即曲线族。
    4. `*DEFINE_TRANSFORM`必须在`*INCLUDE_TRANSFORM`之前定义。
    5. 参数必须先在`*PARAMETER`中定义，才能使用。

14. 每个K文件中，必须具备如下关键字：

    ```
    *KEYWORD
    *CONTROL_TERMINATION
    *NODE
    *ELEMENT
    *MAT
    *SECTION
    *PART
    *DATABASE_BINARY_D3PLOT
    *END
    ```

15. 数据行可以采用固定格式（中间用空格分隔）或自由格式，中间用逗号分隔，而非空格。PrePost导出的K文件都是固定格式，一行80个字符，共8项，每项10个字符，这样更美观些，而且还包含用注释行表示的每个参数的含义。

16. 自由格式和固定格式可以在一个K文件的不同关键字中混合使用，或者同一关键字的不同行间混合使用，但是同一行不允许混合使用。

    ```
    *NODE
           101         x         y         z
    102,x,y,z
    *ELEMENT_SHELL
    1001,pid,n1,n2,n3,n4
    ```

17. 关键字后的每个数据行都称为一个card卡片，每个数据行由多个参数组成。手册中会指定每个参数的类型，I8表示不超过8位的整数，最大位99999999。A70表示不超过70个字符的字符串。F表示浮点数，无论自由格式还是固定格式，都会忽略每行前80个字符以后的任何内容。

18. 许多关键字具有OPTIONS或{OPTIONS}标识，前者是必选项，必须从多个待选中选择一个才可以，后者是可选的，可有可无。

19. 每个关键字都可以被多次定义，例如`*NODE`可以在K文件的多处定义。不过使用PrePost导出K文件，会自动汇总排序。

20. 所有具备ID的关键字，都不允许重复使用ID。因为各个关键字之间通过ID来关联，互相引用。

21. 分析的类型通过`*CONTROL`系列关键字设置。结果输出在`*DATABASE`关键字中设置。

22. 常用的关键字如下：

    ```
    *NODE *ELEMENT
    *PART *MAT *SECTION
    *INITIAL *BOUNDARY *LOAD *CONSTRAINED
    *CONTROL
    *DATABASE *INTERFACE
    ```

23. 关键字在PrePost和手册中是以card卡片的形式给出的。一个关键字可以有多个卡片，卡片数量还取决于特定变量的值。每个卡片最多包含8个变量，每个变量都有名称variable，类型type和或默认值default。

24. <img src="LS-DYNA.assets/image-20250102183115183.png" alt="image-20250102183115183" style="zoom: 67%;" />

25. K文件中不需要写variable，只需要按顺序给出数据即可。不过PrePost导出的K文件，都在数据行的上方会以注释的形式给出variable，方便用户后续手动修改。

    ```shell
    *CONTROL_SOLUTION
    $#    soln       nlq     isnan     lcint
         &soln         0         0       100
    ```

26. 使用PrePost读取K文件时，可以打开Misc.→View message info查看是否产生了错误信息。

27. 可以使用Misc.→Keyword File Separate可以将K文件分割成多个。

28. Model checking可以检查接触，单元质量，关键字中引用的实体是否存在。

29. 定义参数：在`*PARAMETER`中定义参数，记得点击insert。

30. 使用参数：在关键字的编辑页面中，可以勾选`use *parameter`，然后点击关键字内某个参数的名字，就会跳出参数选择界面，选择完成后，需要再取消勾选`use *parameter`，然后才可以Accept，这样就完成了对参数的引用。

31. 以上步骤推荐使用PrePost来设置，而非直接修改K文件。这通常用于LS-DYNA和LS-OPT联合进行参数优化。引用其他参数的选项的输入框中的数据是蓝色的，可以通过这个来区分，直接修改该参数会报错，即使Accept，也会被忽略。不过在新版的PrePost中，蓝色内容表示非默认的值，也就是由用户修改过的。

32. 从外部导入曲线完成后，一定要Plot一下。从http://www.varmintal.comwa网站导入的曲线，指数D，需要改成E，然后保存为.csv格式。曲线不能出现两个横坐标相同的点，会报错，因为此时斜率为无穷大，且DYNA不知道应该取哪个值。

33. 外部数据的格式建议导入前，手动改成csv格式（逗号分隔），否则PrePost会不识别。

34. 可以在Keyword Manager左上角勾选Comment，来为K文件中当前关键字前添加`*COMMENT`，相当于注释了该关键字，其后的数据行也会被忽略，但是这个和直接修改K文件，添加$注释不同的是，`*COMMENT`是可以在PrePost中看到的，可以方便取消注释。

    ```shell
    *COMMENT *CONTROL_TERMINATION
    $#  endtim    endcyc     dtmin    endeng    endmas     nosol
          10.0         0       0.0       0.01.000000E8         0
    ```

35. 保存K文件，然后重新打开后，会在`*COMMENT`中出现。可以点击左上方的Decode来取消注释，还原关键字（其左上角并不会显示勾选Comment），不过这并不会导致`*COMMENT`关键字项的删除。


# 网格生成

1. PrePost支持IGES和STEP两种通用的几何格式。读取时会自动对几何或拓扑错误进行清理，缝合邻接曲面。
2. Shape Mesher和Block Mesher都可以直接创建网格，而不需要借助几何，可以生成四边形或六面体网格。
3. Solid Meshing可以基于映射或扫掠方式创建结构化的六面体或五面体网格。
4. Auto Mesher借助曲面几何来生成三角形或混合网格（包含四边形），也可以对已有曲面网格重新划分网格（ReMesh）。
5. Tetrahedron Mesher的2种用法：
   1. 借助封闭的曲面网格生成四面体网格，这里的封闭壳网格可以是使用Auto Mesher对几何划分得到的。

   2. 在Tetrahedron Mesher中对封闭曲面或实体（通过选择filter来完成）划分网格（选择Skin Geometry），然后利用该曲面网格来划分四面体，步骤：输入edge来进行尺寸控制，然后点击Tria Mesh（这步会生成曲面网格），然后点击TetMesh得到四面体网格。
6. Mesh→Element Generation可以根据实体单元网格抽取得到壳单元中面。
7. 可以先在几何中建立Curve，然后在Mesh→Element generation中生成梁单元。
8. 为了能够对生成的球体进行删除单元得到半球或1/4球等，需要将Shape Mesher的density设置为偶数。
9. 在划分完实体网格之后，应该使用Element Tool→Blank检查下实体内部的网格尺寸是否过小，避免稳定时间步长过短，这可以通过最小尺寸参数来控制。
10. 对于一个混凝土板中心受冲击的问题，可以在中心区域加密，例如使用如下网格形式：
11. <img src="LS-DYNA.assets/image-20250205000744403.png" alt="image-20250205000744403" style="zoom: 50%;" />
12. 可以使用Surf→FitSurf来根据曲面网格创建曲面几何，然后可以用AutoMesher对曲面重新划分网格。
13. 使用Element Generation中的offset工具，可以沿face的法线扩展生成单元，将圆柱面向外扩展，生成一个圆环体。
14. 使用Element Generation→Solid→Two Shell Sets，可以设置Bias，生成渐变尺寸的网格。
15. LS-DYNA提供自适应网格划分技术，用于处理大变形问题。不仅可以细化，也可以粗化，后者在回弹分析中会用到，能够节省时间。ALE也可以处理大变形问题，自适应网格划分是纯拉格朗日算法。步骤如下：
    1. 需要将`*PART`的ADPOPT参数设置为非零，这表明对该part启用何种remesh方法，具体分为：
       1. r-adaptive，
       2. h-adaptive，

    2. 然后在`*CONTROL_ADAPTIVE`中设置重划分的检测时间间隔ADPFREQ，检测方式ADPTYP（可以是角度，厚度，尺寸变化），检测限值ADPTOL。最大重划分级别MAXLVL。
    3. 使用`*CONTROL_REMESHING`和`*CONTROL_REFINE`控制参数。

16. 重划分时会出现非共形网格，就是一个单元的节点出现在另一个单元的边上，后者在该边上没有节点。
17. 对基于总拉格朗日（TL）公式的超弹性材料或材料模型进行重新网格化可能会导致数值不稳定或结果不准确。
18. 由于重新划分网格会导致节点编号错乱，导致边界条件引用失效，这可以使用`*CONSTRAINED_GLOBAL`来施加边界条件，这是根据空间位置来决定的，和网格无关。

# 截面和单元

1. `*SECTION_option`定义了单元公式、积分规则、节点厚度和横截面特性。
2. `*ELEMENT_XX`要使用对应的`*SECTION_XX`。
3. LS-DYNA的`*ELEMENT_option`只是负责构建单元拓扑，也就是形状。同样的solid可以使用各种不同的单元公式，而在Abaqus中，这是在单元层面就区分开的，而非在Section层面。这也是LS-DYNA单元数量较少的原因。
4. DYNA中也包含二次拉格朗日实体单元，该单元可以包含线性变化的应变场，可以自然地模拟弯曲，而且不需要任何沙漏控制或引入非协调模式，可以用于实体或板壳问题。具体包含27节点六面体单元（ELFORM=24），21节点五面体单元（ELFORM=25），15节点四面体单元（ELFORM=26），除了角点，边中点还包含面心和体心节点。还有分别对应的三次单元（ELFORM=27，28，29）。
5. 二次单元的定义方式：
   1. 直接使用`*ELEMENT_SOLID_H27`等来定义，显式输入所有节点编号。
   2. 对于已有模型，可以使用`*ELEMENT_SOLID_H8TOH27`等将一次单元的关键字转化为二次的。此关键字只需要输入8个节点编号即可。新生成的节点会根据原来的节点插值，如果新节点的所有邻居节点都属于某个NodeSet，则该节点也会加入到该NodeSet中。新节点的生成是在求解器内部生成的，不会反映到K文件中，更推荐下一种显式生成单元的方法。
   3. 使用Prepost提供的Element Generation功能，进行单元阶数的转化。例如Hex8→Hex20。Hex20是8个顶点+12个边中点，Hex27是在Hex20的基础上加上6个面心和1个体心。

6. `*SECTION_SHELL`一般就修改一下NIP（厚度方向积分点数量）和厚度T1（修改完，按回车键即可同步设置T2，T3，T4）。
7. 如果使用了完全积分的壳单元，例如公式16，则可以保持默认的厚度方向2个积分点即可，不用增加该值。
8. 在`*SECTION_SOLID`中ELFORM的S/R表示Selective Reduced（选择性缩减积分）。
9. Solid单元如果是受弯为主，则应使用ELFORM=2（完全积分），而非默认的单元公式，否则应该在厚度方向上划分4层。
10. 对于刚体的part，它的section具体使用哪种elform都无所谓，一般默认就好。
11. 高阶单元在计算低频动力问题可得到较高精度，但在高速碰撞，应力波传递分析等问题中，运算速率低且不实用。8节点六面体单元和DYNA曾经使用的20节点8积分点的单元相比，速度快且精度高。
12. 二阶单元使用`*ELEMENT_SOLID_H20`创建，可以通过Element Generation将8节点的实体单元转化为20节点的。
13. 实体和壳单元的section使用不同的关键字，`*SECTION_SOLID`和`*SECTION_SHELL`，但是他们的SID不能重复。单元公式ELFORM也在Section中设置，显式计算默认的单元公式就是一阶缩减积分，在隐式计算中才推荐使用完全积分。
14. 插值型积分公式的思路是使用多项式对被积函数插值，然后用得到0的多项式的积分代替被积函数的积分。具体分为2大类：
    1. Newton-Cotes积分，使用均匀间隔点，分为开（不包含边界点）和闭（包含边界点，更常见）两种形式。系数可以通过拉格朗日插值基函数来获得，只和分段数量n有关。1段闭为梯形公式，2段闭为Simpson公式。当n为偶数时，代数精度为n+1，否则为n。

    2. Gauss积分，使用非均匀间隔点，也分为开（更常见，不包含边界点）和闭（称为Lobatto积分）。开型具有2n+1阶代数精度（n为高斯点个数），闭型具有2n-3阶代数精度（左右边界也是高斯点）。
15. 在实践中，由于非常高阶的多项式往往会剧烈振荡（龙格现象），故不能通过提高阶数的方法来提高求积精度。可以考虑把积分区间划分成固定宽度的子区间，在每个小区间用低阶的牛顿-柯特斯或Gauss公式，最后再把每个小区间的近似结果加起来（定积分的可加性），这种方法称为复合求积法。
16. DYNA中壳单元厚度方向的积分规则可以是高斯积分或Lobatto积分，后者是包含左右边界点的高斯积分，牺牲一定的灵活性，但是确保考虑边界。Lobatto和Simpson类似，都会考虑边界，但是Simpson是均匀的，Lobatto是非均匀的（精度更高）。默认是2点的高斯积分（横坐标分别为$\pm1/\sqrt{3}$​​）。Lobatto规则对于2点积分特别不准确，因此最少3个积分点。
17. 高斯积分点位于单元内部，远离单元边界，避免了边界处形函数导数可能出现的奇异性或数值振荡。在高斯点处，形函数的导数更接近真实导数的平均值，减少了因单元形状畸变导致的误差放大。
18. `*CONTROL_SHELL`中的INTGRD指定了积分规则。
19. `*SECTION_SHELL`中包含剪切修正系数这个参数，用于缩放横向剪切应力。LS-DYNA中的壳公式（BCIZ和DK单元除外）基于一阶剪切变形理论，该理论产生恒定的横向剪切应变，违反了壳顶面和底面零应力的条件。剪切校正系数试图补偿这种误差。对于各向同性材料，建议值为5/6，即0.83333。此值对于夹层或层压壳是不正确的。因此，在一些本构模型中，即材料类型22、54和55中，层压/夹层壳理论现在是一种选择。
20. 可以修改`*SECTION_BEAM`的QR/IRID来提升梁截面的积分点数量。同时在`*DATABASE_EXTENT_BINARY`中修改BEAMIP的值，与之相同，来输出截面的细节。
21. 梁单元支持spot weld beam公式，要配合*MAT_SPOTWELD一起使用。
22. 0D单元包括线性弹簧和扭转弹簧。2种定义方式：
    1. 使用`*ELEMENT_DISCRETE`指定2个节点来定义单元，`*SECTION_DISCRETE`定义截面，这样定义的弹簧单元需要使用专用的材料`*MAT_SPRING_ELASTIC`，输入劲度系数k即可，比较推荐。

    2. 使用`*SECTION_BEAM`类型6的`*ELEMENT_BEAM`梁单元（也就是行为和弹簧一样的梁，Discrete beam/cable），如果要求弹簧的作用线不是节点N1到N2，即VID≠0，则建议使用这种。
23. 要在两个点之间设置弹簧和阻尼器的组合，不能通过为`*ELEMENT_DISCRETE`设置两种材料来完成，因为一个单元只能属于一个part，而一个part只能有一种材料。可以共用节点，创建2个单元。弹簧和阻尼器的Section是一样的，材料分别为`*MAT_SPRING_ELASTIC`和`*MAT_DAMPER_VISCOUS`。
24. 使用`*ELEMENT_DISCRETE`定义的弹簧单元是没有质量的，因为他没有体积和密度，但是由于它和相连单元共用节点，因此节点是有质量的，这也是必须的，否则加速度会无限大。
25. 可以使用`*ELEMENT_MASS`创建质量单元，该单元就一个节点，可以和其他单元共用该节点（这样它才会影响其他单元），直接输入质量即可，不需要密度和体积。
26. 索单元可以设置偏移量，若<0，则表示初始为松弛状态，否则为拉紧状态。
27. TShell就是厚壳，类似于Abaqus的连续体壳，单元形状和实体一样，但是公式是壳公式。具有明确的厚度方向，很多物理量在厚度方向和其他两个面内方向的处理方式不同。厚度方向有分层的概念，和薄壳相同的是，它的积分点也分为层内和厚度方向的。不同的是，厚壳允许按层设置不同的独立材料，形成复合层壳。节点数量和自由度和六面体单元相同，由于增加了厚度方向的自由度，因此可以计算厚度方向的正应力，这是薄壳做不到的，这是二者最大的区别，抛弃了薄壳单元的平面应力假设。另外薄壳因为包含转动自由度，在壳单元连接处以及与实体单元连接的协调性都需要考虑，厚壳单元则不用考虑这些问题。
28. 由于厚壳单元没有转动自由度，在与其他单元连接时不需要考虑对接面的节点分布和单元类型。可以使用`*CONTACT_TIED_NODES_TO_SURFACE`将厚壳和实体，薄壳表面或其他厚壳进行粘合。可以使用`*CONTACT_TIED_SHELL_EDGE_TO_SURFACE`将薄壳的边缘和厚壳的侧面进行粘合。
29. PrePost可以通过壳单元及其section定义来生成相对应的实体单元或厚壳单元。在Element Generation→Solid→Solid by shell thickness，需要的话可以勾选Create tshell element或勾选Delete shell。
30. PrePost可以进行关键字之间的转换，例如将实体网格转化为厚壳网格。在Keyword Manager中选中实体单元关键字，然后右键transfer to，选择TSHELL，选中想要转化的实体单元即可。注意，转化并不会删除旧的实体网格。
31. Cohesive单元可以使用实体单元的公式19或壳单元公式±29。材料推荐使用`*MAT_COHESIVE_MIXED_MODE`（138）或`*MAT_COHESIVE_GENERAL`（186）。
32. 在Model Check中，如果对于四面体网格使用的Section中ELFORM不是4，10或13，则会报error，建议改成10。
33. 多层复合材料可以将`*SECTION_SHELL`中的ICOMP开启（此时从壳单元外观看只有一层，不过聚合了多层的材料性质，每层材料均分壳单元的厚度），也可以使用`*PART_COMPOSITE`来指定每层的材料，厚度和方向（这里需要建立多层壳单元），然后记得将对应的壳单元move到通过`*PART_COMPOSITE`创建新part中。前者建模简单输入方便，后者控制更灵活。
34. 复合材料铺层的0度方向可以在Element Edit→Direction→Shell中查看。
35. 对于薄壳结构，可以不抽取中面，而是只使用其中一个表面，然后在`*SECTION_SHELL`中设置NLOC为1或-1。

# 沙漏

1. 为了提高计算效率，DYNA中大量使用单点积分（一阶缩减）单元，这可能导致沙漏问题（这也是该单元最大的缺点）。沙漏是一种高频零能伪变形模式，不理想的沙漏模式往往具有比结构响应周期短得多的周期，并且通常被观察到是振荡的。它在数学上是稳定的，但是在物理上是不真实的。此时单元没有刚度，结构虽然有变形，但是没有应变（因为仅在积分点处计算），因此不消耗能量。之所以称为沙漏，可以参见下图，两个相邻的四边形，在没有沙漏控制的情况下，变形会得到两个梯形，组合在一起看起来像沙漏，变形呈现锯齿状。

2. ![image-20250111212335778](LS-DYNA.assets/image-20250111212335778.png)

3. 沙漏控制就是通过消耗一部分能量去抵制这种不正常的变形模式，这个能量就称为沙漏能。采用完全积分单元可以完全避免沙漏问题，但是求解效率会降低，同时可能出现体积自锁问题。因此DYNA通过`*HOURGLASS`（Part级别）或`*CONTROL_HOURGLASS`（全局级别），增加单元的刚度或粘性，从而提高抗变形的能力。IHQ参数表示沙漏控制模式，高速变形推荐采用粘性控制模式，低速变形推荐采用刚度控制模式。沙漏刚度系数QH默认为0.1，一般取为0.05-0.12，如果太大会导致数值不稳定。
4. 对于壳和膜单元，QM被视为膜沙漏系数，弯曲为QB，翘曲为QW，这些系数可以单独指定，但一般来说，QM=QB=QW就足够了。
5. 计算结束后，应该检查Hourglass Energy，确保<Internal Energy的10%。通常使用`*DATABASE_GLSTAT`输出全局统计和能量，`*DATABASE_MATSUM`输出各个part的能量，它们会输出成同名的文件。

6. 还需要使用`*CONTROL_ENERGY`关键字开启计算沙漏能量，因为计算该能量的消耗不可忽略，所以默认没有开启。



# 材料模型

1. 材料模型的关键字可以是具体名称，也可以是编号，例如`*MAT_001`等于`*MAT_ELASTIC`。

2. 只有用于实体单元的材料才可能定义状态方程。

3. 使用多种基本实验拟合出材料模型后，应该在软件中对基本实验进行建模并计算， 检查对应的输出是否和实验一致。

4. 常用的材料模型：

   ```shell
   *MAT_ELASTIC #1号，各向同性，线性亚弹性，需要给出密度，弹性模量，泊松比。可用于梁，壳，实体单元。不适用有限应变，如果要模拟有限应变，应该使用MAT_002
   *MAT_PLASTIC_KINEMATIC #3号，各向同性，双线性强化，可以考虑率效应。性价比非常高，可用于梁，壳，实体单元。通过修改β参数来设置强化形式，β=0表示运动强化，β=1表示各向同性强化，如果β在二者之间，则为混合强化。
   ```

5. *MAT_PLASTIC_KINEMATIC材料模型可以使用Cowper Symonds应变率模型来考虑应变率效应，它根据$1+(\frac{\dot{\varepsilon}}{C})^{1/p}$来对屈服应力进行缩放。card2中的SRC和SRP分别为参数C和p，默认均为0，表示不考虑应变率效应的缩放。默认情况下VP=0，表示应变率效应会对屈服应力进行缩放，也可以设置VP=1，此时为完全粘塑性公式（它包含了VP=0的特性），它在屈服面内为黏弹性行为，而非纯弹性。

6. 对于`*MAT_PLASTIC_KINEMATIC`，如果β=1，此时推荐使用`*MAT_ISOTROPIC_ELASTIC_PLASTIC`，12号材料，它需要更少的存储，因为不用存储背应力，且更高效。不过对于壳单元，它的精度不够，还是推荐使用2号材料。

7. `*MAT_RIGID`可以在局部坐标系中约束刚体的自由度，需要设置CMO=-1，CON1设置为坐标系编号，CON2设置为xxxxxx的形式，x为0或1，0表示不约束，1表示约束对应自由度。

8. 一些关键字（例如*MAT_005）允许使用关键字自带的表格输入（一般是10个点，每个点一个横坐标，一个纵坐标），也允许通过引用用户定义的曲线来输入，后者的优先级高。

9. 分段线性MAT_024模型中，支持三种输入方式：曲线LCSS；数据点EPS，ES；屈服点和硬化模量。按照曲线>数据点>屈服参数的优先级采用。数据点的横坐标是EPS（有效塑性应变），纵坐标是ES（有效应力），对于单轴拉伸，有效应力就是单轴应力，有效塑性应变为单轴塑性应变，因为一般假设塑性变形是等体积的，即泊松比为0.5。

10. 可以从K文件中导入其中定义的材料，在Keyword→LoadMatDb，选择对应的K文件即可。不过需要选中mat关键字才可以使用LoadMatDb。

11. 可压碎泡沫（crushable foam）是指类似于聚氨酯泡沫的材料，受压缩时，它会碎裂，而非海绵一样的泡沫。在DYNA中，可压碎泡沫经常和混凝土，土壤共用相同的简单材料模型。

12. 在Load Cruve中，ordinate表示纵坐标，abscissa表示横坐标。

13. Unloading表示卸载，而非未加载。

14. 应变硬化（Strain Hardening）是指材料在塑性变形过程中，随着应变的增加，其屈服强度逐渐提高的现象。

15. Tensile cutoff是拉伸截止，也就是破坏时的最大主应力。

16. 状态方程是表征流体内压力，密度（体积），温度（内能）等三个热力学量的关系式，当材料内的应力超过屈服强度数倍以上时，材料在高压下的剪切效应可以忽略不计，固体也会呈现出流体性质，相应可以用热力学参数描述。

17. 很多材料模型都需要配合状态方程使用，因为材料模型仅处理偏应力和塑性变形相关的行为，而压力和体积应变的关系需要状态方程来处理。高速高压碰撞下的结构材料，流体，爆炸都必须用状态方程描述，也有些不是上述情况的材料，也会使用状态方程。

18. EOS不仅会定义材料的参数，还会对热力学状态E0（单位参考体积的初始内能），V0（初始相对体积）进行初始化。

19. 对于应变率敏感的材料，有的支持输入多条在不同应变率下的应力应变曲线。曲线使用`*DEFINE_CURVE`定义，多条曲线通过`*DEFINE_TABLE`组合起来，横坐标为曲线对应的应变率，纵坐标为曲线编号。DYNA使用的时候，会根据应变率和应变同时插值，得到应力。

20. 应变率敏感材料有两个点需要注意，不同应变率下会有不同的应力-等效塑性应变的曲线，不同应变率下会有不同的屈服应力。前者通过table定义，后者通过curve定义。这可以在`*MAT_PIECEWISE_LINEAR_PLASTICITY`中的LCSS和LCSR看到。

21. 损伤damage和失效fail是不一样的。

    1. 损伤模型中存在一个标量的损伤因子，0表示无损伤，1表示完全损伤，损伤一般会影响材料的弹性模量或其他力学性质，使得材料性能退化。

    2. 失效模型允许模型删除单元，失效可以是损伤因子达到阈值或者是单纯地满足某些准则，例如最大主应力/应变，有效塑性应变等。

22. 当发生单元失效而删除时，解一般会出现波动或震荡。

23. 水的密度并非是`1000kg/m^3`，20℃时，为`998.23kg/m^3`。

24. 对于水这样的纯流体，材料可以是`*MAT_NULL`，该材料模型允许在不计算偏应力的情况下考虑状态方程。如果是实体单元使用该材料，必须配合状态方程使用，和水配合的状态方程一般为`*EOS_GRUNEISEN`，`*EOS_MURNAGHAN`，`*EOS_MIE_GRUNEISEN`。

25. 鸟击中的鸟体，一般使用`*MAT_NULL`或`*MAT_ELASTIC_PLASTIC_HYDRO`。配合`*EOS_LINEAR_POLYNOMIAL`建模。

26. 含铝炸药的反应时间很长，难以准确标定JWL状态方程的参数，这给爆炸计算带来了困难。通常的做法是将其折算为等效TNT当量，然后采用TNT炸药的JWl状态方程参数进行计算。

27. 可以使用圆筒试验试验的数据来标定JWL状态方程的参数。它使用一个装满炸药的铜圆柱，然后引爆，记录膨胀情况。

28. ANFO的TNT当量系数是0.88，表示弱于TNT。C4（核心是RDX）是1.30，表示强于TNT。

29. 根据爆热进行折算是最常用的方法。DYNA手册中还给出了根据炸药的CJ爆速进行折算的方法，爆速越快，折算系数越大。DYNA推荐的TNT密度取值为1.57g/cm^3，爆速为6930m/s。

30. TNT的材料只能用`*MAT_HIGH_EXPLOSIVE_BURN`（8号），EOS一般为`*EOS_JWL`（2号）。

31. `*MAT_JOHNSON_COOK`中的流动应力公式是考虑了应变率的，如果不考虑应变率和温度效应，他就是幂律形式。

32. 钢材可以使用`*MAT_JOHNSON_COOK`（15号），配合`*EOS_GRUNEISEN`（4号）。

33. GFRP布可以使用`*MAT_ENHANCED_COMPOSITE_DAMAGE`（54号）材料来建模。

34. 壳单元使用`*MAT_JOHNSON_COOK`材料模型，不需要配合状态方程，实体单元使用时则需要。

35. 复杂材料模型还具备额外的历史变量，可以在`*DATABASE_EXTENT_BINARY`中设置NEIPH进行输出，例如`*MAT_072R3`（应为6）。可以在PrePost的Fringe component > Misc > history var#n中查看它们。每种材料的同编号历史变量的含义也不同。这记录在`https://www.dynasupport.com/howtos/material/history-variables`网页中。例如：

    ```shell
    *MAT_063 (Model=0)       eqp   volumetric strain ln(V) #eqp的位置被ln(V)替代
                               1   V-1                     #编号为1的history variable
    ```

36. DYNA中有些卡片是需要输入单位信息的，这是因为该公式是通过实验数据拟合得到的，有些系数是带量纲的，因此必须指明全局单位是啥，才可以转换过去，来使用公式：

    1. 例如CSCM159的UNITS参数，用于指明全局基本单位。
    2. 例如`*LOAD_BLAST_ENHANCED`中，爆炸压力的实验数据拟合得到的公式更是基于一个根本不协调的单位系统`lbm-foot-ms-psi`（因为psi是Pounds per square inch，而非foot）。在UNIT参数中指定全局单位，也可以不使用系统提供的，自己来逐个给定全局基本单位和关键字内部公式使用的基本单位的转化关系。

37. LS-DYNA中的材料模型具有特定于所使用的本构模型的历史变量。对于大多数材料，6个用于柯西应力分量，1个用于有效塑性应变，但许多模型的值不止于此。历史变量可能包括材料损伤、材料相组成、应变能密度和应变率等物理量，以及材料方向余弦和比例因子等非物理量。

38. 通过在`*DATABASE_EXTENT_BINARY`中使用NEIPS、NEIPB和NEIPH，这些额外的历史变量可以按照存储顺序导出到d3plot，然后在PrePost中可以变量的曲线或云图。这种方法有一些缺点。例如必须知道给定材料模型和单元类型的某个历史变量的存储位置。虽然这些信息可以在DYNA手册、DYNA支持站点或PrePost本身中检索到，但并不总是很方便。

39. `*DATABASE_EXTENT_BINARY_COMP`中的7个参数可以控制d3plot输出的内容，该关键字中默认都是不输出，如果包含该关键字，此时d3plot的Fringe中只包含Ndv，实际上是没有数据的，绘制不出来。这个一般很少用。

40. `*DATABASE_EXTENT_BINARY`中的STRFLG推荐设置为111，这样可以输出应变/塑性应变/热应变张量，默认不输出。IEVERP用于设置是否要一帧输出一个文件。

41. d3plot中输出的应变张量是通过对变形率张量D进行时间积分得到的。为了处理客观性，对于实体单元，使用Jaumann应变率，用到了旋率张量W（D和W分别为速度梯度张量的对称和反对称部分）。对于壳单元，使用共旋应变率，用到了共旋坐标系Q转动速度$\Omega=\dot{Q}Q^T$。
    $$
    \dot{\varepsilon}=D-\varepsilon W+W\varepsilon \\
    \dot{\varepsilon}=D-\varepsilon \Omega+\Omega\varepsilon
    $$

42. 也就是说，对于杨氏模量为1、泊松比为0的亚弹性材料（`MAT_ELASTIC`），产生的应变将等于柯西应力。在解释结果时应该记住这一点，因为它们对单元公式的变化和可能的节点连接性不是不变的。

43. 此外，对于不同的材料和不同的单元类型，相同的物理量可能存储在不同的位置，这意味着历史变量#1将对应于不同部分的不同事物，这使大型模型的后处理变得复杂。可能还对不一定存储为历史变量的特定材料数量感兴趣；使用这种方法无法检索此数量。最后，如果感兴趣的历史变量恰好存储在一个错误的位置，即在长列表中的最后一个变量中，则有必要将NEIPS、NEIPB或NEIPH设置得足够大，以便在LS PrePost中访问该变量。这可能会导致不必要的二进制绘图文件过大。

44. 对于无法代表局部应变梯度的较粗网格，需要调整破坏应变。



# 混凝土材料

1. 16、72、96和84号材料支持整体式建模来模拟钢筋混凝土，它将钢筋混凝土当成一种复合材料，不用显式建模钢筋，只需要指定钢筋的间距和面积等信息即可。也可以进行分离式建模，此时使用梁单元对钢筋进行显式建模。

2. 混凝土在DYNA中的材料模型。

   1. MAT_072R3（KCC），第3个版本，有三个剪切破坏面，可设置DIF，需要状态方程配合。可以针对不同围压考虑。9个参数。

   2. MAT_084（Winfrith Concrete Model），输入简单，直接输入单轴抗压/抗拉强度即可，可以在d3crack文件中输出裂缝图。该模型没有内置单元失效功能，可以使用`*MAT_ADD_EROSION`来附加（PrePost 4.11版本中输入完成后accept，会导致不显示，不过仍然会保存到K文件中，这是一个显示bug，重启下PrePost就好了）。

   3. MAT_159（Continuous Surface Cap Model，CSCM），可考虑实验数据，材料表现稳定，可设置DIF，可以考虑侵蚀失效，参数建议设置为1.05-1.10。14个参数。

   4. MAT_272（RHT），脆性材料，可以考虑高应变率，可设置DIF，不是很完善。

3. Winfrith模型的裂缝图输出设置方法：添加`*DATABASE_BINARY_D3CRACK`关键字，并在求解器命令中添加`q=`选项，值可以是d3crack或crack，对于LS-RUN，文件名默认为crack。如果没有`q=`选项，则不会输出该文件。

4. 在PrePost→Open→Others→Crack File中打开d3crack文件。裂缝数据要比单元失效更具直观性。裂缝表现为通过单元形心的平面（实际由一个法向量就可以存储一个裂缝面），每个单元中最多可以形成三个相互垂直的裂纹。默认显示所有裂缝，可以在Settings → Post Settings → Concrete Crack Width中设置显示的最小宽度。可以在Misc → Model Info中查看开裂单元数量和最大裂缝宽度。

5. 除了MAT_084（Winfrith Concrete Model）以外，另外3个模型都可以根据简单的数据自动生成所有参数。

6. 最常用的K&C Concrete模型，是由Karagozian&Case开发的，它是一家国际公认的科学和工程咨询公司，1945年成立，不过也是该公司两个创始人的姓名。

7. KCC模型需要输入如下数据：

   1. MAT_072R3关键字。

   2. DEFINE_CURVE，在LCRATE中引用其ID，应变率的规则是受压为正。纵坐标要求是剪力增强因子而非DIF，前者是针对剪力，后者是针对主应力，因为实验数据一般是没有围压的，此时，剪力就是主应力的一般，可以将二个增强因子看成一样。<img src="LS-DYNA.assets/image-20250126183142959.png" alt="image-20250126183142959" style="zoom: 50%;" />

   3. MAT_ADD_EROSION关键字。用于为本身不包含失效行为的材料添加失效行为。MID参数就是基本材料的ID，支持多种变量来设置失效限值。

   4. EOS_TABULATED_COMPACTION，横轴为体积应变率，纵轴为压力。

8. KCC模型可以进行简化输入（可以参考手册最后的例子），DYNA会在求解前自动计算出其余的数据，并保存在d3hsp和message（这里的内容会以keyword的形式保存）中。简化输入模式下，是可以配合应变率效应曲线（简化输入模型中，默认为0，也就是不考虑应变率效应）一起使用的。此时NOUT参数默认为2，即在等效塑性应变的位置输出缩放的损伤度量δ。使用简化输入时，也可以不提供状态方程，让其自动生成，使用的是`*EOS_TABULATED_COMPACTION`。

9. 可以只建立part，mat，section，就提交给求解器，让DYNA对材料进行展开，一般出现在d3hsp的最后或message的开头。

   ```
   -------------------------------------------------------------
             Updated Release III K&C concrete model
             by K&C/Javier Malvar (9/99 updated 4/12)
             based on LRDA/K&C f3dm16w.f (8/7/95)
                LS-DYNA Release III of Mat072 by 
             Len Schwer (May 04) & Y.Wu (April, 12)
   -------------------------------------------------------------
    pressure phi     0.00000E+00    5.00000E-01
    pressure phi     1.06667E-02    5.65625E-01
    pressure phi     2.45333E-02    6.37453E-01
    pressure phi     9.60000E-02    7.53000E-01
    pressure phi     2.70400E-01    1.00000E+00
    f c  fyc    ft    =    3.20000E-02    1.43533E-02    1.40000E-03
    Ec          =    2.67772E+01
   $--------------------------- MATERIAL CARDS -----------------------------------
   $ LS-DYNA Keyword Generated Input for Release III
   $    [Default values = K&C generic f'c=6580 psi concrete]
   *MAT_Concrete_Damage_Rel3
   $    MATID        RO        PR
           72 2.800E-06 2.000E-01
   $       ft        A0        A1        A2        B1     OMEGA       A1F
    1.400E-03 9.459E-03 4.463E-01 2.525E+00 1.600E+00 5.000E-01 4.417E-01
   $ sLambda      NOUT     EDROP     RSIZE       UCF    LCRate  LocWidth      NPTS
   1.000E+02 2.000E+00 1.000E+00 3.937E-02 1.450E+05 0.000E+00 5.000E+01 1.300E+01
   $Lambda01  Lambda02  Lambda03  Lambda04  Lambda05  Lambda06  Lambda07  Lambda08
   0.000E+00 8.000E-06 2.400E-05 4.000E-05 5.600E-05 7.200E-05 8.800E-05 3.200E-04
   $Lambda09  Lambda10  Lambda11  Lambda12  Lambda13        B3       A0Y       A1Y
   5.200E-04 5.700E-04 1.000E+00 1.000E+01 1.000E+10 1.150E+00 7.142E-03 6.250E-01
   $   Eta01     Eta02     Eta03     Eta04     Eta05     Eta06     Eta07     Eta08
   0.000E+00 8.500E-01 9.700E-01 9.900E-01 1.000E+00 9.900E-01 9.700E-01 5.000E-01
   $   Eta09     Eta10     Eta11    Eta012     Eta13        B2       A2F       A2Y
   1.000E-01 0.000E+00 0.000E+00 0.000E+00 0.000E+00 1.350E+00 3.697E+00 8.047E+00
   $---------------------------  EOS-8 CARDS  ------------------------------------
   $ Generated EOS 8 (Tabulated Compaction)
   *EOS_Tabulated_Compaction
   $    EOSID     Gamma        E0      Vol0
           72 0.000E+00 0.000E+00 1.000E+00
   $   VolStrain01     VolStrain02     VolStrain03     VolStrain04     VolStrain05
    0.00000000E+00 -1.50000000E-03 -4.30000000E-03 -1.01000000E-02 -3.05000000E-02
   $   VolStrain06     VolStrain07     VolStrain08     VolStrain09     VolStrain10
   -5.13000000E-02 -7.26000000E-02 -9.43000000E-02 -1.74000000E-01 -2.08000000E-01
   $    Pressure01      Pressure02      Pressure03      Pressure04      Pressure05
    0.00000000E+00  2.23143683E-02  4.86453230E-02  7.81002892E-02  1.48390549E-01
   $    Pressure06      Pressure07      Pressure08      Pressure09      Pressure10
    2.23813114E-01  3.17533462E-01  4.85783799E-01  2.83615622E+00  4.33791321E+00
   $            Multipliers of Gamma*E 
     .000000000E+00  .000000000E+00  .000000000E+00
     .000000000E+00  .000000000E+00  .000000000E+00
   $    BulkUnld01      BulkUnld02      BulkUnld03      BulkUnld04      BulkUnld05
    1.48762456E+01  1.48762456E+01  1.50845130E+01  1.58432015E+01  1.88482031E+01
   $    BulkUnld06      BulkUnld07      BulkUnld08      BulkUnld09      BulkUnld10
    2.18680810E+01  2.48730826E+01  2.71491481E+01  6.10818643E+01  7.43812278E+01
   $------------------------------------------------------------------------------
   ```

# 钢筋混凝土建模

1. 钢筋和混凝土需要耦合，具体方法有：
   1. 通过`*CONSTRAINED_LAGRANGE_IN_SOLID (CTYPE=2)`设置二者的ALE耦合，此方法不要求梁节点与实体单元节点匹配，但是要注意钢筋对混凝土的约束可能会与对称边界条件等其他约束冲突并破坏这些约束。
2. 钢筋和混凝土的耦合可以使用：
   1. 将梁节点合并到混凝土实体单元中（共节点方法，不过需要网格匹配，属于最强的约束）。

   2. 使用1-D接触（这可以处理粘结滑移）连接到混凝土单元。
   3. `*CONSTRAINED_BEAM_IN_SOLID`，将混凝土的能量全部传递给钢筋，没有能量损耗，梁截面的ELFORM需要为1或11。混凝土为master，钢筋为slave。推荐使用这个，因为它是专门为这种耦合设计的，下面的那个是为ALE设计的。

   4. `*CONSTRAINED_LAGRANGE_IN_SOLID (CTYPE=2)`，将钢筋节点和混凝土节点用弹簧连接，针对握裹力设定弹簧的刚度PFAC，通常为0.1。

   5. *ALE_COUPLING_NODAL_CONSTRAINT，类似于上面的。

3. 有了上面的耦合，就可以不用定义接触了。

4. 喷涂的聚脲涂层和混凝土的粘结关系，可以用TIEBREAK，正应力或切应力达到某个值就会发生撕裂分离，变成普通的接触。
5. 钢骨混凝土的建模比较特殊，由于钢材占比较高，不能使用重叠的网格，可以将实心混凝土中的部分单元转化为钢骨（Move即可）。然后将二者Detach，然后设置contact（可以使用tie），这里建议使用较高的摩擦系数，例如0.9。由于二者的网格没有重叠，因此不能使用`*CONSTRAINED_LAGRANGE_IN_SOLID`进行耦合。


# 接触

1. DYNA具有60多种`*CONTACT`接触类型，例如变形体对变形体，变形体对刚体，刚体对刚体，边边接触，侵蚀接触，拉延筋接触等。`*DEFINE`也可以定义接触，例如`*DEFINE_SPH_TO_SPH_COUPLING`定义SPH part间的接触，`*DEFINE_DE_TO_SURFACE_COUPLING`定义离散元颗粒与有限元结构的接触。
2. 所有*CONTACT关键字的前3个card都是一样的，第四个取决于具体类型，这四个都是必选的。
3. DYNA中的摩擦基于库仑公式，用户可以自定义接触中的摩擦模型，将摩擦系数（静态和动态）以及接触传热传导系数定义为接触压力、相对滑动速度、分离距离和温度的函数。还可以定义接触的生效birth time和失效时间death time，使用该功能可以定义螺栓拉紧，然后tie，再放松的过程。接触的生死还可以定义成一个表格，来完成多次间断的生死。
4. 用户可以提供此子程序来控制interface（即接触的生死）的开和关。此选项由*USER_INTERFACE_CONTROL关键字激活。
5. 尽量不要定义重复的接触，可能会导致数值不稳定。
6. 即使给定的是segment set，也可能使用构成segment的node来参与接触，具体取决于接触的类型。
7. slave节点在冲击后被约束在master面上滑动，并且必须保持在master表面，直到节点和面之间产生张力。
8. 一般常用`*CONTACT_AUTOMATIC_SURFACE_TO_SURFACE`指定接触对，可以输出接触力。
9. 接触的公式主要分为两种，默认是Penalty based，除非显示指定Constrained based。
   1. 基于惩罚（Penalty based）的接触在穿透的节点/段和接触面之间放置了法向界面弹簧。这些弹簧施加接触力以减少穿透。

   2. 基于约束（Constrained based）的接触中，穿透接触面的节点被强制拉回到该表面，并且通常受到运动学约束的控制，也称为拉格朗日乘子法。只有`CONSTRAINT_NODES_TO_SURFACE`和`CONSTRAINT_SURFACE_TO_SURFACE`两个。出现在基于约束的接触中的surface和node不能再被基于约束的接触所使用，即不能多次约束。

10. 可选card A的SOFT参数可以改变接触算法的公式。SOFT最常用的值，即0、1和2，指定了调用的惩罚算法的类型。目前，惩罚算法有三种实现方式：
   11. 标准Penalty公式，界面刚度被选择为与垂直于界面的单元的刚度大致相同的数量级。因此计算出的时间步长不受界面存在的影响。然而，如果界面压力变大，可能会发生不可接受的穿透。通过扩大刚度和缩小时间步长，仍然可以使用惩罚方法来解决。由于这增加了分析步的数量，从而增加了成本，因此采用了仅滑动的方法来处理爆炸结构相互作用问题，从而避免了使用惩罚方法。
   12. Soft Constraint Penalty公式，用于处理具有不同材料特性（如钢泡沫）的物体之间的接触。刚度计算及其在模拟过程中的更新与标准Penalty公式不同。
   13. 基于分段的Penalty公式，它是一种强大的接触算法，其逻辑是slave segment-master segment方法，而不是传统的slave node-master segment方法。事实证明，这种接触对于充气和复杂接触条件下的安全气囊自接触非常有用。

14. 以前，跟踪的表面被称为slave表面，参考表面被称为master表面。DYNA在R14.0中将slave-master改为了SURFA-SURFB。PrePost中始终按照名称中的顺序来指定，例如Node to Surface接触，这就表示Slave使用Node形式给出，而Master使用Surface形式给出。
15. 一共分为7类：单向（one-way）、双向（two-way）、单面（single surface）、捆绑（tie）、砂浆（motar）、约束（constrained）和仅滑动（slide only）。
16. 单向接触是非对称的。仅在一个方向上检查穿透，SURFA的节点（或段）不能穿透SURFB的段（或者说穿透时会产生抵抗力），但SURFB节点和段可以穿透SURFA。因此如何确定谁是SURFA和SURFB，对于这种类型的接触至关重要。一般来说SURFA的网格密度应该更细。只有关键字中包含ONE_WAY的才是单向，否则都是双向。
17. 双向接触类似于单向接触，只不过它是对称的。DYNA通过运行两次单向接触算法来检查两个表面是否互相穿透。因此，SURFA和SURFB的定义是任意的，可以交换。使用这种类型的接触的成本大约是单向接触的两倍。对于SINGLE SURFACE接触，只输入SURFA，并在自接触界面的两侧检查穿透情况，其算法基于SURFACE_TO_SURFACE。
18. AUTOMATIC接触是双面（two-sided）的，也就是Segment的两侧都会探测接触，抵抗穿透。这种类型的算法在处理不相交网格方面优于非自动接触算法。因此Segment的法向对于AUTOMATIC接触并不重要，但对于非AUTOMATIC接触至关重要。自动接触是双面的，因为算法会检测壳单元任意一侧的穿透，因此，AUTOMATIC接触适用于碰撞分析。只有关键字中包含AUTOMATIC才是双面探测接触，否则都是单面探测。
19. 为了检测两侧的穿透，AUTOMATIC接触通过将接触界面从壳中面和梁中线偏移来考虑壳体厚度和梁厚度。将壳中面厚度的一半的接触厚度（可以理解为距离小于这个值而非默认的0就会产生接触力）。它们还包括壳体表面外边缘（交界线）上的接触表面，其半径为接触厚度的一半，因此壳表面具有连续的接触表面。对于梁单元，接触面与梁单元的中心线偏移为梁横截面的等效半径。由于接触面的存在，在零件之间建模时保留适当的间隙对于与梁和壳零件的AUTOMATIC接触至关重要。
20. single surface，constraint-based，automatic surface-to-surface，和automatic nodes-to-surface始终会考虑接触时壳单元的厚度。也就是shell thickness offsets，这个由`*CONTROL_CONTACT`的SHLTHK参数控制。offset是指，从壳单元的参考面进行偏移来考虑接触，而非直接使用其参考面来计算接触。因为实际定义contact中给定的是surface，它可以是壳单元或实体单元的face都可以。
21. GFRP包裹混凝土柱分析中，二者的相互作用使用`*CONTACT_TIED_NODES_TO_SURFACE_OFFSET`。Node为混凝土的外表面节点，surface为GFRP的内表面segment。不过这种情况下，GFRP只会和混凝土的外表面相互作用，如果混凝土外表面发生失效，则会失真。之所以使用offset，是因为建模的时候，二者是分离的，间距为GFRP层的一半厚度。如果不用offset，则会进行投影操作。
22. 所有AUTOMATIC接触和使用Segment based（即SOFT=2）公式的接触都包括Edge to Edge接触功能。
23. 名称中带有ERODING的接触适用于接触界面上单元发生失效并被删除的情况。这种接触允许因单元删除而更新接触面，内部的单元面也变得可以探测接触。
24. 名称中带有NODES_TO_SURFACE的接触是一定单向（one-way）或tie接触。SURFA可以用这些接触的节点集合来定义，接触只是node to segment（基于segment和砂浆接触都不可用）。因此不会出现ONE_WAY_NODE_TO_SURFACE这样的接触类型。
25. 名称中包含SURFACE_TO_SURFACE的接触可以使用segment集合和shell集合定义SURFA，但不能用节点集合表示。请注意，能够以segment形式输入并不意味着接触公式一定是基于segment的。除非接触公式是基于segment的（SOFT=2）或接触类型包括砂浆，否则该公式着眼于节点穿透段，而不是段穿透段。
26. 使用`*CONTACT_AUTOMATIC_SINGLE_SURFACE`设定接触时，可以点击名称右侧的小按钮来选择已有的segment set ，shell element set ，part set，part，node set 等，如果没有，则会提示创建，选择NewEntity即可。由于是SINGLE SURFACE，只需要选择一个面即可，它既是master，又是slave。
27. 与NODES_TO_SURFACE接触相比，SURFACE_TO_SURFACE接触具有特殊的高级功能，部分原因是它们的定义方式。例如，SURFACE_TO_SURFACE接触支持热传递，而NODES_TO_SURPACE接触通常不支持。
28. Part较多时，可以创建一个包含所有可能接触的part的set，然后使用`*CONTACT_AUTOMATIC_SINGLE_SURFACE`接触。缺点是无法输出接触力，可以使用力传感器`*CONTACT_FORCE_TRANSDUCER_option`来输出这种接触的接触力。
29. 对于复杂模型，可以先用`*CONTACT_AUTOMATIC_SINGLE_SURFACE`，试跑一段时间，检查其他keyword，如果没有问题，可以修改为特定的接触类型。
30. 对于可能发生溃缩的结构，需要使用SINGLE SURFACE考虑自接触。
31. 建议使用Node或Segment集合而不是零件或零件集合指定Tie，因为它们可以让您更好地控制Tie的内容。通过这种方式识别表面可以防止意外Tie。
32. 只有当surface彼此靠近时，Tie才有效。用于确定slave节点是否被tie的标准是它必须足够近。对于壳单元，距离只要小于δ，就会被Tie，否则会打印一条warning消息：
    1. δ=max(δ1，δ2)
    2. δ1=0.6*（slave节点的厚度+master segment的厚度）
    3. δ2=0.05*min(master segment的对角线)

33. 对于实体单元，节点厚度为0，segment厚度为单元体积除以segment面积。
34. 如果两侧的网格尺寸差距过大，可能造成δ过大，造成过多的节点被Tie。在自适应网格划分时可能出现这种情况。为了避免这种困难，可以在card3上将SAST和SBST指定为负值，此时δ=abs(δ1)。
35. 可选card4控制tie的行为。
36. 对于Tie接触，SURFA的节点被绑定到SURFB的Segment上，因此被约束为随SURFB的Segment运动。
37. 要进行solid to solid的tie（即所有节点都没有旋转自由度），应使用`TIED_NODES_TO_SURFACE`和`TIED_SURFACE_TO_SURFACE`。要进行shells-to-shells and beams-to-shells的tie，应使用`TIED_SHELL_EDGE_TO_SURFACE`。要将壳边缘绑定到实体或将梁端绑定到实体，应使用`TIED_SHELL_EDGE_TO_SOLID`。
38. 基于约束的tie，无法和刚体配合使用，只能使用基于罚刚度的。
39. LS-DYNA中会将tie作为接触的一种，因为它的一个特化，tiebreak允许tie失效，而变成可以分离和滑动的普通接触。
40. PrePost中可以检查tie的效果或初始穿透，菜单栏→Application→Model Checking→General Checking。
41. tie约束，默认会将slave点拉到master面上，接触面上的单元会变形，除非包含关键字中包含offset选项。
42. Segment就是单元的face。选择的时候不分正反面，但是存在法向（通过Element Tools→Normal查看），相邻单元共享的face被认为是一个Segment。
43. 摩擦行为通过设置FS（静摩擦系数），FD（动摩擦系数），DC（衰减指数）。显式分析中使用的等效摩擦系数为：$\mu_c=FD+(FS-FD)e^{-DC|v_{rel}|}$，和相对速度有关。如果定义了动摩擦因数，则必须要定义衰减系数，否则它不会起作用，一般设置为0.3即可。
44. 罚接触公式中，罚刚度会根据单元尺寸和材料性质来计算：
   45. 对于壳来说，$k_1=SLSFAC*sf*K*A/d$。其中SLSFAC是全局缩放因子，sf是局部缩放因子，K是体积模量，A是单元面积，d是厚度或最短对角线。
   46. 对于实体来说，$k_1=SLSFAC*sf*K*A^2/V$​。其中A是segment面积，V是单元体积。
   47. 可以在`*control_contact`中设置全局SLSFAC，默认为0.1。
48. 对于罚接触来说，如果接触的两个面的材料相似，计算效率就比较高，如果一个很硬，一个很软，则容易失效，此时可以缩小card3中的slave面的局部缩放因子（例如为0.1），降低slave侧的冲击，减少过大的穿透。
49. bsort参数可以指定使用桶（bucket）排序搜索接触配对的频率，每隔bsort个增量才会搜索一次，对于single surface，该值为25或100。surface to surface或node to surface，为10~15。如果为0，则由DYNA自己决定，可以在d3hsp中找到，为`number of time steps between contact searching`。如果发现穿透较多，可以降低这个参数的值，来提高搜索频率。
50. DYNA还具有SLIDING_ONLY的接触，也就是不允许法向分离，但是允许切向滑动。有助于处理高爆炸物的气态爆轰产物作用于固体的界面，仅适用于显式求解器。
51. mortar contact是DYNA中专门为隐式分析使用的接触公式，它是segment to segment，基于罚函数的。发生edge to surface的接触时，也推荐使用mortar版本。
52. 使用隐式求解器，模拟薄壁方管溃缩问题时，接触关键字推荐使用MORTAR相关，建议打开可选卡ABC，设置THKOPT=1，SHLTHK=2，IGAP=2。
53. 对于一些高压缩性的泡沫，其材料曲线需要包含致密段（即使试验未做到这一步），否则可能由于过度软化，造成负体积。也建议设置`*CONTACT_INTERIOR`和`*HOURGLASS`，高速冲击建议IHQ=3，低速冲击建议IHQ=6。设置错误的话，可能会出现波浪状的沙漏状态。
54. `*CONTACT_INTERIOR`会对part set的内部面进行接触判定，防止出现反转或负体积，定义part set的时候可以设置其DA2和DA4，这些属性会被`*CONTACT_INTERIOR`使用，详见手册。
55. 注意`*MAT_CRUSHABLE_FOAM`不具有失效行为，因此即使发生极端变形，也不会删除，这也是造成负体积的原因，可以附加`*MAT_ADD_EROSION`属性。
56. 如果使用`*MAT_ADD_EROSION`引入材料的失效，建议将`*CONTROL_CONTACT`的ENMASS设置为1，这样即使单元因为失效被删除了，节点质量还在，能够保持计算的稳定。这样可以让因失效而删除的单元的失效节点在接触算法中保持活动状态。 
57. 有时，表面参与接触的单元可能会由于失效而被删除，此时由于内部单元的表面没有被定义接触，因此会直接产生穿透，此时使用By Part来选择所有的segment，来作为参与接触的Surface。例如小球冲击泡沫材料，泡沫材料的表面很容易就失效了。
58. 对于切削模拟，contact中，如果工件是以part或part set指定的，则他的表面被破坏后，内部并不会和刀头产生接触，因此应该使用segment set，然后使用by part选择，这样该part的所有单元的face都会和刀头产生接触。
59. 对于喷涂聚脲的材料，有时因为表面的混凝土单元失效，而导致该部分聚脲剥离，这是正常现象。即使不使用tiebreak，也可以发现这种情况。
60. 安全气囊织物接触厚度设置应至少为实际织物厚度的10倍，有助于改善接触行为并消除机器不一致。由于安全气囊和相互作用材料（人体或方向盘）之间的刚度差异很大，建议使用软约束选项（soft=1）或基于分段的选项（soft=2）。
61. 对于重物冲击混凝土板，需要设定重物和钢筋的接触，由于钢筋是用beam建模的，因此适用Node to Surface。
62. 在d3hsp中会将接触类型使用符号标记，例如a 3表示`AUTOMATIC_SURFACE_TO_SURFACE`，这个可以在手册的`Mapping of *CONTACT keyword option to “contact type” in d3hsp:`部分找到。
63. 过盈配合使用带`INTERFERENCE`的接触，使用动态松弛的方法进行。也可以用于施加螺栓预紧操作。重点定义隐式和显式接触刚度缩放曲线LCID1和2。


# 初始和边界条件

1. 对于跌落问题，如果非要从高处开始分析，可以设置`*DEFORMABLE_TO_RIGID_AUTOMATIC`，将变形体设置为刚体，这样计算速度会加快很多。然后在将要发生碰撞时转化为变形体。这个关键字可以使得part在刚形体和变形体之间双向转换。
2. DYNA的焊接可以处理点焊，对焊，角焊。原理类似于CNRB的刚体约束。
3. Constrained Joint可以构建球铰，销钉等连接单元。
4. 可以在Create Entity中创建CNRB（Constrained Nodal Rigid Body），它是由节点构成的刚体域。
5. 不建议使用CNRB来将两个区域tie起来，因为它还会将界面约束为刚体。
6. `*CONSTRAINED_RIGID_BODIES`可以将两个刚体连接起来，刚体需要是由`*MAT_RIGID`构成的，但是不能是CNRB。
7. `*BOUNDARY_SPC`约束自由度为0，`*BOUNDARY_PRESCRIBED_MOTION`指定自由度为按照特定曲线变化，`*INITIAL_VELOCITY_GENERATION`指定初始条件。
8. 如果同时约束又赋予初始速度，则物体不会运动。
9. 推荐使用`INITIAL_VELOCITY_GENERATION`而非`INITIAL_VELOCITY`，因为后者只能给nodeset施加速度，这样如果重新划分网格，则会失效，前者可以给part或part set施加。
10. 这些初始/边界条件可以对单个节点或节点集合设置，推荐使用CreateEntity来施加。
11. `*RIGIDWALL_option`是专门用来创建刚性墙的关键字。这样可以简化其他部分和刚性墙的接触定义，其输出也可以方便的在`*DATABASE_RWFORC`中设置。可以创建移动的刚性墙，不过只能设置初始条件，如果设置其质量非常大，则可以认为速度不变，相当于固定速度的边界条件，而不仅是初始条件。默认的尺寸是无限大的。可移动的刚性墙，只能沿着法向平移，另外5个自由度都自动被约束。
12. 转动初始条件也使用`*INITIAL_VELOCITY_GENERATION`，OMEGA参数就是转动角速度。角度使用弧度单位。只需要定义转动中心坐标和转动轴的向量即可。
13. `*CONSTRAINED_GLOBAL`用于定义全局边界约束平面。该关键字实现了平凡约束方程，即被约束的自由度在时间上恒为0。需要指定该平面上一个点的坐标和法向用于定位该平面。网格中容差内的节点都会选中，然后约束在全局平面上无法运动。之所以会存在这种关键字，是因为重新网格划分时会改变节点编号，进而丢失节点约束。它可以和r方法自适应重新网格划分一起使用。如果要指定位于局部平面上的节点的约束，可以使用`*CONSTRAINED_LOCAL`。



# 加载

1. `*LOAD_NODE`和`*LOAD_BODY_option`指定集中力和体积荷载。体积载荷是以加速度的形式给出，默认全局赋予，除非使用`*LOAD_BODY_PARTS`指定要施加的part set，每个K文件中只允许有一个`*LOAD_BODY_PARTS`，如果要对2个part指定不同的体积载荷应使用`*LOAD_BODY_GENERALIZED`替代。`*LOAD_BODY_Z`的加速度以-Z方向为正，因为会替换成惯性力。如果要施加-Z方向的重力，则该关键字的curve取值应该为正数。`*LOAD_GRAVITY_PART`用于模拟分阶段施工，可以方便地施加或删除重力。
1. `*LOAD_BODY_GENERALIZED`相比`*LOAD_BODY_RZ`提升在于，前者除了支持离心力外，还支持科氏力和角加速度产生的欧拉力。
1. `*DEFINE_FUNCTION`，`*DEFINE_CURVE_FUNCTION`，`*DEFINE_FUNCTION_TABULATED`这三个关键采用一种类似于C语言的脚本语言，不用编译，可以自由灵活其定义各类载荷，例如引用计算时间，集合坐标，速度，温度，时间和压力作为自变量。
1. 使用`*LOAD_NODE_SET`施加集中荷载，可以使用函数来计算荷载的值，该函数接受8个参数：

   ```shell
   f(t,x,y,z,x0,y0,z0,nnodes)= -10.*sqrt ( (x-x0)*(x-x0)+(y-y0)*(y-y0)+(z-z0)*(z-z0) )
   #x,y,z为要计算集中力的节点的当前坐标
   #x0,y0,z0为要计算集中力的节点的初始坐标
   #nnodes为node set中的节点个数
   ```

1. 集中力矩只能应用于具有旋转自由度的节点。单元类型和公式决定了节点的自由度。例如实体公式1的节点只有3个平移自由度，没有旋转自由度。

1. 集中力和力矩可以设置转动跟随DOF=4或8，此时力或力矩的方向需要通过三个节点确定的平面（根据`*DEFINE_PLANE`的方式）来定义。M1，M2，M3的当前位置用于控制随动力的方向。正随动力垂直于由这些节点定义的平面，正随动力矩产生围绕W轴的逆时针扭矩（右手法则）。定义力方向的另一种方法是将M3设置为任何非正值，此时随动力在M1到M2方向上。

1. 如果`*LOAD_NODE_SET`对节点集合施加荷载，则该值为合力，会在每个节点上均分。
1. Conwep只能用在非接触爆炸，也就是距离较远的情况。ALE对于接触和非接触爆炸都可以。
1. 使用`*LOAD_BLAST_ENHANCED`来设置TNT炸药（当量，位置，起爆时间），还需要使用`*LOAD_BLAST_SEGMENT_SET`，设置哪些Segment会受到哪个爆炸的作用。可以使用`*DATABASE_BINARY_BLSTFOR`输出爆炸压力，会得到类似于d3plot的一系列blstfor文件，使用PrePost单独打开即可，里边只有`LOAD_BLAST_SEGMENT_SET`定义的几何。可以在blstfor文件的History中输出基于segment的入射压力（inci pre）。
1. 如果爆源距离加载面较远，可以设置起爆时间为负数，这样可以节省计算时间，相当于模拟的0时刻已经起爆了。之所以可以这么做是因为TNT爆炸相当于一个随时间变化的压力curve，修改起爆时间本质就是curve的平移，而这种平移在DYNA中很常见。
1. 求解时，message中会输出`Blast wave reaches structure at 5.3432E-01 milliseconds`。
1. 默认爆炸荷载只对`*LOAD_BLAST_SEGMENT_SET`有效，如果结构表面的单元破坏了，则不会对暴露出来的单元加载，可以使用`*LOAD_ERODING_PART_SET`来替代，不过需要将`LOAD_BLAST_ENHANCED`的BID设置<-2。
1. 使用ALE来模拟爆炸行为，需要对炸药物质进行具体建模，TNT炸药和空气都是ALE的多物质组，加载的结构是Lagrange部分。使用`*INITIAL_DETONATION`来引爆TNT的part，起爆点一般设置为TNT Part的中心位置。如果没有定义`*INITIAL_DETONATION`，则所有高爆单元在时间0时都会发生爆炸。每个单元被点燃的时间会在d3hsp中输出，搜索`lit at time`即可。这里只能设置延迟起爆，不能像LBE那样设置提前起爆。
1. 注意ALE MMG之间不能重叠，但是必须相连。对于空气中的炸药，如果炸药为方形的，建议直接对空气建模，然后将部分单元转化为炸药（这种方法类似于钢骨混凝土的建模方法）。如果炸药的形状不是方形，应该从空气中掏除炸药的部分，可以尝试使用Mesh的Project功能，将节点投影。
1. 在模拟承受爆炸荷载的结构时，有两种分析方法可供选择：

      1. 纯拉格朗日方法，使用LBE关键字，空气爆炸压力是通过经验方程计算的，并直接作用于结构的拉格朗日单元。优点是避免了对炸药和结构之间的空气进行建模，可以显著降低计算成本，特别是远距离爆炸时。缺点是，无法考虑结构对爆炸波阻碍与绕射作用，无法解释爆炸波的聚焦（focus）或阴影（shadow）。
      1. ALE流固耦合方法。爆炸物和空气被明确地建模，通过ALE空气域传播的爆炸波通过FSl撞击拉格朗日结构。
      1. 混合方法，用ALE对拉格朗日结构周围（刚刚包裹住就可以）的空气进行建模，使用LBE关键字将爆炸荷载应用于ALE空气域的外表面。这种可以结合上述两种方法的优点，降低计算成本。需要将`*SECTION_SOLID`的AET参数设置为5，即用于接受LBE荷载，这只有在ELFORM=11时可用。

1. LBE相对于LB方法的增强之一就是前者可以对ALE空气域施加荷载。

1. `*DEFINE_GROUND_MOTION`使用地震动记录定义地震动历史，与`*LOAD_SEISMIC_SSI`结合使用，进行动态地震分析，包括非线性土-结构相互作用。

1. 地震运数据通常仅以地面加速度的形式提供，或以地面加速度、速度和位移的三元组形式提供。通常，速度和位移是使用专门的滤波和基线校正技术从加速度中计算出来的。接受任一输入，每个量都指定为负载曲线。在后一种情况下，只需要加速度和速度。DYNA不需要地面位移。
1. 如果只提供了地面加速度数据，DYNA会通过数值积分来生成相应的速度曲线。生成的曲线将输出到d3hsp文件中。用户有责任确保这些生成的曲线符合分析要求。

# 求解输出控制

1. DYNA将增量称为时间步长time step，这个和Abaqus不一样，一般在1e-6秒数量级。可以使用使用`*CONTROL_TIMESTEP`指定初始时间步长DTINIT，目标时间步长DT2MS（会使用质量缩放来确保）。

2. 普通求解时，会将`*CONTROL_TIMESTEP`的TSSFAC设置为0.9，如果是高速碰撞，建议设置为0.67。这个用来控制实际使用的时间步长和计算得到的时间步长的比值。

3. 如果是冲击问题，默认的初始时间步长，对于较低的速度来说，还需要多个时间步长才会真正发生碰撞，因此可以手动计算间隙，然后除以速度，来得到初始时间步长，实际设置的比这个略小即可，这样可以快速略过无意义的时间。不过在没有发生碰撞的时间内，求解推进的速度也是很快的。

4. 一般在质量缩放后，超重应该低于10%，可以使用Endmas参数控制。在求解输出的message中也可以查看到这个，calculation with mass scaling for minimum dt的ratio。

5. 使用质量缩放求解准静态问题完成后，应该检查全局的动能应该＜5%的全局总能量。

6. 对于高速变形问题，建议使用粘性沙漏控制。刚度控制通常更适合较低的速度，特别是在时间步长较大的情况下。

7. 在求解开始前，会在Message文件中输出时间步长最短的若干个单元编号和所在的part，如果只有几个单元步长最短，可以考虑对该区域重新划分网格。

8. DYNA自动计算的dt和负体积无关，后者主要和网格品质有关。

9. `*CONTROL_TERMINATION`用来指定求解终止的时间。其中的DTMIN可以指定time step相比于初始时间步长（DYNA自动计算的，并非用户设置的）的缩小下限，如果小于这个值，说明发生了严重畸变，则会终止求解。

10. 可以输出的内容有：ASCII DATABASE，BINARY DATABASE，INTERFACE。

   1. ASCII的输出频率可以设置较高，可以输出特定范围的数据。`*DATABASE_ASCII_option`中可以统一设置DT，输入完成后，敲击回车即可为所有选项设置DT。也可以为每项单独指定dt，勾选的项都会在工作目录中生成同名的文件。

   2. `*DATABASE_BINARY_option`可以设置输出的时间间隔（也就是1帧），或将求解时长切分的总数。即使不设置，也会至少将求解时长切分20份。在Post→Fringe中查看动画。

   3. INTERFACE包含Part的应力应变及其边界条件，以关键字的形式输出，可以在后续分析时导入。

11. 以上输出除了使用DT设置间隔外，还都可以使用NPLTC设置输出数量，这个会覆盖DT的设定，即新的DT=ENDTIM/NPLTC。也可以通过LCDT参数指定一个曲线，来设置不同时刻以不同的间隔输出。例如接触前和分离后使用低频率输出，其余时间使用高频率输出。

12. d3plot文件的数量并非输出的帧数，一个d3plot文件会包含多个帧，DYNA根据文件大小自动决定何时创建一个新的文件。

13. 在Post→ASCII中打开`*DATABASE_ASCII_option`输出的文件，如果存在对应的文件，则选项后面有星号，Load后，再点击下面的内容进行绘图。

14. 有些database的输出直接勾选即可输出，有些勾选完成之后还需要指定对哪些对象进行输出，例如secforc，还需要定义`*DATABASE_CROSS_SECTION`。勾选上必定会有同名文件，但是文件内可能没有数据。

15. 汇总表格：

    ```shell
    abstat  #气囊结果
    bndout  #边界条件力和能量结果
    dbfsi   #流固耦合数据
    defgeo  #变形后几何文件结果
    deforc  #离散弹簧和阻尼器结果
    elout   #单元结果
    glstat  #全局结果
    jntforc #关节结果
    matsum  #Part能量结果
    nodout  #节点平动结果
    rbdout  #刚体在全局和局部坐标系的运动
    rcforc  #接触面合力
    rwforc  #刚性墙的力
    secforc #横截面力
    sleout  #接触界面能量
    spcforc #SPC反力
    ```

16. 位移边界条件处（例如spc或prescribed motion）的节点反力通过`*DATABASE_BNDOUT`输出。

17. `*DATABASE_NODFOR`开启输出Group中每个节点的外力分量和合力，`*DATABASE_NODAL_FORCE_GROUP`定义要输出的节点的集合。这些力可能是施加边界力的结果，如节点力和压力边界条件、体力和接触界面力。在没有外力的情况下，例如内部节点，总是会产生一个零力合成向量。通常，此选项将用于曲面节点。

18. 如果要输出特定节点（集合）或单元（集合）的时间历程数据，可以使用`*DATABASE_BINARY_D3THDT`，会输出d3thdt文件。

19. 在Post→History中可以查看节点或单元数据，这个是存储在d3plot中的，它的频率较低（和d3plot一样的频率）。如果要获取高频率的输出，可以使用下面方法。这个输出的频率可以设置很高。

    1. 勾选`DATABASE_ELOUT`，可以开启输出单元输出功能，具体输出哪些单元，需要在`*DATABASE_HISTORY_option_SET`中设置。可以在CreateEntity中创建对应的set，根据单元类型选择。

    2. 以上操作对于`*DATABASE_NODOUT`同理，使用`*DATABASE_HISTORY_NODE_SET`指明要输出的节点集合。

20. `*DATABASE_ELOUT`默认输出特定集合的单元数据到elout文件中。可以使用`*DATABASE_EXTENT_BINARY`的INTOUT和NODOUT控制是否输出积分点或关联节点的应力/应变值，后者会输出到eloutdet文件，其DT和BINARY参数的取值和`*DATABASE_ELOUT`相同。该关键字的手册最后有一个例子。

21. 可以使用`*DATABASE_RCFORC`接触界面的合力，每个接触都有2条曲线，一个slave，一个master。合力方向一般是和surface的法向重合的。

22. 使用`*DATABASE_NCFORC`输出节点接触力，使用`*DATABASE_BINARY_INTFOR`输出接触Interface数据库，需要在求解器命令行添加`S=intfor`参数。对于这两个关键字，还需要将想要输出的接触关键字Card1的SAPR和SBPR设置为1。

23. 建议为每个contact定义名称，标记上接触的两个部分，这样在后处理中方便识别。

24. 可以在rbdout中输出所有刚体的运动。如果只想输出部分刚体的运动，可以使用`*PART_PRINT`定义该刚体，其中的PRBF参数可以指定输出是否输出RBDOUT和MATSUM，默认从`*CONTROL_OUTPUT`中获取该参数的值，而`*CONTROL_OUTPUT`中，该参数为IPRTF，默认值为二者都输出。

25. `*DATABASE_CROSS_SECTION_option`可以设置`*DATABASE_SECFORC`所需的截面。

    1. 按照平面来对某个part切分，该平面可以是圆形或矩形，取决于RADIUS参数。此时DYNA会在内部产生一个截面节点集合和多个切分到的单元集合，设置`*CONTROL_OUTPUT`的ICRFILE来输出到结果文件cross_section_1等中（其中含有使用`*SET_option`定义，set的ID和section的ID一样）。

    2. 直接给定一个截面节点集合和多个相关的单元集合。

26. 如果想要获取空间某固定点的状态随时间变化，则可以使用`*DATABASE_TRACER`和`*DATABASE_ASCII_TRHIST`。

27. binout和d3plot是DYNA中两种不同的文件格式，虽然它们都用于存储仿真结果，但它们的用途和内容有所不同。区别如下：

    1. d3plot存储几何和结果数据，主要用于后处理可视化，可以产生云图动画或进行时间序列分析。文件通常较大，文件名通常为d3plot、d3plot01、d3plot02等（用于分卷存储）。

    2. binout是用于存储纯结果数据的二进制文件，主要用于高效存储和提取特定结果数据。不包含几何信息，只存储结果数据。文件结构更紧凑，适合快速读取特定数据。可以通过PrePost→Post→Binout或编程工具（如Python）提取数据。格式为LSTC Data Archival Format（LSDA），模仿Unix文件系统。每个结果都有一个目录的结构，被称为分支。每个分支可以有几个子目录（子分支），可以访问和绘制该分支可用的各种结果。

28. 实际上binout是和ascii out对应的，这个可以在`*DATABASE`的BINARY选项。SMP的默认输出为ASCII，MPP的默认输出为Binout。可以在LS-RUN的job上右键→Convert Binout to ASCII files，将binout文件转化为ASCII文件。

29. MPP模式下，默认将`*DATABASE_ASCII_option`中勾选的内容输出到一个binout中，SMP则会各自输出到同名文件中。可以修改`*DATABASE_ASCII_option`中对应项的BINARY参数来修改这种行为。

30. `*CONTROL_ACCURACY`关键字可以控制求解的精度。对于某些隐式分析，可以设置IACC=1。

31. `*CONTROL_SOLUTION`中SOLN可以指定分析的类型为纯结构，纯热力学或耦合分析。

32. 热分析采用隐式算法。一般要定义`*CONTROL_THERMAL_SOLVER`，需要设置是否是瞬态ATYPE，是否是线性PTYPE。如果求解报错，可以尝试修改SOLVER。

33. 热分析的分析步相关设定为`*CONTROL_THERMAL_TIMESTEP`关键字。

34. 摩擦生热的问题中，需要修改`*CONTROL_CONTACT`的FRCENG为1。

35. 结构热耦合分析中，可以勾选`*DATABASE_TPRINT`输出耦合结果。

36. 热分析中，需要设置初始条件`*INITIAL_TEMPERATURE_SET`，一般为室温。如果没有设置，可能会报错。

37. MPP求解中会生成大量的重启动相关的文件，可以使用`*CONTROL_MPP_IO_NODUMP`取消这些输出，包括d3dump，runrsf，d3full，runfull。




# 重启动

1. 默认求解正常结束时都会输出一个d3dump01文件，如果意外终止则不会产生该文件。

2. 使用`*DATABASE_BINARY_D3DUMP`来设置每个DT或一共输出NPLTC个d3dump文件。

3. d3dump和runrsf是完全一样的，只是输出模式不同，都使用R=来作为重启动的输入文件。d=nodump设置不输出dump文件。

4. 如果一次模拟运行在几个小时以上，则建议设置runrsf，建议10分钟左右输出一次，具体CYLE需要通过`600s/分析步长`计算得到。

5. 注意，如果在LS-RUN中使用R=d3dump01进行重启动时，可能会删除掉所有的d3dump文件。因此建议先备份d3dump文件。重启动时，选择最后一个即可。

6. `*DATABASE_BINARY_RUNRSF`每隔CYCL个时间步写入一次重启动文件runrsf，最多保存NR个重启动文件，如果待写入时，总数超过了NR，则会覆盖最老的那个。可以通过最近修改时间来确定哪个是最新的。

7. 重启动可以从前一个分析的结尾或中间进行。只要是在输出重启动文件的时刻，都可以进行重启动接续分析。

8. 重启动文件是一个二进制文件，包含了用于重启动分析所需的所有数据（模型数据和这一时刻的结果数据），根据用于的设置，重启动文件在相应的时刻按照顺序输出d3dump01，d3dump02，等。

9. 具体可以查看第一本手册的Getting Started→Restart Analysis和Restart Input Data。
10. 重启动类型分为如下三种：
   1. 简单重启动（Simple），不改变模型和参数的重启动。因此无需用到K文件。用于前一个分析设置的结束时间太短了，没有得到完整的结果，需要继续原来的分析。或者由于意外导致计算终止，例如程序崩溃或停电。提交任务时，选择对应的d3dump即可，需要选择相同的求解器和核心数。建议新建一个文件夹，将d3dump拖入，然后在LS-RUN中添加R=选项运行，建议附加上对应的K文件。
   2. 小型重启动（Small），用于将分析运行到比最初指定更长的时间或对模型进行小幅修改。允许执行以下操作。指定刚性/可变形开关控制；将零件从可变形切换到刚性和背部。
   3. 完全重启动（Full），允许添加或删除模型的某些部分，允许额外的材料和荷载变化。不过接触设置和初速度不能更改，不支持自适应网格，即使在初始运行中存在也不行。具体方法就是Stress initialization。

11. 在小型和完全重启动中可以添加`*CHANGE`系列的关键字修改原始的设定。

12. 可以将重启动和子系统结合使用，发挥出更大的功效。

13. 完全重新启动从上一次计算结束的时间点开始。添加的新的与时间相关的荷载都必须在上次计算结束时刻后开始。例如想在完全重新启动中将速度从10m/s斜坡上升到20m/s，持续时间为2ms，而之前的计算在1ms结束，则加载的时间点应为1ms，值为10m/s，时间点为3m，值为20m/s。


# 隐式分析

1. DYNA默认进行显式求解，除非指定隐式关键字。

2. 动力分析前的螺栓预紧力阶段，冲压后的回弹阶段都建议使用隐式分析。也可以使用Dynamic Relaxation来完成，设置关键字`*CONTROL_DYNAMIC_RELAXATION`和`*INTERFACE_SPRINGBACK_LSDYNA`，需要将所有的Curve的SIDR设置为1或2，然后提交求解，就可以得到dynain文件了。

3. DYNA中Dynamic Relaxation的三种类型：

   1. Explicit after Ansys Solution，先执行隐式分析，然后进行显式动态分析。在这种隐式到显式的顺序求解中，必须首先运行隐式结构分析，以便对结构预加载。隐式分析时，需要完全约束仅在显式分析中使用的任何单元的所有节点（例如鸟撞问题中的鸟）。隐式解在预应力环境中指定时间的节点位移和旋转被写入DYNA动态松弛文件input.sif。
   2. Explicit类型，允许显式求解器通过增加阻尼进行准静态分析，直到动能降至零。此时求解器将每250个循环（默认）检查一次动能，直到施加的预加载的动能消散。支持五种预加载：重力、加速度、旋转加速度、旋转速度和螺栓预紧。
   3. 允许DYNA隐式而非显式初始化，

4. 下面的隐式分析关键字都可以加上_DYN的后缀来控制Dynamic Relaxation。

5. 螺栓预紧力可以使用`*INITIAL_AXIAL_FORCE_BEAM`或`*INITIAL_STRESS_SECTION`施加。

6. 隐式分析需要设置如下关键字：

   1. `*CONTROL_IMPLICIT_GENERAL`，将IMFLAGS设置为1，才会开启隐式分析功能，默认为显式，可以使用曲线来随时间变化。DT0为隐式分析的初始时间步长，一般为总时间的1/10到1/100。

   2. `*CONTROL_IMPLICIT_AUTO`，将IAUTO设置为1，使用自动时间步长。每一个time step的迭代次数在11（ITEOPT）±5（ITEWIN）次。只有自动时间步长时，才可以设置这两个参数。

   3. `*CONTROL_IMPLICIT_SOLUTION`，NSOLVER设定使用的求解器，默认是非线性求解器，如果是线性的，可以手动设置以加速求解，这里类似于Abaqus的几何非线性开关。还可以设置收敛容差，DCTOL为位移相对收敛容差，ECTOL为能量残差，RCTOL为力残差。

   4. `*CONTROL_IMPLICIT_SOLVER`，LSOLVER设定使用的线性方程组求解器。

   5. `*CONTROL_IMPLICIT_DYNAMICS`，IMASS设定静态（默认）还是动态分析（使用Newmark积分）。

7. 当进行隐式静态分析时，时间只是代表加载的比例，而非具体的时间，因此时间的单位也不重要了，一般将结束时间都设置为1。隐式静态分析时，初始时间步长一般设置为总长的5%。

8. 当使用隐式分析时，推荐使用mortar版本的接触方式，速度快很多。

9. 模态分析提取使用`*CONTROL_IMPLICIT_EIGENVALUE`关键字，对应的结果文件为d3eigv。

10. 隐式分析中，使用的荷载曲线应该是渐变（ramp）的，而非显式分析的突变（step）。

11. 可以在隐式分析中，引入`*INTERFACE_SPRINGBACK_LSDYNA`关键字（名称是历史原因，不仅限于回弹分析），该关键字中包含的part set会在求解完成后，输出一个dynain文件（格式和K文件一样，in表示Interface）。包含结束时结构的形状和单元的应力数据，可以使用PrePost打开该文件，然后在Post→Fringe→Dynain中查看，不过没有History输出。可以用于初始化后续的分析。变化如下：

    1. 保留固定边界条件，删除运动边界或荷载。将原来的`*BOUNDARY_SPC_SET`拆解成多个`*BOUNDARY_SPC_NODE`。

    2. 增加关键字`*INITIAL_STRESS_option`。例如壳单元：

       ```shell
       *INITIAL_STRESS_SHELL
                1         1         2         0         0         0         0         0
       -5.774E-01 5.309E-02 4.480E-03-9.839E-06 4.638E-03-1.093E-03-3.080E-03 0.000E+00 #第一个积分点，厚度方向的等参坐标为-1/sqrt{3}。
        5.774E-01-5.301E-02-4.495E-03-1.008E-05-4.671E-03-1.109E-03-3.239E-03 0.000E+00 #第二个积分点，1/sqrt{3}
       ```

    3. `*ELEMENT_SHELL`变为`*ELEMENT_SHELL_THICKNESS`，后者中包含了每个节点的厚度。同时删除了`*SECTION_SHELL`关键字。壳单元会优先使用`*ELEMENT_SHELL_THICKNESS`中指定的厚度，而非`*SECTION_SHELL`中的厚度，不过还是要设置Section的，因为其中不止有厚度。

    4. 该文件中不含Part关键字，但是通过PrePost打开时，会自动创建一个名为auto create的Part。

    5. 材料数据也会删除。

12. dynain文件中不仅记录应力，还会记录有效塑性应变，历史变量等。后续求解时会使用这些数据来初始化单元和其上的材料状态。只有使用增量公式进行应力更新的材料才可以使用此卡进行初始化。

13. 使用dynain文件进行接续显式分析，可以使用子系统的方法，将原来K文件的材料或其他有用的信息保存到一个新的文件中，在其中Include这个dynain文件。

14. 隐式分析的求解器输出：

    ```shell
     BEGIN implicit statics  step      5 t= 1.0078E-02  02/13/25 20:15:37 #第5步
     ============================================================
                    time =  1.00779E-02 #起始时刻
       current step size =  3.98107E-03 #步长
     Iteration:   1     *|du|/|u| =  4.2489892E-01     *Ei/E0 =  1.0000000E+00
     Iteration:   2     *|du|/|u| =  1.6363541E-02     *Ei/E0 =  1.0325771E-03
     Iteration:   3     *|du|/|u| =  6.1025582E-03     *Ei/E0 =  1.0050413E-04
     Iteration:   4     *|du|/|u| =  8.9250281E-03     *Ei/E0 =  4.5952372E-05
     Iteration:   5     *|du|/|u| =  5.1661616E-03     *Ei/E0 =  1.0938739E-05
     Iteration:   6     *|du|/|u| =  3.3172100E-03     *Ei/E0 =  4.4319753E-06
     Iteration:   7     *|du|/|u| =  1.2583467E-03     *Ei/E0 =  1.2382127E-06
    #迭代了7次，直到满足误差标准，定义在*CONTROL_IMPLICIT_SOLUTION
     Equilibrium iterations summary step      5 t= 1.0078E-02   02/13/25 20:15:37
        Number of iterations to converge         =           7
        Number of stiffness reformations         =           0
        Number of right hand side evaluations    =           8
    
     Convergence detected as a combination of
         1. Current  maximum   displacement translational norm           
            Value =   1.1917E-03 vs Tolerance =   1.4075E-03
    ```


# ALE

1. ALE算法的主要特点是：有限元网格的任意性（Arbitrary），计算网格可随特定物理问题，采用自己独特的运动方式。网格不一定用于描述物体的几何形状，而只是用来覆盖物体可能运动的空间。它可以用于计算流体或固体的大变形问题，尤其适合处理高速流体冲击，侵蚀拉格朗日结构等问题，例如爆炸，罐内液体晃动，容器坠落，鸟击，物体入水。

2. 在DYNA的Multi-Material ALE算法中，背景网格中一个单元最多可容纳20种材料。

3. 所有的ALE Part都必须相连，也就是需要通过共节点来耦合起来，例如小球落水中的空气和水。

4. ALE不支持隐式算法和动态松弛（Dynamic Relaxation）。

5. 欧拉分析相比拉格朗日来说多了个固定的背景参考网格，而ALE相比欧拉分析来说，该背景参考网格可以移动。S-ALE相比ALE可以自动生成背景网格。

6. ALE的背景网格不仅可以平动和转动，还可以变形，即节点的位置可以独立移动，以适应流体的复杂运动或边界的变化。例如，在流固耦合问题中，结构变形会导致流体域的边界发生变化，ALE背景网格可以通过变形来适应这种变化，从而保持计算精度。

7. ALE方法没有湍流或边界层特征，因此它不适用于对需要这些特征的传统CFD问题进行建模。

8. 除了ALE公式5支持接触外，ALE通常不支持接触。

9. 三维空间中，ALE仅支持单点积分的实体单元。可以是六面体、五面体或四面体。后者被视为退化六面体单元，因此，对流计算可能不准确，并导致LS-DYNA崩溃，因此建议仅使用具有六面体单元的ALE网格。

10. 对于每种ALE多材料，在单个积分点对每个固体单元中的应变和应力进行评估。从这个意义上讲，ALE单元公式等价于ELEFORM=1的实体单元公式。

11. 内流场和外流场的流固耦合，都可以使用`*CONSTRAINED_LAGRANGE_IN_SOLID`。只要求网格部分重叠即可。

12. 对于模拟油罐车刹车制动，可以为液体和空气域设置初始速度条件，汽车本身设置速度边界条件（迅速降低到0），二者在初始时刻的速度应该一致。这个问题和铁球跌落入水不同的是，这里还需要设置参考系来描述ALE背景网格的运动。使用`*ALE_REFERENCE_SYSTEM_NODE`定义一个由3个节点表示的坐标系，它可以控制ALE网格运动（这一步在PrePost4.11中会闪退）。然后在`*ALE_REFERENCE_SYSTEM_GROUP`中的PRID引用上述坐标系的定义，需要设置PRTYPE=5。

13. 因为拉格朗日Segment将仅在该Segment的正法向侧与流体耦合。类似于接触分析中的非Automatic行为，one-sided。如果ALE分析中结构部分是实体单元，则不用考虑法线问题，因为始终是Part的外表面参与耦合。如果使用壳单元，则必须要确保它的法线是指向ALE部分的。两种思路：

    1. 修改壳单元的法线指向。
    2. 修改`*CONSTRAINED_LAGRANGE_IN_SOLID`的NORM参数，它决定使用右手或者左手定则来确定壳的法线。

14. 涉及到液体和固体的流固耦合问题，空气部分可以设置为真空Vacuum（只需要给一个特别小的密度即可），这样可以省略状态方程。例如液晃问题，或落水冲击问题。

15. MM-ALE单元的ELFORM一般为11。

16. ALE一般要指定Hourglass关键字。

17. 使用`*ALE_MULTI-MATERIAL_GROUP`来定义使用ALE单元公式的每个group，一般一个part作为一个group。

18. 推荐将`*CONTROL_ALE`设置为：DCT=-1（使用增强的对流逻辑，尤其是对于爆炸来说），AFAC=-1（光滑权重因子，-1表示关闭）。

19. FSI中，一般会将`*CONTROL_TIMESTEP`的TSSFAC设置为0.67，虽然可能是低速冲击，但是考虑到流体的存在，建议这么设置。

20. 流固耦合问题中，流体使用ALE网格建模，固体使用拉格朗日网格建模，耦合是通过固体的face和流体相互作用完成的。

21. DYNA为处理流固耦合提供了ALE-FSI方法，此时流体通常采用ALE多物质单元重构流体物质界面，固体使用通常的拉格朗日单元。流体采用欧拉方法，固体采用拉格朗日方法。同一空间位置流体和固体结构网格可以同时存在，相互重叠。在流体和固体物质界面间，信息交换的方法有两种，和接触算法类似：

    1. 约束法：在物质界面处，在遵循动量守恒的前提下，人为改变流体和固体的速度，使之一致。

    2. 罚函数法：在物质界面处，流体和固体之间添加无质量的弹簧，用惩罚力去纠正流体和固体运动间的不协调。这会产生一些穿透，和接触问题是类似的。

22. DYNA的ALE流固耦合一般采用罚函数法，因为约束法无法处理流体和固体的分离。处理瞬态问题时，约束法会导致较大的能量损失。约束法必须和所有流体耦合，而罚函数法可只耦合与特定流体耦合。

23. 罚函数法分为三步：

    1. 确定固体物质界面。首先将固体表面网格构成一个Segment set，然后在每个Segment上生成N*N个结构耦合点。固体物质界面就由这些耦合点代表。
    2. 确定伪流体（pseudo）物质界面。在固体的每个耦合点处判断，这个耦合点是否已经接触到流体物质表面。如果已经接触，在欧拉网格中于此固体耦合点同一位置处标注流体耦合点，伪流体物质界面由这些流体耦合点组成。
    3. 施加惩罚力。在每一对固体和流体耦合点间施加一个无质量弹簧。接下来结构耦合点和流体耦合点分别跟随固体和流体运动，它们之间的相对位移会产生弹簧力，以此施加惩罚力。

24. 流固耦合问题中，需要使用`CONSTRAINED_LAGRANGE_IN_SOLID`或`*ALE_STRUCTURED_FSI`（只能用于S-ALE）将拉格朗日结构（壳或实体）耦合到ALE的流体中。如果ALE网格和拉格朗日网格的节点重合较好，尺寸相似，参数NQUAD（分布在每个耦合拉格朗日曲面segment上的耦合点数量）可以使用默认，否则应该增加，例如3*3。

25. 如果是拉格朗日结构是梁，则推荐使用`CONSTRAINED_BEAM_IN_SOLID`。

26. 传统ALE方法支持的流固耦合关键字有：

    ```
    *CONSTRAINED_LANGRANGE_IN_SOLID
    *ALE_COUPLING_NODAL_CONSTRAINT
    *ALE_COUPLING_NODAL_DRAG
    *ALE_COUPLING_NODAL_PENALTY
    *ALE_COUPLING_RIGID_BODY
    *ALE_FSI_PROJECTION
    ```

27. CTYPE是耦合类型，主要分为基于约束的和基于罚刚度弹簧的，取值建议：

    1. 铁球落水问题，建议为4。如果拉格朗日结构是刚体，则必须为4。

    2. 封闭界面的液晃问题，建议为3。

    3. TNT空中爆炸对结构加载，建议为5，这是因为结构可能会失效，造成内部的单元暴露出来。ctype=5允许对侵蚀的单元加载，如果是4，则只会和表面单元耦合。

28. 流固耦合的方向一般选择法向受压比较稳定，即DIREC=2。这样流体不会反向拉动固体，类似于可以分离的接触。

29. 可以设置MCOUP=1来简化流固耦合计算，也就是固体只和密度最高的流体耦合。通常不建议取0，这会将耦合应用到所有材料，导致无法准确计算流体界面（因为体积分数总是100%）。没有明确的界面，就无法跟踪流体泄漏。也可以使用`*SET_MULTI`创建一个集合，只和集合内的所有材料耦合，其中由MM-ALE Group ID构成。

30. 可以根据需要调节PFAC（罚刚度系数），ILEAK，PLEAK等参数。如果进行的是炮弹侵彻计算，建议使用强泄露控制。

31. 在ALE分析中，可在有限元网格划分时用单元网格描述物质的初始几何形状（类似于钢骨混凝土的建模），也可以由`*INITIAL_VOLUME_FRACTION_GEOMETRY`（填充part或part set，推荐使用）或`*INITIAL_VOLUME_FRACTION`（填充单个单元，不推荐使用）定义每种物质的体积占比。TNT和空气的组合需要使用这个方式来设置TNT的位置和尺寸。

32. `*INITIAL_VOLUME_FRACTION_GEOMETRY`是一个体积填充命令，用于定义最初在ALE网格中占据多个空间区域的各种ALE多材料组（AMMG）的体积分数，仅适用于`*SECTION_SOLID`中的ELFORM=11和12以及`*SECTION_ALE2D`中的ALEFORM=11。其中FMSID是背景网格ID，可以part或part set。BAMMG用于设置初始填充满整个（也就是默认物质，即不显式赋予时的物质）背景网格的物质ID。也就是先用BAMMG填充完，然后再用其他物质覆盖填充部分区域。根据CNTTYP的不同，可以使用Part的边界切分，或平面，锥/柱面，立方体，球体，或者通过`*DEFINE_FUNCTION`来计算（结果为1表示内部，0表示外部）。FILLOPT设置填充内还是外部，实际就是法向量的头head和尾tail，对于CNTTYP=4，5，6的情况，0表示内部，FAMMG指明要填充的物质ID，还可以为该区域设置初始速度。

33. 使用part或segment来指明初始化区域时，还可以设置offset，这样就不用重新构建区域了，它会沿着边界的法向来offset，正负都可以。

34. 该关键字的一行表示一次局部初始化，顺序很重要，后续的初始化区域会覆盖之前的。具体可以见手册中的例子。

35. 该关键字导致在运行结束时为ALE和S-ALE分析输出alevfrc.inc文件。对于S-ALE，它还输出文件salevfrc.lsda，它是alefrc.inc的lsda版本，也就是binout格式。alefrc.inc可以与`*INCLUDE`一起用于后续分析的初始化，而salevfrc.lsda可以与`*INITIAL_VOLUME_FRACTION_lsda`一起包含。这些文件预先填充体积分数并存储修剪的网格，这可以节省后续分析的时间。

36. 可以使用`*DATABASE_BINARY_FSIFOR`输出ALE界面耦合的力（类似于接触界面的力，不过那个是ASCII的RCFORC，这个是可以输出云图的），需要给定Part set的ID。同时还需要在求解器的命令中添加`h=fsifor`参数，可以通过LS-Run完成。会输出一系列文件，类似于d3plot。

37. `*DATABASE_BINARY_FSIFOR`仅适用于拉格朗日和ALE材料的基于罚刚度的耦合，即CTYPE=4或5（`*CONSTRAINED_LAGRANGE_IN_SOLID`，或者在SALE中`*ALE_STRUCTURED_FSI`）。此关键字输出的是耦合表面上随时间变化的耦合压力云图。`*CONSTRAINED_LAGRANGE_IN_SOLID`中的INTFORC参数必须为1，这对于S-ALE的`*ALE_STRUCTURED_FSI`是默认开启的。

38. 可以使用`*DATABASE_FSI`输出与所选拉格朗日曲面（通过SID指定）上的通量和载荷相关的某些耦合信息到ASCII格式的dbfis文件中，这种耦合压力是在被监测的整个表面实体上平均的。DBFSI_ID就是一个编号，可以不用输入。在MPP-DYNA的情况下写入binout文件。

39. ALE采用算子分裂方法处理扩散项和对流项，一个时间步长内，单元会经历一个常规的拉格朗日时间步和一个额外的输运时间步。

40. 在通常的拉格朗日算法中，一个时间步包含如下3个动作：

    1. 更新速度和位移。

    2. 在变形后构型得到新的单元应变率，进而得到新的单元应力。

    3. 由节点的内力，外力及质量计算出新时间步的加速度，然后回到第一步。

41. 输运时间步是指ALE变形后的输运过程，这个过程使得ALE网格脱离了物质点的运动而独立存在，也带了处理复杂度和人为误差。

42. 输运时间步的作用是将变形后网格中个单元的应力应变和其他历史变量映射到ALE网格的单元中。输运过程发生在上述拉格朗日时间步的（2）和（3）之间。包括以下2个步骤：

    1. ALE网格运动，在此之前，单元网格已随该时间步物质点的运动而运动。此时的网格位置与当前时间步开始时的网格位置的差值，就是此时间步的位移。根据不同的问题，选择不同的网格运动方式：如果将网格移回当前时间步开始时的网格位置，就是欧拉网格；如果完全不做网格运动，就是拉格朗日网格。`*ALE_REFERENCE_SYSTEM_GROUP`中的PTYPE=8可以作为一个ALE网格运动的例子。参数EFAC控制网格欧拉类型的比例，新节点位置=欧拉网格节点的位置\*EFAC+拉格朗日节点位置\*（1-EFAC）。

    2. 输运过程（advection，mapping）又称为映射过程，实际上是一个加权平均过程，权函数是体积。对于单元变量，首先计算出各个单元表面的流入/流出体积。然后利用如下公式求出输运后单元变量的新值：新值=（旧值\*单元旧体积+各面流入或流出体积\*流入或流出值）/（单元旧体积+各面流入或流出体积）。

43. 对于单元变量的值的选取，假设该值在单元内为常数，则输运过程就是一阶，如果假设它是线性变化的，则输运过程就是二阶，可以使用`*CONTROL_ALE`的METH参数设置。

44. 节点变量的处理稍微复杂，DYNA采用了Half Index Shift的处理方法，每个单元的8个节点变量都要被逐个放置于单元中心，当作单元变量处理，以防止输运过程中产生过多的人为扩散。

45. 界面重构采用体积占比重构物质界面。为了简化计算，ALE界面重构有以下几个假设：

    1. 单元中的物质界面是一个平面，物质界面在单元间不连续，物质界面的形状随每次输运而变化。注意，这也是造成流固耦合中泄露leakage的根源之一。

    2. 单元中物质界面的数量=物质种类数量-1。

    3. 单元中物质的排列顺序与*ALE_MULTI-MATERIAL_GROUP中的顺序一致。

    4. 物质在它处于的物质界面中均匀分布，即界面重构过程中，原单元中的某种物质和新流入的同种物质被同一化，也就是均匀混合。

46. 使用多物质ALE单元建模时，单元网格并不一定描述物体的几何形状，而只是用来覆盖物体可能运动的空间。物体的几何描述可根据体积占比经由物质界面重构而实现。这正是ALE问题的边界条件施加的特点。

47. ALE单元本身只是一个积分域的描述，并不包含任何物质界面信息，DYNA的ALE使用界面重构法来构造不同流体间的物质界面，从而使同一网格内可以进行多流体计算，ALE多物质单元支持多流体计算，设置如下：

    1. 一维模型，在*SECTION_ALE1D中设置ALEFORM=11
    2. 二维模型，在*SECTION_ALE1D中设置ALEFORM=11
    3. 三维模型，在*SECTION_SOLID中设置ELFORM=11

48. LS-DYNA 通过计算ALE多材料的体积分数来确定流体界面。具体来说界面位于体积分数为 50% 的位置，例如一半空气，一半水。

49. ALE多物质单元使用`*ALE_MULTI-MATERIAL_GROUP`定义。关键字的每行分别为一个Part ID或Part Set ID指定一种MMG ID。

50. 

51. 边界分为2类：

    1. 应力边界，也称为自然边界条件，ALE网格边界处一般只能施加零压力或环境压力Ambient Pressure。这是因为ALE边界并非物质边界，物质并没有在这里截断（施加位移边界时除外）。大部分问题中，边界一般被一个大气压的空气或零应力的`*MAT_VACCUM`所占据。零压力边界，与拉格朗日中的零应力边界问题相同，无须特殊处理，默认就是。`*CONTROL_ALE`中的PREF可以设置ALE网格边界的自由面的参考压力（环境压力），对于外流场问题，应为大气压力。考虑重力时，还需要设置`*ALE_AMBIENT_HYDROSTATIC`和`*INITIAL_HYDROSTATIC_ALE`。

    2. 位移边界，也称为本质边界条件，包含：
       1. 固定边界，边界上一点的某方向自由度被固定，与拉格朗日问题相同，可使用`*BOUNDARY_SPC`指定。

       2. 对称边界，在某一全局方向上，边界上点的位移为零，且与之垂直的2个方向上，边界上点的转动位移为零，设置方法同上。

       3. 滑移边界，法向运动受限，切线方向可以自由滑动。这是ALE独有的，使用`*ALE_ESSENTIAL_BOUNDARY`定义。通常在管道流动时，ALE网格的边界就是管道的内壁，液体在管道内流动时，摩擦力微弱，可以忽略不计。它类似于一个简化的流固耦合问题，此耦合中，固体要么被固定，要么质量和刚度足够大，使得固体本身的变形和移动可以忽略不计，流体携带的动量在耦合过程中没有损失。在R6之前，滑移边界由`*CONTROL_ALE`中的EBC=2指定，但是原有算法只对非常简单的边界形状有效。对于稍复杂的边界就会失效。旧算法对于角点corner和边缘点edge的处理也是错误的。新算法可以正确处理这些，还考虑针对输运时间步的速度修正，从而保证动量和冲量守恒。

       4. 流入流出边界，这是ALE特有的。通常需要同时设置速度边界条件和流入/流出液体的材料性质。后者的设定可以参考`*BOUNDARY_AMBIENT_EOS`和`*SECTION_SOLID(AMBIENT=4)`。在设置速度时，必须注意对环境单元（Ambient）的所有点都施加速度，这样才可以保证环境单元无变形，从而确保单元应力即其他单元变量不变。

52. DYNA中的材料失效可用于ALE和S-ALE。通过创建具有自己ID的虚拟part并将`*MAT_VACUUM`关键字与part相关联，用虚拟真空材料替换失效材料。



# S-ALE

1. 可以在Prepost的菜单栏→Explorer→Solution Explorer，在Multiphysics Solution上右键New solution选择Structured ALE即可。逐个设置，最后可以在Multiphysics Solution上右键导出K文件。也可以将这个工程保存到一个.solution文件中。这里内置了很多材料，可以在Materials中导入。不过需要注意的是，这里的操作并不会反映到keyword manager中。

2. DYNA中的ALE模型大多采用规则的立方体正交网格（对于外流场，很多都是这样的），也称为IJK网格，可以利用这一特点，来降低算法复杂度，减少计算时间，降低内存需求。

3. DYNA原有的ALE算法开发之初是为了解决固体大变形问题的，这类问题中，网格随物质边界变形而移动，而固体也只是用单个材料单元来模拟。虽然后来又扩展了原程序来支持多物质材料和网格运动。但是算法和逻辑远非最优，例如难以解决流固耦合的泄露问题。

4. 近年来ALE模型的单元数量增长很快，输入文件极为庞大，修改编辑K文件耗时很长。而对于规则网格来说，完全可以根据用户提供的简单几何信息，由程序本身在计算开始时创建网格，从而省去用户创建网格和程序读入的麻烦，同时也节省了大量读写操作带来的时间消耗。

5. 2015年，LSTC的陈皓将结构化ALE（S-ALE）加入DYNA，目前正在将AUTODYN的FCT算法引入DYNA的S-ALE中，以提高计算精度。

6. S-ALE求解器易于使用，特别是对于熟悉通用ALE求解器的用户。当使用S-ALE结构网格时，S-ALE求解器会被自动调用，用户不用额外操作。大多数ALE关键字保持不变，新增的关键字，均以`*ALE-STRUCTURED`开头：

   ```shell
   *ALE_STRUCTURED_FSI 
   *ALE_STRUCTURED_MESH
   *ALE_STRUCTURED_MESH_CONTROL_POINTS
   *ALE_STRUCTURED_MESH_MOTION #在模拟过程中控制网格运动
   *ALE_STRUCTURED_MESH_REFINE #将ALE-STRUCTURED_MESH定义的结构网格进行细化，每个方向指定一个整数倍数。
   *ALE_STRUCTURED_MESH_TRIM #修剪/取消修剪生成的网格
   *ALE_STRUCTURED_MESH_VOLUME_FILLING
   ```

7. 通过结构化网格，单元和节点的连接变得简单，用于ALE耦合的搜索算法也大大简化。避免了许多检查，因为这些网格只包含六面体单元。因此当ALE网格是结构化时，推荐使用S-ALE求解器。

8. S-ALE求解器和原有ALE求解器的理论完全相同，采用相同的输运和界面重构算法，但是具有以下优点：

   1. 网格生成简单，S-ALE可以在内部自动生成ALE正交网格，K文件简洁容易维护，I/O时间更少。减少了PrePost使用的内存。
   2. 计算时间缩短20-40%。
   3. 并行效率高，S-ALE适合处理大规模模型，目前支持SMP，MPP，HYBRID。借助于MPP算法的全新设计，MPP的可扩展性得到极大提高，通过运行在400核上的大型算例，可以得到0.9的加速比。S-ALE成功实现SMP并行及结果一致性，而原有ALE求解器无法实现SMP并行计算。
   4. 求解稳健，在流固耦合的泄露方面改进很大，控制参数大大减少。

9. S-ALE使用步骤如下：

   1. 生成S-ALE背景网格
      1. 定义1-3个`*ALE_STRUCTURED_MESH_CONTROL_POINTS`关键字，给出3个局部坐标方向网格集合。

      2. 使用`*ALE_STRUCTURED_MESH`应用上述控制点序列生成结构网格，这就是背景网格，需要给定一个未使用过的Part ID。

   2. 定义S-ALE多物质，及定义S-ALE网格中的材料
      1. 采用`*PART`定义材料part，对于每一种ALE材料，定义一个part，该part将`*SECTION`，`*MAT`，`*EOS`，`HOURGLASS`等组合在一起。

      2. 采用`*ALE_MULTI-MATERIAL_GROUP`关键字定义ALE多物质。

   3. 定义各ALE多物质材料的初始体积占比。初始阶段在S-ALE网格part中填充多物质材料，这通过`*INITIAL_VOLUME_FRACTION_GEOMETRY`（其中part ID为网格Part）或`*ALE_STRUCTURED_MESH_VOLUME_FILLING`（S-ALE专用）。程序内部通过界面重构算法来构建物质界面。

   4. 其他设置
      1. 通过`*CONTROL_ALE`设置物质输运算法：Donor cell（一阶）或Van Leer（二阶）。设置AFAC=-1可以关闭ALE光滑。

      2. 采用`*INITIAL_DETONATION`设置起爆点，注意PID必须是背景网格Part ID。

   5. 设置边界条件
      1. 采用`*BOUNDARY_SPC`设置固定或对称边界条件
      2. 采用`*BOUNDARY_PRESCRIBED_MOTION`施加速度边界条件
      3. 采用`*LOAD_SEGMENT`施加压力边界条件，正值表示和Segment的法线相反。
   6. 流固耦合设置
      1. 推荐采用`*ALE_STRUCTURED_FSI`。
      2. 也可以采用`*CONSTRAINED_LAGRANGE_IN_SOLID`。除了唯一的对MCOUP参数的小改动外，使用方法与原有ALE基本相同。在原有的ALE中，MCOUP=0表示结构与所有流体耦合；MCOUP=1表示结构与密度最大的流体耦合；MCOUP=-N表示与由ID=N的`*SET_MULTI-MATERIAL_GROUP_LIST`中列出的一个或几个流体耦合。现在，为了避免额外的`*SET_MULTI-MATERIAL_GROUP_LIST`关键字，这里规定，当MCOUP=-N并且N≠1时，N代表一个Part Set，这样就可以将要耦合的AMMG用他们的材料Part代替了。

10. `*ALE-STRUCTURED_MESH_CONTROL_POINTS`是用来定义控制点序列的，`*ALE-STRUCTURED_MESH`通过引用这些控制点序列来生成结构网格，在它的CPIDX等中选择对应的控制点序列即可，相当于3个序列的笛卡尔积。控制点的格式如下：

   ```shell
   N     X     RATIO
   1    0.4     0    #注意，第一个控制点的编号必须是1
   6    0.5     0    #至少有2行
   28   0.72    0
   40   0.78    0
   62   1.0     0
   67   1.1     0    #最后一个控制点的编号定义了节点的总数。
   #第一列控制点编号，第二列为坐标，第三列控制网格尺寸在控制点之间是如何变化。
   #6个控制点，可以构成5段，每段的端点就是控制点的坐标值。例如第一段有5小段，长度为0.5-0.4=0.1
   ```

11. 根据ICASE的取值不同，可以有多种设置等比数列（渐变网格）的方式。当ICASE=1时，RATIO为该点附近的网格尺寸，而非比值。

12. 不过DYNA内部都会将ICASE转化为0的模式，这在Message中输出：

    ```shell
    #原始的K文件
    *ALE_STRUCTURED_MESH_CONTROL_POINTS
    $#    cpid    unused     icase       sfo    unused      offo
          3001                   1       1.0                 0.0
    $#                 n                   x            ratio/xl
                       1               -12.0                 0.0
                      13                 0.0                 0.5
                      25                12.0                 0.0
    #message中输出的修正的关键字，这里的icase变成了默认值0，xl也变成了ratio
           *ALE_STRUCTURED_MESH_CONTROL_POINTS card with ID= 3001:
             is with ICASE= 1. Below is the modified keyword.
    -----------------------------------------------------------------------------
    *ALE_STRUCTURED_MESH_CONTROL_POINTS
    $     lcid                           sfy                offy
          3001                     1.000E+00           0.000E+00
    $                  i                   x               ratio
                       1-0.1200000000000E+02-0.1190900278271E+00
                      13 0.0000000000000E+00 0.1190900278271E+00
                      25 0.1200000000000E+02 0.0000000000000E+00
    ```

13. S-ALE网格默认不显示，需要在左侧模型树中点击ALE→Structured Mesh才可以。有时修改`*ALE-STRUCTURED_MESH_CONTROL_POINTS`中的点坐标和ratio，PrePost并不会改变，这是一个显示bug，保存然后重新打开即可。

14. 一共需要定义两种part：

    1. 背景网格Part，由一系列单元和节点组成，没有材料信息，也不包括单元算法，仅仅是一个网格Part。由`*ALE_STRUCTURED_MESH`的DPID定义，用户只需给出一个未使用过的Part ID即可，不用为它设置*Part卡片，S-ALE会自动定义这个part并指明其为S-ALE背景网格。在所有的ALE相关的关键字中，PID指的是Part ID，仅引用其中的网格，而非材料。
    1. 材料Part，与网格Part相反，不包含任何网格信息。S-ALE网格中流动的多物质材料与材料part一一对应，可以有多个卡片，每个卡片定义了一种多物质材料（`*MAT`+`*EOS`+`*HOURGLASS`）。其ID仅出现在`*ALE_MULTI-MATERIAL_GROUP`中，其他任何对该ID的引用都是错误的。

15. 除了这两个关键字外，还需要额外定义一个空的part用于存放S-ALE网格（仅指定Part ID不行），这个Part的ID会在`*ALE-STRUCTURED_MESH`的DPID中引用。该Part的定义中，只需要给定ID，其余的选项都是零即可，因为这里的Part仅指背景网格，而非材料。因为用户定义的MATID不可能为0，因此Part中引用编号为0的MAT表示不使用任何材料。此Part定义在输入阶段自动生成，既不包含材料也不包含单元公式信息。之所以有这个规定，是为了满足遗留规则，即每个单元都必须与一个Part相关联。此ID还用作网格合并的指示器，即如果将相同的Part ID用于多个相邻的自动生成的网格，则它们将合并在一起，形成由这些子网格组成的单个网格。

16. 实际在DYNA内部会给ALE背景网格的part指定一个`*MAT_VACUUM`的材料和ELFROM=11的section。这一点可以在d3hsp的part输出看到。

17. 定义S-ALE结构网格时，用户需要指定3个方向的网格点分布。通过一个节点定义网格源节点，可用于指定网格平动，另外3个节点定义局部坐标系，可用于指定网格旋转。

18. S-ALE可以生成多块结构网格，每块网格独立求解。不同网格可占据相同的空间区域。

19. 一旦使用`*ALE_STRUCTURED_MESH`生成ALE网格，就会调用S-ALE求解器并执行ALE对流时间步长。对于流固耦合，建议使用`*ALE_STRUCTURED_FSI`而不是`*CONSTRAINED_LAGRANGE_IN_SOLID`，因为前者具有更好的自动泄漏检测和控制功能，输入更清晰、更容易，专为S-ALE求解器设计。

20. `*ALE_STRUCTURED_MESH`关键字可以多次使用。每次都会构建一个独立的网格。这些网格可以占据不同或相同的空间域，模拟在这些网格中独立执行。

21. 原有ALE求解器中的边界条件例如：无反射边界`*BOUNDARY_NON_REFLECTING`，节点约束`*BOUNDARY_SPC`，给定运动边界`*BOUNDARY_PRESCRIBED_MOTION`，施加压力`*LOAD_SEGMENT`。同样适用于S-ALE，但定义过程稍有不同。

22. 无反射边界的定义流程：

    1. 通过`*SET_SEGMENT_GENERAL`的OPTION参数（取值为SALEFAC边界面或SALECPT指定节点编号范围）定义Segment Set。

    2. 通过`*BOUNDARY_NON_REFLECTING`将Segment Set定义为无反射面。

23. 节点约束的定义流程：

    1. 通过`*DEFINE_BOX`定义一个区域，把要约束的点都框进去，然后通过`*SET_NODE_GENERAL`将BOX内的节点定义成Node Set。
    2. 也可以通过`*SET_NODE_GENERAL`的OPTION参数（取值为SALEFAC或SALECPT）定义成Node Set。
    3. 通过`*BOUNDARY_SPC`约束Node Set中的某些自由。

24. 注意只有OPTION=SALEFAC或SALECPT才会将S-ALE的node或segment包含到Set中，使用BOX只会包含拉格朗日节点。

25. `*BOUNDARY_SALE_MESH_FACE`可以简化对ALE网格施加边界条件。


# 并行计算

1. SMP并行计算，参与计算的多个核共享同一内存空间，也就是说内存的地址对于每个核是一致的，都可以直接读写。运行的机器可以看作多核的一台独立的机器，也可以是插在同一块主板上的多个CPU，这在服务器领域比较常见，他们共享主板上的内存。

2. DYNA的SMP一般使用OPENMP指令实现。它是由开发者至于一段程序之前的指令，这个指令通知编译器，这段程序的数据之间没有相关性，可以被并行执行。一般是循环或独立的子程序。提高加速比的关键在于将尽可能多的循环或子程序SMP化，尽量减少串行编码的比例。

3. S-ALE支持SMP，MPP和HYBRID并行计算。原有的ALE求解器在并行计算方面存在严重的缺陷，无法实现SMP并行计算。MPP虽然能实现，但是并行效率低。S-ALE在设计时就考虑这些问题，所有算法和实现都采用了对并行计算最优的选择，S-ALE成功实现了SMP并行，加速比很高，实现了计算结果的一致性。在MPP方面，重新设计了MPP通信模式，使得S-ALE相比原有ALE运行速度提高很多，可扩展性也很优异。

4. ALE求解器本身非常耗时，这是因为额外的输运时间步包括非常多的计算量，这些计算大多每次都牵涉到同时进行2个单元的操作。这样每个单元的数据处理必须依靠它相邻的6个单元，数据处理不能以单元为单位，像拉格朗日单元处理那样独立进行。正是因为这些困难，原有的ALE求解器才没有将输运过程SMP化，尽管它耗时最多。

5. 新的S-ALE求解器在实现时考虑了SMP化的需求，改变了输运过程的计算方法，实现了输运过程的SMP化。保证了计算结果的一致性，也就是说计算结果和使用多少核心无关。

6. SMP使用命令如下：

   ```shell
   LSDYNA i=main.k ncpu=-4 jobid=smp4 #其中-4表示使用4个cpu并需要保证结果一致。S-ALE只支持结果一致选项，即ncpu=-4而非ncpu=4。使用后者不会在S-ALE求解器中带来任何加速。
   ```

7. MPP和SMP完全不同，SMP试图尽可能地把大部分的程序并行化，这一过程中必定有一些程序只能串行执行，但往往是这些只能顺序执行的部分严重阻碍并行效率的提高，这就是AmdahI's Law。

8. MPP的思路是将整个问题分解为多个块，分别放置在多个CPU上运行。这样程序本身做到了100%的并行。理论上并行效率可达到1，但是实际中，由于MPP的数据传输交换，并行效率可能远低于此。MPP分解到每个CPU上的子问题通常都不能作为独立问题求解，这些子问题间都是有着互相联系的，这些联系体现在算法上，就需要在各个子问题所在的CPU间进行数据传输。任意两个CPU间数据传输的大小由这两个CPU所含子问题的共有区域决定。例如拉格朗日问题中一个固体part被分在两个CPU上分别求解，那么在每个时间步长内，他们共有的节点量如速度，加速度，坐标就需要在这两个CPU间传输。

9. 原有的ALE和S-ALE求解器在传输数据的量上是一样的，但是S-ALE在实现时，对计算方法和步骤做了精心的设计，试图将数据传输尽可能地集中，以减少传输次数和等待时间，从而使得S-ALE的MPP并行效率和扩展性大为提高。

10. 对于大规模ALE问题，需要的ALE单元数量庞大，这样在MPP执行的初始阶段分解问题时，CPU0读入模型并创建数据库存储，它对内存的需求往往特别高。这也是MPP对内存要求最高的时候。随后大的完整模型被拆分为多个单独的小模型，并写成多个独立的输入文件，最后其他CPU再分别读入各自的输入文件，此时内存需求会大大减少。陈皓重构了S-ALE的初始化阶段，S-ALE网格只在初始化的最后阶段才产生，每个CPU只拥有各自的小模型，使内存需求大大减少。

11. MPP的命令如下：

    ```shell
    mpirun -np=4 mppDYNA i=main.k jobid=mpp4 #其中-np=4指明使用4个CPU。
    ```

12. 注意，由于问题被分解，截断误差使得不同数量的CPU的MPP计算结果无法保持一致。

13. HYBRID时MPP和SMP的简单复合，本身在实现上没有难度，体现是一种计算思想上的进步。对同一工程问题的不断细分，在每个CPU上的单元数越来越少，但是需要进行数据交换的节点越来越多，因此达到一定数量的CPU以后，MPP的加速比将不再增大，甚至有可能变低。

14. 当MPP接近饱和时，可以引入SMP，因为增加SMP线程的个数并不会增加MPP中交换的数据量。即使SMP的加速效率通常不如MPP，但是在MPP饱和的情况下，SMP就成了唯一的选择了。

15. S-ALE既支持MPP，又支持SMP，因此不同任何特殊处理，S-ALE就可以使用HYBRID。而旧的ALE求解器不支持SMP，因此不能使用HYBRID。

16. HYBRID的命令如下：

    ```shell
    mpirun -np=4 mppDYNA ncpu=-2 i=main.k jobid=mpp4s2 #指定使用4个MPP进程，每个MPP进程上运行2个SMP线程。
    ```

17. SMP的引入并不会导致结果不一致，因此HYBRID和MPP一样。

18. 运行HYBRID时，需要注意CPU绑定。这一绑定配置文件随系统而异。例如存在一个48核心的MPP机器，包含4个RANK，每个RANK有12个核心。运行时会希望同一个MPP进程的几个SMP线程尽可能分配在同一个RANK的核心上，否则运行效率会降低。


# SPH

1. 适用于如下问题：
   1. 材料变形较大，例如耐撞性、超高速冲击。

   2. 移动边界、自由表面，例如流固耦合。

   3. 适应性程序，例如锻造和挤压。
2. SPH的Part和结构接触时，需要使用Node to Surface，因为SPH只有Node，没有Surface。可以使用Part或Node set来指定接触的Slave部分。
3. SPH问题需要设置`*CONTROL_SPH`，指明问题的维度，即IDIM参数。
4. 可以先生成实体的壳单元表面，然后使用SPH Generation→Shell Volume来生成SPH粒子。输入材料的密度（这样才会给每个粒子分配质量），点击Set Params，还有每个方向的粒子数量，然后点击Create。然后就可以删除掉壳单元的表面了，分析的时候使用生成的sphnode的Part。
5. 可以使用菜单栏→Settings→General Settings→SPH/Particle来改变SPH粒子的显示样式。推荐Style改为smooth，调整一下小球的尺寸（Radius Scale）和精细程度（sphere divs）。
6. 如果在SPH Generation的方法选择Solid Nodes，来生成SPH的粒子，则一个节点只会对应生成一个粒子。
7. ISPH（不可压缩SPH）适用于较慢的流体流动模拟，如汽车涉水和变速箱润滑。
8. 使用`*DEFINE_ADAPTIVE_SOLID_TO_SPH`关键，可以在包含拉格朗日实体单元的part失效时，将拉格朗日实体part或part set自适应地转换为SPH粒子。每个失效单元将产生一个或多个SPH粒子（单元）。替换失效固体拉格朗日单元的SPH粒子继承了这些失效固体单元的所有拉格朗日节点量和所有拉格朗日积分点量。这些属性被分配给新激活的SPH粒子。



# 多阶段分析

1. 典型的DYNA模拟是一个具有初始条件的边值问题。它从初始时间0到适当的时间T结束求解。初始构型通常被假定为无应力，这基本上意味着所有活动特征中的所有内部变量都被轻松初始化。如果应用足够复杂，设置输入可能会很麻烦，由此产生的模拟也可能难以处理。此时，我们可以将整个问题分为几个阶段stage。一个stage与真实物理过程中一个孤立且定义明确的阶段相关联。每个stage需要满足：

   1. 任何功能中都没有出生或死亡时间

   2. 边界条件很少且简单

   3. 仅隐式或仅显式，不进行切换

   4. 使用具有简单曲线的明确载荷

2. 每个stage本身都是一个具有初始条件的边值问题。唯一需要注意的是，由于前一阶段发生的事情，初始构型现在可能会被预应力。换句话说，为了理解未来的结果，必须从上一阶段传播内部变量。除此之外，每个阶段都可以单独执行和研究，而不必在一次运行中完成整个模拟。

3. 多阶段分析的优点：

   1. 如果模拟失败，可以从最后一个成功的阶段重启动，而不是重新运行整个模拟。
   2. 某些阶段可能只需要整个模型的一个子集。因此，这种方法减少了模拟时间。例如车辆撞击柱子中，柱子的轴压力和重力载荷分析时就不需要考虑汽车。
   3. 一些part在某些阶段中可能是刚性的，从而节省了模拟时间。
   4. 一个阶段的数据可以重复用于后续许多不同类型的模拟，例如不同的负载情况和特征值分析。
   5. 预应力构件可以在后续阶段复制。例如车撞柱子中，只需要做一个柱子的预应力分析，然后可以复制出来多个柱子。

4. 除了阶段按顺序执行外，阶段的关系可以是树形状的。例如，假设您希望三个外部载荷中的每一个都独立地产生响应，但同时受到螺栓预载荷和重力载荷的影响。这样重力载荷产生的内部变量被导入到三种不同的载荷情况中。如果有足够的计算机资源，这三个负载情况可以并行执行。

5. 模拟特定阶段相当简单，但要解释内部变量是如何从一个阶段导出并导入到下一个阶段的。

6. dynain方法在经验丰富的LS-DYNA用户中是一个众所周知的概念，特别是在成形仿真社区中。常见的用法是将毛坯的几何形状和应力从成形模拟输出到一个名为dynain的文件中，然后将该文件包含在后续的模拟中，如回弹。这是多阶段分析的最简单形式，即在两个模拟之间转移应力。

7. dynain文件的格式可以是三种格式中的一种：

   1. ASCII，很受欢迎，因为可以在文本编辑器中打开它。然而它不能表示特定仿真结果的完整系统状态。系统状态不仅是应力和应变，而且是无缝继续该过程而不丢失任何信息所需的一切。特别是，它需要接触的状态，如摩擦历史和接触的信息。
   2. binary，二进制格式没有被广泛使用
   3. lsda，多阶段分析首选的格式，因为它处理了大多数内部变量以获得可接受的结果。

8. 可以使用*CASE关键字来自动进行多阶段分析。

   ```shell
   *KEYWORD
   #定义2个case及名称。
   *CASE
   1,BoltPreload
   *CASE
   3,LoadSide
   # 第一个case，不用引入lsda文件
   *CASE_BEGIN_1
   *INCLUDE
   BoltPreload.k
   *CASE_END_1
   # 第二个case，包含本体和之前分析的lsda
   *CASE_BEGIN_3
   *INCLUDE
   LoadSide.k
   BoltPreload.dynain.lsda
   *CASE_END_3
   #输出所有东西到lsda文件中
   *INTERFACE_SPRINGBACK_LSDYNA
   …
   *INTERFACE_SPRINGBACK_EXCLUDE
   BOUNDARY_SPC_NODE
   #这个边界会在所有stage都生效
   *BOUNDARY
   …
   *END
   ```


# 后处理

1. DYNA计算结果文件中的d3hsp（High speed printer）是ASCII格式，包含大量求解初始化和求解过程中输出信息，由于该文件通常特别大，用户直接打开搜索不太方便，因此可以使用PrePost读取该文件，Misc.→D3hsp以树和列表形式显示，还可以搜索。注意不在File→Open中打开。

2. 使用PrePost进行后处理时，只需要选择d3plot即可，后续的文件（d3plot01，……）会自动打开。

3. DYNA将每帧称为一个state，类似于Abaqus的frame。

4. ALE的问题求解完成后，默认只能看到背景网格（一般不变形），看不到流体运动，需要在Select Part中开启左侧的Fluid(ALE)才可以显示ALE Group。

5. ALE的背景网格如果为六面体，结果中的物质网格也可能是四面体。

6. ALE网格没有节点，因此在其上Pick Center会导致PrePost闪退。

7. 如果在求解没有完成时就查看结果，一般最后一帧的结果会非常失真，这是正常现象。

8. PrePost无法按照路径path绘制结果，例如一条线上的节点的某个方向的位移。只能选中它们，将位移和坐标关于时间的曲线都输出到文件中，然后组合起来，在画图软件中绘制。或者在K文件中使用`*HISTORY_NODE`将该线上的节点都包含进去，这支持比d3plot更高的频率。

9. 可以在菜单栏→Settings→General Settings→Local coordinate system中创建局部坐标系，来解释结果。需要在Post→Fringe的左下角将d3plot改为user，即使用用户坐标系（这一步需要同时打开K文件和d3plot文件才可以）。应用局部坐标系，会使得Fringe中的张量输出在局部坐标系下的分量，History和ASCII同理。

10. History→R-Nodal可以输出两个节点的特定变量的插值，例如接触面上相对应的2个点的坐标差值，这个也可以用曲线操作来实现。

11. History→Scalar可以输出当前显示的云图的量的曲线。

12. 云图可以绘制应变率的情况，在Post→Fringe，单击一个下的按钮可以展开，其中可以找到S.Rate。

13. ASCII→Load后，如果是elout，还会分类为stress，strain等，这个需要在All所在一列最下面选择。

14. 在Legend上右键可以直接修改其样式。

15. 可以在Measure中测量两点间的距离，也可以将它随时间变化的情况，绘制出来。

16. 可以使用Post→Trace来追踪特定节点的运动。使用Post→Follow来保持特定点不动，也就是相对运动。

17. AMMG中的历史变量输出信息会出现在message文件中

    ```
     *** Note history variables in lsprepost --> Fcomp -->misc
         history variable        1 to        3 belongs to AMMG        1
         history variable        4 to       14 belongs to AMMG        2
    ```

18. Prepost自带的曲线filter功能可以滤波，支持SAE和Butterworth等滤波器。SAE是美国汽车工程师学会的简称，它出台了一系列标准，旨在确保产品设计、制造和测试的一致性、安全性和可靠性。与车辆碰撞测试相关的标准为SAE J211，它规定了数据滤波的要求，最小采样频率，数据精度和单位，测试设备校准。

19. 常见的滤波器等级包括CFC 60、CFC 180、CFC 1000等，其中CFC（Channel Frequency Class）表示通道频率等级。例如，CFC 60的截止频率为100 Hz，CFC 1000的截止频率为1650 Hz。CFC滤波器通常基于Butterworth低通滤波器设计。

20. 

21. 

# 二次开发

1. 二次开发功能，支持自定义材料模型，状态方程，单元，求解控制，输入输出。二次开发可以调用所有的函数库和共享数据模块，从R9版本开始，二次开发可以使用动态链接库。DYNA可以加载和调用多个用户动态链接库，并按照用户规则将不同的库分配给相应的单元和模块。

2. 以前的LS-DYNA二次开发环境中Fortran只有一个代码很长的源程序文件，修改编译很不方便。2019年韩志东在原有二次开发环境上推出了极其友好的新一代二次开发环境，完全兼容原有开发环境。用户需要向LSTC申请二次开发所需的相关资料。

3. Linux下新开发环境还简化了用户子程序的编译链接过程，直接生成动态链接库，与LS-DYNA主程序完全脱离。主程序支持同时加载多个用户子程序的动态链接库，按用户规则调用，还新增了用户自定义关键字，模型参数化及自动生成等功能。

4. 原有的二次开发包内只有一个Fortran源文件，2万多行的dyn21.f，包括了材料本构模型，状态方程，单元算法，求解控制，载荷等内容。

5. Windows下的开发步骤：

   1. 用户从LSTC获取二次开发软件包，包含dyn21.f，libdyna.lib，*.inc，nmake.exe
   2. 与二次开发软件包匹配的编译系统，例如Intel Fortran
   3. 用户修改dyn21.f
   4. 编译程序生成可执行文件，如LS-DYNA.exe。

6. 二次开发中容易出错的地方是编译和链接过程。目前DYNA是将所有主程序的OBJ文件打包成库文件提供给用户，而这些OBJ文件是在DYNA的标准编译环境下编译出来的半成品二进制文件。然后用户在自己的开发环境中编译其子程序，与主程序的OBJ库链接生成函有用户子程序的LS-DYNA可执行程序。好处是：方便执行。容易出错的地方是用户的开发环境往往与DYNA的标准编译环境不一样，这会导致链接后的可执行程序无法正常工作。差别可能是：操作系统类别和版本，Fortran，C/C++编译器的版本及其所带的开发库。

7. DYNA预分配的用户材料号只有41到50这10种，对于多供应商的企业来说，这显然不够。

8. 从R11开始，DYNA将dyn21.f文件分割成多个文件，分别为每个模块提供现成的模板程序，用户根据需要修改相应的模块就可以实现二次开发。模板包括以下几类：

   1. 材料模型UMAT
   2. 热材料模型TUMAT
   3. 状态方程UEOS
   4. 单元UELEM
   5. 求解控制模块
   6. 输入输出模块

9. 全套的模板程序提供了很好的示例和开发基础，演示了在大变形，大转动及各种非线性下的高效编程。

10. 新版开发环境的特点：

    1. 主程序是一个可以进行独立分析的标准版可执行程序，与用户子程序完全分离，也不依赖任何用户子程序。主程序可以单独升级，同时保持对子程序的兼容性，子程序无需重新编译或链接。
    2. 子程序在用户开发环境下独立编译链接并生成动态库，保证了版本独立性和兼容性，无需和链接主程序同时升级。有时，动态链接库允许不同的Fortran编译器来编译链接。
    3. 用户可以根据模型需要，在模型文件内指定加载一个或多个动态库，并与模型种相应的part关联，实现动态调用。

11. DYNA中的用户材料号是从41到50号，受关键字`*MAT_USER_DEFINED_MATERIAL_MODELS`控制，所有用户材料主程序的统一入口是dyn21umat.f中的：

    ```fortran
    subroutine usrmat(lft,llt,cm,bqs,capa,eltype,mt,ipt,npc,plc,crv,nnpcrv,rcoor,scoor,tcoor,nnm1,nip,ipt_thk)
    ```

12. 进入这个子程序后，再根据不同的单元类型选择不同的材料子程序，这三个子程序根据各自单元的特点对应力应变进行相应的处理，再进入具体的用户子程序umat41，umat41，……umat50。

    1. urmathn，实体，厚壳，SPH单元的三维材料
    2. urmats，壳单元的二维平面应力材料
    3. urmatb，urmatd，urmatt，三种不同的梁单元

13. 这10个子程序是标准的串行版本模板，如果对计算效率要求较高，用户可以选择对应的矢量版本模板umat41v，umat42v，……umat50v。矢量程序的特点是利用CPU的向量指令集，一次对多个操作数同时运算，例如一个128位宽的指令可以同时对4个32位的单精度实数进行运算。

14. 如果想要进行隐式分析，还需要该材料的切线刚度矩阵子程序，不同单元的入口子程序分别为：

    1. urtanhn，实体，厚壳，SPH单元的三维材料
    2. urmats，壳单元的二维平面应力材料
    3. urtanb三种不同的梁单元

15. 从这三个子程序后续进入的材料程序分别为：utan41，utan42，……，utan50，或其相应的矢量版本。

16. 如果该材料需要支持DYNA的内聚单元（cohesive），则用户还需要开发对应的用户内聚材料子程序。统一入口再dyna21b.f。进入后转入相应的具体内聚材料子程序umat41c，umat42c，……，umat50c。

17. 热材料模型的材料号是从11到15号。由关键字`*MAT_THERMAL_USER_DEFINED`。统一入口是dyn21b.f的如下函数：

    ```fortran
    subroutine thusrmat(mt,c1,c2,c3,cvl,dcvdtl,hsrcl,dhsrcdtl,hsv,iphsv,r_matp,crv,nnpcrv,npc,plc,nel,nep,iep,eltype,dt,atimes,ihsrcl,hsvm,nmecon,temp,hsv2,hstored)
    ```

18. 相应的用户热材料模型子程序位thumat11，thumat12，……，thumat15，没有单独的矢量版本。

19. 默认，DYNA主程序进行计算时不加载任何用户动态链接库，当模型需要调用某个动态链接库时，可以在原来的K文件中加入一个新的关键字`*MODULE_LOAD`来实现加载。

20. 与隐式算法相比，显式计算的步长很小，导致对用户子程序的调用非常频繁。DYNA在内部采用批处理的方式调用子程序，要求一次调用能处理几百个单元，这也为用户子程序实现矢量化计算提供了方便。

21. 可以通过dyn21.F中的`uctrl1`控制I/O，监控能量和其他感兴趣的解，并随时关闭求解器。此子程序在每个时间步调用，不需要任何card来操作。

22. 新版二次开发包包括以下三个内容：

    1. 各个用户子程序的模板，Fortran源程序，包括dyn21.f，dyn21b.f等
    2. 头文件，也是Fortran源程序，包括dyn21.f中各个COMMON BLOCK参数，供二次开发使用。
    3. 编译脚本Makefile。主要用于设置环境变量。

23. 可以对源程序进行跟踪调试，只需将编译脚本中的-O2改为-g，即可取消编译器的优化，添加调试信息。调试MPP版本时，应避免mpirun启动多进程，而应在gdb中加载主程序，并在用户子程序中设置断点。再使用r命令启动DYNA进入单进程模式运行。

    ```shell
    set breakpoint pending on
    break <source file name>:<line number>
    ```

24. DYNA默认不加载任何用户的动态链接库，需要手动在K文件中添加`*MODULE_LOAD`关键字，在其中给定动态链接库的绝对或相对路径。可以使用`*MODULE_PATH`来指定动态库的路径，类似于Path。

25. 如果只有一个动态库，DYNA会将所有对子程序的需求都转入到这个动态库中。

26. 如果有多个动态库，每个都需要通过`*MODULE_LOAD`关键字加载。还需要使用`*MODULE_USE`定义各种调用规则，把对用户子程序的调用转到对应的动态库中。

27. 
