# 基础

1. 数据库就是相互有关联关系的数据的集合。起源于对表的处理。
2. 数据库管理员（DBA）通过数据库管理系统（DBMS）来管理数据库。一般使用SQL。
3. 普通用户通过数据库应用（DBAP）来使用数据库。通过鼠标键盘点选。
4. 数据库管理系统能够创建表，操作表中的数据（增删改查），对数据的访问设置权限限制。是一种系统软件。
5. 常见的数据库管理系统：Oracle，DB 2，MS SQL Server，MySQL。
6. <img src="数据库系统.assets/image-20210520132556030.png" alt="image-20210520132556030" style="zoom:67%;" />
7. 数据库语言包括数据定义，数据操纵，数据控制语言。一条数据库语句相当于高级语言的一个或多个循环。数据库语言可以嵌入到高级语言中使用。
8. 数据结构是将内存中的数据存储，数据库主要是外存。
9. 表的构成要素：
10. <img src="数据库系统.assets/image-20210520130953870.png" alt="image-20210520130953870" style="zoom:67%;" />

# 数据模型

1. DBMS管理数据的三个层次：
   1. 用户层，外模式：某一个用户只能看到全局数据的一部分。
   2. 概念层，逻辑模式，全局模式：从全局角度查看。
   3. 内部层，内模式：反应存储在介质上的数据。
2. 上面三个模式之间有两层映像，E-C和C-I映像。分层的设计可以保证物理和逻辑独立性。
3. 数据是有结构的，视图是某一种表现形式下的数据库中的数据。
4. 模式是描述数据的结构。数据模型是模式的结构。
5. ![image-20210520134235845](数据库系统.assets/image-20210520134235845.png)
6. 三大经典的数据模型：
   1. 关系模型，基于表来组织数据。
   2. 层次模型，基于树来组织数据。
   3. 网状模型，基于图来组织数据。
7. 层次模型和网状模型都需要维护复杂的指针系统，而且是需要用户建立的。关系模型类似于数组，而前两者类似于链表。
8. 数据库系统比文件好的点在于：它可以为操作数据库提供统一接口，可以对数据进行控制。
9. 关系型数据库是按照行列来组织数据的，满足关系的第一范式：即数据项不可再分，例如一个字段为地址，不可以分为省份和市区。
10. 面向对象的数据库可以支持不满足第一范数的数据项，例如：
11. ![image-20210520135731636](数据库系统.assets/image-20210520135731636.png)
12. XML数据库是为了进行数据交换提出的，被称为半结构化的数据库。
13. ODBC （开放数据库互联），Java环境下称为JDBC。应用程序员只需要和ODBC交互即可。ODBC会自动和不同的dmbs交互。

# 关系模型

1. 标准的数据库语言SQL就是建立在关系模型之上的。

2. 关系模型就是处理表的，由三个部分组成：

   1. 如何描述一个表，结构形式。
   2. 对表，表和表之间有哪些操作。
   3. 操作应当遵循的约束。实体完整性，参照完整性，用户自定义完整性。

3. 关系操作：![image-20210520140900988](数据库系统.assets/image-20210520140900988.png)

4. 关系代数是基于集合的操作。

5. 域是一组具有相同类型的值的集合，例如整数的集合，全体学生的集合。集合中元素的个数称为域的基数。

6. n个域之间可以进行笛卡尔积运算，得到n元组的集合。元组的个数=各个域的基数的乘积。

7. 笛卡尔积的元组并不都是有意义的。关系是一组域的笛卡尔积的子集。为了表示关系的含义，可以为关系中的每一列起一个属性名。属性名不等于域名。属性名是和关系紧密结合的。

8. ![image-20210520141848356](数据库系统.assets/image-20210520141848356.png)

9. 关系的描述：R(A1:D1,A2:D2,...,An:Dn)，可以简记为R(A1,A2,...,An)。R是关系的名字，Ai是属性名，Di是属性所对应的域，n是关系的度，关系中元组的数目称为关系的基数。上面的家庭关系就可以描述为    家庭(丈夫:男人,妻子:女人,子女:儿童)。

10. 关系中属性向域的映像可以直接声明为属性的类型和长度，例如：

    ```sql
    Student(S# char(8),Sname char(10),Ssex char(2),Sage integer)
    ```

11. 关系要求列是同质的。即一列中的数据应该是来自同一个域，类型相同。

12. 不同的列可以来自同一个域。例如上面的表格，可以定义一个所有人的域，这样三列都来自这个域。

13. 关系中，行列位置是无关的。关系中任意两个元组不能完全相同。不过现实中，表可能不完全遵守这个特性。

14. 关系要满足第一范式，即属性不可再分。

15. 候选码（键）：关系中能够唯一标识一个元组的属性组。例如在学生成绩表中，学号属性就是候选码，姓名不是。而在选课成绩表中，学号或课程号都不能唯一标识一条选课记录，因为一个学生可能选了多门课，一门课也会有多个学生选择。但是(学号，课程号)联合起来就可以当做候选码了，因为一个学生对于一门课程只能选一次。

16. 在创建一个关系的时候，要确定候选码是那一列。后续的操作也尽量不要改变候选码。

17. 有时候一个关系中可以有多个候选码，例如学生信息表中，学号和身份证号都是候选码。

18. 当一个关系有多个候选码时，需要选择一个作为主码（主键）。DBMS通常以主键作为线索来管理各个元组的。

19. 包含在任何一个候选码中的属性称为主属性，否则称为非主属性。例如在选课表(S#, C#, Sname, Cname)中，由于(S#, C#)构成主码，因此S#和C#都是主属性，其余的不参与构成主码，因此都是非主属性。

20. 在教师授课表(T#, C#)中，(T#, C#)构成一个主码，因此T#和C#都是主属性。这个称为全码关系。

21. 外码：关系R中的一个属性组，不是R中的候选码，但是是另一个关系S的候选码。称它为R的外码。

22. ![image-20210520145455621](数据库系统.assets/image-20210520145455621.png)

23. 两个关系通常是靠外码连接起来的。将两个表中的对应元组连接成一个大的元组。

24. 完整性约束规则：

    1. 实体完整性：关系的主码中的属性值不能为空（不知道或无意义的值）。对于空值需要特殊处理。
    2. 参照完整性：如果关系R的外码F和关系S的主码P相对应，R中元组的F的取值不能超出S中P的取值，但可以是空值。这样规定是为了保证关系连接的正确性。主码具有全局性。
    3. 用户自定义完整性：例如用户要求Sage取值在18-25之间。

25. DBMS会在修改数据时检查是否满足完整性。

# 关系代数

1. 关系代数是以集合为中心的操作。输入是一个或多个关系，输出为一个关系。

2. 关系代数是SQL语言的基础。

3. 关系代数的操作可以分为两类：集合操作和纯关系操作。

4. <img src="数据库系统.assets/image-20210520151847690.png" alt="image-20210520151847690" style="zoom:50%;" />

5. 并，差，交操作需要满足并相容性。

6. 假设：$R(A1,A2,\cdots,An)$，$S(B1,B2,\cdots,Bm)$。R和S满足并相容性则$n=m$且Domain(Ai)=Domain(Bi)。

7. 例如：

   ```sql
   Student (S# char(10), Sname char(10),Age char (3))
   Professor (P# char(10),Pname char(10),Age char(3))       ;这两种关系满足并相容性。
   ```

8. 并运算：$R\cup S=\{t|t\in R\vee t\in S\}$是一个新的关系，它由或者出现在R，或者出现在S中的元组组成。合并时要去掉重复的元组。$R\cup S=S\cup R$。

9. 差运算：$R-S=\{t|t\in R\wedge t\notin S\}$。$R-S\ne S-R$。

10. 广义笛卡尔积：$R\times S$由R中的元组和S中的元组进行所有有可能的拼接构成。度数相加，数目相乘。

11. <img src="数据库系统.assets/image-20210520153625475.png" alt="image-20210520153625475" style="zoom:50%;" />

12. 在操作多个表时，需要将这些个表串接起来才能检索。$R\times S=S\times R$。

13. 选择操作：$\sigma_{con}(R)=\{t|t\in R\wedge con(t)=真\}$。是纯关系操作。从给定的关系R中挑选出满足条件con的元组，构成一个新的关系。

14. 设R(A1,A2,...,An)是一个关系，t是R的元组。t的分量记为t[Ai]，或简写为Ai。

15. 条件con由逻辑运算符连接比较表达式组成。

16. 逻辑运算符有与$\wedge$，或$\vee$，非$\neg$。比较运算符有>，>=，<，<=，=，<>。

17. ![image-20210520154636690](数据库系统.assets/image-20210520154636690.png)

18. 投影操作：$\Pi_A(R)$从关系R中选出属性包含在A中的列。投影运算可以对原关系的列在投影后重新排列。投影后的关系可能出现重复的元组，需要消除掉。

19. ![image-20210520155303214](数据库系统.assets/image-20210520155303214.png)

20. 交运算：$R\cap S=\{t|t\in R\wedge t\in S\}$。$R\cap S=R-(R-S)=S-(S-R)$。

21. $\theta-$连接运算：将多个表连接成一个表。由从R与S的笛卡尔积中，选取R中属性A和S中属性B之间满足$\theta$关系的元组。要求两个属性具有可比性。

22. ![image-20210520160652884](数据库系统.assets/image-20210520160652884.png)

23. <img src="数据库系统.assets/image-20210520160822310.png" alt="image-20210520160822310" style="zoom:67%;" />

24. 可以将自己和自己做$\theta-$连接。此时需要进行更名操作，方便引用。

25. 如下问题，先连接两个表，条件为课程名称相同的，连接后一共有3+3+4+3+4+3+4+3+3+4=34个元组。然后在过滤姓名分别101和202的元组。

26. <img src="数据库系统.assets/image-20210520161541582.png" alt="image-20210520161541582" style="zoom:67%;" />

27. DBMS可以直接进行连接操作，书写SQL语句时，没必要分成笛卡尔积+选择操作。

28. 等值连接是一种特殊的$\theta-$连接，即$\theta$为=。自然连接，是一种特殊的等值连接。会从R和S的笛卡尔积中，选取相同属性B上值相等的元组。连接完成后，去掉任意一个B列即可。

29. <img src="数据库系统.assets/image-20210520162607273.png" alt="image-20210520162607273" style="zoom:67%;" />

30. 关系自己和自己做自然连接，结果还是关系自己。

31. 除运算：关系R除以关系S的结果还是一个关系R/S，R/S的属性为R中的属性去除掉S中的属性。R/S的任意一个元组满足和S中的每一个元组的组合都在R中。R/S的前提是S中的属性是R的属性的真子集。

32. ![image-20210521004307667](数据库系统.assets/image-20210521004307667.png)

33. 用数学语言表示：![image-20210521004452138](数据库系统.assets/image-20210521004452138.png)

34. 除法运算通常用在查询 ...全部的... 例如：查询选修了全部课程的学生的学号$\Pi_{S\#,c\#}(SC)\div\Pi_{C\#}(Course)$。

35. 外连接：有如下三个关系Teacher(T#, Tname, Salary)，Course(C#, Cname)，Teach(T#, C#)。请列出所有老师的有关信息，包括姓名，工资，所教课程。不能直接做自然连接，因为会可能会丢失信息，例如003号老师没有教授任何课程，但是也应该列出他的信息（没讲课）。

36. ![image-20210521010250037](数据库系统.assets/image-20210521010250037.png)

37. 此时需要外连接：关系R和S进行外连接时，如果R中的元组在S中找不到匹配的，则不会忽略该元组，而是认为该元组和S中的空值元祖匹配。以保持R中的每一个元组在新的连接中都有对应。

38. 外连接是有方向的：

39. ![image-20210521010952715](数据库系统.assets/image-20210521010952715.png)

# 关系代数练习

1. 练习，以下问题使用到了这三个关系：Student(S#, Sname, Ssex, Sage, D#, Sclass)，SC(S#, C#, Score)，Course(C#, Cname, Chours, Credit, T#)。 可见Student表的主键为S#，SC表的主键为(S#, C#)。Course表的主键为C#。
2. ![image-20210521001929016](数据库系统.assets/image-20210521001929016.png)
3. ==查询学过==002课程的学生的学号和成绩。设计Student和SC两个关系，先将他们做自然连接，依靠共有的S#属性。但是SC表中S#不是候选码，即存在重复的。所以自然连接后一共有3+3+1+1+3+1=12个元组。然后再进行选择和投影即可。
4. 查询至少学习过001和002号课程的学生的学号：不能用如下语句：
5. ![image-20210520163551804](数据库系统.assets/image-20210520163551804.png)
6. 因为对于选择操作来说，一个元组的课程号不能同时为001和002。因此上述语句的结果为空。应该用连接操作：
7. ![image-20210520163743860](数据库系统.assets/image-20210520163743860.png)
8. 上面链接操作完毕后，结果中元组是成对存在的。因此选择操作的时候只用写一半即可，不需要写SC.C#="002"$\wedge$SC1.C#="001"。
9. 上述问题还可以用交运算来解决：![image-20210520164408037](数据库系统.assets/image-20210520164408037.png)
10. 查询不学习002课程的学生的姓名和年龄，错误的作法如下：![image-20210521002702719](数据库系统.assets/image-20210521002702719.png)
11. 因为一个学生可以选学多门课程。这样做会扩大范围。
12. 另一个错误的作法如下：![image-20210521002845204](数据库系统.assets/image-20210521002845204.png)，因为差运算的两端不满足相容性。将投影操作分别作用于这两个关系，然后再做差即可。
13. 也可以用如下操作：先在SC关系中，选择C#='002'，再投影到S#，得到不学习002课程的学生的学号集合A。然后Student关系中查找所有$S\#\in A$中的元组。最后的这一个操作可以用Student和A的连接来完成。
14. 查询选修了学号为98030201学生所学全部课程的同学的姓名。操作如下：
15. ![image-20210521005812923](数据库系统.assets/image-20210521005812923.png)

# 关系演算

1. 关系演算是以数理逻辑中的谓词逻辑为基础的。根据谓词变量的不同，可以分为关系元组演算和关系域演算。

## 元组演算

1. 元组演算的基本形式：$\{t|P(t)\}$。所有使得谓词P为真的元组t的集合。以元组为单位，循环地遍历关系。
2. 元组演算的原子公式：
   1. $s\in R$
   2. $s[A]\theta c$，$\theta$一般为比较运算符
   3. $s[A]\theta u[B]$
3. 存在量词和全称量词。存在量词的情况是，只要R中存在一个元组使得P(t)为真，那么整个公式就为真，否则为假。
4. ![image-20210521083543079](数据库系统.assets/image-20210521083543079.png)
5. 量词的范围和公司中的部分条件有时候可以互换，小范围中找满足简单条件或者是大范围中找满足复杂条件的元组。
6. 检索出年龄不是最小的所有同学：<img src="数据库系统.assets/image-20210521083922047.png" alt="image-20210521083922047" style="zoom:80%;" />即只要存在年龄比他还小的同学即可。上述演算公式用关系代数可以表示为：
7. ![image-20210521085234971](数据库系统.assets/image-20210521085234971.png)
8. 运算符的优先级：![image-20210521084517251](数据库系统.assets/image-20210521084517251.png)
9. 涉及多个关系的查询：检索出所有课程都及格的学生。
10. ![image-20210521085544136](数据库系统.assets/image-20210521085544136.png)
11. ==错误的写法==如下，全称量词的范围扩大到所有的SC元组了，而对于任意$t\in$Student，SC中肯定存在u，使得t[S#]<>u[S#]，因此结果会大大缩小。
12. ![image-20210521085757926](数据库系统.assets/image-20210521085757926.png)
13. 检索学过所有课程的同学：先将Student和SC表连接起来，然后根据每一个学生来查询他选的课程C#是否等于Course表中的每一项C#。下面的这个思路为两个量词的联合使用。
14. ![image-20210521091548514](数据库系统.assets/image-20210521091548514.png)
15. 检索所有同学所有课程都及格的系，先根据系来确定该系的所有学生。然后对该学生的所有课程进行验证。
16. ![image-20210521091826636](数据库系统.assets/image-20210521091826636.png)
17. 德摩根律：
18. ![image-20210521092656627](数据库系统.assets/image-20210521092656627.png)
19. 查询或者学过001或者学过002课程的所有学生。可以用或运算符表示，下面的式子还应该投影到S#才可以去重。
20. ![image-20210521093055824](数据库系统.assets/image-20210521093055824.png)
21. 也可以从所有学生中去除掉既没学过001又没学过002课程的学生即可。先表示既没学过001又没学过002课程的学生：$\{ u\in SC|\forall (t\in SC\wedge t.s\#=u.S\#)(t.C\#<>001\wedge t.C\#<>002)  \}$。然后投影到S#，再从所有学生中去除即可。
22. ==错误==的作法：![image-20210521094026447](数据库系统.assets/image-20210521094026447.png)，根据德摩根律，该式可以变化为$\{ u|u\in SC \wedge u[C\#]=001 \vee u[C\#]=002 \}$。
23. 带量词的否定：
24. ![image-20210521095206562](数据库系统.assets/image-20210521095206562.png)
25. 例如：对于所有的x$\in$R，x>3   这个命题的否定为 存在x$\in$R，x<=3。
26. 元组演算可以和关系代数==有条件地==相互转化。

## 域演算

1. 域演算和元组演算不同的是，它是以域变量为操作对象的。它是对域的所有值进行循环遍历的。域演算是非过程化的，更适合于用户使用。
2. 检索不是03系的所有学生：$\{ <a,b,c,d,e,f>|<a,b,c,d,e,f>\in Student \wedge e<>03 \}$。范围是所有域变量取值的组合。
3. 域演算的QBE语言，方便一般用户使用，提供基于表格的查询，不用填写复杂的公式。
4. ![image-20210521101525045](数据库系统.assets/image-20210521101525045.png)
5. 查询条件中等号可以省略，不同属性的与条件写在同一行，或条件写在不同行。使用实例元素X进行投影操作。
6. ![image-20210521101901434](数据库系统.assets/image-20210521101901434.png)
7. 在不同的表中使用相同的示例元素时，表示连接：
8. ![image-20210521102219325](数据库系统.assets/image-20210521102219325.png)

## 关系演算的安全性

1. 不产生无限关系和无穷验证的运算称为是安全的。
2. 关系代数是集合运算，是安全的。有限集合的有限次运算的结果仍然是有限的。
3. 关系验算不一定是安全的。例如$\{ t|\neg(R(t)) \}$。R(t)是有限的，非R(t)可能是无限的。
4. 一个数据库语言如果能等价地实现三种关系运算的操作，就称改语言是完备的。