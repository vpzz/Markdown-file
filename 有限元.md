# 矩阵位移法

1. 推导：普通杆件的单元刚度方程，可以通过最小势能原理得出，当应变能-外力功取驻值时，单元平衡。

2. 

3. 

4. 

5. 

6. 

7. 

8. 

9. 二维矩阵位移法的一个例子：

   ```python
   输入数据K文件主要包含如下，所有的列表都是numpy.ndarray类型。
   #节点编号Nodes为：[[0,0],[1,0],[0.5,0.866]]，分别为1，2，3号节点
   #单元编号Elements为：[[1,2],[2,3],[3,1]] 分别为1，2，3号单元，单元内的节点编号也很重要。
   #单元类型ElementsType：[1,1,1] 目前只有一种类型就是二力杆(编号为1)
   #荷载Loads：[[0,0],[0,0],[0,100]]，目前只支持节点的单个集中荷载，分别对应1，2，3号各个节点的。
   #边界条件BoundaryConditions：[[0,0],[None,0],[None,None]]，
   ```

10. 代码：

   ```python
   # 应该从输入数据K文件中读取，不过目前使用手动输入，为了使用矩阵的运算，所有列表都是numpy.ndarray类型。
   import numpy as np
   from math import *
   #节点坐标，边界条件，荷载向量都是全局坐标系下的结果
   Nodes = np.array([[0, 0], [1, 0], [0.5, sqrt(3)/2]])  # 节点编号，分别为0，1，2号节点
   Elements = np.array([[0, 1], [1, 2], [2, 0]])  # 单元编号，分别为0，1，2号单元
   ElementTypes = np.array([0, 0, 0])  # 单元类型，目前只有一种类型就是二力杆(编号为0)
   #材料模型，0号表示线弹性各向同性
   Loads = np.array([[0, 0], [0, 0], [0, 100]])  # 荷载，目前只支持节点的集中荷载，分别对应0，1，2号各个节点的
   BoundaryConditions = np.array([[0, 0], [None, 0], [None, None]])  # 边界条件，目前只支持节点的固定位移约束
   ElementStiffness_0_local = np.array([[1, -1], [-1, 1]])  # 0类型单元的局部单元刚度矩阵
   # 获取单元倾角
   def cos_sin(a, b):  # a,b分别为2个点的坐标，例如[0,0]和[3,4]，结果为(0.6,0.8)
       L = hypot(b[0]-a[0], b[1]-a[1])  # 根据直角边，求斜边长
       return (b[0]-a[0])/L, (b[1]-a[1])/L
   # 坐标变换矩阵T
   def T(ElementNumber):
       ElementType = ElementTypes[ElementNumber]
       if (ElementType == 0):
           cosAlpha, sinAlpha = cos_sin(
               Nodes[Elements[ElementNumber][0]], Nodes[Elements[ElementNumber][1]])
           return np.array([[cosAlpha, sinAlpha, 0, 0], [0, 0, cosAlpha, sinAlpha]])
   # 整体坐标系下的单元刚度矩阵
   def K(ElementNumber):
       ElementType = ElementTypes[ElementNumber]
       if (ElementType == 0):
           T0 = T(ElementNumber)
           a = Nodes[Elements[ElementNumber][0]]
           b = Nodes[Elements[ElementNumber][1]]
           return np.dot(np.dot(T0.transpose(), ElementStiffness_0_local), T0)*(200*10**9 * 0.001/hypot(b[0]-a[0], b[1]-a[1]))
   #由单元刚度矩阵组装成整体刚度矩阵时，需要进行逆切片，也就是说把单元刚度矩阵当作整体刚度矩阵的切片，还原回去。
   #假设单元刚度矩阵对应的自由度编号为a，例如[0,1,2,3]
   #
   #逆切片
   def TranslateElementStiffness(ElementNumber):
       ElementType = ElementTypes[ElementNumber]
       if (ElementType == 0):
           FullMatrix = np.zeros((len(Nodes)*2,len(Nodes)*2), np.float32)
           tmp = []
           for i in Elements[ElementNumber]:
               tmp += [2*i, 2*i+1]
           FullMatrix[np.ix_(tmp, tmp)] = K(ElementNumber)
       return FullMatrix
   #构造整体刚度矩阵
   def constructGlobalStiffness():
       GlobalStiffness = np.zeros((len(Nodes)*2,len(Nodes)*2), np.float32)
       for ElementNumber in range(len(Elements)):
           GlobalStiffness += TranslateElementStiffness(ElementNumber)
       return GlobalStiffness
   #处理边界条件
   def TreateBCs(GlobalStiffness, Loads):
       tmp = CalculatePrescribed()
       TreatedGlobalStiffness = np.zeros((len(tmp),len(tmp)), np.float32)
       TreatedGlobalStiffness = GlobalStiffness[np.ix_(tmp, tmp)]
       TreatedLoads = np.zeros(len(tmp), np.float32)
       TreatedLoads = Loads.reshape(-1,1)[np.ix_(tmp)]
       return TreatedGlobalStiffness, TreatedLoads
   #已知边界条件对应的自由度编号
   def CalculatePrescribed():
       Prescribed = []
       for i in range(2*len(BoundaryConditions)):
           if(BoundaryConditions.reshape(-1)[i] == None):
               Prescribed += [i]
       return Prescribed
   
   GlobalStiffness = constructGlobalStiffness()
   TreatedGlobalStiffness, TreatedLoads= TreateBCs(GlobalStiffness, Loads)
   utmp = np.linalg.solve(TreatedGlobalStiffness, TreatedLoads)
   u = np.zeros((len(Nodes)*2,1), np.float32)
   Prescribed = CalculatePrescribed()
   u[np.ix_(Prescribed)] = utmp
   ```

11. 

12. 

13. 

14. 

15. 

16. 

17. 

18. 