# 预备知识

1. 有限元的网格由单元构成，相邻单元仅在共享的节点上彼此相连，单元的面和边是各自的，不一定共享。
2. 数学上来说，有限元是将一个连续的无限自由度问题，转化成了离散的有限自由度问题了。一旦求得有限节点上的自由度后，单元内部的值通过插值获得。
3. 如果单元满足收敛要求，则随着单元尺寸的变小，近似解将逐步趋于精确解。
4. 运动方程描述的是：应力和体积力之间的关系。物体处于平衡状态$\Leftrightarrow$运动方程的加速度项为0。
5. 几何方程描述的是：应变与位移的关系。
6. 本构（物理）方程描述的是：应力与应变的关系。
7. 在微小变形下，一个点的6个应变分量可用位移表示。
8. 最简单的材料是：各向同性均匀线弹性，其弹性矩阵可以由$E,G,\nu,\lambda,\mu$中任意两个表示。后两个为拉梅系数。
   1. 各向同性：材料在各个方向的行为都是一样的，例如沿各个方向进行拉伸。类似于一个球形，各个轴都是主轴。
   2. 均匀：不同位置的材料性质都一样，即描述材料性质的参数对空间的导数为0。
   3. 弹性：外力撤去后，变形能够完全恢复。
   4. 线性：材料的应力和应变呈线性关系。
9. 拉梅系数$\lambda,\mu$的换算关系：$\lambda=\frac{E\nu}{(1+\nu)(1-2\nu)}$，$\mu=\frac{E}{2(1+\nu)}$。其中$\nu$为泊松比。
10. 如果使用应力作为基本未知量来求解，就不再需要几何方程了，应变是通过本构关系得到的。此时应变还需要满足变形协调方程。如果使用位移作为基本未知量来求解，通过几何方程得到的应变是天然满足变形协调方程的。
11. 应力边界上的表面力需要在整体坐标系上进行分解，不考虑受压或受拉为正的情况。但是应力的正向总是使得分离体受拉为正。想想一下，在表面力边界附近切出一个薄层，右侧作用这表面力，左侧作用着爆露出来的是沿该方向的应力。左侧面上应力的正方向为向左，右侧面上表面力的正方向为全局的正方向，向右。因此$f_t=L\sigma$。上面的分析中，交换左右也是一样的结果。
12. 应力边界条件实际上是，应力作用处的薄层的各向受力平衡，由于薄层的尺寸很小，因此不用考虑力矩平衡。
13. 虚位移的偏导数：$\frac{\partial \delta u}{\partial x}$，虚应变：$\delta\varepsilon=\delta\frac{\partial u}{\partial x}$。由于变分和微分是可交换的，因此认为二者相等。
14. 
15. 
16. 
17. 
18. 
19. 
20. 
21. 
22. 
23. 
24. 
25. 位移和变形的关系：变形可以看作是位移的导数，因此大变形和大位移并没有必然的联系。
    1. 鱼竿受力时，为大位移+小变形，需要鱼竿弯曲较为明显时才可以。
    2. 悬臂柱偏心受压，柱顶侧向位移不需要很大时，轴力产生的弯矩就不可忽略，即P-Δ效应。和鱼竿受力的区别在于，前者的位移和荷载可以认为是线性的，即使在大位移的情况下，而后者是非线性，即使位移不大的情况下。
    3. 蹦床受力，挠度大时会产生薄膜应力，该应力向上的分量不可忽略，为大位移+大变形。
26. 在非线性体系中，唯一性定理和叠加原理不成立。
27. 几何非线性问题，都需要在变形后的构型上建立平衡方程。但是变形后的构型正是待求的，可以逐步加载，例如将荷载分为10份，产生10个荷载的增量，在未变形构型上施加第一个荷载增量，计算出第一个位移增量，每次都在前一个变形构型的基础上增加荷载增量，然后计算位移增量。这个相当于有一个随时间变化的动力荷载，不过这个荷载不考虑惯性效应。
28. 位移增量的计算方法：只能先假定一个可能的位移增量，该位移在平衡方程中会产生残差，然后使用加权残差法平差，然后再检查残差是否满足标准，即不平衡力的相对值，位移的变化值是否收敛。
29. 上一步加载的不平衡力可以在几次迭代后，加入到下一步荷载中。
30. 线弹性材料是弹性材料的细分，弹性指的是，荷载撤去后变形可以完全恢复。线性指的是，应变张量和应力张量呈线性关系。
31. 线弹性体除了要求材料是线弹性外，还要求结构是连续体，且满足胡克定律$u=a_1F_{P1}+a_2F_{P2}+\cdots+a_nF_{Pn}$。$u$为任意一点位移，$a_i$为常系数，$F_{Pi}$为荷载。这意味着小变形，大位移的情况也不是线弹性体。胡克定律一种解释是宏观的，就是位移和荷载呈线性关系。另一种解释是围观的，应力和应变呈呈线性关系。
32. 结构力学中的叠加原理适用于线弹性体。
33. 
34. 虚功原理是最小作用量原理在力学系统中的应用。
35. 作用量是一个标量，描述了系统的能量如何随时间变化。例如一个简单的粒子以恒定速度运动，作用量就是粒子的动量和位移的内积。等价于动能的2倍乘以它拥有这个能量的时间，单位是$J\cdot s$，和角动量单位一样。对于复杂的系统，可以看作是粒子的集体，将每个粒子的作用量加起来就是整个系统的。
36. 从数学上说，作用量是一个关于路径或轨迹的泛函，一般是一个物理量（速度或动量）沿路径的定积分，值为一个实数。也可以表述为关于时间的积分，粒子在这个时间范围内沿着路径运动。因此平稳作用量原理是一种变分原理。
37. 在拉格朗日力学中，作用量中的被积函数为拉格朗日量。该作用量的变分为0会导出欧拉-拉格朗日方程。
38. 哈密顿原理是平稳作用量原理的一个特殊例子。最小作用量原理最早的例子是光在介质中沿直线传播，和入射角等于反射角，这两个例子中光都是选择最短路径或时间作为真实的行为。
39. 
40. 广义坐标所在的空间称为位形空间（Configuration Space），该空间中的一个点对应多个广义坐标的值，决定了系统的一种位形。
    1. 单个粒子的位形空间是$R^3$
    2. 一个刚体的位形空间是$R^3\times SO(3)$，其中$R^3$为附着于刚体的坐标原点的坐标，$SO(3)$为三维空间的旋转群，每个元素都是一个关于坐标原点的旋转操作，可以将地面坐标系旋转到附着于刚体的坐标系。
    3. 一个由n个刚性连杆组成的机械臂，它的位形空间是$[R^3\times SO(3)]^n$的一个子集，因为机械臂会受到约束，每个连杆并非可以以任意姿态达到任意位置。有时也用末端执行器可以达到的位置来定义它的位形，虽然一个末端位置可以对应多种连杆位形，但是这对于机械臂的操作来说是一样的。
41. 位形空间不足以描述整个力学系统，因为它只描述了粒子的位置，遗漏了速度。位形流形中任意一点的速度矢量的集合定义了一个相切的平面。位置和动量的集合构成了位形空间的余切丛，这个更大的流形被称为系统的相空间。
42. 三维空间中绕原点的旋转操作具备群的特征：满足结合律，有单位元，有逆元。两次旋转可以组合成一次旋转。
43. 旋转操作可以用旋转轴和转动角度来表示，旋转轴有2个自由度，因此旋转操作一共有3个自由度。旋转操作是$R^3$中的线性变换，一旦选定一个基，就可以用一个正交矩阵（由旋转操作保角度和长度可以推出）表示这个旋转操作，这里的群操作就变成了矩阵乘法。
44. 同时由于旋转操作还保方向，即空间的左右手的方向，例如将2个向量$\vec{c}=\vec{a}\times\vec{b}$，分别旋转，需要保证旋转后的向量仍然满足这个关系。因此只有行列式为1的正交矩阵才是旋转操作。所有的三阶正交矩阵可以构成一个群，为O(3)，orthogonal group。而旋转矩阵是特殊的正交矩阵，因此记作SO(3)，special orthogonal group。
45. 三维空间的旋转不满足交换律，因此是非阿贝尔群，而二维空间的旋转操作就是阿贝尔群。例如在三维空间中，点(1，0，0)先绕x轴转90，再绕y轴转90的结果为(0，0，-1)。而先绕y轴转90，再绕x轴转90的结果为(0，1，0)，结果不同。对于二维空间中的点，只能绕z轴旋转，很容易发现，它是可交换的。
46. 
47. 
48. 
49. 
50. 
51. 
52. 
53. 
54. 
55. 
56. 
57. 最小作用量原理也被称作平稳作用量原理，实际上不一定要求是最小。只需要作用量这个泛函的一阶变分为零。
58. 将最小作用量原理运用到力学系统的作用量时，会得到系统的运动方程，例如牛顿，拉格朗日，哈密顿方程，甚至广义相对论（作用量为Einstein-Hilbert 作用量），经典电动力学和量子场论中的方程（路径积分方程）。
59. 
60. 
61. 
62. 
63. 一元函数$f$，在区间上连续等价于在区间的每一点都连续（可以用$\varepsilon-\delta$语言定义）。在某一点连续，首先需要在该点存在函数值。
64. 更一般的连续性定义是：$f:X\to Y$是$C^0$（即函数本身存在并连续），如果$Y$的任意开区间的逆像总是源集合中的开区间的并。
65. $Y$中区间的逆像就是该区间内任一点的逆像的集合。开区间的并经过抽象之后，就成为开集或开子集。
66. 只有在集合$X$上定义了拓扑结构后，才可以询问$X$的子集是否是开集。或者说，一个集合的拓扑就是选定了一些子集，将这些子集标记为开集。
67. 给一个集合$X$加上拓扑结构就相当于创建了一个新的集合$\mathscr{T}$（花体的T），集合$\mathscr{T}$的元素都是$X$的子集。选定$X$中不同的子集，就定义了不同的拓扑。每个拓扑$\mathscr{T}$都是$X$的幂集$2^X$的子集。但是并非任意子集都可以定义一个拓扑，选法有相当任意性，但不完全自由。因为拓扑集还需要满足以下三条性质：
    1. $X$和$\varnothing$都$\in \mathscr{T}$。
    2. $\mathscr{T}$中有限个元素的交，还在$\mathscr{T}$中。$\mathscr{T}$中的每个元素都对应于$X$的一个子集。
    3. $\mathscr{T}$中任意多个元素的并，还在$\mathscr{T}$中。

68. 定义了拓扑结构的集合，称为拓扑空间$(X,\mathscr{T})$，其中$X$为底集，同一个底集上可以定义不同的拓扑结构，来构成不同的拓扑空间。拓扑空间中的元素都是底集中的开子集。因此定义了拓扑才可以定义开集。
69. 两个特殊的拓扑空间：
    1. 离散拓扑：拓扑集就是$X$的幂集，即包含了$X$的所有子集，元素最多。
    2. 零距拓扑：拓扑集中只有两个元素就是$X$本身和空集，元素最少。

70. 拓扑要求的第二个条件，不可以是无限个开集的交也是开集，例如$(0,1+1/n)$这样的无限个集合，都是开集，但是他们的交集$(0,1]$却不是开集。
71. $R^n$的通常拓扑$\mathscr{T}_u:=\{x\subset X|x可表示为开球的并 \}$，它就是$R^n$默认使用的拓扑。开球的定义需要使用到欧几里得空间的度量来定义。
72. 因此可以发现$R$中开区间的并就是$R$中的开集，因此也定义了一个拓扑。$R^2$上就是开圆盘的并，$R^3$上就是开球的并。
73. R中的开区间的并对于零距拓扑空间不是开集，对于离散拓扑空间是开集。
74. 设有拓扑空间$(X,\mathscr{T})$，$X$的一个子集$A$上可以定义一个特殊拓扑$\mathscr{S}:=\{ V\subset A|\exist O\in\mathscr{T} s.t. O\cap A=V\}$。这个称为$\mathscr{T}$的诱导拓扑。
75. $R^2$中的线段不是开集，因为它不能表示为开圆盘的并。因为任意的开圆盘都会包含到线段外的点。
76. 
77. 
78. 
79. 
80. 
81. 
82. 
83. 
84. 
85. 

# 矩阵位移法

1. 推导：普通杆件的单元刚度方程，可以通过最小势能原理得出，当应变能-外力功取驻值时，单元平衡。

2. 

3. 

4. 

5. 

6. 

7. 

8. 

9. 二维矩阵位移法的一个例子：

   ```python
   输入数据K文件主要包含如下，所有的列表都是numpy.ndarray类型。
   #节点编号Nodes为：[[0,0],[1,0],[0.5,0.866]]，分别为1，2，3号节点
   #单元编号Elements为：[[1,2],[2,3],[3,1]] 分别为1，2，3号单元，单元内的节点编号也很重要。
   #单元类型ElementsType：[1,1,1] 目前只有一种类型就是二力杆(编号为1)
   #荷载Loads：[[0,0],[0,0],[0,100]]，目前只支持节点的单个集中荷载，分别对应1，2，3号各个节点的。
   #边界条件BoundaryConditions：[[0,0],[None,0],[None,None]]，
   ```

10. 代码：

    ```python
    # 应该从输入数据K文件中读取，不过目前使用手动输入，为了使用矩阵的运算，所有列表都是numpy.ndarray类型。
    import numpy as np
    from math import *
    #节点坐标，边界条件，荷载向量都是全局坐标系下的结果
    Nodes = np.array([[0, 0], [1, 0], [0.5, sqrt(3)/2]])  # 节点编号，分别为0，1，2号节点
    Elements = np.array([[0, 1], [1, 2], [2, 0]])  # 单元编号，分别为0，1，2号单元
    ElementTypes = np.array([0, 0, 0])  # 单元类型，目前只有一种类型就是二力杆(编号为0)
    #材料模型，0号表示线弹性各向同性
    Loads = np.array([[0, 0], [0, 0], [0, 100]])  # 荷载，目前只支持节点的集中荷载，分别对应0，1，2号各个节点的
    BoundaryConditions = np.array([[0, 0], [None, 0], [None, None]])  # 边界条件，目前只支持节点的固定位移约束
    ElementStiffness_0_local = np.array([[1, -1], [-1, 1]])  # 0类型单元的局部单元刚度矩阵
    # 获取单元倾角
    def cos_sin(a, b):  # a,b分别为2个点的坐标，例如[0,0]和[3,4]，结果为(0.6,0.8)
        L = hypot(b[0]-a[0], b[1]-a[1])  # 根据直角边，求斜边长
        return (b[0]-a[0])/L, (b[1]-a[1])/L
    # 坐标变换矩阵T
    def T(ElementNumber):
        ElementType = ElementTypes[ElementNumber]
        if (ElementType == 0):
            cosAlpha, sinAlpha = cos_sin(
                Nodes[Elements[ElementNumber][0]], Nodes[Elements[ElementNumber][1]])
            return np.array([[cosAlpha, sinAlpha, 0, 0], [0, 0, cosAlpha, sinAlpha]])
    # 整体坐标系下的单元刚度矩阵
    def K(ElementNumber):
        ElementType = ElementTypes[ElementNumber]
        if (ElementType == 0):
            T0 = T(ElementNumber)
            a = Nodes[Elements[ElementNumber][0]]
            b = Nodes[Elements[ElementNumber][1]]
            return np.dot(np.dot(T0.transpose(), ElementStiffness_0_local), T0)*(200*10**9 * 0.001/hypot(b[0]-a[0], b[1]-a[1]))
    #由单元刚度矩阵组装成整体刚度矩阵时，需要进行逆切片，也就是说把单元刚度矩阵当作整体刚度矩阵的切片，还原回去。
    #假设单元刚度矩阵对应的自由度编号为a，例如[0,1,2,3]
    #
    #逆切片
    def TranslateElementStiffness(ElementNumber):
        ElementType = ElementTypes[ElementNumber]
        if (ElementType == 0):
            FullMatrix = np.zeros((len(Nodes)*2,len(Nodes)*2), np.float32)
            tmp = []
            for i in Elements[ElementNumber]:
                tmp += [2*i, 2*i+1]
            FullMatrix[np.ix_(tmp, tmp)] = K(ElementNumber)
        return FullMatrix
    #构造整体刚度矩阵
    def constructGlobalStiffness():
        GlobalStiffness = np.zeros((len(Nodes)*2,len(Nodes)*2), np.float32)
        for ElementNumber in range(len(Elements)):
            GlobalStiffness += TranslateElementStiffness(ElementNumber)
        return GlobalStiffness
    #处理边界条件
    def TreateBCs(GlobalStiffness, Loads):
        tmp = CalculatePrescribed()
        TreatedGlobalStiffness = np.zeros((len(tmp),len(tmp)), np.float32)
        TreatedGlobalStiffness = GlobalStiffness[np.ix_(tmp, tmp)]
        TreatedLoads = np.zeros(len(tmp), np.float32)
        TreatedLoads = Loads.reshape(-1,1)[np.ix_(tmp)]
        return TreatedGlobalStiffness, TreatedLoads
    #已知边界条件对应的自由度编号
    def CalculatePrescribed():
        Prescribed = []
        for i in range(2*len(BoundaryConditions)):
            if(BoundaryConditions.reshape(-1)[i] == None):
                Prescribed += [i]
        return Prescribed
    
    GlobalStiffness = constructGlobalStiffness()
    TreatedGlobalStiffness, TreatedLoads= TreateBCs(GlobalStiffness, Loads)
    utmp = np.linalg.solve(TreatedGlobalStiffness, TreatedLoads)
    u = np.zeros((len(Nodes)*2,1), np.float32)
    Prescribed = CalculatePrescribed()
    u[np.ix_(Prescribed)] = utmp
    ```

11. 

12. 

13. 

14. 

15. 

# 微分方程近似解

1. 分为2大类：离散坐标方法和分布坐标方法。
2. 离散坐标方法，就是只会求解定义域中离散点上的近似解，其他点的解可以通过插值获得。将微分方程转化为了差分方程，未知量为离散点上的近似解。通常用在求解CFD和初值问题中。
   1. 有限差分法：使用各种差分格式来替换各阶导数。
   2. 逐步积分法，通常用在初值问题中，也可以用来处理边值问题，此时会从边界的一侧向另一侧传播
      1. 欧拉方法：
      2. 龙格库塔法：
3. 分布坐标方法，是会求解整个定义域上近似解。用一系列满足全部或部分边界条件的基函数的线性组合作为解的近似，组合系数为待求量。
   1. 加权残值法，直接对微分方程进行处理，由于近似的引入，原始方程不在平衡，产生了残差。
      1. 内部残值（Internal）：
         1. 配点法（Point Collocation Method）：强制使得残差函数$R(x)$在多个配点上的值为0。类似于用扣子把衬衣的两侧固定住，扣子的位置就是配点。配点的个数就是待求变量的个数，即$n$，随着配点的密度增大，配点之间的残差幅值可能会变小，不过也可能变大。由于基函数天然满足边界条件，因此所有的配点都应在内部选取。这个相当于选取以配点为中心的冲激函数作为权重函数。由冲激函数的积分特性$\int_{Domain}\delta(x_j)R(x)=R(x_j)$可知。由于边界条件不一定对称，因此得出的线性方程组的系数矩阵也不一定对称。它是加权残值法中最简单的一个，但是精确度不太好。
         2. 子域法：将定义域分成n个小块，强制使得残差函数在多个小块上的积分为0。这里相当于将权重函数$w_j(x)$设置为仅在某个小块上取值为1，其余地方取值均为0。比配点法复杂的是，这里必须要实际计算定积分。随着分块数量的增加，每个块越来越小，这会使得块内的残差幅值也变小。通常来说子域法会比配点法精度更高。这个相当于选取两个单位阶跃函数的差作为权重函数。
         3. 伽辽金法：不再专门选取权重函数，而是使用试函数当作权重函数，即令$\int_{Domain}R(x)\psi_j(x)=0$​，正好得出n个方程，注意这里的积分还是在整个定义域上进行的。这里的积分可能很复杂，建议使用符号计算工具或数值积分完成。也可以使用分部积分，提高权重函数的微分次数，降低试函数的微分次数，优点有：
         
            1. 由于分部积分的一项会出现试函数或其倒数在边界上的函数值，可能会由于试函数满足的边界条件，而导致简化。下面例子中的本质和自然边界条件会使得等号右侧第一项为0。在大多数的结构力学问题中，都包含对位移高阶导数。
            2. 还可以降低对试函数光滑性的要求，使用等号右侧，只需要试函数满足一阶导数可积，原来需要二阶。
            3. 这常常导致结果线性方程组的系数矩阵是对称的，从下面的两个一阶导数乘积可以看出，交换i和j没有区别。对称的系数矩阵求解要更方便些。
            4. 试函数只需要满足本质边界条件即可，其他边界条件已经隐藏到了分部积分等式右侧的第一项中。
            5. 例如：
         
            $$
            \int_{Domain}\psi_j(x)\frac{d^2\psi_i(x)}{dx^2}=\psi_j(x)\frac{d\psi_i(x)}{dx}|_{\partial Domain}-\int_{Domain}\frac{d\psi_j(x)}{dx}\frac{d\psi_i(x)}{dx}dx
            $$
         
         4. 有限单元法，可以看作是在子域上的伽辽金法。这里的子域被称为单元。
         
            1. 主要求解的是单元内的位移，可以使用结点位移当作组合系数（广义坐标），用各点的形函数当作基函数来构造单元内的位移$u(x)=\sum_{i=1}^nu_iN_i(x)$，其中n为节点个数。高阶的形函数可以使用拉格朗日插值方法来构造。
            2. 优点是该方法的广义坐标一般都有直接的物理含义。
            3. 结构网格产生的方程组的系数矩阵会有一些特点，有利于快速求解。
            4. 和一般加权残值法不同的是，基函数的个数并不是任意的，而是和单元的节点数相同。并非每个形函数都满足单元的边界条件，而是跟广义坐标组合到一起后才满足。
            5. 由于要使用伽辽金法，因此只用满足本质边界条件即可。对于单元来说，本质边界条件就是位移模式在各个节点上的值$u(x_i)$要等于节点的位移$u_i$。
            6. 实际上对于有限元软件来说，位移边界条件放在边界条件模块中，而力边界条件被当作荷载来施加。
            7. 对于单元来说，选取位移模式时，并不用考虑整体的边界条件。只需要在最后构成整体刚度方程后，边界单元考虑相关的边界条件。
            8. 将控制微分方程作用在单元的位移模式上，会产生残差，使用伽辽金法来处理这个残差，权函数就是各个形函数。得到的方程组就是单元刚度方程组。
            9. 控制微分方程中的分布力指的是实体单元的体积力，并非作用在边或面上的分布力，后者是边界条件，前者不是。
            10. 对包含应力的体积分项应用分部积分后，或出现体积边界，也就是面边界上的一些积分。这些项需要用面上的分布力来确定。
                $$
                {\displaystyle \int _{\Omega }u\,\nabla \cdot \mathbf {V} \,d\Omega \ =\ \int _{\Gamma }u\mathbf {V} \cdot {\hat {\mathbf {n} }}\,d\Gamma -\int _{\Omega }\nabla u\cdot \mathbf {V} \,d\Omega ,}
                $$
            11. 以下只考虑实体单元，结构单元比较特殊。最简单的实体单元是六面体，有8个顶点（node），12条边（edge），6个面（face）。单元可能有一个顶点，边或面在边界上。因此可能会受到荷载。可能分为节点的集中荷载，边或面上分布荷载。边和面上的分布荷载都要等效到节点上。
            12. 整体的力和位移边界条件可以分为集中和分布的。当投射到单元上时，也成了节点集中，边界集中和边界分布。边界集中可以看作分布的特例，也就是用
            13. 在软件中也不是想往哪施加荷载都可以的。
            14. 不过由于结点是多个单元共享的，如果网格不发生撕裂，即节点不分离，则可以认为该节点上的集中力只属于某个单独的单元，或者在单元间平均分布，反正最后到整体刚度方程时还会汇总到一起。
            15. 实际工作中，不会再构造单元的刚度方程，而是仅构造单元的刚度矩阵，然后组装成整体的刚度矩阵，最后把整体的边界条件施加到整体结构上。
            16. 力边界条件分为两种，作用在节点的集中力，和作用在边界上的集中或分布力。在对伽辽金法使用分部积分法时，会产生边界上的取值，这会引入作用在节点的集中力。
            
            17. 位移边界条件会被留到最后组装完整体刚度矩阵后再处理。
            
            18. 由于伽辽金法不再切分子域，因此是对整个单元积分。
            19. 一维二力杆单元，边界条件为：在端点施加的沿杆方向的集中荷载$p_1,p_2$，端点的沿杆方向的位移为$u_1,u_2$。这里先认为$u_1,u_2$，$p_1,p_2$都是已知的。控制方程为$\frac{d}{dx}(EA\frac{du}{dx})+f(x)=0$。$f(x)$为沿杆方向的分布力，可能是重力，摩擦力等，是已知的。
            20. 如果使用纯粹地伽辽金法，并使用分部积分。构造近似函数可以是$u(x)=a_1(u_1N_1(x)+u_2N_2(x))$。其中$N_1(x)=1-x/L$，$N_2(x)=x/L$。$a_1$是待定系数。实际上基函数可以使用更高阶的函数，或三角函数，同时也可以使用多个基函数的组合，但是这样就够了。将近似函数带入，然后得到$R(x)$。令$\int_{Domain}R(x)\cdot (u_1N_1(x)+u_2N_2(x))dx=0$。
            21. 不过这里转换了以下思路，认为$u(x)=u_1N_1(x)+u_2N_2(x)$，即$N_1(x),N_2(x)$是试函数，$u_1,u_2$是待定系数，可以看到这里的基函数$N_i(x)$就不满足本质边界条件了，但是整个函数$u(x)$仍然满足。这样带入控制方程，残差处理后，得到的线性方程组就是单元的刚度方程组。但是不能像之前一样，通过求解该方程直接求出待定系数。因为此时该方程是奇异的。
            22. 线性方程组中会出现$f(x)N_i(x)$的项，这就是将分布荷载向节点等效。再对被积函数使用分部积分即可得到和自然边界条件有关的项，替换进去即可。这样位移模式就满足所有的边界条件了。
            23. 对于单元来说，$u_1,u_2$是已知量，对于整个结构来说，$u_1,u_2$是未知量。
            24. 
            25. 
            26. 
            27. 
      2. 边界残值
         1. 边界元法：数学上较为复杂，但是结果的精度较好。
   2. 泛函驻值法，使得一个描述系统特定属性的泛函取最大或最小值，例如系统的总能量。使用泛函来表达不同变量的关系是比较容易的，尤其是关系非常复杂时，例如流固耦合，包含控制机构的结构动力学问题。
      1. 瑞利-利兹法：
      2. 有限单元法：
4. 可以看到从泛函驻值法和加权残值法都可以推导出有限元方法。

## 加权残差法 WRM

1. 待求得线性微分方程用如下形式表示：$L(f(x))-g(x)=0$，其中$L(\cdot)$是一个线性微分算子。$g(x)$已知，$f(x)$为待求。$L(\cdot)=a_0(x)+a_1(x)\frac{d}{dx}+a_2(x)\frac{d^2}{dx^2}+\cdots$。

2. 将$f(x)$使用近似：$f(x)\approx\sum_{i=1}^na_i\psi_i(x)$。这一步实际是将一个可以完全自由取值的任意函数$f$用有限个基函数（或试函数）来组合，是一个投影过程。系数$a_i$被称作广义坐标。每个试函数都需要满足所有的边界条件，这样他们的组合也满足边界条件，对于复杂形状和复杂边界条件选取合理的试函数往往比较困难。也要求试函数和待求函数具备相同的连续性和可导性。

3. 将近似带入上面的微分方程，由于$L$是线性的，上式为：$\sum_{i=1}^na_iL(\psi_i(x))-g(x)=R(x)$。这个$R(x)$就是残差。残差并不是误差（error）。误差是真实解$f(x)$和近似解在整个定义域上的差值。残差是由于误差的引入产生的控制方程不平衡项。

4. 所有的加权残值法变种都是为了使得残差最小化，一般是积分意义上的最小化。因为残差不可能为0，除非$f(x)$恰好能够由有限个$\psi_i(x)$的组合表示。如果残差为零函数，此时认为得到了精确解。

5. 使得残差最小化，会得出一个关于组合系数的线性方程组。

6. 令残差函数在整个域上的积分为0，此时残差函数在部分域取正值，部分域取负值。

7. 如果只是对残差函数$R(x)$积分，则只能得到一个方程。但是这里有n个未知的系数$a_1,\cdots,a_n$。这里的残差的加权函数是1，也可以采用不同的权函数。如果使用n个不同的权函数，就可以得到了n个不同的方程，来确定这n个系数了。权函数一般不用特别复杂的函数，但是一定要线性无关，否则得到的线性方程组的解不唯一。因此最终公式为：

8. $$
   \int_{Domain}w_j(x)R(x)dx=\int_{Domain}w_j(x)(\sum_{i=1}^na_iL(\psi_i(x))-g(x))=0
   $$

9. 权值函数的可能性：

   1. 伽辽金法：权值函数就是试函数本身。对于存在非线性系数的情况，取$w_j=\frac{\partial u}{\partial a_i}$，即近似函数对系数的偏导数。

   2. 伪谱方法，也就是配点法：权值函数是以离散点为中心狄拉克$\delta$函数。

   3. 最小二乘法：权值函数为残差函数对系数的偏导数。这相当于让残差函数的$L^2$范数为0。

   4. 矩方法：权值函数为幂函数序列，当所需精度较高时很少使用，因为需要对Hilbert矩阵求逆。

10. 

11. 

12. 

13. 

14. 

15. 

16. 

17. 

18. 

19. 

20. 

21. 

22. 

23. 

24. 

25. 

26. 

27. 

28. 

29. 

30. 

31. 

32. 

33. 

34. 

35. 

36. 

37. 

38. 

39. 

40. 

41. 

42. 

43. 


# Calculix编译记录

1. 下载Calculix.tar.gz文件，解压后会出现CCX目录，内部含有SPOOLES2.2，ARAPCK和Calculix三个文件夹。
2. 先构建SPOOLES2.2和ARAPCK，最后构建Calculix。三个文件夹放在同一级目录中，但不要求都放在用户家目录中，因为makefile中大多数为相对路径。
3. 进入SPOOLES.2.2中执行 make CC=gcc lib。如果不加CC=gcc会报错:/usr/lang-4.0/bin/cc: No such file or directory。
4. 进入ARPACK文件夹，先根据README修改ARmake.inc文件。
   1. 修改home为ARPACK文件夹路径
   2. 修改PLAT = INTEL
   3. 修改FFLAGS = -O -fallow-argument-mismatch。这里去除了-cg89的选项，增加了-fallow-argument-mismatch
   4. 修改UTIL/second.f，在EXTERNAL ETIME的最开头添加*注释
   5. 最后运行make lib即可
6. 在Calculix/ccx_2.20/src中执行make。如果遇到 Interface mismatch in dummy procedure ‘f’ at (1): ‘fun’ is not a function的错误。单独编译该文件，应该加上 --std=legacy的选项。
7. 执行 ./ccx_2.20 ../test/beamp，检查是否出现beamp.dat文件，可以beamp.dat.ref校对检验软件是否成功编译。
7. 
8. 
9. 
10. 
11. 