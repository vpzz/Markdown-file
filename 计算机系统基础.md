# C程序举例

1. 以下问题的环境均为：ISO C90标准，32位系统。

2. 编译器如何处理字面量，实际就是该值在机器中是如何表示的：

   ```c
   -2147483648 < 2147483647; //结果为false，和数学上不符
   //若先将左侧赋值给int变量，再进行比较：
   int i = -2147483648;
   i < 2147483647; //结果为true
   //若将左侧的值写成如下形式：
   -2147483647-1 < 2147483647; //结果也是true
   ```

3. 高级语言表达式的运算规则，对应的机器指令：

   ```c
   sum(int a[], unsigned len){ //数组元素求和
       int i, sum = 0;
       for (i = 0; i <= len-1; i++){ //这里的<=会被转化成jbe指令，即无符号数的条件跳转
           sum += a[i];
       }
       return sum;
   }
   //当sum的第二个参数len为0时，返回值却不为0。有可能出现对内存地址0xC0000005的非法访问错误。
   //因为0U-1为0xFFFFFFFF，即最大的无符号数，因此i<= len-1总是成立，会陷入死循环。
   //如果将len的类型改为int，则不会出现上述错误。
   ```

4. 数学上的恒等式，在计算机世界中不总成立，存在例外：

   ```c
   int x = 65535,y;
   y = x * x;//结果y的值为-131071，违反数学中整数的平方非负的规则。
   
   int a,b;
   (a>b) == (-a<-b); //不一定总是为真(x=-2147483648,y为除-2147483648外的任意数)，而在数学中总是为真的。
   ```

5. 程序中变量存储空间的分配，数据的大小端存储，链接器的符号识别规则：

   ```c
   //main.c
   #include <stdio.h>
   int d = 100; //符号d有一个强定义，一个弱定义，链接没问题。不过会产生隐藏的错误
   int x = 200;
   int main(){
       p1();
       printf("d = %d, x = %d\n",d,x);//结果 d=0,x=1072693248
       return 0
   }
   //p1.c
   double d;
   void p1(){
       d = 1.0;//会将1.0的64位浮点表示0x3FF0000000000000写入到int d的位置。变量d和x都在.data节，各占4字节。x的地址=d的地址+4，因此将8个字节写入到d的地址处，正好会覆盖掉d和x。
       //因此d为0x00000000，x为0x3FF00000。
   }
   ```

6. 乘法运算及溢出，存储空间映射：

   ```c
   int copy_array(int* array, int count){ //复制数组到堆中，count为要复制的元素个数
       int i;
       //在堆中申请一块内存
       int* myarray = (int*)malloc(count*sizeof(int)); //当count=2^30+1时，count*4u=2^32+4,取低32位，结果为4，发生了溢出，。不过此时仍会复制很多数据到堆中，这样就会破坏堆中的数据。
       //有一点需要编程确认，带符号数和无符号数的乘法是否会强制类型转换。
       if(myarray == NULL){
           return -1;
       }
       for(i = 0; i < count; i++){
           myarray[i] = array[i];
       }
       return count;
   }
   ```

7. 编译器优化，除法错异常处理：

   ```c
   int a = 0x80000000;
   int b = a/-1; //b的结果为-2147483648
   //将除法的分母放到变量中，结果就不一样了，可以通过objdump反汇编发现上面除以-1会被优化为取相反数，使用neg指令完成，故未发生溢出。结果是错误的，却没有任何提示。
   int a = 0x80000000;
   int b = -1;
   int c = a/b; //会报错，Floating point exception，CPU检测到了溢出异常。
   //由于分子分母都是变量，无法优化，只能使用IDIV指令，而该指令不会生成溢出OF标志，但是又能判断是否发生了溢出异常，这是因为对于除法运算，机器会对除数和被除数进行预先判断，下面的这个就是特殊情况，它的值为2147483648，无法用32位带符号数表示，因此直接判断为错误，Linux下发送SIGFPE信号到进程。
   //这里是整数除法，却显示浮点异常是因为：
   ```

8. IEEE754表示，x87FPU的体系结构，IA-32和x86-64中过程调用的参数传递：

   ```c
   #include <stdio.h>
   main(){
       double a = 10; //编译器会将它转换为等价的浮点数(0x4024 0000 0000 0000)，然后硬编码到指令中。
       printf("a = %d\n",a);//在IA-32上运行，结果为a=0，在x86-64上运行，结果为一个不确定的值。
   }
   //IA-32中，会先将内存中的浮点格式的a使用fldl载入到ST(0)中，然后再使用fstpl从ST(0)压栈作为printf的参数。在printf函数中，根据%d，会把%ebp+12的4个字节当作整数解析，这4个字节正好是a的低4字节，全0。
   //x86-64，调用printf前，a参数会存放在浮点寄存器xmm0中，而printf看到%d，就会去esi中找，因此会是一个不确定的值。
   ```

9. 过程调用中参数的传递，栈帧中数据的布局：

   ```c
   double func(int i){
       volatile double d[1] = {3.14}; //volatile 关键字会指示编译器应在内存中专门开辟一个存储单元存储该变量，而不是只在寄存器上。
       volatile long int a[2]; //a的两个元素都在d的顶部，而a[0]也在a[1]的顶部，a[3]和a[4]就是d所占的double的8个字节数据。
       a[i] = 1073741824; //仅当i=2和3时，会修改d的8个字节的前后部分。
       return d[0]; //将内存中的d载入到ST(0)，当返回浮点数时，默认放在ST(0)中。
   }
   //当i=0-4时，结果分别为3.14、3.14、3.1399998664856、2.00000061035156、3.14(然后出现存储保护错误)，可能是修改了旧的栈帧ebp的值，而后续代码运行都依赖ebp来获取局部变量，因此会导致乱读写。
   ```

10. 高维数组在内存中的布局，Cache机制，访问局部性：

    ```c
    //从算法时间和空间复杂度来说，两个函数完全等价，但是实际执行时间相差21倍(奔腾4cpu)。
    void copyij(int src[2048][2048], int dst[2048][2048]){
        int i, j;
        for (i = 0; i < 2048; i++){ //一行一行复制
            for (j = 0; j < 2048; j++){
                dst[i][j] = src[i][j];
            }
        }
    }
    void copyji(int src[2048][2048], int dst[2048][2048]){
        int i, j;
        for (j = 0; j < 2048; j++){ //一列一列行复制
            for (i = 0; i < 2048; i++){
                dst[i][j] = src[i][j];
            }
        }
    }
    ```

11. 浮点寄存器舍入：

    ```c
    //使用老版本的gcc -O2编译时，程序1最后i的值为0，程序2最后i的值为1。
    //程序1
    double f(int x){
        return 1.0/x; //会转化为两条指令fld1和fidivl 0x8(%ebp)。前者将1.0压入栈顶，后者将内存地址ebp+8的int数据转化为浮点数后，再用ST(0)除以该数，结果存入ST(0)。
        // = 1.0为80为扩展精度，10为int，但是要转为double。
    }
    void main(){
        double a,b;
        int i;
        a = f(10);
        b = f(10);
        i = a == b;//a是调用f(10)之后将ST(0)内的80位转化为64位存入到内存中了，后来比较的时候又载入到了ST(1)。而b是调用f(10)后，就直接在ST(0)中参与比较。浮点数比较都是在浮点寄存器之间比较的。由于a从80位舍入到64位，然后又扩展到80位，0.1是不可表示数，因此期间发生过截断，因此a==b的结果为false
    }
    //程序2
    double f(int x){
        return 1.0/x;
    }
    void main(){
        double a,b;
        int i;
        a = f(10);
        b = f(10);
        c = f(10); //这次调用会将ST(0)里的b舍入到64位，存入内存单元中，这样在a==b时，二者都会从内存中读取，这样就相等了。
        i = a == b;
    }
    ```

12. 指针的赋值和变量的强制类型转换，局部变量在栈中的位置：

    ```c
    int main(){
        int a = 10; //二进制表示为0x0000000A
        double *p = (double*)&a; //并没有任何具体的指令，所有指针都可以看做是同一种类型，只是给了编译器一些提示而已。
        printf("%f\n",*p);//结果为0.000000。会使用fldl指令，将内存单元当作double类型，直接读入浮点寄存器。
        printf("%f\n",(double)a);//结果为10.000000。会使用fildl，将内存单元当作int，然后转换后再读入浮点寄存器。
    }
    //两次强制类型转换，但是结果不同，关键在于fldl和fildl指令的差异。
    ```

# 基础

## ISA

1. 计算机系统是分层的，指令集体系结构ISA（Instruction Set Architecture），也称为指令系统，是软硬件的交界面，是最重要的一层，规定了软件如何使用硬件，包含如下内容：
   1. 可执行指令的集合，包括指令格式，操作种类及每种操作对应的操作数。实际上也约束了硬件提供给软件的接口。
   2. 指令可以接受的操作数的类型。无符号数，带符号数，浮点数等
   3. 寄存器的名称编号，长度，用途。
   4. 存储空间的大小和编址方式，多字节数据存放大小端方式。
   5. 指令获取操作数的方式，即寻址方式。
   6. 指令执行过程中的控制方式，包括PC，条件码的定义。
2. 有了ISA后，才可以称为通用计算机，即编程使得计算机执行不同的功能。
3. 常见的ISA有：IA-32（x86），MIPS，ARM。
4. 程序员分为应用程序员和系统程序员。
5. 功能部件由门电路构成，门电路由器件构成。
6. <img src="计算机系统基础.assets/image-20210407195254273.png" alt="image-20210407195254273"  />
7. 同一个ISA可以有不同的微体系结构实现，例如乘法指令可以使用ALU的加法和移位来完成，也可以使用专门的乘法器完成。
8. x86指令集至少有Intel和AMD两家的为体系结构实现。
9. 编译器的作者必须要完全理解ISA中每条指令的行为，这样才可以完整无误地将高级语言的意图翻译成指令。

## 冯诺依曼结构

1. 世界上第一台通用的电子计算机 ENIAC(Electronic Numerical Integrator And Computer)是1946年宾夕法尼亚大学研制的，1.8万个电子真空管组成的，耗电巨大，用于解决复杂的弹道问题，主要是做数值计算，高达每秒5000次加法运算，能够计算平方，立方，三角函数计算。用10进制表示信息并运算，通过手动设置开关和插拔电缆来编程。
2. 冯诺依曼架构最重要的思想是存储程序的思想：任何要让计算机完成的工作都需要事先编写好程序，然后将程序和数据都送入主存。程序一旦被启动，计算机就能够自动地取值执行。由于冯诺依曼供职于普林斯顿高等研究院IAS，所以该架构也被称为IAS计算机。
3. 因此冯诺依曼机至少需要以下部件：主存（用来存放程序和数据），自动逐条取指令的部件（控制器），具体执行指令的部件（运算器）。读取用户输入的程序和数据的部件，将结果输出的部件。
4. 早期的计算机中，各部件是分散连接的，线路多而且复杂，现在大多使用总线方式。
5. 存储器能够存放数据和指令，形式上没有区别，都以二进制表示，但是计算机还是能够区分二者。
6. 运算器可以进行加减乘除四种基本的算术运算，还有与或非，移位运算。
7. 指令=操作码+地址码，表示对那些数据做什么操作。 
8. 程序就是一串物理上连续的指令，逻辑上不一定连续执行。

## 现代计算机结构

1. 现代计算机也是由五大部分组成，不过早已经将运算器和控制器结合到一起，成为CPU。
2. 运算器计算完成一次后，有时还会修改标志寄存器，控制器会读取标志寄存器，进而影响后续的计算。
3. 从存储器中获取的指令存放在IR（指令寄存器），然后交由控制器分析，获取的数据放到通用寄存器组（GPRs，General Purpose Registers）中。PC（程序计数器，program counter）寄存器记录着下一次取指令的位置。PC的不断自增，使得程序能够自动执行，也可以在某条指令（例如jmp和call指令）中修改PC，这样下一次读取PC就会去新的地方执行。
4. 数据和指令的读写
   1. 要将寄存器中的数据写入到内存中，需要将数据和地址分别存放到MDR（memory data register）和MAR（memory address register）中，然后由控制器发出写入指令。
   2. 要从内存中的读取数据，需要将带读取的内存地址放在MAR中，用于接受的寄存器编号放在MDR中，然后由控制器发出读取指令，数据会先读入到MDR中，然后转到指定的通用寄存器中，
   3. 要从内存中读取指令，将PC的值复制到MAR中，由控制器发起读取指令，读入的指令会先到MDR中，然后复制到IR中。
5. IR和PC是不一样的，前者是存储当前正在执行的指令，后者是存储下一次要读取指令的内存地址。
6. 早期没有寄存器，只有一个累加器，后来增加了多个，才将他们变成通用的寄存器，所有操作都可以使用。
7. 下图是微体系结构，不同的CPU可能不同。
8. <img src="计算机系统基础.assets/image-20210407202539790.png" alt="image-20210407202539790"  />
9. 取到一个指令后，有时可能要再取数据才可以进行计算，而这个取数据的环节不用显式写出指令，控制器会自动发出。有的CPU架构，不允许指令直接操作内存中的数据，因此需要显式将内存数据读取到寄存器中，然后再对寄存器中的数据进行计算，最后再将显式将结果从寄存器写入到内存中。
10. 一条指令中，源操作数可能有一个，也可能有两个。源操作数可能是立即数，寄存器编号，存储地址。目的操作数可能是寄存器编号或存储地址。

## 程序的历史

1. 程序的历史：
   1. 使用机器语言，纸带打孔表示0，未打孔表示1，输入可以用按钮，开关，输出一般为信号灯。指令中的地址码都是硬编码进去的。如果添加或删除指令，地址码需要重新计算，还要重新打孔。
   2. 汇编语言，面向动作描述。汇编指令是用助记符和标号表示的指令，它和机器指令一一对应。使用助记符表示操作码和寄存器，用标号表示位置。使用汇编器将汇编代码转化为机器代码，他会自动计算地址码。不同机器（CPU）所支持的指令集不同，汇编指令的格式也可能不同（机器代码就更不同了），因此不能移植。同一机器也可以有不同的汇编指令格式，例如x86cpu的AT&T汇编和Intel汇编。相比机器语言的优点是：不需要因为增减指令而修改其他指令，不需要记忆指令编码，编写方便，可读性强。缺点是：机器不能直接识别，需要通过汇编器转换。
   3. 高级语言，面向算法描述的，比机器语言描述能力强得多。一条语句可能会转化为多条汇编指令。分为编译和解释两种。解释程序逐条将语句翻译成指令，然后直接执行，不生成目标文件。
2. C语言源程序的编译过程如下，不过都可以使用gcc命令来结合不同的选项调用对应的命令。编译器将.c转化为.s，汇编器将.s转化为.o：
3. <img src="计算机系统基础.assets/image-20210518102947327.png" alt="image-20210518102947327" />
4. 最早的程序运行不需要操作系统，直接运行在指令集体系结构上。
5. 使用汇编语言编写程序就需要汇编器和操作系统提供的交互界面。
6. 使用高级语言开发程序需要有语言处理系统，即编辑器，编译器，汇编器，链接器和运行时系统等。现代程序运行需要语言处理系统和操作系统内核。
7. 操作系统厂商需要为程序员提供运行时系统和语言处理系统。
8. 第1-4代程序设计语言：机器语言，汇编语言，过程式高级语言，非过程式高级语言。过程式和非过程式语言的区别就是，前者需要描述怎么做，后者只需要描述做什么。
9. 程序的执行结果不仅取决于算法和程序是如何编写的，还取决于语言处理系统，操作系统，ISA和微体系结构。

# 整数

1. 在指令层面，没有结构化数据的概念，都是当做01序列来看待。
2. 机器级数据分为：
   1. 数值数据：无符号整数，有符号整数，浮点数。
   2. 非数值数据：逻辑数据（位串），文字和符号，不能比较大小。
3. 计算机使用二进制编码数据的原因是：
   1. 制造2个稳定态的物理器件比较容易，例如点位高低。
   2. 二进制编码，计数，运算较为简单。
   3. 正好与逻辑命题的真假对应。
   4. 可以方便地使用逻辑电路来实现算术运算。

4. 真值和机器数，机器数是在计算机内部的01编码的数据，真值是现实生活中的数。例如真值unsigned short类型变量x的真值为127，其机器数为0000 0000 0111 1111。
5. 要在真值和机器数之间相互转换，需要确定以下几个要素：
   1. 进位计数制，2，8，10，16进制
   2. 定、浮点表示。
   3. 定点数的二进制编码。

6. 二进制可以用后缀B表示，八进制可以用前缀0或后缀O表示，十六进制可以用0X前缀或H后缀表示。

   ```c
   15 = 1111B = 17O = 017 = 0xF = FH
   ```
7. 日常生活中使用十进制，计算机中使用二进制，引进八进制和十六进制的目的是为了书写和观察方便。
8. 公历起源于古罗马历法。古罗马历法原来只有10个月，罗马元首决定增加两个月放在年尾，后来朱里斯·凯撒大帝把这两个月移到年初，成为1月、2月，原来的1月、2月便成了3月、4月，依次类推。原来的八月就成了十月，但是历法改了，称呼仍然沿用未变。
9. 英语的十月October，来自拉丁文Octo，即“8”的意思，十月是历法改革前的8月。
10. <img src="计算机系统基础.assets/image-20210411141724346.png" alt="image-20210411141724346"  />
11. 某些十进制数，在转化为二进制时，小数部分可能是无限的。例如$(0.63)_{10}=(0.50243\cdots)_8$。除R取余总是有尽头，但是乘R取整不一定。

# 定点数的表示

1. 计算机中只有0和1，小数点在计算机中是无法表示的，只能约定小数点的位置。小数点约定在固定位置的就是定点数，小数点位置可以浮动的就成为浮点数。

2. 定点数分为定点小数（小数点约定在开头，用来表示浮点数的尾数部分）和定点整数（小数点约定在末尾，有符号整数和无符号整数）。例如0.1101可以用1101表示，1101.0可以用1101表示。

3. 浮点数使用一个定点小数和一个定点整数表示，其中小数点的位置由定点整数表示。可见浮点数的表示依赖于定点数的表示方法。

4. 任意实数都可以表示为：$X = (-1)^s\times M\times R^E$。s可以为0或1，是符号位sign。M是一个二进制的定点小数，称为X的尾数，有效数字。R是基数radix，现代计算机一般都是2。E是一个二进制定点整数，称为X的指数exponent。在计算机内部任何实数都可以用一个符号位+定点小数+定点整数来表示。

5. 因此在计算机中解决数值的表示问题就首先要解决定点数的编码问题。

6. 定点数的表示方法：原码，补码，移码，反码（很少用了）。


## 原码

1. 原码表示中一个数和它的相反数仅符号位相反，缺点是0的表示不统一；加减运算不统一，需要额外对符号位进行处理，不利于硬件设计，对于同号数相减和异号数相加的情况，需要先判断二者的绝对值，不能像补码那样将减法用加法来实现；当a<b时，实现a-b比较困难。

   ```c
   //十进制 二进制  十进制 二进制
       0    0000     -0   1000
       1    0001     -1   1001
       2    0010     -2   1010
       3    0011     -3   1011
   ```

2. 因此从50年代开始，整数都用补码表示，但是浮点数的尾数部分还是用原码定点小数表示（因为不用考虑符号位）。


## 移码

1. 移码表示如下：将一个真值+一个偏置常数（bias）。当编码位数为n是，偏置常数通常$2^{n-1}$或$2^{n-1}-1$

   ```c
   //n=4时，E_baised = E+2^3。
   -8 → -8+8 =  0 = 0000B
    0 →  0+8 =  8 = 1000B //0的移码表示唯一
    7 →  7+8 = 15 = 1111B
   //这样所有的负数都会变成正数，因此就不需要符号位了，因此4位的偏置整数能够表示的个数是2^4=16个。
   //当偏置常数取2^(n-1)时，同一个数的移码和补码仅符号位完全相反。
   ```

2. 浮点数的指数部分通常用移码来表示。主要是方便浮点数之间加减时的对阶操作。浮点数加减法时，需要先进行对阶操作，将小阶向大阶对齐，这就需要比较指数的大小，移码可以快速比较大小，从高到低逐位比较大小即可：

   ```c
   //比较1.01x2^-1和1.11x2^3的指数大小。由于-1<3，因此应该将第一个数移阶，得到0.000101x2^3
   //如果将指数使用3位2进制补码表示，则分别为111和011，无法直接进行比较，还要进行有符号数的比较。
   //如果将指数使用3位2进制移码表示(偏置常数取2^2=4)，则分别为011和111，可以由高往低逐位直接进行比较，最高位右侧为1，左侧为0，因此右侧大。
   ```


## 模运算系统

1. 模运算系统中，一个数和该数除以模后的余数是等价的。例如在模12运算系统中，13和1是等价的，因为。$13\equiv 1\mod 12$，称13和1模12同余。

2. 钟表可以看作1位12进制的模运算系统。能表示的数可以是`0,1,2,3,4,5,6,7,8,9,A,B`，没有负数，这里之所以用A、B而不是10和11，是因为不想和十进制混淆。

3. 加法的计算如下，A+2是A的第二个后继，等于(A+1)+1。A+1为B，所以A+2=B+1，B的下一个后继为0，因此A+2=0。

4. 先定义a的相反数：$-a:=\{b|a+b=0\}$，即，例如由于3+9=0。因此9是3的相反数，即$-3=9$，因此可以计算0到B的相反数：

   ```c
   -0=0 -1=B  -2=A  -3=9  -4=8  -5=7  -6=6  -7=5  -8=4  -9=3  -A=2  -B=1
   //可以发现相反数具有对称性，因此-3 = 9，-9 = 3。同时-(-a):=a
   //需要用的时候，查表即可，如果像钟表这样的机械结构，可以将指针旋转180度获得相反数。相反数运算在二进制中是一个比较简单的操作，即翻转一下位即可，0变1，1变0，可以通过一些开关电路实现。
   ```

5. 然后借助于相反数来定义减法，$a-b:=a+(-b)$，减一个数相当于加上这个数的相反数。例如$5-2=5+A=3$，$2-5=2+7=9$，$5-(-2)=5+2=7$。

6. 因此1位12进制数可以表示$0,±1,\cdots,±B$。换成10进制为0到±11，一共23个数。但是没办法区分-3和9，这对于数学运算是不方便的。

## 补码

1. 补码和原码表示有一个共同点，就是通过符号位就都可以判断正负数。不同的是，补码的符号位也是数值位，具有权重，而原码的符号位只表示正负，没有权重。

2. 有符号数使用补码表示，无符号数使用二进制位串表示，其中没有符号位，不是原码，因为源码的最高位是符号位。

3. 补码有两种含义：

   1. 一个十进制数表示为2进制位串时，有多种编码方式，例如原码，移码，补码。

   2. 一个二进制串的求补码运算就是逐位取反，然后加一。

4. 为了同时表示正数和负数，可以使用多位进制数的组合。原码就是用最高位作为单独的符号位，移码通过将负数转化为正数来表示，也可以通过最高位判断正负性，补码则是将最高位的权重变为负数。

   ```c
   //3位2进制原码可以表示的数有(按照进制排列)：
   二进制：// 000 001 010 011 100 101 110 111
   十进制：//  0   1   2   3  -0   -1  -2  -3  //可以看到0有两种表示方式000或100
   //3位2进制移码可以表示的数有(按照进制排列，偏置常数取2^(3-1))：
   二进制：// 000 001 010 011 100 101 110 111
   十进制：// 0-4 1-4 2-4 3-4 4-4 5-4 6-4 7-4
   十进制：//  -4  -3  -2  -1  0   1   2   3         可以看到十进制数是依次递增的
   //3位2进制补码可以表示的数有(按照进制排列)：
   二进制：// 000 001 010 011 100 101 110 111
   十进制：//  0   1   2   3  -4 -4+1 -4+2 -4+3
   十进制：//  0   1   2   3  -4  -3  -2  -1
   //同一个码点表示的数值和范围不同。
   ```

5. 正数的补码表示和原码表示一样，负数的补码表示需要对它的绝对值的补码表示进行位操作得到：将绝对值的原码表示逐位取反，然后再加1即可。

6. 同一个十进制数的不同二进制编码表示，一般都是先求得原码表示，然后对原码进行操作得到补码表示。不同编码所能表示的数的范围不同。n位原码可以表示$±0$到$±(2^{n-1}-1)$。n位补码和移码都可以表示0，±1到$±(2^{n-1}-1)$，还有$2^{n-1}$。

   1. 通过原码表示求补码表示，以下以3位2进制数为例：

      ```c
      //正数的原码和补码相同，这是因为正数的原码和补码的符号位都是0，二者在其余位的权重都一样。
      十进制  原码  补码
        3     011  011 //(-1)^0*(1*2^1+1*2^0)=0*(-2^2)+1*2^1+1*2^1
      //负数的原码和补码不同，将原码的数值位取反，符号位不变，然后再整体加1即可得到补码。
      十进制  原码      补码
      -3      111  (100)+1=101  //
      ```

   2. 通过补码求原码，以下以3位2进制数为例：

      ```c
      //正数的原码和补码相同
      //负数的原码和补码不同，将补码的数值位取反，符号位不变，然后再整体加1即可得到补码。
      十进制  补码      原码
      -3      101  (110)+1=111  //1*(-2^2)+0*2^1+1*2^0=(-1)^1*(1*2^1+1*2^0)
      ```

   3. 通过补码求移码，以下以3位2进制数为例：

      ```c
      //正负数的操作一样，符号位取反，数值位不变即可。
      十进制  补码   移码
      -3      101   001  //1*(-2^2)+0*2^1+1*2^0=0*2^2+0*2^1+1*2^0-2^2
      ```

   4. 可以发现，如果将一个二进制串数值位取反，符号位不变，然后再整体加1，这样的操作进行两次可以得到原来的串。

      ```c
      101 → 110+1 = 111 → 100+1 = 101
      ```

7. 补码运算规则如下，只有溢出时，结果不正确，溢出时最高位会进1：

   1. 补码的加法可以直接进行：

      ```c
      //以下6种情况，有2种情况可能溢出，正+正超出上限，负+负超出下限。加法只可能发生进位，不会发生借位。2种情况可能进位，正+负和负+正。1种情况必定进位，负+负。1种情况必定不进位，正+正。
      正+正：010+001=011       //即2+1=3，正确
      负+负：110+111=1101=101  //即(-2)+(-1)=-3，正确
      正+正：010+011=101       //即2+3=-3，发生上溢出
      负+负：100+101=1001=001  //即(-4)+(-3)=1，发生下溢出
      正+负：010+101=111       //即2+(-3)=-1，正确
      负+正：101+010=111       //即(-3)+2=-1，正确
      ```

   2. 补码的减法可以转化为加法（CPU中一般没有减法器）：将被减数取相反数，然后和减数相加即可。补码的相反数是逐位取反再加1。3=011，其相反数为~011+1=100+1=101。

      ```c
      //以下6种情况，也是只有两种情况可能溢出，正-负超出上限，负-正超出下限。减法只可能发生借位，不会发生进位。2种情况可能借位，正-正和负-负。1种情况必定不借位，负-正。1种情况必定借位，正-负。减法的进位可以通过从最高位逐位比较得到结果。且如果正数a-正数b不借位，那么b-a必定借位。
      正-正：010-001=010+(~001+1)=010+111=1001=001  //即2-1=1，正确
      负-负：110-111=110+(~111+1)=110+001=111       //即(-2)-(-1)=-1，正确
      正-正：010-011=010+(~011+1)=010+101=111       //即2-3=-1，正确
      负-负：100-101=100+(~101+1)=100+011=111       //即(-4)-(-3)=-1，正确
      正-负：010-101=010+(~101+1)=010+011=101       //即2-(-3)=-3，发生正溢出了
      负-正：101-010=101+(~010+1)=101+110=1011=011  //即(-3)-2=3，发生负溢出了
      ```

   3. 可知一个数的相反数等价于0-该数。不过-4的相反数不是4，还是-4，因为补码表示的数的范围不是对称的。

   4. 要实现加减混合运算，只要实现加法器和取反器即可。

8. 使用补码表示的好处：数值运算中，符号位和数值位可以同时参与运算。

9. 由一个数的补码求它的相反数的补码有简便的方法，例如8位2进制数124=0111 1100B，求-124的补码，首先从右向左先找到第一个1，然后该位左侧的所有位取反即可，该位不变。即10000100B=-124。

10. 编译器需要将源代码中输入的字面值常量都转化为2进制的串，可以使用以下算法（和python等语言中的int( )函数一样），CPU也应该提供类似的指令，将一个字符串转化为整数。

    ```c
    signed char a = 35;//在编译器看来35是2个字符。ASCII码值分别为0011 0011和0011 0101。需要将他们转化为0010 0011。
    1. 先将2个ASCII码值和0000 1111做按位与预算，得到低4位。0000 0011和0000 0101
    2. 3的权重是10，5的权重是1，所以用0000 0011*0000 1010+0000 0101*0000 0001=
    3. 二进制乘法可以通过移位和加法实现，上式第一项=0000 1010+0001 0100=0001 1110
    3. 因此上式=0010 0011
    //如果a=-35，则先忽略负号，只处理35，得到0010 0011，然后根据负数补码的运算规则，逐位取反加1即可，位1101 1100+1=1101 1101
    ```

11. 普通的补码是无法保留最高位的溢出的，因此发明了变形补码（主要是用来保存中间结果，来防止中间的结果溢出。最终结果溢出与否无所谓），数值位不变，符号位有2个。8的变形补码为01000，第一个0表示符号位，第二个1表示数值部分溢出了。

    ```c
    十进制   二进制补码  二进制变形补码
      1        0001        00001
      7        0111        00111
      8        1000        01000 //将0111加1得到1000，也就是7+1=-8，这里发生了上溢出，但是如果使用变形补码，则不会溢出，因为原本溢出的那个1，现在的权重为+2^3。
    ...  //变形补码形式的相反数也是逐位取反+1
     -1        1111        11111
     -7        1001        11001
     -8        1000        11000
     -9        0111        10111 //-8+(-1)得到0111，也就是7，这里发生了下溢出，但是如果使用变形补码，则不会溢出，结果为1*(-2^4)+7=-9
    //想通过补码到变形补码，可以进行符号位扩展，例如1001→11001；0111→00111。这是因为当补码的符号位为1时，相当于-2^3，而进行符号位扩展后的变形补码，最高两位为-2^4+2^3=-2^3。
    ```

12. 指针变量存储的是内存地址，参与运算时当作无符号数。

13. 一位半加器→一位全加器→串行进位加法器。低位发生进位会在高位+1。

14. 机器中字的位序列排序有两种方式：例如一个32位字0 ...01011。一般来说计算机中都是LSB（最低有效位）在最右边，MSB（最高有效位）在最左边。这个排序方式实际上就规定了各位的权重方向。

15. C语言中，无符号数字面量应该在末尾加上U或u，例如234u，不加u时，默认当做有符号数。如果无符号数和有符号数运算时，编译器会将有符号数转化为无符号数。例如2+3u等价于2u+3u=5u，运算结果也是无符号数。

16. 计算机只会进行位运算和判断，而程序员还可以进行数学上真值的判断。同时对于同样的机器数，对应到不同的类型，真值不同。

17. 从数学角度理解如下关系表达式：

    ```c
    0 == 0U; //有符号数0会转化为无符号数0，两侧相同，结果为true。
    -1 < 0;  //都是有符号数，结果为true
    -1 < 0U; //需要将左侧当作无符号数看待，-1的补码为11..1，相当于最大的无符号数，因此结果为false
    2147483647 > -2147483647-1; //先分别计算>号的两侧，右侧=-2147483648为10..0，没有溢出，所以结果为true
    2147483647U > -2147483647-1 //先计算右侧，右侧=-2147483648为10..0，要解释为无符号数，即2147483648U，因此结果为false
    2147483647 > (int)2147483648U //等号右侧无符号数的二进制表示为10..0，(int)强制类型转换不会进行任何数据操作，只是将他解释为有符号数，即-2147483648，不溢出，因此结果为true
    -1 > -2 //结果为true
    (unsigned)-1 > -2 //左侧-1的二进制表示为11..1，当作无符号数为4294967295，右侧-2的二进制表示为11..0，当作无符号数为4294967294，因此结果为true
    ```

18. 有符号数和无符号数二进制补码比较大小的简便方法：

    ```c
    //无符号数，从高到低，逐位比较
    //有符号数，先比较符号位，如果不同，则符号位为1的<符号位为0的，因为负数<非负数。如果相同，则按照无符号数比较后续位，后续位大的数大。
    ```

19. 要从位运算角度理解比较操作，需要知道cmp指令会修改的标志寄存器中的位：

    ```c
    //标志寄存器中和cmp指令有关的位：
    ZF:Zero Flag     //当结果的所有位均为0时，设置ZF=1，即为0
    SF:Sign Flag     //当结果的最高位MSB为1时，设置SF=1，即负数。
    PF:Partial Flag  //当结果包含偶数个1时，设置PF=1。而在x86中，PF只检查最低字节。
    AF:Auxiliary Carry Flag //辅助进位标志，只有在使用BCD码进行计算时才会使用到。
    CF:Carry Flag    //当计算过程中最高位发生进位或借位时，设置CF=1。进位标志用于多个ALU之间级联，来进行更多位数的运算。还有移位操作中会用到，例如8位寄存器01010101，且CF=1，对其进行带进位的循环左移，结果寄存器为10101011，CF=0，这里会将最高位移动到CF中，然后将CF移动到最低位中。
    OF:Overflow Flag //两个符号位相同的操作数相加，如果结果的符号位和他们不同，则发生了溢出；两个符号位不同的操作数相减，如果结果的符号位和减数的符号位不同，则发生了溢出。除此之外则不发生溢出。溢出时会设置OF=1。
    //进位与否关注的是计算过程，溢出与否关注的是结果。
    ```

20. 加减指令都是不区分操作数的类型的，因此也都会设置所有的标志寄存器位，需要编译器来决定使用那些寄存器位。例如无符号运算，虽然会设置SF，但是不会用。

21. 无符号数比较与标志位取值：

    ```c
    cmp a,b //如下规则都是通过对具体数的比较可能出现的结果观察来确定的。
    a == b 即 a-b=0，ZF=1
    a != b 即 a-b!=0，ZF=0
    a < b  即 a-b必定借位，CF=1
    a >= b 即 a-b必定不借位，CF=0
    a > b 即 a-b必定不借位且结果又不为0，(CF OR ZF) = 0 //式子中OR是逻辑或，因此不是CF=0或ZF=0，而是CF=0且ZF=0
    a <= b 即 a-b或者借位或者为0，(CF OR ZF) = 1
    //a == b对于有符号数和无符号数都是一样的，都表示每一位都相同，即a-b必定为全0。
    //可以看到当无符号数a < b时，即a按位比较一定比b小。因为第一位为1的数总是比所有第一位为0的数大。所以a-b一定借位，即CF=1。
    //a <= b等价于a < b或a == b，即CF=1或ZF=1。
    //可以通过分别取前二个命题的逆否命题，可得a >= b和a>b的标志位情况。
    ```

22. 有符号数比较与标志位取值，不能仅通过符号位来判断：

    ```c
    cmp a,b
    a == b 即 a-b=0，ZF=1
    a != b 即 a-b!=0，ZF=0 //和a == b互补
    a < b  //(SF=1且OF=0)或(SF=0且OF=1) 等价于 (SF XOR OF) = 1
    a >= b 即 a-b非负且不溢出，SF=0或OF=1     (SF XOR OF) = 0
    a > b  即 a-b为负且有溢出，SF=1且OF=1 //((SF XOR OF) OR ZF) = 0
    a <= b  即 a-b非负且有溢出，SF=0且OF=1//((SF XOR OF) OR ZF) = 1
    //当a < b时，a-b应该为负数，真实的负数有两种情况：符号位为1但不溢出，符号位为0但溢出。因此a < b 等价于即(SF=1且OF=0)或(SF=0且OF=1)。
    //当a > b时，a-b应该为正数，真实的正数有一种情况：非负且非0，即(SF XOR OF) = 0且ZF=0等价于((SF XOR OF) OR ZF) = 0
    //分别取前二个命题的逆否命题，可得a >= b和a <= b的标志位情况。
    ```

23. 以上内容可以查看Intel软件人员开发手册中第1卷附录B。对应的指令为：

    ```c
    //无符号数的<为below，>为above，=为equal。
    JB，JAE，JBE，JA分别为 <，>=，<=，>。
    //有符号数的<为less，>为greater，=为equal。
    JL，JGE，JLE，JG分别为 <，>=，<=，>。
    ```

24. cmp指令相当于减法sub指令，不过不修改操作数，但是会修改标志寄存器。sub指令有可能单独实现（例如x86，8051，这样CF也被称为借位标志），也有可能交由加法指令和取反指令联合实现（例如ARM，PowerPC，这样进位和借位统一了）。

    ```assembly
    sub a,b
    #可能转化为以下三条指令
    inv b #不会有进位，借位或溢出
    inc b #有可能进位或溢出
    add a,b #有可能进位或溢出
    ```

25. 使用cmp指令比较这两个数时是不分有符号和无符号的，但是跳转的时候要区分JB和JL。

26. ```assembly
         7: 	 char a = 255;
    008C1718 C6 45 FB FF          mov         byte ptr [a],0FFh
         8: 	 char b = -1;     #可以看到内存中存储的都是一样的。这是编译器做到的，如果用汇编写程序，就需要程序员自己进行补码的转换。
    008C171C C6 45 EF FF          mov         byte ptr [b],0FFh
         9: 	if (a < b)
    008C1720 0F BE 45 FB          movsx       eax,byte ptr [a]
    008C1724 0F BE 4D EF          movsx       ecx,byte ptr [b]
    008C1728 3B C1                cmp         eax,ecx
    008C172A 7D 0D                jge         main+49h (08C1739h)  #greater equal 即有符号数的>=
    ```

27. 整数在机器中使用补码表示，这句话的意思不仅仅是指在内存中存储是这样的，连编译产生的中间结果也是补码。

28. ```c
    int x = -1; //机器数为11..1B
    unsigned u = 2147483648;  //机器数为10..0B
    // unsigned就是unsigned int
    printf("x = %u = %d",x,x); //%u就是将对应的变量的机器数当做10进制无符号整数来输出。
    //  x = 4294967298 = -1
    printf("u = %u = %d",u,u); //%d就是将对应的变量的机器数当做10进制有符号整数来输出。
    //  u = 2147483648 = -2147483648
    ```

29. 汇编代码如下，可以看到编译器会根据赋值的对象类型将字面量转化为机器数。

    ```assembly
        int x = -1;
    00AA1718  mov   dword ptr [x],0FFFFFFFh
        unsigned u = 2147483648;
    00AA171F  mov   dword ptr [u],80000000h
    ```

30. 编译器如何处理整数字面量，==有待完善，参考CPP Reference==：

    ```c
    //处理方式和32位或64位有关。有后缀的根据后缀来确定类型，没有得根据数值范围来确定。
    //对于负数，编译器会先处理绝对值部分，然后处理负号。前面的负号并不会让它变成int类型，而只是进行逐位取反然后加1的操作
    //赋值时，等号右侧向左侧靠拢，可能会进行截断或扩展，截断不分有/无符号数。有符号数进行符号扩展，和无符号数进行0扩展，这两种扩展都不会改变其数值。
    
    //赋值是单向，会将右侧转化为左侧的类型。
    long long赋值给unsigned，直接截断即可。
    unsigned 赋值给 long long，进行0扩展。
    
    //比较是双向的，会将左右统一到一个类型。
    long long和unsigned比较，先将unsigned进行0扩展至64位的unsigned long long，然后将long long当作无符号数解析，进行无符号比较。
    ```

31. 可以看出不同的字面量，编译器都会解释为不同的类型，因此存储的格式也不同：

    ```c
    //C90情况
    范围           类型
    0→2^31-1       int
    2^31→2^32-1    unsigned int
    2^32→2^63-1    long long
    2^63→2^64-1    unsigned long long
    //C99情况，尽可能用有符号数去fit，实在不行再用无符号数。
    0→2^31-1       int
    2^31→2^63-1    long long  //可以看到unsigned int被吸纳进了long long内部，也就是说直接用64位存储了。
    2^63→2^64-1    unsigned long long
    //以上情况仅表示32位的情况，64位则有区别。
    ```

32. 上述改动对于会导致某些情况下的不同，以下情况会在32位下出现，64位下则都为true：

    ```c
    #include <stdio.h>
    int main() {
        printf("%d\n", -2147483648 < 2147483647); //C89结果为false，C99结果为true，可以看到C99的结果更为合理。
        return 0;
    }
    //C90中，2147483648被解释为unsigned int 10..0，然后取相反数，还是10..0。右侧也要被转成无符号数，01..1，都是32位，因此结果为false。gcc编译时会报warning: this decimal constant is unsigned only in ISO C90。
    //C99中，2147483648被解释为long long，左侧为~00..010..0+1=11..10..0，64位，右侧为01..1，32位。两侧都是有符号数，因此右侧进行符号扩展到64位，为01..1，比较，得结果为true。
    ```

33. 例子：

    ```c
    int x = -2147483648; //分步处理绝对值部分和符号，不论c89还是c99，结果的二进制都是10..0。即x为最小的有符号数。
    unsigned int y = 2147483648; //为10..0。
    x == y; //结果为true
    -2147483647-1 < 2147483647; //左侧2147483647会被当作带符号数01..1，然后取相反数为10..1然后再-1，结果为10..0。<左右都是带符号数，因此结果为true
    ```

# 浮点数

1. 对于一个小数，使用科学计数法，有多种表示，只有一种为规格化的：

   ```c
   //例如1/100可以表示为0.01*10^0，0.1*10^-1，1.0*10^-2或10.0*10^-3等。只有1.0*10^-2是规格化的，因为它的尾数部分在小数点前只有一个非零数。
   //二进制例子，10进制小数0.25可以表示为二进制科学计数法，0.01*2^0，0.1*2^-1，1.0*2^-2，10.0*2^-3，只有0.1*2^-1是规格化的。
   小数的规格化二进制表示有两种可能：±0.1xx..x*2^E 或 ±1.xx..x*2^E，这2种规格化表示的尾数xx..x相同，但是E相差1，因此移码表示的偏置常数也差1，前者为2^8，后者为2^8-1。
   为了表示更多的有效数字，IEEE使用±1.xx..x*2^E。
   ```
2. 伯克利大学的William Kahan为IEEE754的诞生做了大量贡献，因此获得了1989年的图灵奖。
3. IEEE754标准规定了如何在多个位中存储浮点数的三个部分，符号位，尾数部分，指数部分。以32位，float类型为例：

   ```c
   第1位为符号位S
   第2-9位为8位移码表示的指数E，偏置常数为2^8-1。这8位中全0和全1用来表示特殊值。因此规格化数的指数范围为[00000001-127,11111110-127]，即-126到127。当指数为-127和128时，认为是非规格化数，此时指数过小或过大，可能发生0方向溢出或无穷大方向溢出。如果偏置常数为2^8，则规格化数的指数范围为-127到126，则能表示的最大数变小，但是能表示的最小数变得更小了。这种取舍只是一种约定，并非哪一种更好。
   第10-32位为23位原码表示的尾数M。
   //由于规格化表示，小数点前的那位总是1，因此尾数就从小数点后开始记录。23位可以存储24位数。
   float x = 0.25; //它的符号位为0，阶为-2，移码表示为01111101，即125。尾数为0，其因此原码表示为00000000000000000000000。综上float的二进制表示为00111110100000000000000000000000，十六进制为3E80 0000
   ```
4. 规格化数的极限：

   ```c
   最小的正规格化数，阶为-126，尾数为全0，即1.00000000000000000000000*2^(-126)=2^(-126)
   最大的正规格化数，阶为127，尾数为全1，即1.11111111111111111111111*2^127=(2-2^(-23))*2^127，非常接近于2^128。
   因为原码对称，所以表示的规格化数范围也是关于原点对称的：规格化数被分为了2部分，因此将数轴分为了6个区域，0到最小正规格化数为正下溢区，最大正规格化数往上为正上溢区。规格化数段内也不是连续的，段外都是不可以表示的，段内也不是都可以表示的。
   0.0不是规格化数，因为它的二进制中找不到1。它处在正下溢和负下溢范围内。
   浮点数和定点数的个数是一样多的，但是浮点数表示的范围远远大于定点数，因此浮点数之间更稀疏，且不均匀。
   ```
5. 根据8位阶码全0或全1，尾数全0或非全0，可以将除了规格化数以外的情况划分为四种：

   1. 阶码全0，24位尾数全0，表示0，根据符号位的不同，可以有+0和-0。十六进制为0x00000000和0x800000000。可以看到整数0可以直接当作浮点数的0。

      ```c
      float x;
      char str[32] = "80000000";
      FromHex(str, &x, sizeof(x), BigEndian);
      printf("%f\n", x); //结果为-0.000000。如果str为"00000000"，结果为0.000000
      ```
   2. 阶码全0，尾数不全0，表示非规格化数，处在0和最小的±规格化数之间。
   3. 阶码全1，尾数全0，表示无穷大，根据符号位的不同，可以有$+\infin$和$-\infin$。
   4. 阶码全1，尾数不全0，NaN，没有符号位的区别。

6. 浮点数除以0的结果为$±\infin$，并不会发生溢出异常，整数除以0会发生异常。

   ```c
   //所有的除以0常量的代码，在编译阶段都会报warning: division by zero [-Wdiv-by-zero]
   printf("%d\n", 4 / 0); //整数除法，会发生异常错误 Floating point exception (core dumped)
   printf("%f\n", 4.0 / 0);//浮点数除法，结果为inf。并非浮点数的结果是"inf"字符串，而是printf会将阶码全1，尾数全0的浮点数转化为对应的inf或-inf这样的字符串。
   //之所以这么设计是因为有时要利用$±\infin$进行有效比较。
   float x=1.2, y=0.0, z=3.1;
   x/y > z; //浮点数之间可以进行这样的比较。x/y此时为+inf，因此比z大，结果为true。
   ```
7. 无穷大可以参与浮点数的运算，例如：5 + 5.0/0 == 5.0/0，结果为true。

   ```c
   规格数±(±无穷大)都等于±无穷大
   正无穷+正无穷=正无穷
   负无穷+负无穷=负无穷
   负无穷-正无穷=负无穷
   正无穷-负无穷=正无穷
   ```
8. 还有一些运算的结果不能用实数表示，这些被称为NaN，Not a Number。这个结果可以用来调试程序，NaN和NaN之间不一定相同，因为它们的尾数可能不同。

   ```c
   sqrt(-1) = NaN
   0/0 = NaN
   0.0/0.0 = NaN
   无穷大/无穷大 = NaN //和符号无关
   
   正无穷-正无穷=NaN
   负无穷-负无穷=NaN
   负无穷+正无穷=NaN
   正无穷+负无穷=NaN
   ```

9. 规格化数和非规格化数的密度：可以看到在$2^{-126}$和$2^{-125}$之间，$2^{-125}$和$2^{-123}$之间都有$2^23$个数，而后者区间长度是前者的2倍，因此规格化数越靠近0，密度越高。非规格化数，就在0到最小规格化数之间的区间。最小的非规格化数为$2^{-23}\times2^{-126}=2^{-149}$。

10. ![image-20230927215250771](计算机系统基础.assets/image-20230927215250771.png)

11. 由于浮点数在实数轴上是稀疏的，因此部分实数是无法精确表示的，会发生截断或舍入，例如：

    ```c
    #include <stdio.h>
    int main() {
        float x;
        while (1) {
            scanf("%f", &x); //x为float类型，应使用%f，而不是%lf。
            printf("%f\n", x);//默认保留到小数点后6位，足够了。
        }
    }
    输入         输出
    61.419996   61.419994
    61.419997   61.419998 //可以看到至少在[61.419997,61.420000]区间内的实数，都会被就近舍入到61.419998。
    61.419998   61.419998 //61.419998是可精确表示数。
    61.419999   61.419998
    61.420000   61.419998
    61.420001   61.420002
    ```

# 字符数据

1. 西文字符没有输入码，只有内码，也就是ASCII值。中文字符有输入码，因为没有一个包含6万多个按键的键盘，常用的输入码可以是拼音，五笔等。

# 数据宽度

1. 现代计算机中，存储器按字节编址，字节是最小的可寻址单位。

2. LSB为最低有效字节，MSB为最高有效字节。之前介绍的二进制位串，也有LSB和MSB，分别为最低（高）有效位。

3. 字和字长是不同的，前者是一种软件信息，后者是一种硬件信息：

   1. 字（word）是被处理信息的单位，用来衡量数据类型的宽度。和字节，位类似。除了字以外，还有双字（dword），四字（qword），分别为32位，和64位。
   2. 字长（word size）：数据通路的宽度，CPU内部数据流经的路径以及路径上的部件，这些部件的宽度都要一致，这个宽度就是字长。例如32位CPU指的就是字长为32位，即寄存器，ALU单元，和寄存器送到ALU传输路径等都是32位。一次可以处理的信息的宽度。
   3. 二者可以一样，也可以不一样。对于x86体系，不管字长多少，定义字的宽度都是16位，即2个字节。而i386级别的CPU字长就是32位了，现代的x86-64级别的CPU字长都是64位了。对于MIPS32体系，字和字长都是32位。

4. 存储容量和速度大小使用的单位是不同的，例如100K容量为100\*1024B。100k速度为100\*1000b/s。注意容量一般用大写的K，速度一般用小写的k，而M，G，T没有明显的倾向。

5. C语言标准没有明确规定整型类型的具体位数，只给出了下限和相互之间的关系。而浮点数由IEEE754规定，明确了float和double类型分别为32位和64位。

6. C标准并未规定long double的确切长度，有的平台为8字节，有的为10字节，有的16字节。

7. 一个数据如果有多个字节，那么这些个字节在连续的内存中，可以有两种排列方式：大端和小端。

   ```c
   int x = -10; //假定&x=100，其补码表示为0XFFFFFFF6。占4个字节，存放在100到103这4个字节，LSB为F6，MSB为FF。根据LSB和MSB的地址和数据的地址关系，可以分为大端(MSB地址=数据的地址)和小端(LSB地址=数据的地址)。
      地址 大端存储 小端存储
   // 100    FF      F6
   // 101    FF      FF
   // 102    FF      FF
   // 103    F6      FF
   ```

8. 无论大端还是小端，变量的地址都是其所有字节中的地址最小的那个的地址。

9. 可以使用联合数据类型来测试CPU是大端还是小端：

   ```c
   #include <stdio.h>
   void main(){
       //union的特点是所有成员都是优先在低地址存放，例如num的地址为100，那么num.a放在100-103中，num.b放在100中。&num，&num.a，&num.b都是一样的。
       union NUM{ //定义类型为union NUM
           int a;
           char b;
       } num;//同时定义一个变量
       num.a = 0x12345678;
       if (num.b == 0x12){
           printf("BigEndian\n");
       }else{
           printf("LittleEndian\n");
       }
       printf("num.b = 0X%X\n",num.b);
   }
   ```

10. 内存中的指令举例：

    ```assembly
    mov AX,0x12345(BX)  #其中操作码占1个字节为0x40，寄存器AX和BX分别占4位，为0001B和0010B。立即数为32位。若这条指令的地址为100，那么对于小端机器内存中的数据如下，一共占用6个字节：
    地址  值
    100   40
    101   12
    102   45
    103   23
    104   01
    105   00
    #第一个字节操作码，必须在整个指令的开头，也隐含了这个指令的长度。
    ```

11. 在不同端序机器之间交换数据时，应该统一成一种端序（socket就会将数据都转化为大端，在网络上传播），因此需要进行交换字节顺序：

    ```c
    void SwitchEndian(void* data, size_t length) {
        unsigned char tmp;
        unsigned char* datatmp = (unsigned char*)data; //不能使用data = (unsigned char*)data来改变一个指针的类型，必须要重新定义一个新的临时指针。
        for (size_t i = 0; i < length / 2; i++) {
            tmp = datatmp[i];
            datatmp[i] = datatmp[length - 1 - i];
            datatmp[length - 1 - i] = tmp;
        }
    }
    //对于组合数据类型，只能交换其中基本数据类型的端序。
    int x = 0x12345678;
    printf("LittleEndian x = 0x%x\n%",x); //0x12345678
    SwitchEndian(&x, sizeof(x));
    printf("BigEndian x = 0x%x\n%",x); //0x78563412
    ```

12. 不同文件格式也有端序的问题，例如GIF就是小端，而JPEG就是大端。

# 数字逻辑电路基础

1. 布尔代数：关于0和1的一套数学运算体系，用0和1分别代表逻辑值真和假。使用真值表反应输入和输出的关系。
2. 最基本的逻辑运算有与$\and$，或$\or$，非$\neg$。任何一种逻辑表达式都可以写成三种基本运算的组合，例如异或运算异或：$A\oplus B=(\neg A\and B) \or (A\and \neg B)$，异或也成为不等价，当A和B相异时，结果为真。
3. 逻辑运算在机器中可以使用逻辑门电路实现，与或非门电路符号如下：
4. ![image-20230928015802419](计算机系统基础.assets/image-20230928015802419.png)
5. 将各种门电路级联起来，就可以得到逻辑表达式，例如异或门电路实现为为。
6. ![image-20230928015914131](计算机系统基础.assets/image-20230928015914131.png)
7. 机器中可以用一个01位串来表示n个逻辑值。位串之间也可以按位进行逻辑运算，只需要重复使用门电路即可。例如n位异或门电路记号：
8. ![image-20230928020127532](计算机系统基础.assets/image-20230928020127532.png)
9. 根据电路是否具有存储功能，可将逻辑电路分为：
   1. 组合逻辑电路，没有存储功能，输出仅依赖于输入。例如非门。
   2. 时序逻辑电路，具有存储功能，其输出不仅依赖于输入，还依赖于存储单元当前的状态。
10. 可以利用基本逻辑电路构成一些具有特定功能的功能部件，例如译码器，编码器，多路选择器，加法器等。
11. 实现功能部件的步骤：首先使用真值表描述该部件期望的行为，然后根据真值表确定逻辑表达式，最后实现逻辑电路。
12. 1位二路选择器：根据控制端S的值，来选择将A或B直接输出为F。下图中当S=0时，F=A，反之F=B。n位二路选择器中S被复用到n个1位二路选择器的控制端。
13. ![image-20230928103516921](计算机系统基础.assets/image-20230928103516921.png)
14. k路选择器，有k个输入和1个控制，因此s至少有$\log_2k$位。例如k=4，s至少为2位，00，01，10，11。

## 一位加法器

1. 一位半加器，不考虑来自低位的进位和不输出向高位的进位。
2. 一位加法器，也成为全加器。有两个加数A，B和一个低位来的进位Cin，输出为F和向高位的进位Cout。

   ```c
   真值表有9行
   A  B Cin | F Cout
   0  0  0  | 0  0
   0  0  1  | 1  0
   0  1  0  | 1  0
   0  1  1  | 0  1
   1  0  0  | 1  0
   1  0  1  | 0  1
   1  1  0  | 0  1
   1  1  1  | 1  1
   ```
3. 将逻辑表达式化简得到：$F=A\oplus B\oplus Cin$。$Cout=(A\and B)\or(B\and Cin)\or(Cin\and A)$。异或，或都是从左向右计算。全加器（Full Adder）的逻辑电路和符号如下：
4. ![image-20230928110232540](计算机系统基础.assets/image-20230928110232540.png)

## n位加法器

1. n位的加法器可以用n个全加器级联实现，将低位加法器的F直接输出，Cout作为高位加法器的Cin输入。也被称作串行进位加法器。需要从低位到高位严格按照顺序执行n次加法。其逻辑电路和符号如下：
2. ![image-20230928110921899](计算机系统基础.assets/image-20230928110921899.png)
3. ![image-20230928111007590](计算机系统基础.assets/image-20230928111007590.png)
4. 上述n位加法器只能用于记录无符号数的加法，无法用于两个有符号数之间的加法，无法判断是否发生了溢出，因此还需要给他加上一些标志位的输出。

   ```c
   n=4 A=1001 B=1100 Cin=0
   F=0101 Cout=1
   因此这表示二进制数1001+1100+0=10101，即9+12+0=16+4+1=20
   ```
5. n位带标志加法器，会产生4个标志位：

   1. 溢出标志：$OF=C_n\oplus C_{n-1}$，分别为最后一次和倒数第二次加法的进位。还有一种方法：当2个操作数的符号位相同，且和结果的符号位不同时，表示发生了溢出。不过后一种方法需要计算两次异或。
   2. 符号标志：$SF=F_{n-1}$，即最后一次加法的输出F
   3. 零标志：ZF=1当且仅当所有加法的输出F都为0
   4. 加法进位标志：$CF=Cout\oplus Cin$。减法为借位。对于加减器，Cin等于Sub。

6. ![image-20230928111951107](计算机系统基础.assets/image-20230928111951107.png)
7. ![image-20230928232458068](计算机系统基础.assets/image-20230928232458068.png)
8. 程序中经常要用到比较大小，这都是通过判断减法得到的标志信息来实现的。补码的减法可以用加法来实现。

## n位加减器

1. 下图通过将非门，2路选择器和带标志加法器结合，得到了一个带标志的加减器，也可以进行无符号数的加减。Sub为0或1，可以分别作为2路选择器的控制和加法器的Cin。如果Sub=0，则2路选择器输出B本身，那么加法器的Cin也为0，计算的就是A+B。如果Sub=1，则2路选择器输出B的反，然后Cin=1，这样就相当于输入$B’$为-B，因此计算的就是A+(-B)。
2. ![image-20230928232755882](计算机系统基础.assets/image-20230928232755882.png)
3. 在整数加减器的基础上，加上寄存器，移位器和控制逻辑就可以实现ALU，乘/除运算以及浮点运算电路。下图为ALU的符号，有一个操作控制端ALUop，用来决定ALU所执行的处理的功能，它的位数决定了可能进行的操作的数量。它的功能一般包含：无符号数和有符号数的加减等算术运算，与、或、非、异或等逻辑运算。
4. ![image-20230928233503080](计算机系统基础.assets/image-20230928233503080.png)

## 运算符与指令

1. 高级语言中涉及到的运算都会转化为指令集中指令序列，指令会被解码，送到各个由门电路组成的运算器中，指令集中至少应该包含：

   1. 带符号数的，取负/符号扩展/加减乘除/算术移位
   2. 无符号数的，0扩展/加减乘除/逻辑移位
   3. 逻辑操作，与、或、非、异或等
   4. 浮点数的加减乘除

2. 按位逻辑运算：

   ```c
   | //按位或
   & //按位与
   ~ //按位取反
   ^ //按位异或，一个位和1异或，相当于取反。一个位和0异或，啥变化也没有。
   //例子
   x&0xFF //提取int x的LSB
   ```
3. 移位运算：

   ```c
   >> //右移，在C语言层面不区分逻辑和算术移位，而转换成指令时，会根据操作数来区分。
   << //左移
   //右移位运算可以当作除法，不过是整数除法。
   //对于有符号数，移位是算术移位，右移高位补符号位
   //对于无符号数，移位是逻辑移位，右移高位补0
   //无论是算术移位还是逻辑移位，左移低位都是补0，逻辑左移如果移除的是1，则发生溢出，算术左移如果前后符号位不一致，则发生溢出。
   ```
4. 逻辑运算：

   ```c
   || //逻辑或运算
   && //逻辑与运算
   !  //逻辑非运算
   ```
5. 位扩展和截断，C语言中没有对应的运算符，类型转换时需要执行。扩展分为0扩展（无符号数）和符号扩展（有符号数），具体使用哪个，由编译器根据被扩展的数的类型自动选择。截断不区分是否是有符号数，可能会发生溢出。

   ```c
   //在大端机器上输出si,usi,i,ui
   short si = -32768; //最小的有符号数0x8000。
   unsigned short usi = si; //长度没变，不用做扩展和截断，只是改变了数据的解释方式，usi=32768
   int i = si; //进行符号扩展，为0xFFFF8000。i=-32768。
   unsigned = usi;//进行0扩展，0x00008000，uis=32768。
   //可见单纯的扩展并不会修改数值
   int i = 32768; //0x00008000
   short si = (short)i; //截断，si为0x8000，此时发生溢出了，si=-32768。
   int j = si;// 符号扩展j=0xFFFF8000，j=-32768。
   ```
6. 指针通常当作无符号数，因此进行指针运算时，也会将操作数转化为无符号数。
7. 有符号数运算通过OF来判断是否溢出，无符号数运算通过CF判断结果是否进位或借位，这样可以判断结果是否是正确的，符合数学规律的。

   ```c
   //4位2进制有符号运算 可表示范围为-8到7
   -7-6 = -7+(-6) = 1001B+1010B = 10011B = 3 //操作数符号位都是1，结果符号位是0，发生了溢出，结果不对。
   -3-5 = -3+(-5) = 1101B+1011B = 11000B = -8 //操作数符号位都是1，结果符号位也是1，没有溢出，结果正确。
   //4位2进制无符号运算 可表示范围为0到15
   9-6 = 9+(-6) = 1001B-0110B = 1001B+1010B = 10011B = 3 //高位进位(最后一步加法的，而不是取相反数时的加法)Cout=1，减法Sub=1。因此CF=Cout⊕Sub=0，结果正确。
   13-5 = 1101B-0101B = 1101B+1011B = 11000B = 8 //高位进位Cout=1,Sub=1，因此CF=0，结果正确。
   ```
8. 用程序判断两个无符号数相加减是否溢出，即进位：

   ```c
   int uadd_ok(unsigned x, unsigned y){
       unsigned sum = x+y; //不溢出时，结果正确就是x+y，溢出时，结果是x+y-2^n。
       //溢出时，结果一定比x和y都要小，因为如果结果比x大，则x+y-2^n > x → y > 2^n，无符号数最大为2^n-1，显然错误。
       return sum >= x;//没有溢出时，sum >= x为真，返回true。
   }
   //不能用以下程序判断无符号数相减是否借位：
   int usub_ok(unsigned x, unsigned y){
       return uadd_ok(x,-y); //有一个例外就是当x=0, y=0x80000000时，减法会借位，结果为0x80000000。而加法为0+0x80000000=0x800000000，显然sum>=x，没有进位。
   }
   //应该使用类似于uadd_ok的方法来判断是否进/借位：
   int usub_ok(unsigned x, unsigned y){
       unsigned add = x-y; //不溢出时，结果正确就是x-y，溢出时，结果是x+y+2^n。
       //溢出时，结果一定 >= x，因为如果结果比x小，则x-y+2^n < x → y > 2^n，无符号数最大为2^n-1，显然错误。
       return sum < x;//没有溢出时，sum < x为真，返回true。
   }
   ```
9. 用程序判断两个带符号数相加减是否溢出：

   ```c
   int tadd_ok(int a, int b){
       int sum = x+y;
       int neg_over = (x < 0 && y < 0) && sum >= 0; //负数+负数，结果为非负数。
       int pos_over = (x >= 0 && y >= 0) && sum < 0;
       return (!neg_over) && (!pos_over);//不发生正溢出且不发生负溢出。
   }
   //不能用以下程序判断带符号数相减是否溢出：
   int tsub_ok(int a, int b){
       return tadd_ok(x,-y); //有一个例外就是当x=0, y=0x80000000时，减法结果为0x800000000，发生正溢出了。而加法为0+0x80000000=0x800000000，并不会溢出。
   }
   //应该使用类似于tadd_ok的符号位判断方法来判断是否溢出：
   int tsub_ok(int a, int b){
       int sub = x-y;
       int neg_over = (x < 0 && y >= 0) && sum >= 0; //负数-非负数，结果为非负数。
       int pos_over = (x >= 0 && y < 0) && sum < 0;
       return (!neg_over) && (!pos_over);//不发生正溢出且不发生负溢出。
   }
   ```

## 整数乘法

1. 例如2个n位整数相乘，在乘法电路中是可以得到2n位乘积的，但是只会进行截断，把低n位赋值给结果。

2. 数学上，$x^2\ge0$​恒成立，但是计算机中不一定。

   ```c
   //4位2进制带符号数x=5=0101B，x^2=00000101+00010100B=00011001B，结果只取低4位=1001B=-7。
   5*5=25，比7大，模位16，而25和-7模16同余，因此结果为-7。
   ```

3. 编译器判断有符号数乘法是否溢出的方法：2n位乘积的高n位为全0或全1且等于低n位的最高位时，截断不会发生溢出，即2n位乘积的高n+1位全0或全1。不过将2n位乘积截断到n位时，如果截断的部分有1，那一定不会是全1。即不会出现符号扩展的逆运算那样的截断：

   ```c
   //以4位2进制串为例1111*1111=1110 0001，这已经是最大的串了，因此不会出现将11111xyz截断为1xyz的情况，截断的都是01串或全0串，不会是全1串。
   ```

4. 编译器判断无符号数乘法是否溢出的方法：只有2n位乘积的高n位为全0时，截断才不会发生溢出。

5. 用程序判断有符号数乘法的结果是否正确：

   ```c
   int mul_ok(int x, int y){
       int z = x*y;
       if (!x || z/x == y){
           return true; //当x为0时，结果必然正确。或者z/x和y相等即可逆时，结果也正确。
       }else{
           return false;
       }
   }
   //这个表达式!x || z/x == y 也可以判断无符号数乘法的结果是否正确。
   ```

6. CPU会将2n位的结果都提供出来，编译器可以使用某些指令获取高n位，来根据数据类型自主判断是否溢出。硬件不会取判定是否溢出。

   ```c
   //以IA-32为例，mul ax,bx 会进行16位的乘法，结果的高16位存放在dx中，低16位存放在ax中。
   ```

7. 乘法指令不会修改标志寄存器的OF标志，因此无法通过标志判断是否溢出。

8. 如果程序员在源代码中没有判断，且编译器也没有植入一些检查指令，那么就有可能发生溢出，但没有被发现。

9. CPU中乘法指令是区分无符号还是带符号的，这和加减运算不同。

10. 无符号乘法器和带符号乘法器的符号如下，如果4个乘数两两对应位串相等，那么Pu和Ps也是位串相等的，但是高n位的Puh和Psh==不一定相等==。因此机器中可以用无符号乘法器来进行带符号乘法运算。

11. ![image-20230929145509274](计算机系统基础.assets/image-20230929145509274.png)

12. 变量和常数之间的乘法运算，可以由编译器优化成移位和加法运算，这样可以大大提高效率，因为乘法运算通常需要多个时钟周期，而移位和加法一般都是一个或更少的时钟周期。

    ```c
    x*20=x*(16+4)=(x<<4)+(x<<2)。 //带符号数和无符号数都适用，且当结果溢出时，也是和直接相乘结果一样。
    ```


## 整数除法

1. 对于带符号整数来说，n位除以n位，只有$-2^{n-1}/-1=2^{n-1}$会溢出，因为带符号数无法正确表示$2^{n-1}$。

2. 整数除法的商也是整数，因此在不能整除时通常规定朝0的方向舍入。即正数商会向下取整floor，负数商会向上取整ceiling。

3. 整数除以0的结果，是找不到一个2进制位串来表示的，因为所有的二进制位串都表示有限值。因此会CPU发生异常。

4. 整数除法操作不能使用流水线方式实现，因为需要根据每次试商的结果调整，一会做加法，一会做减法，无法预测后续的操作，它的开销比乘法还要大，大约30多个指令周期。

5. 编译器在处理变量除以2的幂的常数时，通常会转化为移位指令，而不是直接使用除法指令。对于无符号数，采用逻辑右移；有符号数，采用算术右移。

   ```c
   //移除的位全0时，表示能够整除
   12/4 = 00001100 >> 2 = 00000011 = 3
   -12/3 = 11110100 >> 2 = 11111101 = -3
   //移除的位中有1时，表示不能整除，需要进行相应的处理
   //当被除数为无符号，带符号正数时，移除的位直接社区，什么也不错：
   14/4 = 00001110 >> 2 = 00000011=3//正确，被移出的为10
   //当被除数为带符号负数，需要先加上偏移量2^k-1，然后再右移k位，低位直接截断即可。
   -14/4 = 11110010 >> 2 = 11111100=-4≠-3 //错误做法
   -14/4 = (11110010+00000011) >> 2 = 11110101 >> 2 = 11111101=-3//正确做法
   ```

6. 假设x为int变量，请给出一个用来计算x/32的函数div32，要求不能使用除法，乘法，模运算，比较运算，循环和条件语句，可以使用右移，加法以及任何按位运算

   ```c
   //若x为非负数，则直接右移5位即可，若x为负数，需要先加上31，再右移5位。综合为(x+b)>>5。当x为非负时，b=0，当x为负数时，b=31。因此可以令b = (x>>31) &0x1F。
   ```


## 浮点数加减运算

1. 设两个规格化的浮点数分别为：$A=M_a\cdot2^{E_a}$，$B=M_b\cdot2^{E_b}$。且$E_a\ge E_b$。则$A\pm B=(M_a\pm M_b\cdot2^{-(E_a-E_b)})\cdot2^{E_a}$。这里进行了对阶操作。$A\cdot B=(M_a\cdot M_b)\cdot2^{E_a+E_b}$，$A/B=(M_a/M_b)\cdot2^{E_a-E_b}$。乘除法不用对阶，尾数相乘除，阶码相加减。

2. 对阶：小阶向大阶看起，阶小的那个数的尾数右移，位数等于大阶-小阶的值。移除的位会保留到特党的附加位，会参与后续的尾数计算，然后输出最终结果时才舍入。

3. 浮点数四则运算可能出现以下结果：

   1. 阶码上溢，一个正的指数超过了最大允许的值，可能为$\pm\infin$。例如float类型中，最大的阶码为11111110B，指数为254-127=127。例如$2^{100}\cdot2^{100}$的阶为200，无法用float表示，因此结果为$+\infin$
   2. 阶码下溢，一个负的指数超过了最大允许的值，可能为$\pm0$。例如float类型中，最小的阶码为00000001B，指数为1-127=-126.例如$2^{-100}\cdot2^{-100}$的阶位-200，无法用float表示，因此结果为0。
   3. 尾数溢出，最高有效位有进位，称为右规。例如float类型中，1.5+1.5=3.0，尾数为11.0，产生了进位，需要移动小数点（通常只用移动一位）使之规格化，同时需要改变阶码（需要判断是否发生上溢）。因此尾数溢出，不一定会造成结果溢出。
   4. 非规格化尾数，数值部分高位为0，称为左规。例如float类型中，1.5-1.0=0.5，尾数为0.1B，需要移动小数点（可能不止一位）使之规格化，同时需要改变阶码（需要判断是否发生下溢）。因此产生非规格化尾数，不一定会造成结果溢出。
   5. 右规和对阶时，右段低位的有效数字可能丢失，称为尾数舍入，因此在计算过程中，可以采用更多的位来表示中间结果，只在最后输出结果时才舍入。

4. IEEE754建议浮点计算硬件为上述每种异常情况提供一个自陷允许位，若某异常对应的位为1，则发生异常时，会调用一个特定的处理程序去处理。类似于信号屏蔽字。

5. IEEE754规定的5种异常情况：

   1. 无效运算，至少一个运算数为非有限数（5+(+∞)），或结果无效（NaN）。
   2. 除以0，即无穷大。结果的尾数为全0，阶码全1表示，符号位视情况而定。
   3. 数太大，阶码上溢
   4. 数太小，阶码下溢
   5. 结果不精确，1/3的结果不能精确表示成浮点数。

6. 浮点数除以0的例子：

   ```c
   #include <stdio.h>
   void main(){
       int a = 1, b = 0;
       printf("%d\n",a/b);//整数除法，会产生运行时错误。因为整数所有位串都只能表示有限数。
       double x = 1.0, y = -1.0, z = 0.0;
       printf("x/z = %f, y/z = %f\n", x/z, y/z); //不会报错，分别为+inf和-inf。浮点数存在特定位串表示±无穷大。
   }
   ```

7. 如果运算结果的尾数都为0，那么阶码也应设置为0，因为尾数为0说明结果就是0。

8. 例子：

   ```c
   0.5+(-0.4375) = 0.0625
   //分别表示为二进制0.5=1.000*2^-1，-0.4375=-1.110*2^-2。
   //对阶后加减为：(1.000+0.1110)*2^-1 = 0.0010*2^-1。
   //尾数为非规格化，需要左规=1.0*2^-4，阶码没有溢出。
   ```

9. 实数除了使用浮点数表示外，还可以使用定点小数表示，定点小数由于没有阶码，一般来说有效数字会比同长度的浮点数多。


# IA-32

1. 计算机中的指令有：

   1. 微指令，微程序指令，属于硬件范畴，CPU内部理解。

   2. 机器指令，处理软硬件交界面的，和用符号表示的汇编指令一一对应

   3. 伪（宏）指令。由若干机器指令构成的序列，属于软件范畴。

2. 同一个ISA可以由不同的汇编指令格式，例如

   ```assembly
   mov [bx+di-6],cl     #Intel格式
   movb %cl,-6(%bx,%di) #AT&T格式，操作码中含有长度后缀。
   #也可以一种通用的描述，寄存器传送语言RTL Register Transfer Language
   M[R[bx]+R[di]-6]←R[cl] #R[]表示寄存器单元，M[]表示内存单元
   ```

3. AT&T汇编风格：

   ```assembly
   movb %ax,%bx #将ax寄存器的内容传送到bx寄存器中
   addb %ax,%bx #将ax寄存器的内容和bx寄存器的内存相加，结果存放到bx中
   andl %eax,(%ecx) #将eax的内容和ecx指向的内存单元的内容做按位相与，结果存放在后者中
   ```

4. 可重定位目标文件和可执行文件中同一个函数的指令都是一样的，不过使用objdump -d反汇编的结果有些不同，可重定位文件中函数的地址是0，指令的地址是相对于函数的偏移地址。可执行文件中函数的地址是一个虚拟地址，指令也是一样的。

5. ![image-20230929220558905](计算机系统基础.assets/image-20230929220558905.png)

6. Intel将x86-32架构改名为IA-32。Intel Architecture。AMD首先提出了兼容IA-32指令集的64位版本，扩充了指令和寄存器的长度和个数，更新了参数传递的方式。AMD将其称为AMD64，Intel称其为Intl64，命名为x86-64，简称为x64。它不同于IA-64（全新的，不兼容32位情况）。

7. IA-32规定了如下内容：

   ```
   8个通用寄存器，1个标志寄存器EFLAGS，PC为EIP
   32位地址空间，为4GB
   变长指令格式，指令由操作码，寻址方式等字段构成
   ```

8. long double实际长度位80位，但是分配96位，按照4字节对齐。

9. IA-32是由16位发展而来的，在16位时代，Intel将16位数据定义为1个字。IA-32的字长为32位。

10. 标志寄存器中除了条件标志外，还存在控制标志：

    ```c
    DF //Direction Flag，方向标志，用来确定自动变址方向是增还是减
    IF //Interrupt Flag，中断允许标志，仅对外部的可屏蔽中断有用
    TF //Trap Flag，陷阱标志，标记是否是单步跟踪状态
    ```

11. 寻址方式是根据指令给出的信息找到操作数或操作数的地址：

    1. 立即数寻址，操作数就包含在指令本身中

    2. 寄存器寻址，操作数在某个寄存器中，指令中指定寄存器的编号

    3. 存储器寻址，指令中直接或间接给出操作数所在的存储单元的地址

12. 存储器寻址方式和处理器的工作模式有关：

    1. 实地址模式，也称实模式，基本用不到了，这是为了与8086/8088兼容而保留的，加电或复位时会首先进入实地址模式。地址宽度20位，寻址空间为1MB，寻址方式为段地址<<4+偏移地址。

    2. 保护模式， 从实模式进入，采用虚拟存储管理，可以在多任务情况下隔离保护。80286以上才有。寻址空间有2^32B=4GB。寻址方式为段基址+段内偏移。

13. IA-32中有6个段寄存器，CS（代码段），SS（堆栈段），DS（数据段），ES（附加段），FS（附加段），GS（附加段）。都是16位长度，根据段寄存器的内容可以取到段基址，间接给出。

14. 保护模式下存储器寻址的方式：

    ```c
    //LA是线性地址，SR是段寄存器，(SR)后的内容统称为有效地址，即在段内的偏移地址。
    位移                LA=(SR)+A //段内偏移由指令中的立即数给出
    基址                LA=(SR)+(B) //B为基址寄存器
    基址+位移           LA=(SR)+(B)+A //综合前两种方式
    比例变址+位移       LA=(SR)+(I)×S+A //I是变址寄存器，S是比例系数，可以是1，2，4，8等。
    基址+变址+位移      LA=(SR)+(B)+(I)+A //综合前几种方式，且S=1
    基址+比例变址+位移  LA=(SR)+(B)+(I)×S+A //综合之前所有的方式
    //还有一种存储器寻址方式和段基址没有关，而是和下一条指令的地址有关系
    相对寻址  LA=(PC)+A  //EIP的值加上位移A的结果为操作数的内存地址
    ```

15. 对于double类型数据，Linux系统中其地址按4B边界对齐，Windows系统中其地址按8B边界对齐，即地址是8的倍数。

16. 根据数组首地址来获取数组内元素的地址时，就可以使用比例变址+位移，比例系数就是数组元素的大小，变址寄存器的内容就是数组元素的下标，位移就是数组首元素地址。

17. IA-32的指令格式：

    ```c
    字段     操作码 + 寻址方式 + SIB + 位移 + 直接数据
    占用字节  1或2      0或1    0或1  1,2,4   立即数
    //位移量和立即数可以是1，2，4个字节
    //操作码包含了opcode，W位，D位。W位与机器模式一起确定寄存器位数，D位确定操作方向，确定源和目标
    //SIB包含了比例因子SS(2位),变址Index(3位),基址Base(3位)。其中Index和Base可以是8个通用寄存器中的任何一个。比例因子用2位表示4种情况，即1，2，4，8。
    //寻址方式包含mod，Reg/OP，r/m。Mod表示寻址方式(2位)，Reg/OP为寄存器编号或操作码扩展字段(3位)，R/m模式位标识是寄存器还是存储器操作数(3位)。
    ```

18. IA-32是典型的CISC（复杂指令集计算机）风格的ISA，指令可能很复杂，很长，变化很多。

## 传送指令

1. 通用数据传送指令：

   ```assembly
   mov #一般传送，包括movb,movw,movl。分别为字节，字，双字
   movs #符号扩展并传送，包括movsbw,movswl,movsbl，例如将char赋值给int类型
   movz #零扩展并传送，包括movzbw,movzwl,movzbl，例如将unsigned char赋值给unsigned int
   xchg #数据交换，相当于两次mov，但是原子操作
   push/pop #入栈，出栈。包括pushb,pushw,pushl,popb,popw,popl。
   ```

2. 地址传送指令，一般用于存储器寻址时，有效地址的计算和临时存储：

   ```assembly
   lea #加载有效地址Load effictive address，如lea (%edx,%eax),%eax，也就是将eax和edx寄存器的值相加，结果存放到eax中，相当于加法指令，如果在多个寄存器之间操作，lea指令比add效率更高，且不会像add那样修改中间寄存器。
   ```

3. 输入输出指令：

   ```assembly
   in/out #用于I/O端口和寄存器之间的数据交换
   ```

4. 标志传送指令：

   ```assembly
   pushf/popf #将EFLAGS寄存器压入，弹出栈
   ```

5. 栈从高地址向低地址生长。SP寄存器指向当前栈顶，入栈时，先移动SP，然后将输入送到栈顶单元。

## 算术指令

1. 定点算术运算指令：

   ```assembly
   #加减运算指令，会影响标志寄存器。不区分操作数是带符号数还是无符号数
   add #加法，包括addb,addw,addl
   sub #减法，包括subb,subw,subl
   #递增指令，会影响除了CF以外的标志，不区分操作数是带符号数还是无符号数
   inc #加1，包括incb,incw,incl
   dec #减1，包括decb,decw,decl
   #取负运算，会影响标志寄存器，若对0取负，结果为0且CF清0，否则对于其他操作数，CF都置1
   neg #取负，包括negb,negw,negl
   #比较运算，做减法得到标志，不影响寄存器的内容，不区分操作数是带符号数还是无符号数
   cmp #比较，包括cmpb,cmpw,cmpl
   #乘除运算，不影响标志，区分无/带符号数
   mul/imul  #无符号/带符号
   div/idivl #无符号/带符号
   ```

2. 乘法指令可以给出1，2或3个操作数：

   1. 如果给出1个操作数，则另一个乘数隐含在al/ax/eax中。结果将存储在ax/dx-ax/eax-edx中，此时进行的是n\*n=2n位的乘法。
   2. 如果给出2个操作数，则结果放在其中第2个操作数中，进行的是n\*n=n位的乘法。
   3. 如果给出3个操作数，则结果存放在第3个操作数中。

3. 除法指令中只会显式给出除数，被除数存放在特定寄存器中。例如如果除数占32位，那么被除数存放在EDX-EAX中，结果的商在EAX中，余数在EDX中。

4. ALU中包含加减器，逻辑运算部件。并没有乘法器，乘法运算可以由移位和加减实现或者在ALU外面单独构造一个乘法器，乘法区分有无符号数。除法同上。

5. 有符号数的补码乘法可以使用Booth算法，也称为补码一位乘法。

   ```c
   booth算法的原理就是小学学过的乘法简化方法，例如(-76)*17=(-76)*16+(-76)*1，而补码比较特殊的一点是它会将17=16+1转化为17=32-16+2-1，然后分别计算4个乘法，当乘数为负数时，例如(-76)*(-16)=(-(-76))*16=76*16。这样就都转化成乘法和加法了。
   //计算8位2进制补码乘法x=-76，y=17，x×y=10110100×00010001，y=2^4+2^0=(2^5-2^4)+(2^1-2^0)。同时需要将x和y都扩充为2n位以便进行后续的加法，即x = 11111111 10110100，-x=00000000 01001100，因此结果为
   111 10110100 00000 + 0000 01001100 0000 + 1111111 10110100 0 + 00000000 01001100 = 0xFAF4 = -1292 = -76*17
   ```


## 按位操作指令

1. 逻辑指令：

   ```assembly
   #以下仅not不影响标志，其他指令中OF=CF=0，ZF和SF根据结果设置
   not #非，包括notb,notw,notl
   and #与，包括andb,andw,andl
   or  #或，包括orb,orw,orl
   xor #异或，xorb,xorw,xorl
   test#测试，和与的效果一样，不过仅影响标志，不修改数值
   ```

2. 移位指令：

   ```assembly
   #移出去的位会被送到CF中
   shl/shr #逻辑左/右移shift，包括shlb,shlw,shll,shrb,shrw,shrl
   sal/sar #算术左/右移，包括salb,salw,sall,sarb,sarw,sarl，如果左移前后最高位不同，则OF=1。
   rol/ror #循环左/右移rotate，包括rolb,rolw,roll,rorb,rorw,rorl
   rcl/rcr #带进位循环左/右移。将CF追加到最高位前面，再进行循环移位
   ```


## 条件转移指令

1. 控制转移：

   ```assembly
   jmp dst #无条件跳转，该指令执行的结果就是将EIP的值设置为dst
   jcc dst #cc为条件码，根据标志位判断条件是否满足，满足则跳转，不满足则顺序执行
   setcc dst #满足条件则将dst寄存器置为1，否则为0
   call dst #将返回地址入栈，转到dst处执行，相当于先push eip，再jmp dst
   ret #从栈中弹出返回地址，相当于pop eip
   
   ```

2. (unsigned)char和(unsigned)short之间比较或者和更长的int比较时，都会转化为int。unsigned int和long long比较时，会转换为long long。


## 浮点处理指令

1. IA-32的浮点处理架构有2种：x87浮点指令集，gcc默认就是这个；SSE指令集，x86-64架构使用

2. 可以处理3种浮点数类型，float，double和80位扩展精度long double格式，扩展精度不属于IEEE754规定的。1位符号位，15位阶码（偏置常数为2^15），1位显式的首位有效位（这个在IEEE754中是隐含的1），63位尾数，没有隐藏位。

3. 早期的浮点处理器都是作为CPU的协处理器出现的（直到80487），CPU内只有定点处理功能。现在都集成到CPU内部了。

4. x87 FPU特指与x86处理器配套的浮点协处理器架构。其内部的浮点寄存器采用栈结构。栈深度为8，宽度有80位，即8个80位的寄存器。分别为ST(0)→ST(7)。栈顶为ST(0)。

5. 所有的浮点运算都是按照80位扩展精度进行的，即使带运算的数是float或double类型。

6. 浮点数可以在浮点寄存器和内存之间传送。扩展精度long double在内存中占用96位（为了4B边界对齐），其中高16位无意义。从浮点寄存器传送到内存时，要将80位的寄存器转换为指定的位数。

7. 数据传送指令：

   ```assembly
   fld  #将数据从内存中装入浮点寄存器栈顶ST(0)，这里要求内存中也是浮点类型
   fild #将int型数据先转化为浮点格式后，再装入浮点寄存器栈顶ST(0)
   fsts/fstl #将浮点寄存器栈顶ST(0)转化为单/双精度格式，然后存入内存单元。
   fstps/fstpl #弹出栈顶元素，并完成fsts/fstl相同的动作
   fists/fistl #将栈顶int型数据转化为浮点格式，存入内存单元
   fistps/fistpl #弹出栈顶元素，并完成fists/fistl相同的动作
   #弹出栈顶元素，会使得ST(1)变为ST(0)了
   fxch #交换栈顶和次栈顶元素
   fldx #将常数x装入栈顶x可以是1(1.2)，z(0.0)，PI(π)，L2E(log_2(e))，L2T(log_2(10))，LG2(log_10(2))，LN2(log_e(2))
   ```

8. 算术运算指令：

   ```assembly
   fadd/faddp #相加/相加后弹出栈
   fiadd #将int型转换后再相加
   fsub/fsubp #相减/相减后弹出栈，栈顶-次栈顶
   fsubr/fsubrp #反过来相减，次栈顶-栈顶
   fisub/fisubp #将int型转换后再相减
   fisubr/fisubrp ##将int型转换后再反过来相减
   fucompp #比较ST(0)和ST(1)
   #如果加减法指令没有带操作数，则默认为ST(0)-ST(1)
   fmul/fmulp #相乘/相乘后弹出栈
   fimul #将int型转换后再相乘
   fdiv/fdivp #相除/相除后弹出栈
   ```

9. MMX（Multimedia extension）多媒体扩展指令，最早在多能奔腾处理器中引入。后来又发展出SSE指令。

10. MMX指令使用8个64位寄存器，MM0-MM7，借用了80位寄存器ST(0)-ST(7)中的64位尾数部分。不同的是，它可以同时处理8个字节，4个字，2个双字或一个四字数据，是SIMD（Single Instruction Multiple Data）技术，数据级并行指令。

11. MMX指令并没有带来3D游戏性能的显著提升，因此后来又推出了SSE指令，后来又陆续推出了SSE2，SSE3，SSE4等指令。这些统称为SSE指令集。

12. SSE指令将80位浮点寄存器ST(0)-ST(7)扩充到128位，分别为XMM(0)-XMM(7)。可以同时处理16个字节，8个字，4个双字，2个四字的数据。

13. 从SSE2开始，还支持128位整数运算，或并行处理2个64位double运算。

14. 为了比较普通指令和SIMD指令的速度，所有操作数都只放在寄存器中，不读写内存，这样可以避免内存读写遇到的不确定延时。前者用时22.64s，后者用时1.41s。加速度大致为16。

    ```assembly
    <dummy_add>:
    push %ebp
    mov %esp,%ebp
    mov $0x4000000,%ecx #一共执行2^26次
    mov $0x1,%al
    mov $0x0,%bl
    add %al,%bl #每次执行8位的加法，0+1
    loop <dummy_add+0xc> #就是add指令的地址
    pop %ebp
    ret
    ############################
    <dummy_add_sse>
    push %ebp
    mov $0x10049d00,%eax #eax指向内存中的单元，其值为1
    mov %esp,%ebp
    push %ebx
    mov $0x10049d20,%ebx #ebx指向内存中的单元，其值为0
    mov $0x400000,%ecx #设定循环次数为2^22，因为一次循环相当于原来的16次
    movdqa (%eax),%xmm0 #从内存中读入到xmm寄存器中，xmm0宽度为128位，数据宽度为8位
    movdqa (%ebx),%xmm1
    paddb %xmm0,%xmm1
    loop <dummy_add_sse+0x1b>
    pop %ebx
    pop %ebp
    ret
    ```

15. SSE指令：

    ```assembly
    paddb #对两个xmm寄存器中的数据按字节(byte)进行相加。一条指令可以同时完成16个单字节数据相加，paddw可以完成8个单字数据相加。
    movdqa #将2个四字数据从源移动到目标，用于在xmm寄存器和128位内存单元之间或2个xmm寄存器之间传输。最后的a表示对齐，即源或目标如果是内存地址时，需要以16B边界对齐，否则会产生一般保护性异常。movdqu表示可以不对齐。
    ```


# 过程调用

1. 例子：

   ```c
   int add(int x, int y){
       return x+y;
   }
   int main(){
       int t1 = 125;
       int t2 = 80;
       int sum = add(t1,t2);
       return sum;
   }
   ```

2. 因为所有过程共享同一套寄存器，因此被调用过程在开始执行自己的代码前，应该先保存自己将要用到的寄存器（没用到的不用保存，一般都是压入栈中），然后再返回前，再将这些寄存器从栈中弹出，恢复通用寄存器。

3. IA-32也给出了寄存器使用约定。这样不同编译器编译的程序都遵守同一套约定，不会出错。

   1. 调用者应保存的寄存器 eax，edx，ecx。被调用者可以直接使用。也不是必须的，如果调用者认为其中数据没有用了，可以不保存
   2. 被调用者应该保存的寄存器ebx，esi，edi。被调用者需要事先保存，事后还原。也不是必须的，如果被调用者不会使用到这几个寄存器，可以不保存。
   3. EBP和ESP分别为帧指针寄存器，栈指针寄存器。分别指向当前栈帧的底部和顶部。

4. 调用者将想要保存的寄存器入栈，然后将参数按照一定顺序入栈，最后调用call指令，该指令会将返回地址入栈。被调用者先将ebp寄存器的值入栈（保存之前栈帧的底部），然后将esp赋值给ebp，新的栈帧形成，栈顶和栈底目前相同，然后将要使用的寄存器入栈，然后执行代码，最后返回时从栈中弹出ebp，然后ret，该指令又会将返回地址从栈中弹出。

   ```assembly
   #使用objdump -d main.o进行反汇编
   main.o:     file format elf32-i386
   
   Disassembly of section .text:
   
   0000118d <add>:
       118d:       55                      push   %ebp
       118e:       89 e5                   mov    %esp,%ebp
       1190:       e8 43 00 00 00          call   11d8 <__x86.get_pc_thunk.ax>
       1195:       05 47 2e 00 00          add    $0x2e47,%eax
       119a:       8b 55 08                mov    0x8(%ebp),%edx
       119d:       8b 45 0c                mov    0xc(%ebp),%eax
       11a0:       01 d0                   add    %edx,%eax
       11a2:       5d                      pop    %ebp
       11a3:       c3                      ret    
   
   000011a4 <main>:
       11a4:       55                      push   %ebp #准备阶段，保存上一个栈帧的栈底
       11a5:       89 e5                   mov    %esp,%ebp #修改当前栈帧的栈底，使之等于当前栈顶
       11a7:       83 ec 10                sub    $0x10,%esp #栈顶减小，也就是主动扩张了16字节
       11aa:       e8 29 00 00 00          call   11d8 <__x86.get_pc_thunk.ax>
       11af:       05 2d 2e 00 00          add    $0x2e2d,%eax #给eax增加0x2e2d
       11b4:       c7 45 f4 7d 00 00 00    movl   $0x7d,-0xc(%ebp) #在栈上分配局部变量t1=125
       11bb:       c7 45 f8 50 00 00 00    movl   $0x50,-0x8(%ebp) #t2=80，这里没有给sum显式分配，是因为他没有赋值，不过这里将-0x4(%ebp)留给了sum。
       11c2:       ff 75 f8                push   -0x8(%ebp) #将t2入栈
       11c5:       ff 75 f4                push   -0xc(%ebp) #将t1入栈
       11c8:       e8 c0 ff ff ff          call   118d <add> #调用函数
       11cd:       83 c4 08                add    $0x8,%esp #栈收缩8个字节，相当于将t2和t1弹出栈
       11d0:       89 45 fc                mov    %eax,-0x4(%ebp)#返回值默认在eax中，赋值给局部变量sum
       11d3:       8b 45 fc                mov    -0x4(%ebp),%eax #main函数的返回值为sum，也应存放在eax中
       11d6:       c9                      leave  #退栈，相当于mov %ebp,%esp和pop %ebp
       11d7:       c3                      ret #返回调用
   
   000011d8 <__x86.get_pc_thunk.ax>:
       11d8:       8b 04 24                mov    (%esp),%eax #将栈顶内容存入eax中
       11db:       c3                      ret    
   ```

5. ![image-20230930171937450](计算机系统基础.assets/image-20230930171937450.png)

6. 参数传递可以有按值传递和按地址传递，二者转换成的指令分别是mov和lea。

   ```assembly
   #例如变量t1的地址为ebp-4
   #值传递为：
   movl -4(%ebp),%eax #将地址为ebp-4的单元赋值给eax
   movl %eax,(%esp) #将eax赋值给栈顶元素
   #指针传递为：
   leal -4(%ebp),%eax #将ebp-4赋值给eax
   movl %eax,(%esp) #将eax赋值给栈顶元素
   ```

7. 一般来说ebp都指向当前栈帧的底部，值为上一个栈帧的ebp，ebp+4存放返回地址，ebp+8存放第一个参数，ebp+12存放第二个，以此类推。


# 控制结构

1. if-else语句的机器级表示：

   ```c
   if (cond_expr){
       then_statement
   }else{
       else_statement
   }
   //会被转化为如下伪代码
       c = cond_expr
       if(c){
           goto true_label; //条件跳转
       }
       else_statement
       goto done; //无条件跳转
   true_label:
   	then_statement
   done:
   ```

2. switch-case结构中的break会转化为一条无条件跳转指令jmp。

3. 具体做法：

   1. 根据case的个数，和数值，制作一个跳转表。例如case分别为15，10，12|17，14，default，标号分别为(.L1,.L2,.L3,.L4,.L5,.L7)。这样跳转表(标号为.L8)中就有17-10+1=8项，这8项分别为4个数值跳转地址。

   2. 在switch开始前，计算eax=eax-10,再cmp $7,%eax,如果above，则跳转到default的地址。否则继续执行无条件jmp *.L8(,%eax,4)。

   3. 跳转表存放在只读数据区域，如果case值的范围非常大，跳转表就会很大，此时编译器可能会将其转化为等价的if-else。


# 数组，结构体，联合体

1. 数组元素在内存中连续存放，后一个元素的地址一定大于前一个的。

   ```c
   //假定数组short A[4]首元素的地址放在edx中，i放在eax中，现在要将A[i]读取到ax中，可以使用
   movw 0(%edx,%eax,2),%ax // A[i]的地址为%edx+%eax*2
   
   ```

2. 结构体的各成员的地址可以用首地址+偏移得到。

3. 使用结构体指针获取成员有两种方式：

   ```c
   struct x{
       int a;
   } x1;
   struct *p1 = &x1;
   (*p1).a;//必须要加括号，因为*的优先级比.低
   p1->a;  //专用符号
   ```

4. 联合体各成员共享存储空间，按最大成员分配空间，各成员都优先在低地址存放，所有成员的地址都一样，都等于联合体的地址。联合体可以实现对同一位串的不同解释：

   ```c
   unsigned float2unsigned(float f){
       union{
           float f;
           unsigned u;
       }tmp_union; //32位
       tmp_union.f = f;
       return tmp_union.u;
   }
   float2unsigned(10.0); //结果为1092616192
   ```


# 数据对齐

1. 数据对齐就是让数据的地址是相应数值的倍数。主存通常按照机器字长或其倍数作为传送单位进行读写，且读写的起始地址也是机器字长的倍数。不进行数据对齐的话，读写数据时，可能会增加实际的读写次数。

2. Windows按照数据长度进行对齐，例如int型数据的地址必须是4的倍数，short型数据的地址必须是2的倍数。

3. Linux的策略更宽松，short型数据的地址是2的倍数，其余长度>=4字节的类型的地址只需要是4的倍数即可。

   ```c
   struct s1{
       int i;
       char c; //c的地址和j的地址差4，中间空了3个字节，因此推荐将j的定义放在c前面，这样整个结构体的长度由12变成9
       int j;
   }
   ```

4. 结构体数组的成员之间和数组元素之间都可能有对齐产生的空隙。

5. 数据对齐是用空间换时间。

6. 可以通过在源代码中添加编译器指令来指导编译器如何处理对齐：

   ```c
   #pragma pack(n) //整体的设定，对所有的变量都生效。指定结构体或类内部成员的对齐方式，当自然边界(例如int的自然边界就是4)比n大时，按n字节对齐。确定pragma指令或n=0时，按自然边界对齐。
   __attribute__((aligned(m))) //指示编译器对一个结构体，类或普通变量的对齐方式，按m(2的幂)字节对齐，且其占用空间也是m的整数倍，以保证在连续申请该类型变量时，各元素也按照m对齐。
   __attribute__((packed)) //不对齐，紧凑存放
   
   //例子
   #pragma pack(4)
   typedef struct {
       uint32_t f1;
       uint8_t f2;
       uint8_t f3;
       uint32_t f4;
       uint64_t f5;
   }__attribute__((packed(1024))) ts; //定义了一个类型ts
   sizeof(ts);//结果为1024
   &((ts*)0->f1); //结果为0。强制类型转换，这里并没有读写f1，只是进行地址的计算，因此0地址也不会报错。
   &((ts*)0->f2); //4
   &((ts*)0->f3); //5
   &((ts*)0->f4); //8
   &((ts*)0->f5); //12，自然边界为8，pack为4<8，因此按照4对齐。
   ```

7. Linux下的例子：

   ```c
   struct test1{
       char x2;
       int x1;
       short x3;
       long long x4;
   }__attribute__((packed)); //紧凑存储，总大小为1+4+2+8=15
   struct test2{
       char x2;
       int x1;
       short x3;
       long long x4;
   };//按照自然边界对齐，总大小为(1+3)+4+(2+2)+8=20
   struct test3{
       char x2;
       int x1;
       short x3;
       long long x4;
   }__attribute__((aligned(8))); //按照8字节外部对齐，内部情况和test2一样，末尾需要加上4个字节，来凑齐24字节，为8的倍数。
   //如果在开头设置了#pragma pack(1)，则表示都按1字节对齐。此时test1大小为15，test2大小为15，test3的大小为16，为8的倍数。
   ```

8. 缓冲区溢出攻击，通过修改函数的返回地址，使之跳转到一段自定义的代码区域，来执行想要的动作。自定义代码区域应该在末尾的地方修改栈顶，然后再ret，这样可以再执行完自定义代码后，恢复到原本的样子。


# x86-64

1. Intel最早推出的64位架构是不兼容32位的，称为IA-64架构，是显式并行指令，基于超长指令。安腾cpu就使用这种架构。由于不兼容旧的代码，因此市场份额惨淡。

2. AMD利用Intel在IA-64上的失败，在2003年抢先推出兼容IA-32的64位版本指令集x86-64。AMD后来将其改名为AMD64。

3. Intel也在2004年推出了IA32-EM64T，它支持x86-64指令集，后来将其改名为Intel64。

4. 注意Intel和IA-64不同，前者是x86-64。Intel64和AMD64都是对x86-64的各自称呼。

5. 64位架构下，long类型占64位，所有指针占64位，long double为80/128位。64位整数指令后缀为q。浮点运算，double操作数的指令后缀原来为l，64位下为d。

6. 新增了8个64位的通用寄存器（整数），为R8-R15。他们都可以作为8，16，32位的寄存器使用，例如R9W为R9寄存器的低16位。

7. 原来的通用寄存器都扩展为64位。例如EAX升级成了RAX。

8. 在32位中，EBP，ESP，ESI，EDI都只有16位的，没有8位的寄存器可以使用，在64位中不全了，分别为BPL，SPL，SIL，DIL。L为low的意思。仍然兼容原来的AH，BH，CH，DH。

9. 这样一来，16个通用寄存器，都可以以64，32，16，8位形式使用。

10. 可以发现64位情况下多了很多寄存器可以使用，因此优先使用寄存器传递参数，大部分函数不需要用栈传递了，因此x86-64不需要栈帧寄存器来标识栈底了，此时RBP可以当作普通寄存器使用。局部变量或实参都通过rsp来获取。

11. 程序计数器也变成64位EIP了。

12. 数据传送指令，使用q后缀表示操作数长度位四字：

    ```assembly
    movabsq I,R #将64位立即数送入64位通用寄存器
    movq #传送一个四字，两个操作数都是64位，不用扩展。
    movsbq movswq movslq #将源操作数进行符号扩展并送入到一个64位寄存器，s表示符号
    movzbq movzwq #将源操作数进行零扩展并送入到一个64位寄存器，z表示零
    movl #相当于movzlq
    #如果要进行截断，可以直接将源操作数设置为低字节的寄存器即可。long型源数据存在%rdi，int型目的数据存在%eax中，可以使用movl %edi,%eax进行截断。或者movslq %edi,%rax也行。
    pushq #将64位操作数入栈
    popq  #将64位操作数弹出栈
    ```

13. 算术逻辑指令，只需将IA-32中的指令后缀改为q即可。

14. 在x86-64平台上使用gcc -m32可以得到与IA-32兼容的指令，默认是-m64。

15. 过程调用：

    1. 最多可以有6个整型或指针参数通过寄存器传递，分别用rdi，rsi，rdx，rcx，r8，r9及它们的32，16，8位寄存器中，从左到右。
    2. 如果超过6个参数，后面的使用栈来传递（从右到左依次入栈）。在栈中传递的参数，如果是基本类型，则都被分配8个字节。IA-32中以8字节对齐。
    3. call的64位返回地址还是保存在栈中。
    4. 返回值都在rax中。
    5. 调用者应保存的寄存器为rax，r10，r11。被调用者应保存的寄存器为rbx，rbp，r12，r13，r14，r15。

# ELF文件

1. 目标文件有三种，在Unix平台上目标文件的格式有多种，常用的就是ELF，Executable Linkage Format，可执行可链接文件。

   ```shell
   ELF 64-bit LSB executable     #可执行目标文件
   ELF 64-bit LSB relocatable    #可重定位目标文件(.o),相当于Windows的.obj文件
   ELF 64-bit LSB shared object  #共享的目标文件(shared object)，动态链接库(.so)，相当于Windows的.dll文件
   ELF 64-bit LSB core file      #核心转储文件 coredump
   #使用file命令来查看文件的格式。
   zj@zj-hit:~$ file /usr/bin/ls
   /usr/bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=897f49cafa98c11d63e619e7e40352f855249c13, for GNU/Linux 3.2.0, stripped
   ```

2. 可重定位目标文件内的代码和数据的地址都是从0开始的，因此不能直接执行。

3. 共享库文件是特殊的可重定位目标文件，它是在程序运行时动态装入并链接。

4. 常用的目标文件格式：

   1. COM格式，DOS上使用，必须被加载到固定地址执行。
   2. COFF格式，System V Unix早期版本使用，包含重定位信息，调试信息，符号表等其他信息。
   3. PE（Portable Executable）格式，Windows上使用，从COFF格式变化而来。
   4. ELF格式，Linux上使用，从COFF格式变化而来。

5. ELF有两种视图，链接视图和执行视图。

6. 32位Linux环境下，ELF头会被加载到0x08048000，入口函数在.text节中，因此会在0x08048000后。4GB虚拟内存空间中，最高的1GB是内核预留的。

7. 可以使用objdump来对ELF文件进行查看，可以对代码区域进行反汇编。

   ```shell
   objdump -d main  #对可执行的节(Flag中含有X)进行反汇编   如果在gcc编译时加入了-g调试选项，可以在此加入-S，反汇编的同时显示源码。默认显示的是AT&T的汇编风格，可以使用-M intel来使用Intel汇编风格显示。-EB和-EL来指定文件是大端还是小端存放的，这是在编译时确定的。
   ```

8. 使用hexdump或od(默认是8进制)命令来查看二进制文件。可以配合head或tail来查看开始或末尾的部分字节。head和tail默认是按照行来查看，而二进制文件中没有行的概念，所以应该按照字节来查看。

   ```shell
   [zj@ZJ lib64]$ head -c 100 libc-2.28.so |hexdump -C #查看开头的100个字节的二进制和ASCII对照。
   00000000  7f 45 4c 46 02 01 01 03  00 00 00 00 00 00 00 00  |.ELF............|
   00000010  03 00 3e 00 01 00 00 00  c0 38 02 00 00 00 00 00  |..>......8......|
   00000020  40 00 00 00 00 00 00 00  10 10 30 00 00 00 00 00  |@.........0.....|
   00000030  00 00 00 00 40 00 38 00  0c 00 40 00 4c 00 4b 00  |....@.8...@.L.K.|
   00000040  06 00 00 00 04 00 00 00  40 00 00 00 00 00 00 00  |........@.......|
   00000050  40 00 00 00 00 00 00 00  40 00 00 00 00 00 00 00  |@.......@.......|
   00000060  a0 02 00 00                                       |....|
   00000064
   ```

9. ELF文件的节和C语言程序中的变量，代码互相对应。局部变量是在运行时，动态在栈上生成的。全局和静态变量分为初始化的和未初始化的，已初始化的放在.data节中，未初始化的放在.bss节中。

10. bss节仅是占位符，不占据实际的磁盘空间，在载入到内存时才会分配空间。之所以区分初始化和未初始化的数据，是为了节省磁盘空间。bss（Block Started by Symbol）是UA-SAP汇编器中使用的一个伪指令，用于为符号预留一块内存空间。bss节内各变量的大小在符号表中给出。

11. 由于C语言规定，未初始化的全局变量和局部静态变量的默认值都是0，因此在ELF文件中可以只做登记。

12. ELF文件的组织，不同ELF文件含有的节可能不一样：

    ```shell
    ELF头 #任何类型的文件都具有类似的头
    .text
    .rodata
    .data
    .bss
    .symtab #存放函数名，全局变量名的信息，不包括局部变量
    .rel.text #.text节中的重定位信息
    .rel.data #.data节中重定位信息
    .debug #调试用的符号表，gcc -g时会生成
    .strtab #包含symtab和debug节中的符号或节名字符串
    .line
    Section header table #节头表
    ```

13. 未初始化的全局变量和静态变量只会在符号表中存储一个common，这个和具体编译器实现有关。

14. 例子：

    ```c
    #include <stdio.h>
    int g_init_var1 = 1;
    int g_uinit_var2 ;
    void foo(int i){
        printf("%d\n",i);
    }
    int main(void)
    {
        static int var3 = 2;
        static int var4;
        int x =3;
        foo(x);
        return 0;
    }
    ```

15. 使用objdump -h查看目标文件的节头。

    ```shell
    [zj@ZJ test]$ objdump -h main.o
    main.o：     文件格式 elf64-x86-64
    节：
    Idx Name          Size      VMA               LMA               File off  Algn
      0 .text         00000042  0000000000000000  0000000000000000  00000040  2**0
                      CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  #指令部分
      1 .data         00000008  0000000000000000  0000000000000000  00000084  2**2
                      CONTENTS, ALLOC, LOAD, DATA  #已经初始化的全局和静态变量。
      2 .bss          00000004  0000000000000000  0000000000000000  0000008c  2**2
                      ALLOC    #未初始化的全局和局部变量，会在程序运行的一开始初始化。
      3 .rodata       00000004  0000000000000000  0000000000000000  0000008c  2**0
                      CONTENTS, ALLOC, LOAD, READONLY, DATA # 只读数据，字符串和只读变量存储在这里。
      4 .comment      0000002d  0000000000000000  0000000000000000  00000090  2**0
                      CONTENTS, READONLY  #编译器写入的信息
      5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000bd  2**0
                      CONTENTS, READONLY
      6 .eh_frame     00000058  0000000000000000  0000000000000000  000000c0  2**3
                      CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
    ```

16. 使用objdump -d main.o查看.text节的反汇编：

    ```assembly
    [zj@ZJ test]$ objdump -d main.o
    main.o：     文件格式 elf64-x86-64
    Disassembly of section .text:
    0000000000000000 <foo>:
       0:   55                      push   %rbp
       1:   48 89 e5                mov    %rsp,%rbp
       4:   48 83 ec 10             sub    $0x10,%rsp
       8:   89 7d fc                mov    %edi,-0x4(%rbp)
       b:   8b 45 fc                mov    -0x4(%rbp),%eax
       e:   89 c6                   mov    %eax,%esi
      10:   bf 00 00 00 00          mov    $0x0,%edi
      15:   b8 00 00 00 00          mov    $0x0,%eax
      1a:   e8 00 00 00 00          callq  1f <foo+0x1f>
      1f:   90                      nop
      20:   c9                      leaveq
      21:   c3                      retq
    0000000000000022 <main>:
      22:   55                      push   %rbp
      23:   48 89 e5                mov    %rsp,%rbp
      26:   48 83 ec 10             sub    $0x10,%rsp
      2a:   c7 45 fc 03 00 00 00    movl   $0x3,-0x4(%rbp)
      31:   8b 45 fc                mov    -0x4(%rbp),%eax
      34:   89 c7                   mov    %eax,%edi
      36:   e8 00 00 00 00          callq  3b <main+0x19>
      3b:   b8 00 00 00 00          mov    $0x0,%eax
      40:   c9                      leaveq
      41:   c3                      retq
    ```

17. 使用objdump -s查看各节的内容：

    ```shell
    [zj@ZJ test]$ objdump -s main.o
    main.o：     文件格式 elf64-x86-64
    Contents of section .text: 
     0000 554889e5 4883ec10 897dfc8b 45fc89c6  UH..H....}..E...
     0010 bf000000 00b80000 0000e800 00000090  ................
     0020 c9c35548 89e54883 ec10c745 fc030000  ..UH..H....E....
     0030 008b45fc 89c7e800 000000b8 00000000  ..E.............
     0040 c9c3                                 ..
    Contents of section .data:   #可读可写数据区域
     0000 01000000 02000000                    ........ #2个int数据，分别为1和2
    Contents of section .rodata:  #只读数据区域
     0000 25640a00                             %d.. #字符串"%d\n"
    Contents of section .comment:  #注释区域，这里是保存了编译器信息的字符串
     0000 00474343 3a202847 4e552920 382e332e  .GCC: (GNU) 8.3.
     0010 31203230 31393131 32312028 52656420  1 20191121 (Red
     0020 48617420 382e332e 312d3529 00        Hat 8.3.1-5).
    Contents of section .eh_frame:
     0000 14000000 00000000 017a5200 01781001  .........zR..x..
     0010 1b0c0708 90010000 1c000000 1c000000  ................
     0020 00000000 22000000 00410e10 8602430d  ...."....A....C.
     0030 065d0c07 08000000 1c000000 3c000000  .]..........<...
     0040 00000000 20000000 00410e10 8602430d  .... ....A....C.
     0050 065b0c07 08000000                    .[......
    ```

18. ELF文件是按照Section和Segment来组织的。

    1. Segment是载入内存时需要用到的，每个Segment是内存权限相同的。装入内存时要和内存中的段对应。
    2. Section是链接器使用的，标识ELF的每一部分是什么。链接的时候，链接器会将不同ELF文件的相同Section合并，并修复相互的引用。

19. 相同权限的section会放入同一个segment，一个section也可以属于多个segment。后者一般是因为内存映射是按页进行的，粒度比较粗，当section比较小的时候可能会出现这种情况。一般来说ELF文件中的段比节的数量要少。

20. 可执行文件必须要有段表，可以没有节表，因为执行时不需要。目标文件必须要有节表，可以没有段表，因为链接时不需要。动态库两者都需要有，因为该文件在链接和执行的时候都会用到。

21. 可执行文件中一般会比可重定位文件多出一个.init节，用于定义_init函数，用来执行一些初始化工作。

22. 可执行文件中一般没有.rel节，因为它不需要再进行重定位了。

23. 段头表（如果存在的话）一般紧跟在ELF头之后，而节头表一般在中部，.rel节在其后面。

24. program header又叫segment header。段头表和节头表中包含很多个段头和节头，他们分别记录了段和节的开始地址，大小，和内存映射到的虚拟地址。

25. 可以使用内存映射mmap来解析elf文件。ELF文件中的节头表不一定是在文件的末尾。readelf中显示的节的顺序不一定和文件存储的相同。

26. 实际上execve命令就是将可执行文件分区域映射到内存块上中，和mmap的操作类似，并不会立即将对应的字节赋值到内存中，因为会用到虚拟内存的技术。

27. readelf是专门用来处理elf文件的，比objdump功能更完善。

28. 可以使用readelf -h 来查看ELF文件头信息：

    ```shell
    [zj@ZJ test]$ readelf -h main
    ELF 头：
      Magic：  7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
      类别:                              ELF64
      数据:                              2 补码，小端序 (little endian)
      版本:                              1 (current)
      OS/ABI:                            UNIX - System V
      ABI 版本:                          0
      类型:                              EXEC (可执行文件)
      系统架构:                          Advanced Micro Devices X86-64
      版本:                              0x1
      入口点地址：              0x4004b0  #内存映像中入口点的虚拟地址
      程序头起点：              64 (bytes into file) #第一个段头的起始地址，相对于文件的最开始
      Start of section headers:          11000 (bytes into file)  #第一个节头的起始地址，相对于文件的最开始
      标志：             0x0
      本头的大小：       64 (字节)      #ELF文件头的大小
      程序头大小：       56 (字节)      #每个段头的大小
      Number of program headers:         9   #段头的个数
      节头大小：         64 (字节)      #每个节头的大小
      节头数量：         30             #节头的个数
      字符串表索引节头： 29              #字符串表索引节头所在的下标
    ```

29. 可以使用readelf -S 来查看ELF文件的节表：

    ```shell
    [zj@ZJ test]$ readelf -S main
    There are 30 section headers, starting at offset 0x2af8:
    节头：
      [号] 名称              类型             地址              偏移量
           大小              全体大小          旗标   链接   信息   对齐
      [ 0]                   NULL             0000000000000000  00000000
           0000000000000000  0000000000000000           0     0     0
      [ 1] .interp           PROGBITS         0000000000400238  00000238
           000000000000001c  0000000000000000   A       0     0     1
    ...
      [29] .shstrtab         STRTAB           0000000000000000  000029dd
           0000000000000119  0000000000000000           0     0     1
    Key to Flags:
      W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
      L (link order), O (extra OS processing required), G (group), T (TLS),
      C (compressed), x (unknown), o (OS specific), E (exclude),
      l (large), p (processor specific)
    #A标志标识执行程序时，需要给该节分配空间，.text，.data，.bss，.rodata都要分配空间
    ```

30. 可以使用readelf -p 节名 elf文件名   来以字符串的方式查看ELF文件的某一节。

    ```shell
    [zj@ZJ test]$ readelf -p .shstrtab main.o
    String dump of section '.shstrtab':      #节名一般在这里存储
      [     1]  .symtab
      [     9]  .strtab
      [    11]  .shstrtab
      [    1b]  .rela.text
      [    26]  .data
      [    2c]  .bss
      [    31]  .rodata
      [    39]  .comment
      [    42]  .note.GNU-stack
      [    52]  .rela.eh_frame
    
    [zj@ZJ test]$ readelf -p .strtab main.o
    String dump of section '.strtab':   #符号名一般在这里处处。
      [     1]  main.c   #源文件名
      [     8]  var4.2367  #局部变量被重命名了
      [    12]  var3.2366  #局部变量
      [    1c]  g_init_var1  #全局变量var1被重命名了
      [    28]  g_uinit_var2   #全局变量var2
      [    35]  foo  #函数名
      [    39]  printf  #标准库中的函数
      [    40]  main  #函数名
    ```

31. 可以使用readelf -l 来查看ELF文件的段表，栈是不占用文件的大小的，内存虚拟地址也是不确定的，由内核加载的时候确定：

    ```shell
    [zj@ZJ test]$ readelf -l main
    Elf 文件类型为 EXEC (可执行文件)
    Entry point 0x4004b0
    There are 9 program headers, starting at offset 64
    程序头：
      Type           Offset             VirtAddr           PhysAddr
                     FileSiz            MemSiz              Flags  Align
      PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040
                     0x00000000000001f8 0x00000000000001f8  R      0x8
      INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238
                     0x000000000000001c 0x000000000000001c  R      0x1
          [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
      LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                     0x00000000000007c8 0x00000000000007c8  R E    0x200000
      LOAD           0x0000000000000e00 0x0000000000600e00 0x0000000000600e00
                     0x000000000000022c 0x0000000000000238  RW     0x200000
      DYNAMIC        0x0000000000000e10 0x0000000000600e10 0x0000000000600e10
                     0x00000000000001d0 0x00000000000001d0  RW     0x8
      NOTE           0x0000000000000254 0x0000000000400254 0x0000000000400254
                     0x0000000000000044 0x0000000000000044  R      0x4
      GNU_EH_FRAME   0x000000000000067c 0x000000000040067c 0x000000000040067c
                     0x0000000000000044 0x0000000000000044  R      0x4
      GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                     0x0000000000000000 0x0000000000000000  RW     0x10
      GNU_RELRO      0x0000000000000e00 0x0000000000600e00 0x0000000000600e00
                     0x0000000000000200 0x0000000000000200  R      0x1
     Section to Segment mapping:  #段和节的映射关系
      段节...
       00     
       01     .interp 
       02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame 
       03     .init_array .fini_array .dynamic .got .got.plt .data .bss 
       04     .dynamic 
       05     .note.ABI-tag .note.gnu.build-id 
       06     .eh_frame_hdr 
       07     
       08     .init_array .fini_array .dynamic .got 
    ```

32. 可以通过readelf -s 来查看ELF文件的符号表，重定位时会用到：

    ```shell
    [zj@ZJ test]$ readelf -s main.o
    Symbol table '.symtab' contains 16 entries:
       Num:    Value          Size Type    Bind   Vis      Ndx Name
         0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
         1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c
         2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1
         3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3
         4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
         5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
         6: 0000000000000000     4 OBJECT  LOCAL  DEFAULT    4 var4.2367
         7: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 var3.2366
         8: 0000000000000000     0 SECTION LOCAL  DEFAULT    7
         9: 0000000000000000     0 SECTION LOCAL  DEFAULT    8
        10: 0000000000000000     0 SECTION LOCAL  DEFAULT    6
        11: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 g_init_var1
        12: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM g_uinit_var2  #未初始化的全局变量，存在于.bss段中。
        13: 0000000000000000    34 FUNC    GLOBAL DEFAULT    1 foo
        14: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf  #链接前不知道该标号是什么类型和节号，Ndx是当前符号所在的节
        15: 0000000000000022    32 FUNC    GLOBAL DEFAULT    1 main
    ```

33. ELF链接视图和执行视图之间的对应关系，在程序运行期间时，可以通过/proc/进程PID/maps目录查看内存映射：

34. ![image-20210530215709443](计算机系统基础.assets/image-20210530215709443.png)

35. 可以使用gdb启动该程序，这样程序会被自然中断，然后就可以查看它的内存模块了。

36. ELF头文件中使用到的数据类型，64位：

    ```c
    typedef uint16_t Elf64_Half;
    typedef uint32_t Elf64_Word;
    typedef	int32_t  Elf64_Sword;
    typedef uint64_t Elf64_Xword;
    typedef	int64_t  Elf64_Sxword;
    typedef uint64_t Elf64_Addr;
    typedef uint64_t Elf64_Off;
    typedef uint16_t Elf64_Section; //因此最多65536个节
    typedef Elf64_Half Elf64_Versym;
    ```

37. ELF文件头结构体，32位时为52字节，64位时为64字节。记录里节和段的信息。

    ```c
    #define EI_NIDENT 16
    typedef struct{
      unsigned char	e_ident[EI_NIDENT]; //16个字节的魔数
      Elf64_Half	e_type;       //目标文件的类型，
      Elf64_Half	e_machine;    //架构
      Elf64_Word	e_version;    //目标文件的版本
      Elf64_Addr	e_entry;      //入口点的虚拟地址
      Elf64_Off	e_phoff;          //段头表的文件偏移地址，如果是0，则表示没有段头表
      Elf64_Off	e_shoff;          //节头表的文件偏移地址
      Elf64_Word	e_flags;      //处理器特定的标志
      Elf64_Half	e_ehsize;     //ELF文件头的大小，默认都是以字节为单位
      Elf64_Half	e_phentsize;  // 段头表每个条目的大小
      Elf64_Half	e_phnum;      //段头表的条目数量
      Elf64_Half	e_shentsize;  //节头表每个条目的大小。
      Elf64_Half	e_shnum;      //节头表的条目数量
      Elf64_Half	e_shstrndx;   //字符串表在节头表中的下标。
    } Elf64_Ehdr;
    ```

38. 段头表中的每一项，一般为56字节：

    ```c
    typedef struct{
      Elf64_Word	p_type;   //段类型，可以是LOAD(直接装入内存或像.bss那样)，GNU_STACK(栈)
      Elf64_Word	p_flags;  //段标志
      Elf64_Off	p_offset;     //段在ELF文件中的偏移
      Elf64_Addr	p_vaddr;  //段在内存中的虚拟地址
      Elf64_Addr	p_paddr;  //段在内存中的物理地址，现在都是使用虚拟内存，因此和上一个字段一样
      Elf64_Xword	p_filesz; //段在文件中占用的大小
      Elf64_Xword	p_memsz;  //段在内存中占用的大小
      Elf64_Xword	p_align;  //段对齐
    } Elf64_Phdr;
    ```

39. 节头表中的每一项，一般为64字节，文件的不同节不重叠，可能存在一些字节，不属于文件头部和任何节：

    ```c
    typedef struct{
      Elf64_Word	sh_name;   //节名，实际上是在节头字符串表的偏移地址，字符串以'\0'结尾
      Elf64_Word	sh_type;   //节类型，可能是空，代码，数据，符号等
      Elf64_Xword	sh_flags;  //节的属性，该节在虚拟空间中的访问属性
      Elf64_Addr	sh_addr;   //执行时节的虚拟地址
      Elf64_Off	sh_offset;     //节在ELF文件中的偏移地址，对于.bss节无意义
      Elf64_Xword	sh_size;   //节大小
      Elf64_Word	sh_link;   //和链接相关的节，例如.text的sh_link就是.rel.text
      Elf64_Word	sh_info;   //额外的节信息
      Elf64_Xword	sh_addralign;  //节对齐方式
      Elf64_Xword	sh_entsize;//表中每项的大小，如果节包含表
    } Elf64_Shdr;
    ```

40. 符号section内存储的是一个一个的符号结构体：

    ```c
    typedef struct{
        Elf64_Word    st_name;  //符号名字符串在.strtab节中的偏移
        unsigned char st_info;  //符号类型(数据，函数，源文件，节，未知)和绑定属性(全局符号，局部符号，弱符号)。
        unsigned char st_other; /* Symbol visibility */
        Elf64_Section st_shndx; //符号对应目标所在的节编号
        Elf64_Addr    st_value; //符号在对应节中的偏移
        Elf64_Xword   st_size;  //符号占用的字节数
    } Elf64_Sym;
    ```

41. 例子：

    ```shell
    #从ELF文件头中可以得到：
    #节头表的偏移地址为0x2AF8，一共有0x1E个节，每个大小为0x40，字符串索引节头表是节头表的第1D项。
    #一共有9个段，每个段头的大小为0x38，程序的入口点的虚拟地址为0x4004B0
    00000000: 7F 45 4C 46 02 01 01 00 00 00 00 00 00 00 00 00    .ELF............
    00000010: 02 00 3E 00 01 00 00 00 B0 04 40 00 00 00 00 00    ..>.....0.@.....
    00000020: 40 00 00 00 00 00 00 00 F8 2A 00 00 00 00 00 00    @.......x*......
    00000030: 00 00 00 00 40 00 38 00 09 00 40 00 1E 00 1D 00    ....@.8...@.....
    
    #第13个节头表，首地址为0x2AF8+13*64=0x2E38，当前节的名称为0x29DD+0x94=0x2A71查询最下面的表，可以看到是.text  当前节的起始地址为0x4B0。该节在内存中的地址为0x4004B0，和文件头中的属性对应上，因此当前节就是程序的入口点。
    00002e30: -- -- -- -- -- -- -- -- 94 00 00 00 01 00 00 00    ................
    00002e40: 06 00 00 00 00 00 00 00 B0 04 40 00 00 00 00 00    ........0.@.....
    00002e50: B0 04 00 00 00 00 00 00 A5 01 00 00 00 00 00 00    0.......%.......
    00002e60: 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00 00    ................
    00002e70: 00 00 00 00 00 00 00 00 -- -- -- -- -- -- -- --    ................
    
    #字符串索引节头表的地址为0x2AF8+29*64=0x3238,节的起始地址为0x29DD。当前节的名称为0x29DD+0x11=0x29EE查询最下面的表，可以看到是.shstrtab
    00003230: -- -- -- -- -- -- -- -- 11 00 00 00 03 00 00 00    ................
    00003240: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    00003250: DD 29 00 00 00 00 00 00 19 01 00 00 00 00 00 00    ])..............
    00003260: 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00    ................
    00003270: 00 00 00 00 00 00 00 00                            ........
    
    #字符串索引节的内容
    000029d0: -- -- -- -- -- -- -- -- -- -- -- -- -- 00 2E 73    g_uinit_var2...s
    000029e0: 79 6D 74 61 62 00 2E 73 74 72 74 61 62 00 2E 73    ymtab..strtab..s
    000029f0: 68 73 74 72 74 61 62 00 2E 69 6E 74 65 72 70 00    hstrtab..interp.
    ...
    00002a70: 00 2E 74 65 78 74 00 2E 66 69 6E 69 00 2E 72 6F    ..text..fini..ro
    
    #.text节的内容
    000004b0: F3 0F 1E FA 31 ED 49 89 D1 5E 48 89 E2 48 83 E4    s..z1mI.Q^H.bH.d
    000004c0: F0 50 54 49 C7 C0 50 06 40 00 48 C7 C1 E0 05 40    pPTIG@P.@.HGA`.@
    000004d0: 00 48 C7 C7 B8 05 40 00 FF 15 0A 0B 20 00 F4 90    .HGG8.@.......t.
    ```

# 链接

1. 机器语言中，跳转的目的地址或变量的地址都是使用绝对地址，这样插入或删除指令后，会造成地址引用的错误。因此在汇编语言中使用符号来标记这些地址，然后再用汇编器处理符号定义和符号引用，自动化地计算出符号地址，并在引用符号处填入定义符号的地址。

2. 链接的步骤：

   1. 进行符号解析（也称为符号绑定），确定符号之间的引用关系

   2. 合并目标文件（代码段和数据段分别合并），此时各个符号都有了确定的位置

   3. 在引用符号的地方替换上新的地址，后两步称为重定位。

3. 任意出现符号的位置，都要区分是定义还是引用：

   ```c
   void swap(){} //定义了swap符号
   void swap(); //也是定义符号，不过是弱符号
   swap(); //引用了swap符号
   int *xp = &x; //定义了xp符号，引用了x符号
   extern int buf[]; //也是定义了一个弱符号，表明该符号定义在当前模块外
   ```

4. 编译器会将源文件中定义的所有符号存放到ELF文件中的符号表中，符号表在.symtab节中，是一个结构体数组，每个表项包含了符号名，长度，位置，属性等信息。

5. 编译器会将源文件中关于符号的引用存放到ELF文件中的重定位节中，例如.rel.text和.rel.data节。

6. 定义的符号不一定在本目标文件中被引用，引用的符号也不一定在本目标文件中被定义。

7. 符号可以分为3类：

   1. 全局符号，由本模块定义，可以被其他模块引用。例如非static的函数和非static的全局变量。

   2. 外部符号，由其他模块定义，可以被本模块引用。例如头文件中导入的函数声明，extern声明的外部符号。

   3. 局部符号，由本模块定义，不能被外部模块引用。例如static的函数和static的变量。并非局部变量。

8. 所有引用的符号的位置都只能找到一个关于该符号的定义，否则会有歧义。

9. 全局符号具有强弱性：函数名和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。而不只是根据extern来判断，外部符号都是弱符号。

   ```c
   int var1 = 5; //强
   int var2; //弱
   int p1(){ }//所有的函数都是强符号
   ```

10. 对于多重定义符号的规则，这里不区分符号的类型：

    1. 强符号只能定义一次，否则连接错误。

    2. 如果一个符号被定义为一次强符号，多次弱符号，则以强符号为准。

    3. 如果一个符号只有多个弱符号定义，没有强符号定义，则任选一个。gcc -fno-common 可以对这种情况输出警告。

11. 为了避免符号引用错误，尽量使用局部符号，因为只在同一个模块内部引用一般不会出错；全局变量应赋初值，使之成为强符号，让符号重定义问题在链接截断就暴露出来；外部符号推荐使用extern。

12. 符号解析的过程：

    1. 会使用到三个集合，E（所有用来被合并的目标文件的集合），U（当前所有未解析的引用符号），D（当前所有定义的符号）

    2. 开始时，EUD都为空。逐个扫描命令行参数中的输入目标文件，将其加入到E中。

    3. 扫描期间当当前未解析的引用记录到U中，之后每遇到一个新的.o或.a时，就会进行搜索。

    4. 如果找到则将符号从U转到D中，且该目标文件也会被最终添加到结果中。

    5. 如果最终U不为空，则表示存在为解析的符号。

13. 链接器命令行参数中目标文件和库文件的顺序很重要，因为链接器是按照顺序处理引用的。如果一个库文件中的所有目标文件都不匹配U中所有的符号，那么整个库就会被丢弃，后续对于该库中符号的引用，也会因为找不到符号而报错 undefined reference to "xxx"。

14. 目标文件应该按照调用顺序来排序。一般推荐将库文件.a放在后面。如果两个目标文件存在相互调用，则可以将其中一个重复出现：

    ```shell
    gcc libx.a liby.a libx.a # x在y前面，y也在x的前面
    ```

15. 符号解析产生的集合E和D，在重定位时都要使用，集合E会被合并到节中，集合D中的每个符号都要确定其地址。

16. 汇编器在生成目标文件过程中，遇到引用时，会生成一个重定位条目，未知的地址一般会用全0暂时填充。

    ```c
    typedef struct{
        int offset;//符号在节内的偏移量
        int symbol:24,//符号表中的编号
            type:8; //重定位的类型，IA-32有两种，R_386_32(绝对地址)，R_386_32(PC相对地址)
    }Elf32_Rel;  //一共8个字节，后4个字节分成了2个位域，一个占24位，一个占8位。
    //由于需要重定位的都是函数或变量地址，因此不用声明符号的长度，32位下地址都是32位，64位下地址都是64位。
    //重定位过程中要修改的地址可能包含在.text的指令中，也可能包含在.data的数据中，在指针变量中存储其他变量的地址就会发生这种情况。
    ```

17. 重定位过程：

    1. 将集合E中所有目标模块中相同的节合并成新的节。

    2. 对集合D中所有的定义符号确定其在虚拟地址空间中的位置。

    3. 为引用符号进行重定位。重定位类型为绝对地址时，就填入绝对地址，如果是PC相对地址，要计算下一条指令开头+偏移=目标的地址，这个偏移就是要填入的地址。

    4. 有一个点需要注意，待重定位的地方，不一定都是全0，例如对buf[1]的引用，不只是需要知道符号buf的地址，还要计算它的第一个数组元素的地址，因此这个待重定位的地方的值为，因为buf[1]比buf大4个字节。

18. 例子：

    ```c
    //main.c
    int buf[2] = {1,2}; //全局强符号
    void swap(); //外部弱符号
    int main(){ //全局强符号
        ...
    }
    //swap.c
    extern int buf[]; //外部弱符号
    int *bufp0 = &buf[0]; //全局强符号
    static int*bufp1; //局部符号
    void swap(){ //全局强符号
        ...
    }
    ```

19. C标准库libc.a大约包含1392个目标文件，包含了I/O，存储分配，信号处理，字符串，时间处理等功能。

20. libc.a是数学库，401个目标文件，包含了浮点数运算函数。

21. 使用链接功能，允许程序分模块编写，修改部分源文件后，也只需要编译该文件，然后再链接即可。动态链接还可以提高代码复用性。静态链接时，只会将静态库文件中使用到的函数的目标文件包括到最终的可执行文件中，例如如果只使用了libc.a的printf.o中的printf函数，则不会包含其他.o文件。

22. gcc中无需显式指明C标准库libc.so或libc.a。

23. 静态库允许使用ar命令增量更新，当修改了一个模块后，可以替换掉库中旧的该模块。

    ```shell
    gcc -c a.c b.c #会产生2个目标文件a.o b.o
    ar rcs mylib.a a.o b.o #打包2个.o文件到mylib.a静态库中
    ```

24. 静态链接的缺点：

    1. 静态库的函数都存放在程序的.text节，执行时会被加载到只读段，如果有多个程序都是用同一个函数，也会加载多份到内存中，造成内存浪费。同时也会造成磁盘空间的浪费。

    2. 如果静态库内代码更新，可执行程序需要重新链接才可以使用更新的功能，给用户分发更新比较麻烦。

25. 动态库的使用可以和可执行程序同时加载（自动完成），也可以在程序已经运行后，需要手动加载和卸载，调用dlopen()，dlclose()函数，后者称为延迟绑定，可以提高程序的启动速度。

26. 将动态库参与链接生成可执行文件时，使用的是静态链接器，生成的是部分链接的可执行文件。执行该程序时，会使用到动态链接器，此时会找到动态库，产生一个完全链接的文件（只在内存中，并不在硬盘上），载入内存。

27. 可执行文件的.interp段中指明了要使用的动态链接器。

28. 函数内的局部变量分配在栈上，不能再函数外被引用，因此不是符号定义，也就是说不会参与链接时的符号解析。

29. gcc链接时默认使用动态库，系统中默认是不安装有静态库的。运行以下命令来安装：

    ```shell
    yum --enablerepo=powertools install glibc-static
    ```

30. 编译器为了防止标识符重名的情况，会在编译时对符号进行装饰。

31. 使用readel -r 或objdump -r可以查看重定位信息：

    ```shell
    [zj@ZJ test]$ readelf -r main.o
    重定位节 '.rela.text' at offset 0x2e0 contains 3 entries:
      偏移量          信息           类型           符号值        符号名称 + 加数
    000000000011  00050000000a R_X86_64_32       0000000000000000 .rodata + 0
    00000000001b  000e00000002 R_X86_64_PC32     0000000000000000 printf - 4
    000000000037  000d00000002 R_X86_64_PC32     0000000000000000 foo - 4
    重定位节 '.rela.eh_frame' at offset 0x328 contains 2 entries:
      偏移量          信息           类型           符号值        符号名称 + 加数
    000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0
    000000000040  000200000002 R_X86_64_PC32     0000000000000000 .text + 22
    
    [zj@ZJ test]$ objdump -r main.o
    main.o：     文件格式 elf64-x86-64
    RELOCATION RECORDS FOR [.text]:
    OFFSET           TYPE              VALUE
    0000000000000011 R_X86_64_32       .rodata
    000000000000001b R_X86_64_PC32     printf-0x0000000000000004
    0000000000000037 R_X86_64_PC32     foo-0x0000000000000004
    RELOCATION RECORDS FOR [.eh_frame]:
    OFFSET           TYPE              VALUE
    0000000000000020 R_X86_64_PC32     .text
    0000000000000040 R_X86_64_PC32     .text+0x0000000000000022
    ```

32. ld --verbose查看默认的链接脚本。在嵌入式开发中，有时需要对链接进行精确控制，此时可以自己书写链接脚本。

33. 可以看到编译前，main函数中调用函数的call指令，其指令的操作数部分都是0，需要搜索符号表确定被调函数的地址。

34. 可执行文件的装载过程：

    1. 操作系统给进程分配资源，开辟虚拟地址空间。
    2. 建立可执行文件到进程虚拟地址空间的映射。
    3. 将IP设置为程序入口点，开始执行。

35. 映射是按照segment来的，section的组织对顺序没有要求，而同一个segment中的section的内存操作权限是相同。因此section的组织是配合segment来的。

36. 可以在/proc/进程ID/maps文件下面看到进程的虚拟地址映射关系：

    1. 第1列为虚拟内存的起始和终止地址
    2. 第2列为内存的权限，前三个个读写执行，最后一个为共享或私有
    3. 第3列为映射在文件中的偏移量
    4. 第4列为映像文件的主次设备号
    5. 第5列为映像文件的iNode号
    6. 第6列为映像文件的路径

37. ![image-20210531203113792](计算机系统基础.assets/image-20210531203113792.png)

38. 可执行文件的装载器在进程开始执行前，会将argc和argv会有放入到进程的栈中。

39. 使用动态库的进程地址空间。ld-2.12.so是动态链接器。操作系统会先将控制权交给动态链接器，进行链接，完成后再将控制权交给程序本身。动态链接器是在elf文件中指定的。

40. ![image-20210531233109994](计算机系统基础.assets/image-20210531233109994.png)

41. 通过readelf查看.so文件的segment，可以看到，虚拟地址是从0开始的，表示最终的装载地址是不确定的。

    ```shell
    [zj@ZJ test]$ readelf -l add.so
    Elf 文件类型为 DYN (共享目标文件)
    Entry point 0x4c0
    There are 7 program headers, starting at offset 64
    程序头：
      Type           Offset             VirtAddr           PhysAddr
                     FileSiz            MemSiz              Flags  Align
      LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                     0x0000000000000624 0x0000000000000624  R E    0x200000
      LOAD           0x0000000000000e08 0x0000000000200e08 0x0000000000200e08
    ...
    ```

42. 静态链接时会进行重定位，动态链接的程序在执行的开始，也会进行符号查找，重定位。

43. PIC，位置无关代码。编译器会将指令中需要被修改的部分分离出来和数据部分放到一起。好处：动态库可以被不同的程序装载到各自虚拟地址空间中的不同位置；即使动态库的代码长度发生了变化，也不会影响到调用它的程序。

44. .dynamic节是和动态链接相关的。

    ```shell
    [zj@ZJ test]$ readelf -d main
    
    Dynamic section at offset 0xe00 contains 25 entries:
      标记        类型                         名称/值
     0x0000000000000001 (NEEDED)             共享库：[./add.so]
     0x0000000000000001 (NEEDED)             共享库：[libc.so.6]
     0x000000000000000c (INIT)               0x400518
     0x000000000000000d (FINI)               0x400728
     0x0000000000000019 (INIT_ARRAY)         0x600df0
     0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)
     ...
    ```

45. 该节是由如下结构体构成的：

    ```c
    typedef struct{
      Elf64_Sxword  d_tag;                  /* Dynamic entry type */
      union{
          Elf64_Xword d_val;                /* Integer value */
          Elf64_Addr d_ptr;                 /* Address value */
        } d_un;
    } Elf64_Dyn;
    ```

46. 可以使用readelf -sD 查看动态库的符号表。

    ```shell
    [zj@ZJ test]$ readelf -sD add.so
    
    Symbol table of `.gnu.hash' for image:
      Num Buc:    Value          Size   Type   Bind Vis      Ndx Name
        5   0: 0000000000201020     0 NOTYPE  GLOBAL DEFAULT  20 _edata
        6   0: 0000000000201028     0 NOTYPE  GLOBAL DEFAULT  21 _end
        7   1: 0000000000000579    20 FUNC    GLOBAL DEFAULT  11 add   #动态库导出的函数
        8   1: 0000000000201020     0 NOTYPE  GLOBAL DEFAULT  21 __bss_start
    ```

47. 动态链接的程序执行的步骤：

    1. 根据elf文件的动态.dynamic节，确定需要使用的动态库文件名。
    2. 将可执行文件的segment和上述文件映射到进程的虚拟空间。根据可执行文件中的重定位表去动态链接库的符号表中查找，对应的函数，变量的实际地址，进行修正。

48. 可以使用ldd命令查看程序所依赖的动态库。

49. ```shell
    [zj@ZJ test]$ ldd main
            linux-vdso.so.1 (0x00007fff1d5f6000)   #库的名称是按照链接时指定的记录的。默认会在系统的lib目录下查找
            ./add.so (0x00007f1969bff000)
            libc.so.6 => /lib64/libc.so.6 (0x00007f196983c000) #标准C库
            /lib64/ld-linux-x86-64.so.2 (0x00007f1969e01000) #动态链接器
    [zj@ZJ test]$ ldd /lib64/ld-linux-x86-64.so.2
            statically linked      #可以看到动态连接器本身是静态链接生成的，本身不依赖其他的动态库。特殊的是，该文件本身是可执行的。它是glibc的一部分
    ```

50. 自己编写的程序如果使用到自己的编写的共享库，最终生成可执行文件时，应该将共享库拷贝到系统目录的lib下，再执行一遍链接，此时ldd中显示的依赖才变成系统目录中的库。这样发布给用户使用，也不会出问题。

51. 共享库的命名要符合规范例如  libadd.so库在gcc链接时，选项为-ladd

52. 操作系统在程序装载后，最开始执行的并不是main函数的第一行代码。而是运行入口函数，它负责初始化运行环境。然后调用main函数。并且在main函数返回后，记录它的返回值，调用使用atexit注册过的函数，最后结束进程。

    ```c
    _start → _libc_init_first → _init → atexit → main → _exit
    ```

53. 以glibc为例，入口函数是由链接脚本所指定的，默认是_start。记录在elf文件头的入口点中。
