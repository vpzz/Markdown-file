# C程序举例

1. 以下问题的环境均为：ISO C90标准，32位系统。

2. 编译器如何处理字面量，实际就是该值在机器中是如何表示的：

   ```c
   -2147483648 < 2147483647; //结果为false，和数学上不符
   //若先将左侧赋值给int变量，再进行比较：
   int i = -2147483648;
   i < 2147483647; //结果为true
   //若将左侧的值写成如下形式：
   -2147483647-1 < 2147483647; //结果也是true
   ```

3. 高级语言表达式的运算规则，对应的机器指令：

   ```c
   sum(int a[], unsigned len){ //数组元素求和
       int i, sum = 0;
       for (i = 0; i <= len-1; i++){
           sum += a[i];
       }
       return sum;
   }
   //当sum的第二个参数len为0时，返回值却不为0。有可能出现对内存地址0xC0000005的非法访问错误。
   //如果将len的类型改为int，则不会出现上述错误。
   ```

4. 数学上的恒等式，在计算机世界中不总成立，存在例外：

   ```c
   int x = 65535,y;
   y = x * x;//结果y的值为-131071，违反数学中整数的平方非负的规则。
   
   int a,b;
   (a>b) == (-a<-b); //不一定总是为真(x=-2147483648,y为除-2147483648外的任意数)，而在数学中总是为真的。
   ```

5. 程序中变量存储空间的分配，数据的大小端存储，链接器的符号识别规则：

   ```c
   //编译指令为gcc main.c p1.c -o main
   //main.c
   #include <stdio.h>
   int d = 100;
   int x = 200;
   int main(){
       p1();
       printf("d = %d, x = %d\n",d,x);//结果 d=0,x=1072693248
       return 0
   }
   //p1.c
   double d;
   void p1(){
       d = 1.0;
   }
   ```

6. 乘法运算及溢出，存储空间映射：

   ```c
   int copy_array(int* array, int count){ //复制数组到堆中，count为要复制的元素个数
       int i;
       //在堆中申请一块内存
       int* myarray = (int*)malloc(count*sizeof(int)); //当count=2^30+1时，count*4u=2^32+4,取低32位，结果为4，发生了溢出，。不过此时仍会复制很多数据到堆中，这样就会破坏堆中的数据。
       //有一点需要编程确认，带符号数和无符号数的乘法是否会强制类型转换。
       if(myarray == NULL){
           return -1;
       }
       for(i = 0; i < count; i++){
           myarray[i] = array[i];
       }
       return count;
   }
   ```

7. 编译器优化，除法错异常处理：

   ```c
   int a = 0x80000000;
   int b = a/-1; //b的结果为-2147483648
   //将除法的分母放到变量中，结果就不一样了，可以通过objdump反汇编发现上面除以-1会被优化为取相反数，使用neg指令完成，故未发生溢出。结果是错误的，却没有任何提示。
   int a = 0x80000000;
   int b = -1;
   int c = a/b; //会报错，Floating point exception，CPU检测到了溢出异常。
   //由于分子分母都是变量，无法优化，只能使用IDIV指令，而该指令不会生成溢出OF标志，但是又能判断是否发生了溢出异常，这是因为对于除法运算，机器会对除数和被除数进行预先判断，下面的这个就是特殊情况，它的值为2147483648，无法用32位带符号数表示，因此直接判断为错误，Linux下发送SIGFPE信号到进程。
   //这里是整数除法，却显示浮点异常是因为：
   ```

8. IEEE754表示，x87FPU的体系结构，IA-32和x86-64中过程调用的参数传递：

   ```c
   #include <stdio.h>
   main(){
       double a = 10;
       printf("a = %d\n",a);//在IA-32上运行，结果为a=0，在x86-64上运行，结果为一个不确定的值。
   }
   ```

9. 过程调用中参数的传递，栈帧中数据的布局：

   ```c
   double func(int i){
       volatile double d[1] = {3.14};
       volatile long int a[2];
       a[i] = 1073741824;
       return d[0];//根据i的不同，返回值可能不同，因为i的值不同，可能造成上一句发生数组下标越界行为
   }
   //当i=0-4时，结果分别为3.14、3.14、3.1399998664856、2.00000061035156、3.14(然后出现存储保护错误)。
   ```

10. 高维数组在内存中的布局，Cache机制，访问局部性：

    ```c
    //从算法时间和空间复杂度来说，两个函数完全等价，但是实际执行时间相差21倍(奔腾4cpu)。
    void copyij(int src[2048][2048], int dst[2048][2048]){
        int i, j;
        for (i = 0; i < 2048; i++){ //一行一行复制
            for (j = 0; j < 2048; j++){
                dst[i][j] = src[i][j];
            }
        }
    }
    void copyji(int src[2048][2048], int dst[2048][2048]){
        int i, j;
        for (j = 0; j < 2048; j++){ //一列一列行复制
            for (i = 0; i < 2048; i++){
                dst[i][j] = src[i][j];
            }
        }
    }
    ```

11. 例子：

    ```c
    //使用老版本的gcc -O2编译时，程序1最后i的值为0，程序2最后i的值为1。
    //程序1
    double f(int x){
        return 1.0/x;
    }
    void main(){
        double a,b;
        int i;
        a = f(10);
        b = f(10);
        i = a == b;
    }
    //程序2
    double f(int x){
        return 1.0/x;
    }
    void main(){
        double a,b;
        int i;
        a = f(10);
        b = f(10);
        c = f(10);
        i = a == b;
    }
    ```

12. 指针的赋值和变量的强制类型转换，局部变量在栈中的位置：

    ```c
    int main(){
        int a = 10;
        double *p = (double*)&a;
        printf("%f\n",*p);//结果为0.000000
        printf("%f\n",(double)a);//结果为10.000000
    }
    //两次强制类型转换，但是结果不同，关键在于fldl和fildl指令的差异。
    ```

# 基础

## ISA

1. 计算机系统是分层的，指令集体系结构ISA（Instruction Set Architecture），也称为指令系统，是软硬件的交界面，是最重要的一层，规定了软件如何使用硬件，包含如下内容：
   1. 可执行指令的集合，包括指令格式，操作种类及每种操作对应的操作数。实际上也约束了硬件提供给软件的接口。
   2. 指令可以接受的操作数的类型。无符号数，带符号数，浮点数等
   3. 寄存器的名称编号，长度，用途。
   4. 存储空间的大小和编址方式，多字节数据存放大小端方式。
   5. 指令获取操作数的方式，即寻址方式。
   6. 指令执行过程中的控制方式，包括PC，条件码的定义。
2. 有了ISA后，才可以称为通用计算机，即编程使得计算机执行不同的功能。
3. 常见的ISA有：IA-32（x86），MIPS，ARM。
4. 程序员分为应用程序员和系统程序员。
5. 功能部件由门电路构成，门电路由器件构成。
6. <img src="计算机系统基础.assets/image-20210407195254273.png" alt="image-20210407195254273" style="zoom:50%;" />
7. 同一个ISA可以有不同的微体系结构实现，例如乘法指令可以使用ALU的加法和移位来完成，也可以使用专门的乘法器完成。
8. x86指令集至少有Intel和AMD两家的为体系结构实现。

## 冯诺依曼结构

1. 世界上第一台通用的电子计算机 ENIAC(Electronic Numerical Integrator And Computer)是1946年宾夕法尼亚大学研制的，1.8万个电子真空管组成的，耗电巨大，用于解决复杂的弹道问题，主要是做数值计算，高达每秒5000次加法运算，能够计算平方，立方，三角函数计算。用10进制表示信息并运算，通过手动设置开关和插拔电缆来编程。
2. 冯诺依曼架构最重要的思想是存储程序的思想：任何要让计算机完成的工作都需要事先编写好程序，然后将程序和数据都送入主存。程序一旦被启动，计算机就能够自动地取值执行。由于冯诺依曼供职于普林斯顿高等研究院IAS，所以该架构也被称为IAS计算机。
3. 因此冯诺依曼机至少需要以下部件：主存（用来存放程序和数据），自动逐条取指令的部件（控制器），具体执行指令的部件（运算器）。读取用户输入的程序和数据的部件，将结果输出的部件。
4. 早期的计算机中，各部件是分散连接的，线路多而且复杂，现在大多使用总线方式。
5. 存储器能够存放数据和指令，形式上没有区别，都以二进制表示，但是计算机还是能够区分二者。
6. 运算器可以进行加减乘除四种基本的算术运算，还有与或非，移位运算。
7. 指令=操作码+地址码，表示对那些数据做什么操作。 
8. 程序就是一串物理上连续的指令，逻辑上不一定连续执行。

## 现代计算机结构

1. 现代计算机也是由五大部分组成，不过早已经将运算器和控制器结合到一起，成为CPU。
2. 运算器计算完成一次后，有时还会修改标志寄存器，控制器会读取标志寄存器，进而影响后续的计算。
3. 从存储器中获取的指令存放在IR（指令寄存器），然后交由控制器分析，获取的数据放到通用寄存器组（GPRs，General Purpose Registers）中。PC（程序计数器，program counter）寄存器记录着下一次取指令的位置。PC的不断自增，使得程序能够自动执行，也可以在某条指令（例如jmp和call指令）中修改PC，这样下一次读取PC就会去新的地方执行。
4. 数据和指令的读写
   1. 要将寄存器中的数据写入到内存中，需要将数据和地址分别存放到MDR（memory data register）和MAR（memory address register）中，然后由控制器发出写入指令。
   2. 要从内存中的读取数据，需要将带读取的内存地址放在MAR中，用于接受的寄存器编号放在MDR中，然后由控制器发出读取指令，数据会先读入到MDR中，然后转到指定的通用寄存器中，
   3. 要从内存中读取指令，将PC的值复制到MAR中，由控制器发起读取指令，读入的指令会先到MDR中，然后复制到IR中。
5. IR和PC是不一样的，前者是存储当前正在执行的指令，后者是存储下一次要读取指令的内存地址。
6. 早期没有寄存器，只有一个累加器，后来增加了多个，才将他们变成通用的寄存器，所有操作都可以使用。
7. 下图是微体系结构，不同的CPU可能不同。
8. <img src="计算机系统基础.assets/image-20210407202539790.png" alt="image-20210407202539790" style="zoom: 50%;" />
9. 取到一个指令后，有时可能要再取数据才可以进行计算，而这个取数据的环节不用显式写出指令，控制器会自动发出。有的CPU架构，不允许指令直接操作内存中的数据，因此需要显式将内存数据读取到寄存器中，然后再对寄存器中的数据进行计算，最后再将显式将结果从寄存器写入到内存中。
10. 一条指令中，源操作数可能有一个，也可能有两个。源操作数可能是立即数，寄存器编号，存储地址。目的操作数可能是寄存器编号或存储地址。

## 程序的历史

1. 程序的历史：
   1. 使用机器语言，纸带打孔表示0，未打孔表示1，输入可以用按钮，开关，输出一般为信号灯。指令中的地址码都是硬编码进去的。如果添加或删除指令，地址码需要重新计算，还要重新打孔。
   2. 汇编语言，面向动作描述。汇编指令是用助记符和标号表示的指令，它和机器指令一一对应。使用助记符表示操作码和寄存器，用标号表示位置。使用汇编器将汇编代码转化为机器代码，他会自动计算地址码。不同机器（CPU）所支持的指令集不同，汇编指令的格式也可能不同（机器代码就更不同了），因此不能移植。同一机器也可以有不同的汇编指令格式，例如x86cpu的AT&T汇编和Intel汇编。相比机器语言的优点是：不需要因为增减指令而修改其他指令，不需要记忆指令编码，编写方便，可读性强。缺点是：机器不能直接识别，需要通过汇编器转换。
   3. 高级语言，面向算法描述的，比机器语言描述能力强得多。一条语句可能会转化为多条汇编指令。分为编译和解释两种。解释程序逐条将语句翻译成指令，然后直接执行，不生成目标文件。
2. C语言源程序的编译过程如下，不过都可以使用gcc命令来结合不同的选项调用对应的命令。编译器将.c转化为.s，汇编器将.s转化为.o：
3. ![image-20210518102947327](计算机系统基础.assets/image-20210518102947327.png)
4. 最早的程序运行不需要操作系统，直接运行在指令集体系结构上。
5. 使用汇编语言编写程序就需要汇编器和操作系统提供的交互界面。
6. 使用高级语言开发程序需要有语言处理系统，即编辑器，编译器，汇编器，链接器和运行时系统等。现代程序运行需要语言处理系统和操作系统内核。
7. 操作系统厂商需要为程序员提供运行时系统和语言处理系统。
8. 第1-4代程序设计语言：机器语言，汇编语言，过程式高级语言，非过程式高级语言。过程式和非过程式语言的区别就是，前者需要描述怎么做，后者只需要描述做什么。
9. 程序的执行结果不仅取决于算法和程序是如何编写的，还取决于语言处理系统，操作系统，ISA和微体系结构。

# 整数

1. 在指令层面，没有结构化数据的概念，都是当做01序列来看待。
2. 机器级数据分为：
   1. 数值数据：无符号整数，有符号整数，浮点数。
   2. 非数值数据：逻辑数据（位串），文字和符号，不能比较大小。
3. 计算机使用二进制编码数据的原因是：
   1. 制造2个稳定态的物理器件比较容易，例如点位高低。
   2. 二进制编码，计数，运算较为简单。
   3. 正好与逻辑命题的真假对应。
   4. 可以方便地使用逻辑电路来实现算术运算。

4. 真值和机器数，机器数是在计算机内部的01编码的数据，真值是现实生活中的数。例如真值unsigned short类型变量x的真值为127，其机器数为0000 0000 0111 1111。
5. 要在真值和机器数之间相互转换，需要确定以下几个要素：
   1. 进位计数制，2，8，10，16进制
   2. 定、浮点表示。
   3. 定点数的二进制编码。

6. 二进制可以用后缀B表示，八进制可以用前缀0或后缀O表示，十六进制可以用0X前缀或H后缀表示。

   ```c
   15 = 1111B = 17O = 017 = 0xF = FH
   ```
7. 日常生活中使用十进制，计算机中使用二进制，引进八进制和十六进制的目的是为了书写和观察方便。
8. 公历起源于古罗马历法。古罗马历法原来只有10个月，罗马元首决定增加两个月放在年尾，后来朱里斯·凯撒大帝把这两个月移到年初，成为1月、2月，原来的1月、2月便成了3月、4月，依次类推。原来的八月就成了十月，但是历法改了，称呼仍然沿用未变。
9. 英语的十月October，来自拉丁文Octo，即“8”的意思，十月是历法改革前的8月。
10. <img src="计算机系统基础.assets/image-20210411141724346.png" alt="image-20210411141724346" style="zoom:67%;" />
11. 某些十进制数，在转化为二进制时，小数部分可能是无限的。例如$(0.63)_{10}=(0.50243\cdots)_8$。除R取余总是有尽头，但是乘R取整不一定。

# 定点数的表示

1. 计算机中只有0和1，小数点在计算机中是无法表示的，只能约定小数点的位置。小数点约定在固定位置的就是定点数，小数点位置可以浮动的就成为浮点数。

2. 定点数分为定点小数（小数点约定在开头，用来表示浮点数的尾数部分）和定点整数（小数点约定在末尾，有符号整数和无符号整数）。例如0.1101可以用1101表示，1101.0可以用1101表示。

3. 浮点数使用一个定点小数和一个定点整数表示，其中小数点的位置由定点整数表示。可见浮点数的表示依赖于定点数的表示方法。

4. 任意实数都可以表示为：$X = (-1)^s\times M\times R^E$。s可以为0或1，是符号位sign。M是一个二进制的定点小数，称为X的尾数，有效数字。R是基数radix，现代计算机一般都是2。E是一个二进制定点整数，称为X的指数exponent。在计算机内部任何实数都可以用一个符号位+定点小数+定点整数来表示。

5. 因此在计算机中解决数值的表示问题就首先要解决定点数的编码问题。

6. 定点数的表示方法：原码，补码，移码，反码（很少用了）。


## 原码

1. 原码表示中一个数和它的相反数仅符号位相反，缺点是0的表示不统一；加减运算不统一，需要额外对符号位进行处理，不利于硬件设计，对于同号数相减和异号数相加的情况，需要先判断二者的绝对值，不能像补码那样将减法用加法来实现；当a<b时，实现a-b比较困难。

   ```c
   //十进制 二进制  十进制 二进制
       0    0000     -0   1000
       1    0001     -1   1001
       2    0010     -2   1010
       3    0011     -3   1011
   ```

2. 因此从50年代开始，整数都用补码表示，但是浮点数的尾数部分还是用原码定点小数表示（因为不用考虑符号位）。


## 移码

1. 移码表示如下：将一个真值+一个偏置常数（bias）。当编码位数为n是，偏置常数通常$2^{n-1}$或$2^{n-1}-1$

   ```c
   //n=4时，E_baised = E+2^3。
   -8 → -8+8 =  0 = 0000B
    0 →  0+8 =  8 = 1000B //0的移码表示唯一
    7 →  7+8 = 15 = 1111B
   //这样所有的负数都会变成正数，因此就不需要符号位了，因此4位的偏置整数能够表示的个数是2^4=16个。
   //当偏置常数取2^(n-1)时，同一个数的移码和补码仅符号位完全相反。
   ```

2. 浮点数的指数部分通常用移码来表示。主要是方便浮点数之间加减时的对阶操作。浮点数加减法时，需要先进行对阶操作，将小阶向大阶对齐，这就需要比较指数的大小，移码可以快速比较大小，从高到低逐位比较大小即可：

   ```c
   //比较1.01x2^-1和1.11x2^3的指数大小。由于-1<3，因此应该将第一个数移阶，得到0.000101x2^3
   //如果将指数使用3位2进制补码表示，则分别为111和011，无法直接进行比较，还要进行有符号数的比较。
   //如果将指数使用3位2进制移码表示(偏置常数取2^2=4)，则分别为011和111，可以由高往低逐位直接进行比较，最高位右侧为1，左侧为0，因此右侧大。
   ```


## 模运算系统

1. 模运算系统中，一个数和该数除以模后的余数是等价的。例如在模12运算系统中，13和1是等价的，因为。$13\equiv 1\mod 12$，称13和1模12同余。

2. 钟表可以看作1位12进制的模运算系统。能表示的数可以是`0,1,2,3,4,5,6,7,8,9,A,B`，没有负数，这里之所以用A、B而不是10和11，是因为不想和十进制混淆。

3. 加法的计算如下，A+2是A的第二个后继，等于(A+1)+1。A+1为B，所以A+2=B+1，B的下一个后继为0，因此A+2=0。

4. 先定义a的相反数：$-a:=\{b|a+b=0\}$，即，例如由于3+9=0。因此9是3的相反数，即$-3=9$，因此可以计算0到B的相反数：

   ```c
   -0=0 -1=B  -2=A  -3=9  -4=8  -5=7  -6=6  -7=5  -8=4  -9=3  -A=2  -B=1
   //可以发现相反数具有对称性，因此-3 = 9，-9 = 3。同时-(-a):=a
   //需要用的时候，查表即可，如果像钟表这样的机械结构，可以将指针旋转180度获得相反数。相反数运算在二进制中是一个比较简单的操作，即翻转一下位即可，0变1，1变0，可以通过一些开关电路实现。
   ```

5. 然后借助于相反数来定义减法，$a-b:=a+(-b)$，减一个数相当于加上这个数的相反数。例如$5-2=5+A=3$，$2-5=2+7=9$，$5-(-2)=5+2=7$。

6. 因此1位12进制数可以表示$0,±1,\cdots,±B$。换成10进制为0到±11，一共23个数。但是没办法区分-3和9，这对于数学运算是不方便的。

## 补码

1. 补码和原码表示有一个共同点，就是通过符号位就都可以判断正负数。不同的是，补码的符号位也是数值位，具有权重，而原码的符号位只表示正负，没有权重。

2. 有符号数使用补码表示，无符号数使用二进制位串表示，其中没有符号位，不是原码，因为源码的最高位是符号位。

3. 补码有两种含义：

   1. 一个十进制数表示为2进制位串时，有多种编码方式，例如原码，移码，补码。

   2. 一个二进制串的求补码运算就是逐位取反，然后加一。

4. 为了同时表示正数和负数，可以使用多位进制数的组合。原码就是用最高位作为单独的符号位，移码通过将负数转化为正数来表示，也可以通过最高位判断正负性，补码则是将最高位的权重变为负数。

   ```c
   //3位2进制原码可以表示的数有(按照进制排列)：
   二进制：// 000 001 010 011 100 101 110 111
   十进制：//  0   1   2   3  -0   -1  -2  -3  //可以看到0有两种表示方式000或100
   //3位2进制移码可以表示的数有(按照进制排列，偏置常数取2^(3-1))：
   二进制：// 000 001 010 011 100 101 110 111
   十进制：// 0-4 1-4 2-4 3-4 4-4 5-4 6-4 7-4
   十进制：//  -4  -3  -2  -1  0   1   2   3         可以看到十进制数是依次递增的
   //3位2进制补码可以表示的数有(按照进制排列)：
   二进制：// 000 001 010 011 100 101 110 111
   十进制：//  0   1   2   3  -4 -4+1 -4+2 -4+3
   十进制：//  0   1   2   3  -4  -3  -2  -1
   //同一个码点表示的数值和范围不同。
   ```

5. 正数的补码表示和原码表示一样，负数的补码表示需要对它的绝对值的补码表示进行位操作得到：将绝对值的原码表示逐位取反，然后再加1即可。

6. 同一个十进制数的不同二进制编码表示，一般都是先求得原码表示，然后对原码进行操作得到补码表示。不同编码所能表示的数的范围不同。n位原码可以表示$±0$到$±(2^{n-1}-1)$。n位补码和移码都可以表示0，±1到$±(2^{n-1}-1)$，还有$2^{n-1}$。

   1. 通过原码表示求补码表示，以下以3位2进制数为例：

      ```c
      //正数的原码和补码相同，这是因为正数的原码和补码的符号位都是0，二者在其余位的权重都一样。
      十进制  原码  补码
        3     011  011 //(-1)^0*(1*2^1+1*2^0)=0*(-2^2)+1*2^1+1*2^1
      //负数的原码和补码不同，将原码的数值位取反，符号位不变，然后再整体加1即可得到补码。
      十进制  原码      补码
      -3      111  (100)+1=101  //
      ```

   2. 通过补码求原码，以下以3位2进制数为例：

      ```c
      //正数的原码和补码相同
      //负数的原码和补码不同，将补码的数值位取反，符号位不变，然后再整体加1即可得到补码。
      十进制  补码      原码
      -3      101  (110)+1=111  //1*(-2^2)+0*2^1+1*2^0=(-1)^1*(1*2^1+1*2^0)
      ```

   3. 通过补码求移码，以下以3位2进制数为例：

      ```c
      //正负数的操作一样，符号位取反，数值位不变即可。
      十进制  补码   移码
      -3      101   001  //1*(-2^2)+0*2^1+1*2^0=0*2^2+0*2^1+1*2^0-2^2
      ```

   4. 可以发现，如果将一个二进制串数值位取反，符号位不变，然后再整体加1，这样的操作进行两次可以得到原来的串。

      ```c
      101 → 110+1 = 111 → 100+1 = 101
      ```

7. 补码运算规则如下，只有溢出时，结果不正确，溢出时最高位会进1：

   1. 补码的加法可以直接进行：

      ```c
      //以下6种情况，有2种情况可能溢出，正+正超出上限，负+负超出下限。加法只可能发生进位，不会发生借位。2种情况可能进位，正+负和负+正。1种情况必定进位，负+负。1种情况必定不进位，正+正。
      正+正：010+001=011       //即2+1=3，正确
      负+负：110+111=1101=101  //即(-2)+(-1)=-3，正确
      正+正：010+011=101       //即2+3=-3，发生上溢出
      负+负：100+101=1001=001  //即(-4)+(-3)=1，发生下溢出
      正+负：010+101=111       //即2+(-3)=-1，正确
      负+正：101+010=111       //即(-3)+2=-1，正确
      ```

   2. 补码的减法可以转化为加法（CPU中一般没有减法器）：将被减数取相反数，然后和减数相加即可。补码的相反数是逐位取反再加1。3=011，其相反数为~011+1=100+1=101。

      ```c
      //以下6种情况，也是只有两种情况可能溢出，正-负超出上限，负-正超出下限。减法只可能发生借位，不会发生进位。2种情况可能借位，正-正和负-负。1种情况必定不借位，负-正。1种情况必定借位，正-负。减法的进位可以通过从最高位逐位比较得到结果。且如果正数a-正数b不借位，那么b-a必定借位。
      正-正：010-001=010+(~001+1)=010+111=1001=001  //即2-1=1，正确
      负-负：110-111=110+(~111+1)=110+001=111       //即(-2)-(-1)=-1，正确
      正-正：010-011=010+(~011+1)=010+101=111       //即2-3=-1，正确
      负-负：100-101=100+(~101+1)=100+011=111       //即(-4)-(-3)=-1，正确
      正-负：010-101=010+(~101+1)=010+011=101       //即2-(-3)=-3，发生正溢出了
      负-正：101-010=101+(~010+1)=101+110=1011=011  //即(-3)-2=3，发生负溢出了
      ```

   3. 可知一个数的相反数等价于0-该数。不过-4的相反数不是4，还是-4，因为补码表示的数的范围不是对称的。

   4. 要实现加减混合运算，只要实现加法器和取反器即可。

8. 使用补码表示的好处：数值运算中，符号位和数值位可以同时参与运算。

9. 由一个数的补码求它的相反数的补码有简便的方法，例如8位2进制数124=0111 1100B，求-124的补码，首先从右向左先找到第一个1，然后该位左侧的所有位取反即可，该位不变。即10000100B=-124。

10. 编译器需要将源代码中输入的字面值常量都转化为2进制的串，可以使用以下算法（和python等语言中的int( )函数一样），CPU也应该提供类似的指令，将一个字符串转化为整数。

   ```c
   signed char a = 35;//在编译器看来35是2个字符。ASCII码值分别为0011 0011和0011 0101。需要将他们转化为0010 0011。
   1. 先将2个ASCII码值和0000 1111做按位与预算，得到低4位。0000 0011和0000 0101
   2. 3的权重是10，5的权重是1，所以用0000 0011*0000 1010+0000 0101*0000 0001=
   3. 二进制乘法可以通过移位和加法实现，上式第一项=0000 1010+0001 0100=0001 1110
   3. 因此上式=0010 0011
   //如果a=-35，则先忽略负号，只处理35，得到0010 0011，然后根据负数补码的运算规则，逐位取反加1即可，位1101 1100+1=1101 1101
   ```

11. 普通的补码是无法保留最高位的溢出的，因此发明了变形补码（主要是用来保存中间结果，来防止中间的结果溢出。最终结果溢出与否无所谓），数值位不变，符号位有2个。8的变形补码为01000，第一个0表示符号位，第二个1表示数值部分溢出了。

    ```c
    十进制   二进制补码  二进制变形补码
      1        0001        00001
      7        0111        00111
      8        1000        01000 //将0111加1得到1000，也就是7+1=-8，这里发生了上溢出，但是如果使用变形补码，则不会溢出，因为原本溢出的那个1，现在的权重为+2^3。
    ...  //变形补码形式的相反数也是逐位取反+1
     -1        1111        11111
     -7        1001        11001
     -8        1000        11000
     -9        0111        10111 //-8+(-1)得到0111，也就是7，这里发生了下溢出，但是如果使用变形补码，则不会溢出，结果为1*(-2^4)+7=-9
    //想通过补码到变形补码，可以进行符号位扩展，例如1001→11001；0111→00111。这是因为当补码的符号位为1时，相当于-2^3，而进行符号位扩展后的变形补码，最高两位为-2^4+2^3=-2^3。
    ```

12. 指针变量存储的是内存地址，用无符号整数表示。

13. 一位半加器→一位全加器→串行进位加法器。低位发生进位会在高位+1。

14. 机器中字的位序列排序有两种方式：例如一个32位字0 ...01011。一般来说计算机中都是LSB（最低有效位）在最右边，MSB（最高有效位）在最左边。这个排序方式实际上就规定了各位的权重方向。

15. C语言中，无符号数字面量应该在末尾加上U或u，例如234u，不加u时，默认当做有符号数。如果无符号数和有符号数运算时，编译器会将有符号数转化为无符号数。例如2+3u等价于2u+3u=5u，运算结果也是无符号数。

16. 计算机只会进行位运算和判断，而程序员还可以进行数学上真值的判断。同时对于同样的机器数，对应到不同的类型，真值不同。

17. 从数学角度理解如下关系表达式：

    ```c
    0 == 0U; //有符号数0会转化为无符号数0，两侧相同，结果为true。
    -1 < 0;  //都是有符号数，结果为true
    -1 < 0U; //需要将左侧当作无符号数看待，-1的补码为11..1，相当于最大的无符号数，因此结果为false
    2147483647 > -2147483647-1; //先分别计算>号的两侧，右侧=-2147483648为10..0，没有溢出，所以结果为true
    2147483647U > -2147483647-1 //先计算右侧，右侧=-2147483648为10..0，要解释为无符号数，即2147483648U，因此结果为false
    2147483647 > (int)2147483648U //等号右侧无符号数的二进制表示为10..0，(int)强制类型转换不会进行任何数据操作，只是将他解释为有符号数，即-2147483648，不溢出，因此结果为true
    -1 > -2 //结果为true
    (unsigned)-1 > -2 //左侧-1的二进制表示为11..1，当作无符号数为4294967295，右侧-2的二进制表示为11..0，当作无符号数为4294967294，因此结果为true
    ```

18. 有符号数和无符号数二进制补码比较大小的简便方法：

    ```c
    //无符号数，从高到低，逐位比较
    //有符号数，先比较符号位，如果不同，则符号位为1的<符号位为0的，因为负数<非负数。如果相同，则按照无符号数比较后续位，后续位大的数大。
    ```

19. 要从位运算角度理解比较操作，需要知道cmp指令会修改的标志寄存器中的位：

    ```c
    //标志寄存器中和cmp指令有关的位：
    ZF:Zero Flag     //当结果的所有位均为0时，设置ZF=1，即为0
    SF:Sign Flag     //当结果的最高位MSB为1时，设置SF=1，即负数。
    PF:Partial Flag  //当结果包含偶数个1时，设置PF=1。而在x86中，PF只检查最低字节。
    CF:Carry Flag    //当计算过程中最高位发生进位或借位时，设置CF=1。进位标志用于多个ALU之间级联，来进行更多位数的运算。还有移位操作中会用到，例如8位寄存器01010101，且CF=1，对其进行带进位的循环左移，结果寄存器为10101011，CF=0，这里会将最高位移动到CF中，然后将CF移动到最低位中。
    OF:Overflow Flag //两个符号位相同的操作数相加，如果结果的符号位和他们不同，则发生了溢出；两个符号位不同的操作数相减，如果结果的符号位和减数的符号位不同，则发生了溢出。除此之外则不发生溢出。溢出时会设置OF=1。
    //进位与否关注的是计算过程，溢出与否关注的是结果。
    ```

20. 加减指令都是不区分操作数的类型的，因此也都会设置所有的标志寄存器位，需要编译器来决定使用那些寄存器位。例如无符号运算，虽然会设置SF，但是不会用。

21. 无符号数比较与标志位取值：

    ```c
    cmp a,b //如下规则都是通过对具体数的比较可能出现的结果观察来确定的。
    a == b 即 a-b=0，ZF=1
    a != b 即 a-b!=0，ZF=0
    a < b  即 a-b必定借位，CF=1
    a >= b 即 a-b必定不借位，CF=0
    a > b 即 a-b必定不借位且结果又不为0，(CF OR ZF) = 0 //式子中OR是逻辑或，因此不是CF=0或ZF=0，而是CF=0且ZF=0
    a <= b 即 a-b或者借位或者为0，(CF OR ZF) = 1
    //a == b对于有符号数和无符号数都是一样的，都表示每一位都相同，即a-b必定为全0。
    //可以看到当无符号数a < b时，即a按位比较一定比b小。因为第一位为1的数总是比所有第一位为0的数大。所以a-b一定借位，即CF=1。
    //a <= b等价于a < b或a == b，即CF=1或ZF=1。
    //可以通过分别取前二个命题的逆否命题，可得a >= b和a>b的标志位情况。
    ```

22. 有符号数比较与标志位取值，不能仅通过符号位来判断：

    ```c
    cmp a,b
    a == b 即 a-b=0，ZF=1
    a != b 即 a-b!=0，ZF=0 //和a == b互补
    a < b  //(SF=1且OF=0)或(SF=0且OF=1) 等价于 (SF XOR OF) = 1
    a >= b 即 a-b非负且不溢出，SF=0或OF=1     (SF XOR OF) = 0
    a > b  即 a-b为负且有溢出，SF=1且OF=1 //((SF XOR OF) OR ZF) = 0
    a <= b  即 a-b非负且有溢出，SF=0且OF=1//((SF XOR OF) OR ZF) = 1
    //当a < b时，a-b应该为负数，真实的负数有两种情况：符号位为1但不溢出，符号位为0但溢出。因此a < b 等价于即(SF=1且OF=0)或(SF=0且OF=1)。
    //当a > b时，a-b应该为正数，真实的正数有一种情况：非负且非0，即(SF XOR OF) = 0且ZF=0等价于((SF XOR OF) OR ZF) = 0
    //分别取前二个命题的逆否命题，可得a >= b和a <= b的标志位情况。
    ```

23. 以上内容可以查看Intel软件人员开发手册中第1卷附录B。对应的指令为：

    ```c
    //无符号数的<为below，>为above，=为equal。
    JB，JAE，JBE，JA分别为 <，>=，<=，>。
    //有符号数的<为less，>为greater，=为equal。
    JL，JGE，JLE，JG分别为 <，>=，<=，>。
    ```

24. cmp指令相当于减法sub指令，不过不修改操作数，但是会修改标志寄存器。sub指令有可能单独实现（例如x86，8051，这样CF也被称为借位标志），也有可能交由加法指令和取反指令联合实现（例如ARM，PowerPC，这样进位和借位统一了）。

    ```assembly
    sub a,b
    #可能转化为以下三条指令
    inv b #不会有进位，借位或溢出
    inc b #有可能进位或溢出
    add a,b #有可能进位或溢出
    ```

25. 使用cmp指令比较这两个数时是不分有符号和无符号的，但是跳转的时候要区分JB和JL。

26. ```assembly
         7: 	 char a = 255;
    008C1718 C6 45 FB FF          mov         byte ptr [a],0FFh
         8: 	 char b = -1;     #可以看到内存中存储的都是一样的。这是编译器做到的，如果用汇编写程序，就需要程序员自己进行补码的转换。
    008C171C C6 45 EF FF          mov         byte ptr [b],0FFh
         9: 	if (a < b)
    008C1720 0F BE 45 FB          movsx       eax,byte ptr [a]
    008C1724 0F BE 4D EF          movsx       ecx,byte ptr [b]
    008C1728 3B C1                cmp         eax,ecx
    008C172A 7D 0D                jge         main+49h (08C1739h)  #greater equal 即有符号数的>=
    ```

27. 整数在机器中使用补码表示，这句话的意思不仅仅是指在内存中存储是这样的，连编译产生的中间结果也是补码。

28. ```c
    int x = -1; //机器数为11..1B
    unsigned u = 2147483648;  //机器数为10..0B
    // unsigned就是unsigned int
    printf("x = %u = %d",x,x); //%u就是将对应的变量的机器数当做10进制无符号整数来输出。
    //  x = 4294967298 = -1
    printf("u = %u = %d",u,u); //%d就是将对应的变量的机器数当做10进制有符号整数来输出。
    //  u = 2147483648 = -2147483648
    ```

29. 汇编代码如下，可以看到编译器会根据赋值的对象类型将字面量转化为机器数。

    ```assembly
        int x = -1;
    00AA1718  mov   dword ptr [x],0FFFFFFFh
        unsigned u = 2147483648;
    00AA171F  mov   dword ptr [u],80000000h
    ```

30. 编译器如何处理整数字面量，==有待完善，参考CPP Reference==：

    ```c
    //处理方式和32位或64位有关。有后缀的根据后缀来确定类型，没有得根据数值范围来确定。
    //对于负数，编译器会先处理绝对值部分，然后处理负号。前面的负号并不会让它变成int类型，而只是进行逐位取反然后加1的操作
    //赋值时，等号右侧向左侧靠拢，可能会进行截断或扩展，截断不分有/无符号数。有符号数进行符号扩展，和无符号数进行0扩展，这两种扩展都不会改变其数值。
    
    //赋值是单向，会将右侧转化为左侧的类型。
    long long赋值给unsigned，直接截断即可。
    unsigned 赋值给 long long，进行0扩展。
    
    //比较是双向的，会将左右统一到一个类型。
    long long和unsigned比较，先将unsigned进行0扩展至64位的unsigned long long，然后将long long当作无符号数解析，进行无符号比较。
    ```

31. 可以看出不同的字面量，编译器都会解释为不同的类型，因此存储的格式也不同：

    ```c
    //C90情况
    范围           类型
    0→2^31-1       int
    2^31→2^32-1    unsigned int
    2^32→2^63-1    long long
    2^63→2^64-1    unsigned long long
    //C99情况，尽可能用有符号数去fit，实在不行再用无符号数。
    0→2^31-1       int
    2^31→2^63-1    long long  //可以看到unsigned int被吸纳进了long long内部，也就是说直接用64位存储了。
    2^63→2^64-1    unsigned long long
    //以上情况仅表示32位的情况，64位则有区别。
    ```

32. 上述改动对于会导致某些情况下的不同，以下情况会在32位下出现，64位下则都为true：

    ```c
    #include <stdio.h>
    int main() {
        printf("%d\n", -2147483648 < 2147483647); //C89结果为false，C99结果为true，可以看到C99的结果更为合理。
        return 0;
    }
    //C90中，2147483648被解释为unsigned int 10..0，然后取相反数，还是10..0。右侧也要被转成无符号数，01..1，都是32位，因此结果为false。gcc编译时会报warning: this decimal constant is unsigned only in ISO C90。
    //C99中，2147483648被解释为long long，左侧为~00..010..0+1=11..10..0，64位，右侧为01..1，32位。两侧都是有符号数，因此右侧进行符号扩展到64位，为01..1，比较，得结果为true。
    ```

33. 例子：

    ```c
    int x = -2147483648; //分步处理绝对值部分和符号，不论c89还是c99，结果的二进制都是10..0。即x为最小的有符号数。
    unsigned int y = 2147483648; //为10..0。
    x == y; //结果为true
    -2147483647-1 < 2147483647; //左侧2147483647会被当作带符号数01..1，然后取相反数为10..1然后再-1，结果为10..0。<左右都是带符号数，因此结果为true
    ```

# 浮点数

1. 对于一个小数，使用科学计数法，有多种表示，只有一种为规格化的：

   ```c
   //例如1/100可以表示为0.01*10^0，0.1*10^-1，1.0*10^-2或10.0*10^-3等。只有1.0*10^-2是规格化的，因为它的尾数部分在小数点前只有一个非零数。
   //二进制例子，10进制小数0.25可以表示为二进制科学计数法，0.01*2^0，0.1*2^-1，1.0*2^-2，10.0*2^-3，只有0.1*2^-1是规格化的。
   小数的规格化二进制表示有两种可能：±0.1xx..x*2^E 或 ±1.xx..x*2^E，这2种规格化表示的尾数xx..x相同，但是E相差1，因此移码表示的偏置常数也差1，前者为2^8，后者为2^8-1。
   为了表示更多的有效数字，IEEE使用±1.xx..x*2^E。
   ```
2. 伯克利大学的William Kahan为IEEE754的诞生做了大量贡献，因此获得了1989年的图灵奖。
3. IEEE754标准规定了如何在多个位中存储浮点数的三个部分，符号位，尾数部分，指数部分。以32位，float类型为例：

   ```c
   第1位为符号位S
   第2-9位为8位移码表示的指数E，偏置常数为2^8-1。这8位中全0和全1用来表示特殊值。因此规格化数的指数范围为[00000001-127,11111110-127]，即-126到127。当指数为-127和128时，认为是非规格化数，此时指数过小或过大，可能发生0方向溢出或无穷大方向溢出。如果偏置常数为2^8，则规格化数的指数范围为-127到126，则能表示的最大数变小，但是能表示的最小数变得更小了。这种取舍只是一种约定，并非哪一种更好。
   第10-32位为23位原码表示的尾数M。
   //由于规格化表示，小数点前的那位总是1，因此尾数就从小数点后开始记录。23位可以存储24位数。
   float x = 0.25; //它的符号位为0，阶为-2，移码表示为01111101，即125。尾数为0，其因此原码表示为00000000000000000000000。综上float的二进制表示为00111110100000000000000000000000，十六进制为3E80 0000
   ```
4. 规格化数的极限：

   ```c
   最小的正规格化数，阶为-126，尾数为全0，即1.00000000000000000000000*2^(-126)=2^(-126)
   最大的正规格化数，阶为127，尾数为全1，即1.11111111111111111111111*2^127=(2-2^(-23))*2^127，非常接近于2^128。
   因为原码对称，所以表示的规格化数范围也是关于原点对称的：规格化数被分为了2部分，因此将数轴分为了6个区域，0到最小正规格化数为正下溢区，最大正规格化数往上为正上溢区。规格化数段内也不是连续的，段外都是不可以表示的，段内也不是都可以表示的。
   0.0不是规格化数，因为它的二进制中找不到1。它处在正下溢和负下溢范围内。
   浮点数和定点数的个数是一样多的，但是浮点数表示的范围远远大于定点数，因此浮点数之间更稀疏，且不均匀。
   ```
5. 根据8位阶码全0或全1，尾数全0或非全0，可以将除了规格化数以外的情况划分为四种：

   1. 阶码全0，24位尾数全0，表示0，根据符号位的不同，可以有+0和-0。十六进制为0x00000000和0x800000000。可以看到整数0可以直接当作浮点数的0。

      ```c
      float x;
      char str[32] = "80000000";
      FromHex(str, &x, sizeof(x), BigEndian);
      printf("%f\n", x); //结果为-0.000000。如果str为"00000000"，结果为0.000000
      ```
   2. 阶码全0，尾数不全0，表示非规格化数，处在0和最小的±规格化数之间。
   3. 阶码全1，尾数全0，表示无穷大，根据符号位的不同，可以有$+\infin$和$-\infin$。
   4. 阶码全1，尾数不全0，NaN，没有符号位的区别。

6. 浮点数除以0的结果为$±\infin$，并不会发生溢出异常，整数除以0会发生异常。

   ```c
   //所有的除以0常量的代码，在编译阶段都会报warning: division by zero [-Wdiv-by-zero]
   printf("%d\n", 4 / 0); //整数除法，会发生异常错误 Floating point exception (core dumped)
   printf("%f\n", 4.0 / 0);//浮点数除法，结果为inf。并非浮点数的结果是"inf"字符串，而是printf会将阶码全1，尾数全0的浮点数转化为对应的inf或-inf这样的字符串。
   //之所以这么设计是因为有时要利用$±\infin$进行有效比较。
   float x=1.2, y=0.0, z=3.1;
   x/y > z; //浮点数之间可以进行这样的比较。x/y此时为+inf，因此比z大，结果为true。
   ```
7. 无穷大可以参与浮点数的运算，例如：5 + 5.0/0 == 5.0/0，结果为true。

   ```c
   规格数±(±无穷大)都等于±无穷大
   正无穷+正无穷=正无穷
   负无穷+负无穷=负无穷
   负无穷-正无穷=负无穷
   正无穷-负无穷=正无穷
   ```
8. 还有一些运算的结果不能用实数表示，这些被称为NaN，Not a Number。这个结果可以用来调试程序，NaN和NaN之间不一定相同，因为它们的尾数可能不同。

   ```c
   sqrt(-1) = NaN
   0/0 = NaN
   0.0/0.0 = NaN
   无穷大/无穷大 = NaN //和符号无关
   
   正无穷-正无穷=NaN
   负无穷-负无穷=NaN
   负无穷+正无穷=NaN
   正无穷+负无穷=NaN
   ```

9. 规格化数和非规格化数的密度：可以看到在$2^{-126}$和$2^{-125}$之间，$2^{-125}$和$2^{-123}$之间都有$2^23$个数，而后者区间长度是前者的2倍，因此规格化数越靠近0，密度越高。非规格化数，就在0到最小规格化数之间的区间。最小的非规格化数为$2^{-23}\times2^{-126}=2^{-149}$。

10. <img src="E:\Markdown-file\assets\image-20230927215250771.png" alt="image-20230927215250771" style="zoom:80%;" />

11. 由于浮点数在实数轴上是稀疏的，因此部分实数是无法精确表示的，会发生截断或舍入，例如：

    ```c
    #include <stdio.h>
    int main() {
        float x;
        while (1) {
            scanf("%f", &x); //x为float类型，应使用%f，而不是%lf。
            printf("%f\n", x);//默认保留到小数点后6位，足够了。
        }
    }
    输入         输出
    61.419996   61.419994
    61.419997   61.419998 //可以看到至少在[61.419997,61.420000]区间内的实数，都会被就近舍入到61.419998。
    61.419998   61.419998 //61.419998是可精确表示数。
    61.419999   61.419998
    61.420000   61.419998
    61.420001   61.420002
    ```

# 字符数据

1. 西文字符没有输入码，只有内码，也就是ASCII值。中文字符有输入码，因为没有一个包含6万多个按键的键盘，常用的输入码可以是拼音，五笔等。

# 数据宽度

1. 现代计算机中，存储器按字节编址，字节是最小的可寻址单位。

2. LSB为最低有效字节，MSB为最高有效字节。之前介绍的二进制位串，也有LSB和MSB，分别为最低（高）有效位。

3. 字和字长是不同的，前者是一种软件信息，后者是一种硬件信息：

   1. 字（word）是被处理信息的单位，用来衡量数据类型的宽度。和字节，位类似。除了字以外，还有双字（dword），四字（qword），分别为32位，和64位。
   2. 字长（word size）：数据通路的宽度，CPU内部数据流经的路径以及路径上的部件，这些部件的宽度都要一致，这个宽度就是字长。例如32位CPU指的就是字长为32位，即寄存器，ALU单元，和寄存器送到ALU传输路径等都是32位。一次可以处理的信息的宽度。
   3. 二者可以一样，也可以不一样。对于x86体系，不管字长多少，定义字的宽度都是16位，即2个字节。而i386级别的CPU字长就是32位了，现代的x86-64级别的CPU字长都是64位了。对于MIPS32体系，字和字长都是32位。

4. 存储容量和速度大小使用的单位是不同的，例如100K容量为100\*1024B。100k速度为100\*1000b/s。注意容量一般用大写的K，速度一般用小写的k，而M，G，T没有明显的倾向。

5. C语言标准没有明确规定整型类型的具体位数，只给出了下限和相互之间的关系。而浮点数由IEEE754规定，明确了float和double类型分别为32位和64位。

6. C标准并未规定long double的确切长度，有的平台为8字节，有的为10字节，有的16字节。

7. 一个数据如果有多个字节，那么这些个字节在连续的内存中，可以有两种排列方式：大端和小端。

   ```c
   int x = -10; //假定&x=100，其补码表示为0XFFFFFFF6。占4个字节，存放在100到103这4个字节，LSB为F6，MSB为FF。根据LSB和MSB的地址和数据的地址关系，可以分为大端(MSB地址=数据的地址)和小端(LSB地址=数据的地址)。
      地址 大端存储 小端存储
   // 100    FF      F6
   // 101    FF      FF
   // 102    FF      FF
   // 103    F6      FF
   ```

8. 无论大端还是小端，变量的地址都是其所有字节中的地址最小的那个的地址。

9. 可以使用联合数据类型来测试CPU是大端还是小端：

   ```c
   #include <stdio.h>
   void main(){
       //union的特点是所有成员都是优先在低地址存放，例如num的地址为100，那么num.a放在100-103中，num.b放在100中。&num，&num.a，&num.b都是一样的。
       union NUM{ //定义类型为union NUM
           int a;
           char b;
       } num;//同时定义一个变量
       num.a = 0x12345678;
       if (num.b == 0x12){
           printf("BigEndian\n");
       }else{
           printf("LittleEndian\n");
       }
       printf("num.b = 0X%X\n",num.b);
   }
   ```

10. 内存中的指令举例：

    ```assembly
    mov AX,0x12345(BX)  #其中操作码占1个字节为0x40，寄存器AX和BX分别占4位，为0001B和0010B。立即数为32位。若这条指令的地址为100，那么对于小端机器内存中的数据如下，一共占用6个字节：
    地址  值
    100   40
    101   12
    102   45
    103   23
    104   01
    105   00
    #第一个字节操作码，必须在整个指令的开头，也隐含了这个指令的长度。
    ```

11. 在不同端序机器之间交换数据时，应该统一成一种端序（socket就会将数据都转化为大端，在网络上传播），因此需要进行交换字节顺序：

    ```c
    void SwitchEndian(void* data, size_t length) {
        unsigned char tmp;
        unsigned char* datatmp = (unsigned char*)data; //不能使用data = (unsigned char*)data来改变一个指针的类型，必须要重新定义一个新的临时指针。
        for (size_t i = 0; i < length / 2; i++) {
            tmp = datatmp[i];
            datatmp[i] = datatmp[length - 1 - i];
            datatmp[length - 1 - i] = tmp;
        }
    }
    //对于组合数据类型，只能交换其中基本数据类型的端序。
    int x = 0x12345678;
    printf("LittleEndian x = 0x%x\n%",x); //0x12345678
    SwitchEndian(&x, sizeof(x));
    printf("BigEndian x = 0x%x\n%",x); //0x78563412
    ```

12. 不同文件格式也有端序的问题，例如GIF就是小端，而JPEG就是大端。

# 数字逻辑电路基础

1. 布尔代数：关于0和1的一套数学运算体系，用0和1分别代表逻辑值真和假。使用真值表反应输入和输出的关系。
2. 最基本的逻辑运算有与$\and$，或$\or$，非$\neg$。任何一种逻辑表达式都可以写成三种基本运算的组合，例如异或运算异或：$A\oplus B=(\neg A\and B) \or (A\and \neg B)$，异或也成为不等价，当A和B相异时，结果为真。
3. 逻辑运算在机器中可以使用逻辑门电路实现，与或非门电路符号如下：
4. <img src="E:\Markdown-file\assets\image-20230928015802419.png" alt="image-20230928015802419" style="zoom: 80%;" />
5. 将各种门电路级联起来，就可以得到逻辑表达式，例如异或门电路实现为为。
6. <img src="E:\Markdown-file\assets\image-20230928015914131.png" alt="image-20230928015914131" style="zoom:80%;" />
7. 机器中可以用一个01位串来表示n个逻辑值。位串之间也可以按位进行逻辑运算，只需要重复使用门电路即可。例如n位异或门电路记号：
8. ![image-20230928020127532](E:\Markdown-file\assets\image-20230928020127532.png)
9. 根据电路是否具有存储功能，可将逻辑电路分为：
   1. 组合逻辑电路，没有存储功能，输出仅依赖于输入。例如非门。
   2. 时序逻辑电路，具有存储功能，其输出不仅依赖于输入，还依赖于存储单元当前的状态。
10. 可以利用基本逻辑电路构成一些具有特定功能的功能部件，例如译码器，编码器，多路选择器，加法器等。
11. 实现功能部件的步骤：首先使用真值表描述该部件期望的行为，然后根据真值表确定逻辑表达式，最后实现逻辑电路。
12. 1位二路选择器：根据控制端S的值，来选择将A或B直接输出为F。下图中当S=0时，F=A，反之F=B。n位二路选择器中S被复用到n个1位二路选择器的控制端。
13. <img src="E:\Markdown-file\assets\image-20230928103516921.png" alt="image-20230928103516921" style="zoom:80%;" />
14. k路选择器，有k个输入和1个控制，因此s至少有$\log_2k$位。例如k=4，s至少为2位，00，01，10，11。

## 一位加法器

1. 一位半加器，不考虑来自低位的进位和不输出向高位的进位。
2. 一位加法器，也成为全加器。有两个加数A，B和一个低位来的进位Cin，输出为F和向高位的进位Cout。

   ```c
   真值表有9行
   A  B Cin | F Cout
   0  0  0  | 0  0
   0  0  1  | 1  0
   0  1  0  | 1  0
   0  1  1  | 0  1
   1  0  0  | 1  0
   1  0  1  | 0  1
   1  1  0  | 0  1
   1  1  1  | 1  1
   ```
3. 将逻辑表达式化简得到：$F=A\oplus B\oplus Cin$。$Cout=(A\and B)\or(B\and Cin)\or(Cin\and A)$。异或，或都是从左向右计算。全加器（Full Adder）的逻辑电路和符号如下：
4. <img src="E:\Markdown-file\assets\image-20230928110232540.png" alt="image-20230928110232540" style="zoom:80%;" />

## n位加法器

1. n位的加法器可以用n个全加器级联实现，将低位加法器的F直接输出，Cout作为高位加法器的Cin输入。也被称作串行进位加法器。需要从低位到高位严格按照顺序执行n次加法。其逻辑电路和符号如下：
2. <img src="E:\Markdown-file\assets\image-20230928110921899.png" alt="image-20230928110921899" style="zoom:80%;" />
3. ![image-20230928111007590](E:\Markdown-file\assets\image-20230928111007590.png)
4. 上述n位加法器只能用于记录无符号数的加法，无法用于两个有符号数之间的加法，无法判断是否发生了溢出，因此还需要给他加上一些标志位的输出。

   ```c
   n=4 A=1001 B=1100 Cin=0
   F=0101 Cout=1
   因此这表示二进制数1001+1100+0=10101，即9+12+0=16+4+1=20
   ```
5. n位带标志加法器，会产生4个标志位：

   1. 溢出标志：$OF=C_n\oplus C_{n-1}$，分别为最后一次和倒数第二次加法的进位。还有一种方法：当2个操作数的符号位相同，且和结果的符号位不同时，表示发生了溢出。不过后一种方法需要计算两次异或。
   2. 符号标志：$SF=F_{n-1}$，即最后一次加法的输出F
   3. 零标志：ZF=1当且仅当所有加法的输出F都为0
   4. 加法进位标志：$CF=Cout\oplus Cin$。减法为借位。对于加减器，Cin等于Sub。

6. <img src="E:\Markdown-file\assets\image-20230928111951107.png" alt="image-20230928111951107" style="zoom:80%;" />
7. <img src="E:\Markdown-file\assets\image-20230928232458068.png" alt="image-20230928232458068" style="zoom:80%;" />
8. 程序中经常要用到比较大小，这都是通过判断减法得到的标志信息来实现的。补码的减法可以用加法来实现。

## n位加减器

1. 下图通过将非门，2路选择器和带标志加法器结合，得到了一个带标志的加减器，也可以进行无符号数的加减。Sub为0或1，可以分别作为2路选择器的控制和加法器的Cin。如果Sub=0，则2路选择器输出B本身，那么加法器的Cin也为0，计算的就是A+B。如果Sub=1，则2路选择器输出B的反，然后Cin=1，这样就相当于输入$B’$为-B，因此计算的就是A+(-B)。
2. <img src="E:\Markdown-file\assets\image-20230928232755882.png" alt="image-20230928232755882" style="zoom:80%;" />
3. 在整数加减器的基础上，加上寄存器，移位器和控制逻辑就可以实现ALU，乘/除运算以及浮点运算电路。下图为ALU的符号，有一个操作控制端ALUop，用来决定ALU所执行的处理的功能，它的位数决定了可能进行的操作的数量。它的功能一般包含：无符号数和有符号数的加减等算术运算，与、或、非、异或等逻辑运算。
4. ![image-20230928233503080](E:\Markdown-file\assets\image-20230928233503080.png)

## 运算符与指令

1. 高级语言中涉及到的运算都会转化为指令集中指令序列，指令会被解码，送到各个由门电路组成的运算器中，指令集中至少应该包含：

   1. 带符号数的，取负/符号扩展/加减乘除/算术移位
   2. 无符号数的，0扩展/加减乘除/逻辑移位
   3. 逻辑操作，与、或、非、异或等
   4. 浮点数的加减乘除

2. 按位逻辑运算：

   ```c
   | //按位或
   & //按位与
   ~ //按位取反
   ^ //按位异或，一个位和1异或，相当于取反。一个位和0异或，啥变化也没有。
   //例子
   x&0xFF //提取int x的LSB
   ```
3. 移位运算：

   ```c
   >> //右移，在C语言层面不区分逻辑和算术移位，而转换成指令时，会根据操作数来区分。
   << //左移
   //右移位运算可以当作除法，不过是整数除法。
   //对于有符号数，移位是算术移位，右移高位补符号位
   //对于无符号数，移位是逻辑移位，右移高位补0
   //无论是算术移位还是逻辑移位，左移低位都是补0，逻辑左移如果移除的是1，则发生溢出，算术左移如果前后符号位不一致，则发生溢出。
   ```
4. 逻辑运算：

   ```c
   || //逻辑或运算
   && //逻辑与运算
   !  //逻辑非运算
   ```
5. 位扩展和截断，C语言中没有对应的运算符，类型转换时需要执行。扩展分为0扩展（无符号数）和符号扩展（有符号数），具体使用哪个，由编译器根据被扩展的数的类型自动选择。截断不区分是否是有符号数，可能会发生溢出。

   ```c
   //在大端机器上输出si,usi,i,ui
   short si = -32768; //最小的有符号数0x8000。
   unsigned short usi = si; //长度没变，不用做扩展和截断，只是改变了数据的解释方式，usi=32768
   int i = si; //进行符号扩展，为0xFFFF8000。i=-32768。
   unsigned = usi;//进行0扩展，0x00008000，uis=32768。
   //可见单纯的扩展并不会修改数值
   int i = 32768; //0x00008000
   short si = (short)i; //截断，si为0x8000，此时发生溢出了，si=-32768。
   int j = si;// 符号扩展j=0xFFFF8000，j=-32768。
   ```
6. 指针通常当作无符号数，因此进行指针运算时，也会将操作数转化为无符号数。
7. 有符号数运算通过OF来判断是否溢出，无符号数运算通过CF判断结果是否进位或借位，这样可以判断结果是否是正确的，符合数学规律的。

   ```c
   //4位2进制有符号运算 可表示范围为-8到7
   -7-6 = -7+(-6) = 1001B+1010B = 10011B = 3 //操作数符号位都是1，结果符号位是0，发生了溢出，结果不对。
   -3-5 = -3+(-5) = 1101B+1011B = 11000B = -8 //操作数符号位都是1，结果符号位也是1，没有溢出，结果正确。
   //4位2进制无符号运算 可表示范围为0到15
   9-6 = 9+(-6) = 1001B-0110B = 1001B+1010B = 10011B = 3 //高位进位(最后一步加法的，而不是取相反数时的加法)Cout=1，减法Sub=1。因此CF=Cout⊕Sub=0，结果正确。
   13-5 = 1101B-0101B = 1101B+1011B = 11000B = 8 //高位进位Cout=1,Sub=1，因此CF=0，结果正确。
   ```
8. 用程序判断两个无符号数相加减是否溢出，即进位：

   ```c
   int uadd_ok(unsigned x, unsigned y){
       unsigned sum = x+y; //不溢出时，结果正确就是x+y，溢出时，结果是x+y-2^n。
       //溢出时，结果一定比x和y都要小，因为如果结果比x大，则x+y-2^n > x → y > 2^n，无符号数最大为2^n-1，显然错误。
       return sum >= x;//没有溢出时，sum >= x为真，返回true。
   }
   //不能用以下程序判断无符号数相减是否借位：
   int usub_ok(unsigned x, unsigned y){
       return uadd_ok(x,-y); //有一个例外就是当x=0, y=0x80000000时，减法会借位，结果为0x80000000。而加法为0+0x80000000=0x800000000，显然sum>=x，没有进位。
   }
   //应该使用类似于uadd_ok的方法来判断是否进/借位：
   int usub_ok(unsigned x, unsigned y){
       unsigned add = x-y; //不溢出时，结果正确就是x-y，溢出时，结果是x+y+2^n。
       //溢出时，结果一定 >= x，因为如果结果比x小，则x-y+2^n < x → y > 2^n，无符号数最大为2^n-1，显然错误。
       return sum < x;//没有溢出时，sum < x为真，返回true。
   }
   ```
9. 用程序判断两个带符号数相加减是否溢出：

   ```c
   int tadd_ok(int a, int b){
       int sum = x+y;
       int neg_over = (x < 0 && y < 0) && sum >= 0; //负数+负数，结果为非负数。
       int pos_over = (x >= 0 && y >= 0) && sum < 0;
       return (!neg_over) && (!pos_over);//不发生正溢出且不发生负溢出。
   }
   //不能用以下程序判断带符号数相减是否溢出：
   int tsub_ok(int a, int b){
       return tadd_ok(x,-y); //有一个例外就是当x=0, y=0x80000000时，减法结果为0x800000000，发生正溢出了。而加法为0+0x80000000=0x800000000，并不会溢出。
   }
   //应该使用类似于tadd_ok的符号位判断方法来判断是否溢出：
   int tsub_ok(int a, int b){
       int sub = x-y;
       int neg_over = (x < 0 && y >= 0) && sum >= 0; //负数-非负数，结果为非负数。
       int pos_over = (x >= 0 && y < 0) && sum < 0;
       return (!neg_over) && (!pos_over);//不发生正溢出且不发生负溢出。
   }
   ```

## 整数乘法

1. 例如2个n位整数相乘，在乘法电路中是可以得到2n位乘积的，但是只会进行截断，把低n位赋值给结果。

2. 数学上，$x^2\ge0$​恒成立，但是计算机中不一定。

   ```c
   //4位2进制带符号数x=5=0101B，x^2=00000101+00010100B=00011001B，结果只取低4位=1001B=-7。
   5*5=25，比7大，模位16，而25和-7模16同余，因此结果为-7。
   ```

3. 编译器判断有符号数乘法是否溢出的方法：2n位乘积的高n位为全0或全1且等于低n位的最高位时，截断不会发生溢出，即2n位乘积的高n+1位全0或全1。不过将2n位乘积截断到n位时，如果截断的部分有1，那一定不会是全1。即不会出现符号扩展的逆运算那样的截断：

   ```c
   //以4位2进制串为例1111*1111=1110 0001，这已经是最大的串了，因此不会出现将11111xyz截断为1xyz的情况，截断的都是01串或全0串，不会是全1串。
   ```

4. 编译器判断无符号数乘法是否溢出的方法：只有2n位乘积的高n位为全0时，截断才不会发生溢出。

5. 用程序判断有符号数乘法的结果是否正确：

   ```c
   int mul_ok(int x, int y){
       int z = x*y;
       if (!x || z/x == y){
           return true; //当x为0时，结果必然正确。或者z/x和y相等即可逆时，结果也正确。
       }else{
           return false;
       }
   }
   //这个表达式!x || z/x == y 也可以判断无符号数乘法的结果是否正确。
   ```

6. CPU会将2n位的结果都提供出来，编译器可以使用某些指令获取高n位，来根据数据类型自主判断是否溢出。硬件不会取判定是否溢出。

   ```c
   //以IA-32为例，mul ax,bx 会进行16位的乘法，结果的高16位存放在dx中，低16位存放在ax中。
   ```

7. 乘法指令不会修改标志寄存器的OF标志，因此无法通过标志判断是否溢出。

8. 如果程序员在源代码中没有判断，且编译器也没有植入一些检查指令，那么就有可能发生溢出，但没有被发现。

9. CPU中乘法指令是区分无符号还是带符号的，这和加减运算不同。

10. 无符号乘法器和带符号乘法器的符号如下，如果4个乘数两两对应位串相等，那么Pu和Ps也是位串相等的，但是高n位的Puh和Psh==不一定相等==。因此机器中可以用无符号乘法器来进行带符号乘法运算。

11. ![image-20230929145509274](E:\Markdown-file\assets\image-20230929145509274.png)

12. 变量和常数之间的乘法运算，可以由编译器优化成移位和加法运算，这样可以大大提高效率，因为乘法运算通常需要多个时钟周期，而移位和加法一般都是一个或更少的时钟周期。

    ```c
    x*20=x*(16+4)=(x<<4)+(x<<2)。 //带符号数和无符号数都适用，且当结果溢出时，也是和直接相乘结果一样。
    ```


## 整数除法

1. 对于带符号整数来说，n位除以n位，只有$-2^{n-1}/-1=2^{n-1}$会溢出，因为带符号数无法正确表示$2^{n-1}$。

2. 整数除法的商也是整数，因此在不能整除时通常规定朝0的方向舍入。即正数商会向下取整floor，负数商会向上取整ceiling。

3. 整数除以0的结果，是找不到一个2进制位串来表示的，因为所有的二进制位串都表示有限值。因此会CPU发生异常。

4. 整数除法操作不能使用流水线方式实现，因为需要根据每次试商的结果调整，一会做加法，一会做减法，无法预测后续的操作，它的开销比乘法还要大，大约30多个指令周期。

5. 编译器在处理变量除以2的幂的常数时，通常会转化为移位指令，而不是直接使用除法指令。对于无符号数，采用逻辑右移；有符号数，采用算术右移。

   ```c
   //移除的位全0时，表示能够整除
   12/4 = 00001100 >> 2 = 00000011 = 3
   -12/3 = 11110100 >> 2 = 11111101 = -3
   //移除的位中有1时，表示不能整除，需要进行相应的处理
   //当被除数为无符号，带符号正数时，移除的位直接社区，什么也不错：
   14/4 = 00001110 >> 2 = 00000011=3//正确，被移出的为10
   //当被除数为带符号负数，需要先加上偏移量2^k-1，然后再右移k位，低位直接截断即可。
   -14/4 = 11110010 >> 2 = 11111100=-4≠-3 //错误做法
   -14/4 = (11110010+00000011) >> 2 = 11110101 >> 2 = 11111101=-3//正确做法
   ```

6. 假设x为int变量，请给出一个用来计算x/32的函数div32，要求不能使用除法，乘法，模运算，比较运算，循环和条件语句，可以使用右移，加法以及任何按位运算

   ```c
   //若x为非负数，则直接右移5位即可，若x为负数，需要先加上31，再右移5位。综合为(x+b)>>5。当x为非负时，b=0，当x为负数时，b=31。因此可以令b = (x>>31) &0x1F。
   ```


## 浮点数加减运算

1. 设两个规格化的浮点数分别为：$A=M_a\cdot2^{E_a}$，$B=M_b\cdot2^{E_b}$。且$E_a\ge E_b$。则$A\pm B=(M_a\pm M_b\cdot2^{-(E_a-E_b)})\cdot2^{E_a}$。这里进行了对阶操作。$A\cdot B=(M_a\cdot M_b)\cdot2^{E_a+E_b}$，$A/B=(M_a/M_b)\cdot2^{E_a-E_b}$。乘除法不用对阶，尾数相乘除，阶码相加减。

2. 对阶：小阶向大阶看起，阶小的那个数的尾数右移，位数等于大阶-小阶的值。移除的位会保留到特党的附加位，会参与后续的尾数计算，然后输出最终结果时才舍入。

3. 浮点数四则运算可能出现以下结果：

   1. 阶码上溢，一个正的指数超过了最大允许的值，可能为$\pm\infin$。例如float类型中，最大的阶码为11111110B，指数为254-127=127。例如$2^{100}\cdot2^{100}$的阶为200，无法用float表示，因此结果为$+\infin$
   2. 阶码下溢，一个负的指数超过了最大允许的值，可能为$\pm0$。例如float类型中，最小的阶码为00000001B，指数为1-127=-126.例如$2^{-100}\cdot2^{-100}$的阶位-200，无法用float表示，因此结果为0。
   3. 尾数溢出，最高有效位有进位，称为右规。例如float类型中，1.5+1.5=3.0，尾数为11.0，产生了进位，需要移动小数点（通常只用移动一位）使之规格化，同时需要改变阶码（需要判断是否发生上溢）。因此尾数溢出，不一定会造成结果溢出。
   4. 非规格化尾数，数值部分高位为0，称为左规。例如float类型中，1.5-1.0=0.5，尾数为0.1B，需要移动小数点（可能不止一位）使之规格化，同时需要改变阶码（需要判断是否发生下溢）。因此产生非规格化尾数，不一定会造成结果溢出。
   5. 右规和对阶时，右段低位的有效数字可能丢失，称为尾数舍入，因此在计算过程中，可以采用更多的位来表示中间结果，只在最后输出结果时才舍入。

4. IEEE754建议浮点计算硬件为上述每种异常情况提供一个自陷允许位，若某异常对应的位为1，则发生异常时，会调用一个特定的处理程序去处理。类似于信号屏蔽字。

5. IEEE754规定的5种异常情况：

   1. 无效运算，至少一个运算数为非有限数（5+(+∞)），或结果无效（NaN）。
   2. 除以0，即无穷大。结果的尾数为全0，阶码全1表示，符号位视情况而定。
   3. 数太大，阶码上溢
   4. 数太小，阶码下溢
   5. 结果不精确，1/3的结果不能精确表示成浮点数。

6. 浮点数除以0的例子：

   ```c
   #include <stdio.h>
   void main(){
       int a = 1, b = 0;
       printf("%d\n",a/b);//整数除法，会产生运行时错误。因为整数所有位串都只能表示有限数。
       double x = 1.0, y = -1.0, z = 0.0;
       printf("x/z = %f, y/z = %f\n", x/z, y/z); //不会报错，分别为+inf和-inf。浮点数存在特定位串表示±无穷大。
   }
   ```

7. 如果运算结果的尾数都为0，那么阶码也应设置为0，因为尾数为0说明结果就是0。

8. 例子：

   ```c
   0.5+(-0.4375) = 0.0625
   //分别表示为二进制0.5=1.000*2^-1，-0.4375=-1.110*2^-2。
   //对阶后加减为：(1.000+0.1110)*2^-1 = 0.0010*2^-1。
   //尾数为非规格化，需要左规=1.0*2^-4，阶码没有溢出。
   ```

9. 实数除了使用浮点数表示外，还可以使用定点小数表示，定点小数由于没有阶码，一般来说有效数字会比同长度的浮点数多。

10. 

11. 

12. 

13. 

14. 

15. 

16. 

17. 

18. 

19. 

20. 

21. 

22. 

# ELF文件

1. 可以使用objdump来对ELF文件进行查看，可以对代码区域进行反汇编。

   ```shell
   objdump -d main  #对可执行的节进行反汇编   如果在gcc编译时加入了-g调试选项，可以在此加入-S，反汇编的同时显示源码。默认显示的是AT&T的汇编风格，可以使用-M intel来使用Intel汇编风格显示。-EB和-EL来指定文件时大端还是小端存放的。
   
   ```

2. ELF文件的分区和C语言程序的对应。局部变量是在运行时，动态在栈上生成的。全局和静态变量分为初始化的和未初始化的，已初始化的放在.data节中，未初始化的放在.bss节中。

3. ![image-20210529151356804](计算机系统基础.assets/image-20210529151356804.png)

4. 未初始化的全局变量和静态变量只会在符号表中存储一个common，这个和具体编译器实现有关。

5. 由于编译的时候是每个源文件独立编译，因此需要通过链接来处理各个模块之间的相互引用。例如在应用程序中使用到了标准库的printf函数，编译的时候并不知道该函数的入口地址，链接器在链接时，会根据引用到的符号printf去相应的模块中查找printf的地址。然后对源模块进行修正。

6. gcc链接时默认使用动态库，系统中默认是不安装有静态库的。运行以下命令来安装：

   ```shell
   yum --enablerepo=powertools install glibc-static
   ```

7. 动态库的后缀名为.so 意思是shared object。

8. 使用hexdump或od(默认是8进制)命令来查看二进制文件。不过一般都要配合head或tail来查看开始或默认的部分字节。head和tail默认是按照行来查看，而二进制文件中没有行的概念，所以应该按照字节来查看。

   ```shell
   [zj@ZJ lib64]$ head -c 100 libc-2.28.so |hexdump -C #查看开头的100个字节的二进制和ASCII对照。
   00000000  7f 45 4c 46 02 01 01 03  00 00 00 00 00 00 00 00  |.ELF............|
   00000010  03 00 3e 00 01 00 00 00  c0 38 02 00 00 00 00 00  |..>......8......|
   00000020  40 00 00 00 00 00 00 00  10 10 30 00 00 00 00 00  |@.........0.....|
   00000030  00 00 00 00 40 00 38 00  0c 00 40 00 4c 00 4b 00  |....@.8...@.L.K.|
   00000040  06 00 00 00 04 00 00 00  40 00 00 00 00 00 00 00  |........@.......|
   00000050  40 00 00 00 00 00 00 00  40 00 00 00 00 00 00 00  |@.......@.......|
   00000060  a0 02 00 00                                       |....|
   00000064
   ```

9. 使用--verbose选项，可以使GCC打印出具体调用的命令细节，collect2程序是对ld链接器的一个封装：

   ```shell
   [zj@ZJ test]$ gcc hello.o -o hello --verbose
   ...
    /usr/libexec/gcc/x86_64-redhat-linux/8/collect2 -plugin /usr/libexec/gcc/x86_64-redhat-linux/8/liblto_plugin.so -plugin-opt=/usr/libexec/gcc/x86_64-redhat-linux/8/lto-wrapper -plugin-opt=-fresolution=/tmp/ccRrSl6f.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --no-add-needed --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o hello /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crt1.o /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crti.o /usr/lib/gcc/x86_64-redhat-linux/8/crtbegin.o -L/usr/lib/gcc/x86_64-redhat-linux/8 -L/usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64 -L/lib/../lib64 -L/usr/lib/../lib64 -L/usr/lib/gcc/x86_64-redhat-linux/8/../../.. hello.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-redhat-linux/8/crtend.o /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crtn.o
   COLLECT_GCC_OPTIONS='-o' 'hello' '-v' '-mtune=generic' '-march=x86-64'
   ```

10. ELF文件Executable Linkage Format，可执行，可链接文件。使用file命令来查看文件的格式。包含以下4种：

   ```shell
   可执行文件              ELF 64-bit LSB executable
   目标文件(.o)            ELF 64-bit LSB relocatable
   动态链接库(.so)         ELF 64-bit LSB shared object
   核心转储文件 coredump   ELF 64-bit LSB core file
   ```

11. 例子：

    ```c
    #include <stdio.h>
    int g_init_var1 = 1;
    int g_uinit_var2 ;
    void foo(int i){
        printf("%d\n",i);
    }
    int main(void)
    {
        static int var3 = 2;
        static int var4;
        int x =3;
        foo(x);
        return 0;
    }
    ```

12. 使用objdump -h查看目标文件的节头。

    ```shell
    [zj@ZJ test]$ objdump -h main.o
    main.o：     文件格式 elf64-x86-64
    节：
    Idx Name          Size      VMA               LMA               File off  Algn
      0 .text         00000042  0000000000000000  0000000000000000  00000040  2**0
                      CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  #指令部分
      1 .data         00000008  0000000000000000  0000000000000000  00000084  2**2
                      CONTENTS, ALLOC, LOAD, DATA  #已经初始化的全局和静态变量。
      2 .bss          00000004  0000000000000000  0000000000000000  0000008c  2**2
                      ALLOC    #未初始化的全局和局部变量，会在程序运行的一开始初始化。
      3 .rodata       00000004  0000000000000000  0000000000000000  0000008c  2**0
                      CONTENTS, ALLOC, LOAD, READONLY, DATA # 只读数据，字符串和只读变量存储在这里。
      4 .comment      0000002d  0000000000000000  0000000000000000  00000090  2**0
                      CONTENTS, READONLY  #编译器写入的信息
      5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000bd  2**0
                      CONTENTS, READONLY
      6 .eh_frame     00000058  0000000000000000  0000000000000000  000000c0  2**3
                      CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
    ```

13. 使用objdump -d main.o查看.text节的反汇编：

    ```assembly
    [zj@ZJ test]$ objdump -d main.o
    main.o：     文件格式 elf64-x86-64
    Disassembly of section .text:
    0000000000000000 <foo>:
       0:   55                      push   %rbp
       1:   48 89 e5                mov    %rsp,%rbp
       4:   48 83 ec 10             sub    $0x10,%rsp
       8:   89 7d fc                mov    %edi,-0x4(%rbp)
       b:   8b 45 fc                mov    -0x4(%rbp),%eax
       e:   89 c6                   mov    %eax,%esi
      10:   bf 00 00 00 00          mov    $0x0,%edi
      15:   b8 00 00 00 00          mov    $0x0,%eax
      1a:   e8 00 00 00 00          callq  1f <foo+0x1f>
      1f:   90                      nop
      20:   c9                      leaveq
      21:   c3                      retq
    0000000000000022 <main>:
      22:   55                      push   %rbp
      23:   48 89 e5                mov    %rsp,%rbp
      26:   48 83 ec 10             sub    $0x10,%rsp
      2a:   c7 45 fc 03 00 00 00    movl   $0x3,-0x4(%rbp)
      31:   8b 45 fc                mov    -0x4(%rbp),%eax
      34:   89 c7                   mov    %eax,%edi
      36:   e8 00 00 00 00          callq  3b <main+0x19>
      3b:   b8 00 00 00 00          mov    $0x0,%eax
      40:   c9                      leaveq
      41:   c3                      retq
    ```

14. 使用objdump -s查看各节的内容，ELF文件中是：

    ```shell
    [zj@ZJ test]$ objdump -s main.o
    main.o：     文件格式 elf64-x86-64
    Contents of section .text: 
     0000 554889e5 4883ec10 897dfc8b 45fc89c6  UH..H....}..E...
     0010 bf000000 00b80000 0000e800 00000090  ................
     0020 c9c35548 89e54883 ec10c745 fc030000  ..UH..H....E....
     0030 008b45fc 89c7e800 000000b8 00000000  ..E.............
     0040 c9c3                                 ..
    Contents of section .data:   
     0000 01000000 02000000                    ........
    Contents of section .rodata:  
     0000 25640a00                             %d..
    Contents of section .comment:  
     0000 00474343 3a202847 4e552920 382e332e  .GCC: (GNU) 8.3.
     0010 31203230 31393131 32312028 52656420  1 20191121 (Red
     0020 48617420 382e332e 312d3529 00        Hat 8.3.1-5).
    Contents of section .eh_frame:
     0000 14000000 00000000 017a5200 01781001  .........zR..x..
     0010 1b0c0708 90010000 1c000000 1c000000  ................
     0020 00000000 22000000 00410e10 8602430d  ...."....A....C.
     0030 065d0c07 08000000 1c000000 3c000000  .]..........<...
     0040 00000000 20000000 00410e10 8602430d  .... ....A....C.
     0050 065b0c07 08000000                    .[......
    ```

15. ELF文件是按照section，segment来组织的。

    1. Segment是载入内存时需要用到的，每个segment是内存权限相同的。
    2. Section是链接器使用的，标识ELF的每一部分是什么。链接的时候，链接器会将不同ELF文件的相同部分合并，并修复相互的引用。

16. 相同权限的section会放入同一个segment，一个section也可以属于多个segment。后者一般是因为内存映射是按页进行的，粒度比较粗，当section比较小的时候可能会出现这种情况。

17. 可执行文件必须要有段表，可以没有节表。目标文件必须要有节表，可以没有段表。动态库两者都需要有，因为链接和执行的时候都会需要它。这是和他们的功能相关的。

18. program header又叫segment header。段头表和节头表中包含很多个段头和节头，他们分别记录了段和节的开始地址，大小，和内存映射到的虚拟地址。

19. ![image-20210530212630660](计算机系统基础.assets/image-20210530212630660.png)

20. 可以使用readelf -h 来查看ELF文件头的结构：

    ```shell
    [zj@ZJ test]$ readelf -h main
    ELF 头：
      Magic：  7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
      类别:                              ELF64
      数据:                              2 补码，小端序 (little endian)
      版本:                              1 (current)
      OS/ABI:                            UNIX - System V
      ABI 版本:                          0
      类型:                              EXEC (可执行文件)
      系统架构:                          Advanced Micro Devices X86-64
      版本:                              0x1
      入口点地址：              0x4004b0  #内存映像中入口点的虚拟地址
      程序头起点：              64 (bytes into file) #第一个段头的起始地址，相对于文件的最开始
      Start of section headers:          11000 (bytes into file)  #第一个节头的起始地址，相对于文件的最开始
      标志：             0x0
      本头的大小：       64 (字节)      #文件头的大小
      程序头大小：       56 (字节)      #每个段头的大小
      Number of program headers:         9   #段头的个数
      节头大小：         64 (字节)      #每个节头的大小
      节头数量：         30             #节头的个数
      字符串表索引节头： 29              #字符串表索引节头所在的下标
    ```

21. 可以使用readelf -l 来查看段表的结构，栈是不占用文件的大小的，内存虚拟地址也是不确定的，有内核加载的时候确定：

    ```shell
    [zj@ZJ test]$ readelf -l main
    Elf 文件类型为 EXEC (可执行文件)
    Entry point 0x4004b0
    There are 9 program headers, starting at offset 64
    程序头：
      Type           Offset             VirtAddr           PhysAddr
                     FileSiz            MemSiz              Flags  Align
      PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040
                     0x00000000000001f8 0x00000000000001f8  R      0x8
      INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238
                     0x000000000000001c 0x000000000000001c  R      0x1
          [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
      LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                     0x00000000000007c8 0x00000000000007c8  R E    0x200000
      LOAD           0x0000000000000e00 0x0000000000600e00 0x0000000000600e00
                     0x000000000000022c 0x0000000000000238  RW     0x200000
      DYNAMIC        0x0000000000000e10 0x0000000000600e10 0x0000000000600e10
                     0x00000000000001d0 0x00000000000001d0  RW     0x8
      NOTE           0x0000000000000254 0x0000000000400254 0x0000000000400254
                     0x0000000000000044 0x0000000000000044  R      0x4
      GNU_EH_FRAME   0x000000000000067c 0x000000000040067c 0x000000000040067c
                     0x0000000000000044 0x0000000000000044  R      0x4
      GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                     0x0000000000000000 0x0000000000000000  RW     0x10
      GNU_RELRO      0x0000000000000e00 0x0000000000600e00 0x0000000000600e00
                     0x0000000000000200 0x0000000000000200  R      0x1
     Section to Segment mapping:  #段和节的映射关系
      段节...
       00     
       01     .interp 
       02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame 
       03     .init_array .fini_array .dynamic .got .got.plt .data .bss 
       04     .dynamic 
       05     .note.ABI-tag .note.gnu.build-id 
       06     .eh_frame_hdr 
       07     
       08     .init_array .fini_array .dynamic .got 
    ```

22. 可以使用readelf -S 来查看ELF文件的节表：

    ```shell
    [zj@ZJ test]$ readelf -S main
    There are 30 section headers, starting at offset 0x2af8:
    节头：
      [号] 名称              类型             地址              偏移量
           大小              全体大小          旗标   链接   信息   对齐
      [ 0]                   NULL             0000000000000000  00000000
           0000000000000000  0000000000000000           0     0     0
      [ 1] .interp           PROGBITS         0000000000400238  00000238
           000000000000001c  0000000000000000   A       0     0     1
    ...
      [29] .shstrtab         STRTAB           0000000000000000  000029dd
           0000000000000119  0000000000000000           0     0     1
    Key to Flags:
      W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
      L (link order), O (extra OS processing required), G (group), T (TLS),
      C (compressed), x (unknown), o (OS specific), E (exclude),
      l (large), p (processor specific)
    ```

23. 文件到内存的映射关系，程序执行起来的时，可以通过/proc/进程PID/maps目录查看内存映射：

24. ![image-20210530215709443](计算机系统基础.assets/image-20210530215709443.png)

25. ELF头文件中使用到的数据类型，64位：

    ```c
    /* Type for a 16-bit quantity.  */
    typedef uint16_t Elf64_Half;
    /* Types for signed and unsigned 32-bit quantities.  */
    typedef uint32_t Elf64_Word;
    typedef	int32_t  Elf64_Sword;
    /* Types for signed and unsigned 64-bit quantities.  */
    typedef uint64_t Elf64_Xword;
    typedef	int64_t  Elf64_Sxword;
    /* Type of addresses.  */
    typedef uint64_t Elf64_Addr;
    /* Type of file offsets.  */
    typedef uint64_t Elf64_Off;
    /* Type for section indices, which are 16-bit quantities.  */
    typedef uint16_t Elf64_Section;         //因此最多65536个节
    /* Type for version symbol information.  */
    typedef Elf64_Half Elf64_Versym;
    ```

26. ELF文件头结构体，64位时为64字节。记录里节和段的信息。

27. ```c
    typedef struct
    {
      unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */16个字节的魔数
      Elf64_Half	e_type;			/* Object file type */ 目标文件的类型，
      Elf64_Half	e_machine;		/* Architecture */
      Elf64_Word	e_version;		/* Object file version */
      Elf64_Addr	e_entry;		/* Entry point virtual address */ 入口点的虚拟地址
      Elf64_Off	e_phoff;		/* Program header table file offset */ 段头表的偏移地址，如果是0，则表示没有段头表
      Elf64_Off	e_shoff;		/* Section header table file offset */ 节头表的偏移地址
      Elf64_Word	e_flags;		/* Processor-specific flags */
      Elf64_Half	e_ehsize;		/* ELF header size in bytes */ 文件头的大小
      Elf64_Half	e_phentsize;		/* Program header table entry size */ 段头表每个条目的大小。
      Elf64_Half	e_phnum;		/* Program header table entry count */段头表的条目数量
      Elf64_Half	e_shentsize;		/* Section header table entry size */节头表每个条目的大小。
      Elf64_Half	e_shnum;		/* Section header table entry count */节头表的条目数量
      Elf64_Half	e_shstrndx;		/* Section header string table index */字符串表索引节头在节头表中的下标。
    } Elf64_Ehdr;
    ```

28. 16个字节的魔数：

29. 段头表中的每一项，一般为56字节：

31. ```c
    typedef struct
    {
      Elf64_Word	p_type;			/* Segment type */
      Elf64_Word	p_flags;		/* Segment flags */
      Elf64_Off	p_offset;		/* Segment file offset */  段在ELF文件中的偏移
      Elf64_Addr	p_vaddr;		/* Segment virtual address */  段在内存中的虚拟地址
      Elf64_Addr	p_paddr;		/* Segment physical address */
      Elf64_Xword	p_filesz;		/* Segment size in file */  段在文件中的大小
      Elf64_Xword	p_memsz;		/* Segment size in memory */  段在内存中的大小。
      Elf64_Xword	p_align;		/* Segment alignment */
    } Elf64_Phdr;
    ```

32. 节头表中的每一项，一般为64字节，出现在每一节的最开始，文件的不同节不重叠，文件中可能存在一些字节，不属于文件头部和任何节：

    ```c
    typedef struct
    {
      Elf64_Word	sh_name;		/* Section name (string tbl index) */当前节的名称，实际上是一个在节头字符串表的偏移地址，字符串以'\0'结尾。
      Elf64_Word	sh_type;		/* Section type */
      Elf64_Xword	sh_flags;		/* Section flags */标识当前节的属性。
      Elf64_Addr	sh_addr;		/* Section virtual addr at execution */
      Elf64_Off	sh_offset;		/* Section file offset */
      Elf64_Xword	sh_size;		/* Section size in bytes */
      Elf64_Word	sh_link;		/* Link to another section */
      Elf64_Word	sh_info;		/* Additional section information */
      Elf64_Xword	sh_addralign;		/* Section alignment */
      Elf64_Xword	sh_entsize;		/* Entry size if section holds table */
    } Elf64_Shdr;
    ```

33. sh_type：

34. 

35. sh_flags：

    1. SHF_WRITE，是否可以写入数据。
    2. SHF_ALLOC，是否占用内存（某些节只起到控制作用，并不出现在进程的内存映像中）。
    3. SHF_EXECINSTR，是否包含机器指令。

36. ```assembly
    文件头，可以发现节头表的偏移地址为0x2AF8，一共有0x1E个节，每个大小为0x40，字符串索引表节头是第1D个。
    一共有9个段，每个段头的大小为0x38，程序的入口点的虚拟地址为0x4004B0
    00000000: 7F 45 4C 46 02 01 01 00 00 00 00 00 00 00 00 00    .ELF............
    00000010: 02 00 3E 00 01 00 00 00 B0 04 40 00 00 00 00 00    ..>.....0.@.....
    00000020: 40 00 00 00 00 00 00 00 F8 2A 00 00 00 00 00 00    @.......x*......
    00000030: 00 00 00 00 40 00 38 00 09 00 40 00 1E 00 1D 00    ....@.8...@.....
    
    第13个节头表，首地址为0x2AF8+13*64=0x2E38，当前节的名称为0x29DD+0x94=0x2A71查询最下面的表，可以看到是.text  当前节的起始地址为0x4B0。该节在内存中的地址为0x4004B0，和文件头中的属性对应上，因此当前节就是程序的入口点。
    00002e30: -- -- -- -- -- -- -- -- 94 00 00 00 01 00 00 00    ................
    00002e40: 06 00 00 00 00 00 00 00 B0 04 40 00 00 00 00 00    ........0.@.....
    00002e50: B0 04 00 00 00 00 00 00 A5 01 00 00 00 00 00 00    0.......%.......
    00002e60: 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00 00    ................
    00002e70: 00 00 00 00 00 00 00 00 -- -- -- -- -- -- -- --    ................
    
    字符串索引表节头，第29个首地址为0x2AF8+29*64=0x3238,节的起始地址为0x29DD。当前节的名称为0x29DD+0x11=0x29EE查询最下面的表，可以看到是.shstrtab
    00003230: -- -- -- -- -- -- -- -- 11 00 00 00 03 00 00 00    ................
    00003240: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    00003250: DD 29 00 00 00 00 00 00 19 01 00 00 00 00 00 00    ])..............
    00003260: 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00    ................
    00003270: 00 00 00 00 00 00 00 00                            ........
    
    字符串索引表
    000029d0: -- -- -- -- -- -- -- -- -- -- -- -- -- 00 2E 73    g_uinit_var2...s
    000029e0: 79 6D 74 61 62 00 2E 73 74 72 74 61 62 00 2E 73    ymtab..strtab..s
    000029f0: 68 73 74 72 74 61 62 00 2E 69 6E 74 65 72 70 00    hstrtab..interp.
    ...
    00002a70: 00 2E 74 65 78 74 00 2E 66 69 6E 69 00 2E 72 6F    ..text..fini..ro
    
    .text节的内容
    000004b0: F3 0F 1E FA 31 ED 49 89 D1 5E 48 89 E2 48 83 E4    s..z1mI.Q^H.bH.d
    000004c0: F0 50 54 49 C7 C0 50 06 40 00 48 C7 C1 E0 05 40    pPTIG@P.@.HGA`.@
    000004d0: 00 48 C7 C7 B8 05 40 00 FF 15 0A 0B 20 00 F4 90    .HGG8.@.......t.
    ```

37. 通过对.text节进行反汇编得到如下：

38. ```assembly
    Disassembly of section .text:
    00000000004004b0 <_start>:
      4004b0:       f3 0f 1e fa             endbr64 
      4004b4:       31 ed                   xor    %ebp,%ebp
      4004b6:       49 89 d1                mov    %rdx,%r9
      4004b9:       5e                      pop    %rsi
      4004ba:       48 89 e2                mov    %rsp,%rdx
      4004bd:       48 83 e4 f0             and    $0xfffffffffffffff0,%rsp
      4004c1:       50                      push   %rax
      4004c2:       54                      push   %rsp
      4004c3:       49 c7 c0 50 06 40 00    mov    $0x400650,%r8
      4004ca:       48 c7 c1 e0 05 40 00    mov    $0x4005e0,%rcx
      4004d1:       48 c7 c7 b8 05 40 00    mov    $0x4005b8,%rdi
      4004d8:       ff 15 0a 0b 20 00       callq  *0x200b0a(%rip)        # 600fe8 <__libc_start_main@GLIBC_2.2.5>
      4004de:       f4                      hlt   
    ```

39. 可以使用readelf -p 节名 elf文件名   来以字符串的方式查看elf文件的某一节。

    ```shell
    [zj@ZJ test]$ readelf -p .shstrtab main.o
    String dump of section '.shstrtab':      #节名一般在这里存储
      [     1]  .symtab
      [     9]  .strtab
      [    11]  .shstrtab
      [    1b]  .rela.text
      [    26]  .data
      [    2c]  .bss
      [    31]  .rodata
      [    39]  .comment
      [    42]  .note.GNU-stack
      [    52]  .rela.eh_frame
    
    [zj@ZJ test]$ readelf -p .strtab main.o
    String dump of section '.strtab':   #符号名一般在这里处处。
      [     1]  main.c   #源文件名
      [     8]  var4.2367  #局部变量被重命名了
      [    12]  var3.2366  #局部变量
      [    1c]  g_init_var1  #全局变量var1被重命名了
      [    28]  g_uinit_var2   #全局变量var2
      [    35]  foo  #函数名
      [    39]  printf  #标准库中的函数
      [    40]  main  #函数名
    ```

# 链接

1. 编译器为了防止标识符重名的情况，会在编译时进行重命名。

2. 可以通过readelf -s 来查看elf文件的符号表，符号表是在重定位时会用到：

   ```shell
   readelf -s main.o
   Symbol table '.symtab' contains 16 entries:
      Num:    Value          Size Type    Bind   Vis      Ndx Name
        0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
        1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c
        2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1
        3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3
        4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
        5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
        6: 0000000000000000     4 OBJECT  LOCAL  DEFAULT    4 var4.2367
        7: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 var3.2366
        8: 0000000000000000     0 SECTION LOCAL  DEFAULT    7
        9: 0000000000000000     0 SECTION LOCAL  DEFAULT    8
       10: 0000000000000000     0 SECTION LOCAL  DEFAULT    6
       11: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 g_init_var1
       12: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM g_uinit_var2  #未初始化的全局变量，存在于.bss段中。
       13: 0000000000000000    34 FUNC    GLOBAL DEFAULT    1 foo
       14: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf  #链接前不知道该标号是什么类型和节号，Ndx是当前符号所在的节
       15: 0000000000000022    32 FUNC    GLOBAL DEFAULT    1 main
   
   ```

3. 符号section内存储的是一个一个的符号结构体：

   ```c
   typedef struct
   {
       Elf64_Word    st_name;                /* Symbol name (string tbl index) */ .strtab节的偏移
       unsigned char st_info;                /* Symbol type and binding */
       unsigned char st_other;               /* Symbol visibility */
       Elf64_Section st_shndx;               /* Section index */  所属的节
       Elf64_Addr    st_value;               /* Symbol value */
       Elf64_Xword   st_size;                /* Symbol size */
   } Elf64_Sym;
   ```

4. 未链接的目标文件的结构图，==使用内存映射mmap来分析elf文件==。ELF中的节头表不一定是在文件的末尾。readelf中显示的节的顺序不一定和文件存储的相同。

5. 实际上exec命令就是将可执行文件映射到内存中，和mmap的操作类似。

6. ELF头64个字节，.text段从0x40开始，大小为41个字节，他后面的.data节是从0x84开始的，这是因为该节的对齐是4字节。即节的起始地址要是4个倍数。

7. ![image-20210531195643672](计算机系统基础.assets/image-20210531195643672.png)

8. 静态链接的过程：

   1. 先将不同目标文件的相同的节进行合并。
   2. 根据符号表，搜索，重定位。

9. 使用readel -r 或objdump -r可以查看重定位信息：

   ```shell
   [zj@ZJ test]$ readelf -r main.o
   重定位节 '.rela.text' at offset 0x2e0 contains 3 entries:
     偏移量          信息           类型           符号值        符号名称 + 加数
   000000000011  00050000000a R_X86_64_32       0000000000000000 .rodata + 0
   00000000001b  000e00000002 R_X86_64_PC32     0000000000000000 printf - 4
   000000000037  000d00000002 R_X86_64_PC32     0000000000000000 foo - 4
   重定位节 '.rela.eh_frame' at offset 0x328 contains 2 entries:
     偏移量          信息           类型           符号值        符号名称 + 加数
   000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0
   000000000040  000200000002 R_X86_64_PC32     0000000000000000 .text + 22
   
   [zj@ZJ test]$ objdump -r main.o
   main.o：     文件格式 elf64-x86-64
   RELOCATION RECORDS FOR [.text]:
   OFFSET           TYPE              VALUE
   0000000000000011 R_X86_64_32       .rodata
   000000000000001b R_X86_64_PC32     printf-0x0000000000000004
   0000000000000037 R_X86_64_PC32     foo-0x0000000000000004
   RELOCATION RECORDS FOR [.eh_frame]:
   OFFSET           TYPE              VALUE
   0000000000000020 R_X86_64_PC32     .text
   0000000000000040 R_X86_64_PC32     .text+0x0000000000000022
   ```

10. ld --verbose查看默认的链接脚本。在嵌入式开发中，有时需要对链接进行精确控制，此时可以自己书写链接脚本。

11. 可以看到编译前，main函数中调用函数的call指令，其指令的操作数部分都是0，需要搜索符号表确定被调函数的地址。

12. <img src="计算机系统基础.assets/image-20210531200353935.png" alt="image-20210531200353935" style="zoom:67%;" />

13. 可执行文件的装载过程：

    1. 操作系统给进程分配资源，开辟虚拟地址空间。
    2. 建立可执行文件到进程虚拟地址空间的映射。
    3. 将IP设置为程序入口点，开始执行。

14. 映射是按照segment来的，section的组织对顺序没有要求，而同一个segment中的section的内存操作权限是相同。因此section的组织是配合segment来的。

15. 可以再/proc/进程ID/maps文件下面看到进程的虚拟地址映射关系：

    1. 第1列为虚拟内存的起始和终止地址
    2. 第2列为内存的权限，前三个个读写执行，最后一个为共享或私有。
    3. 第3列为映射在文件中的偏移量。
    4. 第4列为映像文件的主次设备号
    5. 第5列为映像文件的iNode号
    6. 第6列为映像文件的路径

16. ![image-20210531203113792](计算机系统基础.assets/image-20210531203113792.png)

17. 可执行文件的装载器在进程开始执行前，会将argc和argv会有放入到进程的栈中。

18. 生成动态库：

    ```shell
    gcc -fPIC -shared -o hello.o hello.c   #-shared 生成共享对象，即.so的动态库。 -fPIC 生成位置无关代码
    gcc -o main main.c ./hello.so  #根据文件的路径使用动态库。
    ```

19. 使用动态库的进程地址空间。ld-2.12.so是动态链接器。操作系统会先将控制权交给动态链接器，进行链接，完成后再将控制权交给程序本身。动态连接器是在elf文件中指定的。

20. ![image-20210531233109994](计算机系统基础.assets/image-20210531233109994.png)

21. 通过readelf查看.so文件的segment，可以看到，虚拟地址是从0开始的，表示最终的装载地址是不确定的。

    ```shell
    [zj@ZJ test]$ readelf -l add.so
    Elf 文件类型为 DYN (共享目标文件)
    Entry point 0x4c0
    There are 7 program headers, starting at offset 64
    程序头：
      Type           Offset             VirtAddr           PhysAddr
                     FileSiz            MemSiz              Flags  Align
      LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                     0x0000000000000624 0x0000000000000624  R E    0x200000
      LOAD           0x0000000000000e08 0x0000000000200e08 0x0000000000200e08
    ...
    ```

22. 静态链接时会进行重定位，动态链接的程序在运行的最开始，也会进行符号查找，重定位。一般会使用如下技术：

    1. PIC，位置无关代码，将指令中需要被修改的部分分离出来和数据部分放到一起。
    2. 延迟绑定，只有当函数被调用到时，才会链接，而不是运行的一开始就全部链接。因此启动速度也可以提高。

23. .dynamic节是和动态链接相关的。

    ```shell
    [zj@ZJ test]$ readelf -d main
    
    Dynamic section at offset 0xe00 contains 25 entries:
      标记        类型                         名称/值
     0x0000000000000001 (NEEDED)             共享库：[./add.so]
     0x0000000000000001 (NEEDED)             共享库：[libc.so.6]
     0x000000000000000c (INIT)               0x400518
     0x000000000000000d (FINI)               0x400728
     0x0000000000000019 (INIT_ARRAY)         0x600df0
     0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)
     ...
    ```

24. 该节是由如下结构体构成的：

    ```c
    typedef struct
    {
      Elf64_Sxword  d_tag;                  /* Dynamic entry type */
      union
        {
          Elf64_Xword d_val;                /* Integer value */
          Elf64_Addr d_ptr;                 /* Address value */
        } d_un;
    } Elf64_Dyn;
    ```

25. 可以使用readelf -sD 查看动态库的符号表。

    ```shell
    [zj@ZJ test]$ readelf -sD add.so
    
    Symbol table of `.gnu.hash' for image:
      Num Buc:    Value          Size   Type   Bind Vis      Ndx Name
        5   0: 0000000000201020     0 NOTYPE  GLOBAL DEFAULT  20 _edata
        6   0: 0000000000201028     0 NOTYPE  GLOBAL DEFAULT  21 _end
        7   1: 0000000000000579    20 FUNC    GLOBAL DEFAULT  11 add   #动态库导出的函数
        8   1: 0000000000201020     0 NOTYPE  GLOBAL DEFAULT  21 __bss_start
    ```

26. 动态链接的程序执行的步骤：

    1. 根据elf文件的动态.dynamic节，确定需要使用的动态库文件名。
    2. 将可执行文件的segment和上述文件映射到进程的虚拟空间。根据可执行文件中的重定位表去动态链接库的符号表中查找，对应的函数，变量的实际地址，进行修正。

27. 可以使用ldd命令查看程序所以来的动态链接库。

28. ```shell
    [zj@ZJ test]$ ldd main
            linux-vdso.so.1 (0x00007fff1d5f6000)   #库的名称是按照链接时指定的记录的。默认会在系统的lib目录下查找
            ./add.so (0x00007f1969bff000)
            libc.so.6 => /lib64/libc.so.6 (0x00007f196983c000)
            /lib64/ld-linux-x86-64.so.2 (0x00007f1969e01000)
    [zj@ZJ test]$ ldd /lib64/ld-linux-x86-64.so.2
            statically linked      #可以看到动态连接器文件是静态链接生成的，本身不依赖其他的动态库。特殊的是，该文件本身是可执行的。它是glibc的一部分
    ```

29. 自己编写的程序如果使用到自己的书写的共享库，最终生成可执行文件时，应该讲共享库拷贝到系统目录的lib下，再执行一遍链接，此时ldd中显示的依赖才变成系统目录中的库。这样发布给用户使用，也不会出问题。

30. 共享库的命名要符合规范例如  libadd.so库在gcc链接时，选项为-ladd

31. 操作系统在程序装载后，最开始执行的并不是main函数的第一行代码。而是运行库中的代码。它负责初始化运行环境，然后调用main函数。并且在main函数返回后，记录它的返回值，调用使用atexit注册过的函数，最后结束进程。

32. 以glibc为例，入口函数是由链接脚本所指定的，默认是_start。记录在elf文件头的入口点中。

56. 