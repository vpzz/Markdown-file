# 基础

1. 计算机系统是分层的，ISA（Instruction Set Architecture）是软硬件的交界面，是最重要的一层，规定了如下：
   1. 软件如何使用硬件，所有指令的集合。实际上也约束了硬件提供给软件的接口。
   2. 指令可以接受的操作数的类型。
   3. 寄存器的名称编号，用途。
   4. 存储空间的编址方式，大小端方式。
   5. 指令获取操作数的方式，即寻址方式。
   6. 指令执行过程中的控制方式，包括PC，条件码。
2. 常见的ISA有：IA-32（x86），MIPS，ARM。
3. 程序员分为应用程序员和系统程序员。
4. <img src="计算机系统基础.assets/image-20210407195254273.png" alt="image-20210407195254273" style="zoom:50%;" />
5. 程序执行的结果不仅仅取决于程序的编写，还取决于编译器，操作系统，指令集架构，微体系结构等。
6. 世界上第一台通用的电子计算机 ENIAC是1946年宾夕法尼亚大学研制的，电子真空管组成的，用于解决复杂的弹道问题，主要是做数值计算，用10进制表示信息并运算，通过手动设置开关来编程。
7. 冯诺依曼架构最重要的思想是存储程序的思想。程序一旦被启动，计算机就能够自动地取值执行。
8. 早期的计算机中，各部件是分散连接的，线路多尔复杂，现在大多使用总线方式。
9. 存储器能够存放数据和指令，形式上没有区别，但是计算机还是能够区分二者。
10. 指令=操作码+地址码，表示对那些数据做什么操作。
11. 运算器计算完成一次后，有时还会修改标志寄存器，控制器会读取标志寄存器，进而影响后续的计算。
12. 通用寄存器组 General Purpose Registers。从存储器中获取的指令存放在IR（指令寄存器），获取的数据放到寄存器。PC（程序计数器）记录着当前程序执行到的位置，也就是下一次取指令的位置。PC的不断自增，使得程序能够自动执行。
13. <img src="计算机系统基础.assets/image-20210407202539790.png" alt="image-20210407202539790" style="zoom: 50%;" />
14. 要从存储器中读取下一条指令时，先要将PC中的内容送到MAR。从存储器中读取到的指令或数据要先存放到MDR，如果是指令再转送到IR。
15. CPU=运算器+控制器。
16. 一条指令中，源操作数可能有一个，也可能有两个。源操作数可能是立即数，寄存器编号，存储地址。目的操作数可能是寄存器编号或存储地址。
17. 程序的历史：
    1. 使用机器语言，纸带打孔表示0，未打孔表示1，输入可以用按钮，开关，输出一般为信号灯。如果修改指令的位置，地址码需要重新计算，还要重新打孔。
    2. 汇编语言，面向动作描述。使用符号表示跳转位置和变量位置，这使得加减指令不用重新计算地址码。使用助记符表示操作码和寄存器，用标号表示位置。使用汇编器将汇编代码转化为机器代码，他会自动计算地址码。汇编指令是用助记符和标号表示的指令，它和机器指令一一对应。不同机器（CPU）上汇编指令的格式不同（机器代码就更不同了），因此不能移植。
    3. 高级语言，面向算法描述的，比机器语言描述能力强得多。分为编译和解释两种。
18. C语言源程序的编译过程：
19. ![image-20210518102947327](计算机系统基础.assets/image-20210518102947327.png)
20. 一个操作系统最少包含两部分：内核和人机接口。

# 整数

1. 在指令层面，没有结构化数据的概念，都是当做01序列来看待。
2. 机器级数据分为：
   1. 数值数据：无符号整数，有符号整数，浮点数。
   2. 非数值数据：逻辑数据（位串），文字和符号。    不能比较大小。
3. 真值和机器数，机器数是在计算机内部的01编码的数据，真值是现实生活中的数。例如真值unsigned short类型变量x的真值为127，其机器数为0000 0000 0111 1111。
4. 计算机内的浮点数的机器表示中是不记录浮点数的小数点的位置的，都是约定在第几位。正负号也是。
5. 没有类型的数据是不能判断真值是多少的。类型包括进位（2，8，16进制），定浮点（定点数还是浮点数），编码形式（原码，反码，补码）。
6. 二进制1.01B的十进制表示为$1\times 2^0+1\times 2^{-2}=1.25$。 后缀B表示该序列是二进制数。
7. 日常生活中使用十进制，计算机中使用二进制，引进八进制和十六进制的目的是为了书写和观察方便。
8. 公历起源于古罗马历法。古罗马历法原来只有10个月，罗马元首决定增加两个月放在年尾，后来朱里斯·凯撒大帝把这两个月移到年初，成为1月、2月，原来的1月、2月便成了3月、4月，依次类推。原来的八月就成了十月，但是历法改了，称呼仍然沿用未变。
9. 英语的十月October，来自拉丁文Octo，即“8”的意思，十月是历法改革前的8月。
10. 15 = 1111B = 17O = 017 = 0xF = FH    八进制一般是后缀O或前缀0，十六进制一般是后缀H或前缀0x。
11. <img src="计算机系统基础.assets/image-20210411141724346.png" alt="image-20210411141724346" style="zoom:67%;" />
12. 某些十进制数，在转化为二进制时，小数部分可能是无限的。例如$(0.63)_{10}=(0.50243\cdots)_8$。除R取余总是有尽头，但是乘R取整不一定。

# 定点数的表示

1. 小数点在计算机中是无法表示的，计算机中只能约定小数点的位置。小数点约定在固定位置的就是定点数，小数点位置可以浮动的就成为浮点数。

2. 定点数分为定点小数（用来表示浮点数的尾数）和定点整数（有符号整数和无符号整数）。

3. 任意实数都可以表示为：$X = (-1)^s\times M\times R^E$。s可以为0或1，是符号位。M是一个二进制的定点小数，称为X的尾数，有效数字。R是基数，现代计算机一般都是2。E是一个二进制定点整数，称为X的指数。在计算机内部任何实数都可以用一个符号位+定点小数+定点整数来表示。

4. 因此在计算机中解决数值的表示问题就首先要解决定点数的编码问题。

5. 定点数的表示方法：原码，补码，移码，反码（很少用了）。

6. 原码表示如下，缺点是0的表示不统一，加减运算不统一，需要额外对符号位进行处理。因此从50年代开始，整数都用补码表示，但是浮点数的尾数部分还是用原码定点小数表示（因为不用考虑符号位）。

7. <img src="计算机系统基础.assets/image-20210411143246889.png" alt="image-20210411143246889" style="zoom:50%;" />

8. 移码表示如下：将一个真值+一个偏置常数。当编码位数为n是，通常+$2^{n-1}$或$2^{n-1}-1$。例如：

   ```
   n=4时，E_baised = E+2^3。
   -8→-8+8 = 0000B
   0→0+8=1000B
   7→7+8=15=1111B。因此4位的偏置整数能够表示的个数是16个。
   ```

9. 移码表示中，0的表示是唯一的，当偏置常数为$2^{n-1}$时，移码和补码仅第一位不同。浮点数的指数部分通常用移码来表示。主要是方便浮点数之间加减时的对阶操作（比较大小）。如下，都是正数就好比较大小了。从高到低逐位比较大小即可。

10. ![image-20210411182047129](计算机系统基础.assets/image-20210411182047129.png)

11. 补码是模运算系统中的概念。模运算系统中，一个数和该数除以模后的余数是等价的。例如时钟是模12的系统，13点和1点是一样的。$13\equiv 1\mod 12$。同理13+12=25和1-12=-11都是模12同余的。因此称1是-11对模12的补码。

12. ![image-20210411182337409](计算机系统基础.assets/image-20210411182337409.png)

13. 模运算系统可以看成一个转盘。4位2进制数的最大值7再加1后，就得到4位2进制数的最小值-8。

14. 从上可知：

    1. 一个负数的补码等于模-该负数的绝对值。在模12系统中，-9的补码=12 - |-9|=3。模在模运算系统中，比任何数都大。实际上如果负数的补码还使用这种方式进行计算，仍然不能摆脱负数计算的问题，实际的负数补码的获得过程见下面的一条。
    2. 某数-小于模的另一个数=该数+另一个数的负数的补码，即可以用加法来代替减法，实现了加和减的统一。在模12系统中， 4-9 =4+（-9的补码）= 4+3=7。

15. 负数的补码不是算出来的，而是位操作得来的，它绝对值的所有位取补，然后加1。例如对于4位10进制数-1928来说，他的补码是1928的所有位取补再加1。10进制中，0的补位是9，1的补位是8。1928所有位取补的值为8071。再加1位8072。

16. 假设时钟只能顺拨，从10点倒拨4格后是几点，10-4相当于10+8=6（mod12）。时钟相当于是一个1位的12进制的数，只有从0-11。位内每一个数的补位都是事先规定好的，不用计算，例如1的补位是11，4的补位是7。

17. 例如对于4位十进制模运算系统（表示数的范围从0000-9999）中，计算9828-1928，使用第二条规则，原式=9828+（-1928的补码）。-1928的补码等于1928的按位补+1=8071+1=8072。因此原式=9828+8072=1 7900。而本运算系统最大只能记录4位，高位的进1被丢弃，因此原式=7900。

18. 一位半加器→一位全加器→串行进位加法器。低位发生进位会在高位+1。

19. 对于多位2进制的系统来说，求补码特别简单，因为其中的按位求补位就是电路状态改变为原来的相反状态即可，高→低，低→高。因此要实现加减混合运算，只要实现加法器和取反器即可。

20. <img src="计算机系统基础.assets/image-20210411190106558.png" alt="image-20210411190106558" style="zoom:50%;" />

21. 使用补码的好处还有，可以将正负数的机器数进行统一。

22. <img src="计算机系统基础.assets/image-20210411190422960.png" alt="image-20210411190422960" style="zoom:50%;" />

23. 在32位机器中，int占32位，short占16位，char占8位。

24. 普通的补码是无法保留最高位的溢出的，因此发明了变形补码，双符号位。8的变形补码为01000，第一个0表示符号位，第二个1表示数值部分溢出了。

25. <img src="计算机系统基础.assets/image-20210411192046938.png" alt="image-20210411192046938" style="zoom:50%;" />

26. 变形补码主要是用来保存中间结果，来防止最终的结果不溢出。

27. 求一个负数补码还有简便的方法，例如8位2进制数-123 = -01111011B，对于该数绝对值的补码从右向左先找到第一个1，然后该位左侧的所有位取反即可。即10000101B。

28. 根据补码序列来求它对应的真值：例如8位2进制数的补码为11010110B，则该数为$-2^7+2^6+2^4+2^2+2^1=-42$。

29. ![image-20210411193240323](计算机系统基础.assets/image-20210411193240323.png)

30. 指针变量存储的是内存地址，用无符号整数表示。

31. 机器中字的位序列排序有两种方式：例如一个32位字0 ...01011。一般来说计算机中都是LSB在最右边，MSB在最左边。这个排序方式实际上就规定了各位的权重方向。

32. ![image-20210411193903622](计算机系统基础.assets/image-20210411193903622.png)

33. C语言中，无符号数常量应该在末尾加上U或u，例如234u，不加u时，默认当做有符号数。如果无符号数和有符号数运算时，编译器会将有符号数转化为无符号数。例如2+3u等价于2u+3u=5u，运算结果也是无符号数。

34. 例子：

    1. 判断-1 <0u的结果，需要将-1看做无符号数，-1的补码表示为111...111，这个补码表示在无符号数中是最大的数，因此原表达式为false。使用cmp指令比较这两个数时是不分有符号和无符号的，但是跳转的时候要区分JB和JL。
    2. 判断2147483647U>-2147483647-1的结果，先计算>号右侧，结果是-2147483648，最小的有符号数，补码为10..00，按照无符号数来看待的话，是2147483648U，结果为false。
    3. 判断2147483647>(int)2147483648U的结果，右侧的无符号数补码表示为10...000U。再强制转化为int数据后，机器数并不会变，只是将其解读为有符号数，即-2147483648，因此结果为true。

35. ```assembly
         7: 	 char a = 255;
    008C1718 C6 45 FB FF          mov         byte ptr [a],0FFh  
         8: 	 char b = -1;     #可以看到内存中存储的都是一样的。这是编译器做到的，如果用汇编写程序，就需要程序员自己进行补码的转换。
    008C171C C6 45 EF FF          mov         byte ptr [b],0FFh  
         9: 	if (a < b)
    008C1720 0F BE 45 FB          movsx       eax,byte ptr [a]  
    008C1724 0F BE 4D EF          movsx       ecx,byte ptr [b]  
    008C1728 3B C1                cmp         eax,ecx  
    008C172A 7D 0D                jge         main+49h (08C1739h)  
    ```

36. 可以看出来同样的机器数，对应到不同的类型，真值不同。

37. 负数在机器中使用补码表示，这句话的意思不仅仅是指在内存中存储是这样的，连编译产生的中间结果也是补码。

38. ```c
    int x = -1;       //机器数为11...1111B,作为无符号数解释就是最大的32位无符号数，即2^32-1。作为有符号数解释就是-1。
    unsigned u = 2147483648;  //机器数为100.000B,
    // unsigned就是unsigned int
    printf("x = %u = %d",x,x); //%u就是将对应的变量的机器数当做10进制无符号整数来输出。
    //  x=4294967298=-1
    printf("u = %u = %d",u,u); //%d就是将对应的变量的机器数当做10进制有符号整数来输出。
    //  u=2147483648=-2147483648
    ```

39. 汇编代码如下，可以看到编译器会根据赋值的对象类型将字面量转化为机器数。

40. ![image-20210411203346304](计算机系统基础.assets/image-20210411203346304.png)

41. 根据变量的地址，找到了对应内存中的布局，可以看到是小端存储。

42. ![image-20210411203656416](计算机系统基础.assets/image-20210411203656416.png)

43. 可以看出不同的字面量，编译器都会解释为不同的类型，因此存储的格式也不同。例如

44. <img src="计算机系统基础.assets/image-20210411205133846.png" alt="image-20210411205133846" style="zoom:50%;" />

45. 表达式 -2147483648<2147483647在C90和C99下结果不一样：

    1. C90下，2147483648被当做unsigned int(long)类型，十六进制表示为0x80000000。因此该数的相反数为取反+1，还是0x80000000

46. 

47. 

48. ![image-20210411204811959](计算机系统基础.assets/image-20210411204811959.png)

49. ![image-20210411204944477](计算机系统基础.assets/image-20210411204944477.png)

# 浮点数

1. 
2. 
3. 
29. 

# ELF文件

1. 可以使用objdump来对ELF文件进行查看，可以对代码区域进行反汇编。

   ```shell
   objdump -d main  #对可执行的节进行反汇编   如果在gcc编译时加入了-g调试选项，可以在此加入-S，反汇编的同时显示源码。默认显示的是AT&T的汇编风格，可以使用-M intel来使用Intel汇编风格显示。-EB和-EL来指定文件时大端还是小端存放的。
   
   ```

2. ELF文件的分区和C语言程序的对应。局部变量是在运行时，动态在栈上生成的。全局和静态变量分为初始化的和未初始化的，已初始化的放在.data节中，未初始化的放在.bss节中。

3. ![image-20210529151356804](计算机系统基础.assets/image-20210529151356804.png)

4. 未初始化的全局变量和静态变量只会在符号表中存储一个common，这个和具体编译器实现有关。

5. 由于编译的时候是每个源文件独立编译，因此需要通过链接来处理各个模块之间的相互引用。例如在应用程序中使用到了标准库的printf函数，编译的时候并不知道该函数的入口地址，链接器在链接时，会根据引用到的符号printf去相应的模块中查找printf的地址。然后对源模块进行修正。

6. gcc链接时默认使用动态库，系统中默认是不安装有静态库的。运行以下命令来安装：

   ```shell
   yum --enablerepo=powertools install glibc-static
   ```

7. 动态库的后缀名为.so 意思是shared object。

8. 使用hexdump或od(默认是8进制)命令来查看二进制文件。不过一般都要配合head或tail来查看开始或默认的部分字节。head和tail默认是按照行来查看，而二进制文件中没有行的概念，所以应该按照字节来查看。

   ```shell
   [zj@ZJ lib64]$ head -c 100 libc-2.28.so |hexdump -C #查看开头的100个字节的二进制和ASCII对照。
   00000000  7f 45 4c 46 02 01 01 03  00 00 00 00 00 00 00 00  |.ELF............|
   00000010  03 00 3e 00 01 00 00 00  c0 38 02 00 00 00 00 00  |..>......8......|
   00000020  40 00 00 00 00 00 00 00  10 10 30 00 00 00 00 00  |@.........0.....|
   00000030  00 00 00 00 40 00 38 00  0c 00 40 00 4c 00 4b 00  |....@.8...@.L.K.|
   00000040  06 00 00 00 04 00 00 00  40 00 00 00 00 00 00 00  |........@.......|
   00000050  40 00 00 00 00 00 00 00  40 00 00 00 00 00 00 00  |@.......@.......|
   00000060  a0 02 00 00                                       |....|
   00000064
   ```

9. 使用--verbose选项，可以使GCC打印出具体调用的命令细节，collect2程序是对ld链接器的一个封装：

   ```shell
   [zj@ZJ test]$ gcc hello.o -o hello --verbose
   ...
    /usr/libexec/gcc/x86_64-redhat-linux/8/collect2 -plugin /usr/libexec/gcc/x86_64-redhat-linux/8/liblto_plugin.so -plugin-opt=/usr/libexec/gcc/x86_64-redhat-linux/8/lto-wrapper -plugin-opt=-fresolution=/tmp/ccRrSl6f.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --no-add-needed --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o hello /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crt1.o /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crti.o /usr/lib/gcc/x86_64-redhat-linux/8/crtbegin.o -L/usr/lib/gcc/x86_64-redhat-linux/8 -L/usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64 -L/lib/../lib64 -L/usr/lib/../lib64 -L/usr/lib/gcc/x86_64-redhat-linux/8/../../.. hello.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-redhat-linux/8/crtend.o /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crtn.o
   COLLECT_GCC_OPTIONS='-o' 'hello' '-v' '-mtune=generic' '-march=x86-64'
   ```

10. ELF文件Executable Linkage Format，可执行，可链接文件。使用file命令来查看文件的格式。包含以下4种：

   ```shell
   可执行文件              ELF 64-bit LSB executable
   目标文件(.o)            ELF 64-bit LSB relocatable
   动态链接库(.so)         ELF 64-bit LSB shared object
   核心转储文件 coredump   ELF 64-bit LSB core file
   ```

11. 例子：

    ```c
    #include <stdio.h>
    int g_init_var1 = 1;
    int g_uinit_var2 ;
    void foo(int i){
        printf("%d\n",i);
    }
    int main(void)
    {
        static int var3 = 2;
        static int var4;
        int x =3;
        foo(x);
        return 0;
    }
    ```

12. 使用objdump -h查看目标文件的节头。

    ```shell
    [zj@ZJ test]$ objdump -h main.o
    main.o：     文件格式 elf64-x86-64
    节：
    Idx Name          Size      VMA               LMA               File off  Algn
      0 .text         00000042  0000000000000000  0000000000000000  00000040  2**0
                      CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  #指令部分
      1 .data         00000008  0000000000000000  0000000000000000  00000084  2**2
                      CONTENTS, ALLOC, LOAD, DATA  #已经初始化的全局和静态变量。
      2 .bss          00000004  0000000000000000  0000000000000000  0000008c  2**2
                      ALLOC    #未初始化的全局和局部变量，会在程序运行的一开始初始化。
      3 .rodata       00000004  0000000000000000  0000000000000000  0000008c  2**0
                      CONTENTS, ALLOC, LOAD, READONLY, DATA # 只读数据，字符串和只读变量存储在这里。
      4 .comment      0000002d  0000000000000000  0000000000000000  00000090  2**0
                      CONTENTS, READONLY  #编译器写入的信息
      5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000bd  2**0
                      CONTENTS, READONLY
      6 .eh_frame     00000058  0000000000000000  0000000000000000  000000c0  2**3
                      CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
    ```

13. 使用objdump -d main.o查看.text节的反汇编：

    ```assembly
    [zj@ZJ test]$ objdump -d main.o
    main.o：     文件格式 elf64-x86-64
    Disassembly of section .text:
    0000000000000000 <foo>:
       0:   55                      push   %rbp
       1:   48 89 e5                mov    %rsp,%rbp
       4:   48 83 ec 10             sub    $0x10,%rsp
       8:   89 7d fc                mov    %edi,-0x4(%rbp)
       b:   8b 45 fc                mov    -0x4(%rbp),%eax
       e:   89 c6                   mov    %eax,%esi
      10:   bf 00 00 00 00          mov    $0x0,%edi
      15:   b8 00 00 00 00          mov    $0x0,%eax
      1a:   e8 00 00 00 00          callq  1f <foo+0x1f>
      1f:   90                      nop
      20:   c9                      leaveq
      21:   c3                      retq
    0000000000000022 <main>:
      22:   55                      push   %rbp
      23:   48 89 e5                mov    %rsp,%rbp
      26:   48 83 ec 10             sub    $0x10,%rsp
      2a:   c7 45 fc 03 00 00 00    movl   $0x3,-0x4(%rbp)
      31:   8b 45 fc                mov    -0x4(%rbp),%eax
      34:   89 c7                   mov    %eax,%edi
      36:   e8 00 00 00 00          callq  3b <main+0x19>
      3b:   b8 00 00 00 00          mov    $0x0,%eax
      40:   c9                      leaveq
      41:   c3                      retq
    ```

14. 使用objdump -s查看各节的内容，ELF文件中是：

    ```shell
    [zj@ZJ test]$ objdump -s main.o
    main.o：     文件格式 elf64-x86-64
    Contents of section .text: 
     0000 554889e5 4883ec10 897dfc8b 45fc89c6  UH..H....}..E...
     0010 bf000000 00b80000 0000e800 00000090  ................
     0020 c9c35548 89e54883 ec10c745 fc030000  ..UH..H....E....
     0030 008b45fc 89c7e800 000000b8 00000000  ..E.............
     0040 c9c3                                 ..
    Contents of section .data:   
     0000 01000000 02000000                    ........
    Contents of section .rodata:  
     0000 25640a00                             %d..
    Contents of section .comment:  
     0000 00474343 3a202847 4e552920 382e332e  .GCC: (GNU) 8.3.
     0010 31203230 31393131 32312028 52656420  1 20191121 (Red
     0020 48617420 382e332e 312d3529 00        Hat 8.3.1-5).
    Contents of section .eh_frame:
     0000 14000000 00000000 017a5200 01781001  .........zR..x..
     0010 1b0c0708 90010000 1c000000 1c000000  ................
     0020 00000000 22000000 00410e10 8602430d  ...."....A....C.
     0030 065d0c07 08000000 1c000000 3c000000  .]..........<...
     0040 00000000 20000000 00410e10 8602430d  .... ....A....C.
     0050 065b0c07 08000000                    .[......
    ```

15. ELF文件是按照section，segment来组织的。

    1. Segment是载入内存时需要用到的，每个segment是内存权限相同的。
    2. Section是链接器使用的，标识ELF的每一部分是什么。链接的时候，链接器会将不同ELF文件的相同部分合并，并修复相互的引用。

16. 相同权限的section会放入同一个segment，一个section也可以属于多个segment。后者一般是因为内存映射是按页进行的，粒度比较粗，当section比较小的时候可能会出现这种情况。

17. 可执行文件必须要有段表，可以没有节表。目标文件必须要有节表，可以没有段表。动态库两者都需要有，因为链接和执行的时候都会需要它。这是和他们的功能相关的。

18. program header又叫segment header。段头表和节头表中包含很多个段头和节头，他们分别记录了段和节的开始地址，大小，和内存映射到的虚拟地址。

19. ![image-20210530212630660](计算机系统基础.assets/image-20210530212630660.png)

20. 可以使用readelf -h 来查看ELF文件头的结构：

    ```shell
    [zj@ZJ test]$ readelf -h main
    ELF 头：
      Magic：  7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
      类别:                              ELF64
      数据:                              2 补码，小端序 (little endian)
      版本:                              1 (current)
      OS/ABI:                            UNIX - System V
      ABI 版本:                          0
      类型:                              EXEC (可执行文件)
      系统架构:                          Advanced Micro Devices X86-64
      版本:                              0x1
      入口点地址：              0x4004b0  #内存映像中入口点的虚拟地址
      程序头起点：              64 (bytes into file) #第一个段头的起始地址，相对于文件的最开始
      Start of section headers:          11000 (bytes into file)  #第一个节头的起始地址，相对于文件的最开始
      标志：             0x0
      本头的大小：       64 (字节)      #文件头的大小
      程序头大小：       56 (字节)      #每个段头的大小
      Number of program headers:         9   #段头的个数
      节头大小：         64 (字节)      #每个节头的大小
      节头数量：         30             #节头的个数
      字符串表索引节头： 29              #字符串表索引节头所在的下标
    ```

21. 可以使用readelf -l 来查看段表的结构，栈是不占用文件的大小的，内存虚拟地址也是不确定的，有内核加载的时候确定：

    ```shell
    [zj@ZJ test]$ readelf -l main
    Elf 文件类型为 EXEC (可执行文件)
    Entry point 0x4004b0
    There are 9 program headers, starting at offset 64
    程序头：
      Type           Offset             VirtAddr           PhysAddr
                     FileSiz            MemSiz              Flags  Align
      PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040
                     0x00000000000001f8 0x00000000000001f8  R      0x8
      INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238
                     0x000000000000001c 0x000000000000001c  R      0x1
          [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
      LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                     0x00000000000007c8 0x00000000000007c8  R E    0x200000
      LOAD           0x0000000000000e00 0x0000000000600e00 0x0000000000600e00
                     0x000000000000022c 0x0000000000000238  RW     0x200000
      DYNAMIC        0x0000000000000e10 0x0000000000600e10 0x0000000000600e10
                     0x00000000000001d0 0x00000000000001d0  RW     0x8
      NOTE           0x0000000000000254 0x0000000000400254 0x0000000000400254
                     0x0000000000000044 0x0000000000000044  R      0x4
      GNU_EH_FRAME   0x000000000000067c 0x000000000040067c 0x000000000040067c
                     0x0000000000000044 0x0000000000000044  R      0x4
      GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                     0x0000000000000000 0x0000000000000000  RW     0x10
      GNU_RELRO      0x0000000000000e00 0x0000000000600e00 0x0000000000600e00
                     0x0000000000000200 0x0000000000000200  R      0x1
     Section to Segment mapping:  #段和节的映射关系
      段节...
       00     
       01     .interp 
       02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame 
       03     .init_array .fini_array .dynamic .got .got.plt .data .bss 
       04     .dynamic 
       05     .note.ABI-tag .note.gnu.build-id 
       06     .eh_frame_hdr 
       07     
       08     .init_array .fini_array .dynamic .got 
    ```

22. 可以使用readelf -S 来查看ELF文件的节表：

    ```shell
    [zj@ZJ test]$ readelf -S main
    There are 30 section headers, starting at offset 0x2af8:
    节头：
      [号] 名称              类型             地址              偏移量
           大小              全体大小          旗标   链接   信息   对齐
      [ 0]                   NULL             0000000000000000  00000000
           0000000000000000  0000000000000000           0     0     0
      [ 1] .interp           PROGBITS         0000000000400238  00000238
           000000000000001c  0000000000000000   A       0     0     1
    ...
      [29] .shstrtab         STRTAB           0000000000000000  000029dd
           0000000000000119  0000000000000000           0     0     1
    Key to Flags:
      W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
      L (link order), O (extra OS processing required), G (group), T (TLS),
      C (compressed), x (unknown), o (OS specific), E (exclude),
      l (large), p (processor specific)
    ```

23. 文件到内存的映射关系，程序执行起来的时，可以通过/proc/进程PID/maps目录查看内存映射：

24. ![image-20210530215709443](计算机系统基础.assets/image-20210530215709443.png)

25. ELF头文件中使用到的数据类型，64位：

    ```c
    /* Type for a 16-bit quantity.  */
    typedef uint16_t Elf64_Half;
    /* Types for signed and unsigned 32-bit quantities.  */
    typedef uint32_t Elf64_Word;
    typedef	int32_t  Elf64_Sword;
    /* Types for signed and unsigned 64-bit quantities.  */
    typedef uint64_t Elf64_Xword;
    typedef	int64_t  Elf64_Sxword;
    /* Type of addresses.  */
    typedef uint64_t Elf64_Addr;
    /* Type of file offsets.  */
    typedef uint64_t Elf64_Off;
    /* Type for section indices, which are 16-bit quantities.  */
    typedef uint16_t Elf64_Section;         //因此最多65536个节
    /* Type for version symbol information.  */
    typedef Elf64_Half Elf64_Versym;
    ```

26. ELF文件头结构体，64位时为64字节。记录里节和段的信息。

27. ```c
    typedef struct
    {
      unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */16个字节的魔数
      Elf64_Half	e_type;			/* Object file type */ 目标文件的类型，
      Elf64_Half	e_machine;		/* Architecture */
      Elf64_Word	e_version;		/* Object file version */
      Elf64_Addr	e_entry;		/* Entry point virtual address */ 入口点的虚拟地址
      Elf64_Off	e_phoff;		/* Program header table file offset */ 段头表的偏移地址，如果是0，则表示没有段头表
      Elf64_Off	e_shoff;		/* Section header table file offset */ 节头表的偏移地址
      Elf64_Word	e_flags;		/* Processor-specific flags */
      Elf64_Half	e_ehsize;		/* ELF header size in bytes */ 文件头的大小
      Elf64_Half	e_phentsize;		/* Program header table entry size */ 段头表每个条目的大小。
      Elf64_Half	e_phnum;		/* Program header table entry count */段头表的条目数量
      Elf64_Half	e_shentsize;		/* Section header table entry size */节头表每个条目的大小。
      Elf64_Half	e_shnum;		/* Section header table entry count */节头表的条目数量
      Elf64_Half	e_shstrndx;		/* Section header string table index */字符串表索引节头在节头表中的下标。
    } Elf64_Ehdr;
    ```

28. 16个字节的魔数：

29. 段头表中的每一项，一般为56字节：

31. ```c
    typedef struct
    {
      Elf64_Word	p_type;			/* Segment type */
      Elf64_Word	p_flags;		/* Segment flags */
      Elf64_Off	p_offset;		/* Segment file offset */  段在ELF文件中的偏移
      Elf64_Addr	p_vaddr;		/* Segment virtual address */  段在内存中的虚拟地址
      Elf64_Addr	p_paddr;		/* Segment physical address */
      Elf64_Xword	p_filesz;		/* Segment size in file */  段在文件中的大小
      Elf64_Xword	p_memsz;		/* Segment size in memory */  段在内存中的大小。
      Elf64_Xword	p_align;		/* Segment alignment */
    } Elf64_Phdr;
    ```

32. 节头表中的每一项，一般为64字节，出现在每一节的最开始，文件的不同节不重叠，文件中可能存在一些字节，不属于文件头部和任何节：

    ```c
    typedef struct
    {
      Elf64_Word	sh_name;		/* Section name (string tbl index) */当前节的名称，实际上是一个在节头字符串表的偏移地址，字符串以'\0'结尾。
      Elf64_Word	sh_type;		/* Section type */
      Elf64_Xword	sh_flags;		/* Section flags */标识当前节的属性。
      Elf64_Addr	sh_addr;		/* Section virtual addr at execution */
      Elf64_Off	sh_offset;		/* Section file offset */
      Elf64_Xword	sh_size;		/* Section size in bytes */
      Elf64_Word	sh_link;		/* Link to another section */
      Elf64_Word	sh_info;		/* Additional section information */
      Elf64_Xword	sh_addralign;		/* Section alignment */
      Elf64_Xword	sh_entsize;		/* Entry size if section holds table */
    } Elf64_Shdr;
    ```

33. sh_type：

34. 

35. sh_flags：

    1. SHF_WRITE，是否可以写入数据。
    2. SHF_ALLOC，是否占用内存（某些节只起到控制作用，并不出现在进程的内存映像中）。
    3. SHF_EXECINSTR，是否包含机器指令。

36. ```assembly
    文件头，可以发现节头表的偏移地址为0x2AF8，一共有0x1E个节，每个大小为0x40，字符串索引表节头是第1D个。
    一共有9个段，每个段头的大小为0x38，程序的入口点的虚拟地址为0x4004B0
    00000000: 7F 45 4C 46 02 01 01 00 00 00 00 00 00 00 00 00    .ELF............
    00000010: 02 00 3E 00 01 00 00 00 B0 04 40 00 00 00 00 00    ..>.....0.@.....
    00000020: 40 00 00 00 00 00 00 00 F8 2A 00 00 00 00 00 00    @.......x*......
    00000030: 00 00 00 00 40 00 38 00 09 00 40 00 1E 00 1D 00    ....@.8...@.....
    
    第13个节头表，首地址为0x2AF8+13*64=0x2E38，当前节的名称为0x29DD+0x94=0x2A71查询最下面的表，可以看到是.text  当前节的起始地址为0x4B0。该节在内存中的地址为0x4004B0，和文件头中的属性对应上，因此当前节就是程序的入口点。
    00002e30: -- -- -- -- -- -- -- -- 94 00 00 00 01 00 00 00    ................
    00002e40: 06 00 00 00 00 00 00 00 B0 04 40 00 00 00 00 00    ........0.@.....
    00002e50: B0 04 00 00 00 00 00 00 A5 01 00 00 00 00 00 00    0.......%.......
    00002e60: 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00 00    ................
    00002e70: 00 00 00 00 00 00 00 00 -- -- -- -- -- -- -- --    ................
    
    字符串索引表节头，第29个首地址为0x2AF8+29*64=0x3238,节的起始地址为0x29DD。当前节的名称为0x29DD+0x11=0x29EE查询最下面的表，可以看到是.shstrtab
    00003230: -- -- -- -- -- -- -- -- 11 00 00 00 03 00 00 00    ................
    00003240: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    00003250: DD 29 00 00 00 00 00 00 19 01 00 00 00 00 00 00    ])..............
    00003260: 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00    ................
    00003270: 00 00 00 00 00 00 00 00                            ........
    
    字符串索引表
    000029d0: -- -- -- -- -- -- -- -- -- -- -- -- -- 00 2E 73    g_uinit_var2...s
    000029e0: 79 6D 74 61 62 00 2E 73 74 72 74 61 62 00 2E 73    ymtab..strtab..s
    000029f0: 68 73 74 72 74 61 62 00 2E 69 6E 74 65 72 70 00    hstrtab..interp.
    ...
    00002a70: 00 2E 74 65 78 74 00 2E 66 69 6E 69 00 2E 72 6F    ..text..fini..ro
    
    .text节的内容
    000004b0: F3 0F 1E FA 31 ED 49 89 D1 5E 48 89 E2 48 83 E4    s..z1mI.Q^H.bH.d
    000004c0: F0 50 54 49 C7 C0 50 06 40 00 48 C7 C1 E0 05 40    pPTIG@P.@.HGA`.@
    000004d0: 00 48 C7 C7 B8 05 40 00 FF 15 0A 0B 20 00 F4 90    .HGG8.@.......t.
    ```

37. 通过对.text节进行反汇编得到如下：

38. ```assembly
    Disassembly of section .text:
    00000000004004b0 <_start>:
      4004b0:       f3 0f 1e fa             endbr64 
      4004b4:       31 ed                   xor    %ebp,%ebp
      4004b6:       49 89 d1                mov    %rdx,%r9
      4004b9:       5e                      pop    %rsi
      4004ba:       48 89 e2                mov    %rsp,%rdx
      4004bd:       48 83 e4 f0             and    $0xfffffffffffffff0,%rsp
      4004c1:       50                      push   %rax
      4004c2:       54                      push   %rsp
      4004c3:       49 c7 c0 50 06 40 00    mov    $0x400650,%r8
      4004ca:       48 c7 c1 e0 05 40 00    mov    $0x4005e0,%rcx
      4004d1:       48 c7 c7 b8 05 40 00    mov    $0x4005b8,%rdi
      4004d8:       ff 15 0a 0b 20 00       callq  *0x200b0a(%rip)        # 600fe8 <__libc_start_main@GLIBC_2.2.5>
      4004de:       f4                      hlt   
    ```

39. 可以使用readelf -p 节名 elf文件名   来以字符串的方式查看elf文件的某一节。

    ```shell
    [zj@ZJ test]$ readelf -p .shstrtab main.o
    String dump of section '.shstrtab':      #节名一般在这里存储
      [     1]  .symtab
      [     9]  .strtab
      [    11]  .shstrtab
      [    1b]  .rela.text
      [    26]  .data
      [    2c]  .bss
      [    31]  .rodata
      [    39]  .comment
      [    42]  .note.GNU-stack
      [    52]  .rela.eh_frame
    
    [zj@ZJ test]$ readelf -p .strtab main.o
    String dump of section '.strtab':   #符号名一般在这里处处。
      [     1]  main.c   #源文件名
      [     8]  var4.2367  #局部变量被重命名了
      [    12]  var3.2366  #局部变量
      [    1c]  g_init_var1  #全局变量var1被重命名了
      [    28]  g_uinit_var2   #全局变量var2
      [    35]  foo  #函数名
      [    39]  printf  #标准库中的函数
      [    40]  main  #函数名
    ```

# 链接

1. 编译器为了防止标识符重名的情况，会在编译时进行重命名。

2. 可以通过readelf -s 来查看elf文件的符号表，符号表是在重定位时会用到：

   ```shell
   readelf -s main.o
   Symbol table '.symtab' contains 16 entries:
      Num:    Value          Size Type    Bind   Vis      Ndx Name
        0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
        1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c
        2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1
        3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3
        4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
        5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
        6: 0000000000000000     4 OBJECT  LOCAL  DEFAULT    4 var4.2367
        7: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 var3.2366
        8: 0000000000000000     0 SECTION LOCAL  DEFAULT    7
        9: 0000000000000000     0 SECTION LOCAL  DEFAULT    8
       10: 0000000000000000     0 SECTION LOCAL  DEFAULT    6
       11: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 g_init_var1
       12: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM g_uinit_var2  #未初始化的全局变量，存在于.bss段中。
       13: 0000000000000000    34 FUNC    GLOBAL DEFAULT    1 foo
       14: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf  #链接前不知道该标号是什么类型和节号，Ndx是当前符号所在的节
       15: 0000000000000022    32 FUNC    GLOBAL DEFAULT    1 main
   
   ```

3. 符号section内存储的是一个一个的符号结构体：

   ```c
   typedef struct
   {
       Elf64_Word    st_name;                /* Symbol name (string tbl index) */ .strtab节的偏移
       unsigned char st_info;                /* Symbol type and binding */
       unsigned char st_other;               /* Symbol visibility */
       Elf64_Section st_shndx;               /* Section index */  所属的节
       Elf64_Addr    st_value;               /* Symbol value */
       Elf64_Xword   st_size;                /* Symbol size */
   } Elf64_Sym;
   ```

4. 未链接的目标文件的结构图，==使用内存映射mmap来分析elf文件==。ELF中的节头表不一定是在文件的末尾。readelf中显示的节的顺序不一定和文件存储的相同。

5. 实际上exec命令就是将可执行文件映射到内存中，和mmap的操作类似。

6. ELF头64个字节，.text段从0x40开始，大小为41个字节，他后面的.data节是从0x84开始的，这是因为该节的对齐是4字节。即节的起始地址要是4个倍数。

7. ![image-20210531195643672](计算机系统基础.assets/image-20210531195643672.png)

8. 静态链接的过程：

   1. 先将不同目标文件的相同的节进行合并。
   2. 根据符号表，搜索，重定位。

9. 使用readel -r 或objdump -r可以查看重定位信息：

   ```shell
   [zj@ZJ test]$ readelf -r main.o
   重定位节 '.rela.text' at offset 0x2e0 contains 3 entries:
     偏移量          信息           类型           符号值        符号名称 + 加数
   000000000011  00050000000a R_X86_64_32       0000000000000000 .rodata + 0
   00000000001b  000e00000002 R_X86_64_PC32     0000000000000000 printf - 4
   000000000037  000d00000002 R_X86_64_PC32     0000000000000000 foo - 4
   重定位节 '.rela.eh_frame' at offset 0x328 contains 2 entries:
     偏移量          信息           类型           符号值        符号名称 + 加数
   000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0
   000000000040  000200000002 R_X86_64_PC32     0000000000000000 .text + 22
   
   [zj@ZJ test]$ objdump -r main.o
   main.o：     文件格式 elf64-x86-64
   RELOCATION RECORDS FOR [.text]:
   OFFSET           TYPE              VALUE
   0000000000000011 R_X86_64_32       .rodata
   000000000000001b R_X86_64_PC32     printf-0x0000000000000004
   0000000000000037 R_X86_64_PC32     foo-0x0000000000000004
   RELOCATION RECORDS FOR [.eh_frame]:
   OFFSET           TYPE              VALUE
   0000000000000020 R_X86_64_PC32     .text
   0000000000000040 R_X86_64_PC32     .text+0x0000000000000022
   ```

10. ld --verbose查看默认的链接脚本。在嵌入式开发中，有时需要对链接进行精确控制，此时可以自己书写链接脚本。

11. 可以看到编译前，main函数中调用函数的call指令，其指令的操作数部分都是0，需要搜索符号表确定被调函数的地址。

12. <img src="计算机系统基础.assets/image-20210531200353935.png" alt="image-20210531200353935" style="zoom:67%;" />

13. 可执行文件的装载过程：

    1. 操作系统给进程分配资源，开辟虚拟地址空间。
    2. 建立可执行文件到进程虚拟地址空间的映射。
    3. 将IP设置为程序入口点，开始执行。

14. 映射是按照segment来的，section的组织对顺序没有要求，而同一个segment中的section的内存操作权限是相同。因此section的组织是配合segment来的。

15. 可以再/proc/进程ID/maps文件下面看到进程的虚拟地址映射关系：

    1. 第1列为虚拟内存的起始和终止地址
    2. 第2列为内存的权限，前三个个读写执行，最后一个为共享或私有。
    3. 第3列为映射在文件中的偏移量。
    4. 第4列为映像文件的主次设备号
    5. 第5列为映像文件的iNode号
    6. 第6列为映像文件的路径

16. ![image-20210531203113792](计算机系统基础.assets/image-20210531203113792.png)

17. 可执行文件的装载器在进程开始执行前，会将argc和argv会有放入到进程的栈中。

18. 生成动态库：

    ```shell
    gcc -fPIC -shared -o hello.o hello.c   #-shared 生成共享对象，即.so的动态库。 -fPIC 生成位置无关代码
    gcc -o main main.c ./hello.so  #根据文件的路径使用动态库。
    ```

19. 使用动态库的进程地址空间。ld-2.12.so是动态链接器。操作系统会先将控制权交给动态链接器，进行链接，完成后再将控制权交给程序本身。动态连接器是在elf文件中指定的。

20. ![image-20210531233109994](计算机系统基础.assets/image-20210531233109994.png)

21. 通过readelf查看.so文件的segment，可以看到，虚拟地址是从0开始的，表示最终的装载地址是不确定的。

    ```shell
    [zj@ZJ test]$ readelf -l add.so
    Elf 文件类型为 DYN (共享目标文件)
    Entry point 0x4c0
    There are 7 program headers, starting at offset 64
    程序头：
      Type           Offset             VirtAddr           PhysAddr
                     FileSiz            MemSiz              Flags  Align
      LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                     0x0000000000000624 0x0000000000000624  R E    0x200000
      LOAD           0x0000000000000e08 0x0000000000200e08 0x0000000000200e08
    ...
    ```

22. 静态链接时会进行重定位，动态链接的程序在运行的最开始，也会进行符号查找，重定位。一般会使用如下技术：

    1. PIC，位置无关代码，将指令中需要被修改的部分分离出来和数据部分放到一起。
    2. 延迟绑定，只有当函数被调用到时，才会链接，而不是运行的一开始就全部链接。因此启动速度也可以提高。

23. .dynamic节是和动态链接相关的。

    ```shell
    [zj@ZJ test]$ readelf -d main
    
    Dynamic section at offset 0xe00 contains 25 entries:
      标记        类型                         名称/值
     0x0000000000000001 (NEEDED)             共享库：[./add.so]
     0x0000000000000001 (NEEDED)             共享库：[libc.so.6]
     0x000000000000000c (INIT)               0x400518
     0x000000000000000d (FINI)               0x400728
     0x0000000000000019 (INIT_ARRAY)         0x600df0
     0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)
     ...
    ```

24. 该节是由如下结构体构成的：

    ```c
    typedef struct
    {
      Elf64_Sxword  d_tag;                  /* Dynamic entry type */
      union
        {
          Elf64_Xword d_val;                /* Integer value */
          Elf64_Addr d_ptr;                 /* Address value */
        } d_un;
    } Elf64_Dyn;
    ```

25. 可以使用readelf -sD 查看动态库的符号表。

    ```shell
    [zj@ZJ test]$ readelf -sD add.so
    
    Symbol table of `.gnu.hash' for image:
      Num Buc:    Value          Size   Type   Bind Vis      Ndx Name
        5   0: 0000000000201020     0 NOTYPE  GLOBAL DEFAULT  20 _edata
        6   0: 0000000000201028     0 NOTYPE  GLOBAL DEFAULT  21 _end
        7   1: 0000000000000579    20 FUNC    GLOBAL DEFAULT  11 add   #动态库导出的函数
        8   1: 0000000000201020     0 NOTYPE  GLOBAL DEFAULT  21 __bss_start
    ```

26. 动态链接的程序执行的步骤：

    1. 根据elf文件的动态.dynamic节，确定需要使用的动态库文件名。
    2. 将可执行文件的segment和上述文件映射到进程的虚拟空间。根据可执行文件中的重定位表去动态链接库的符号表中查找，对应的函数，变量的实际地址，进行修正。

27. 可以使用ldd命令查看程序所以来的动态链接库。

28. ```shell
    [zj@ZJ test]$ ldd main
            linux-vdso.so.1 (0x00007fff1d5f6000)   #库的名称是按照链接时指定的记录的。默认会在系统的lib目录下查找
            ./add.so (0x00007f1969bff000)
            libc.so.6 => /lib64/libc.so.6 (0x00007f196983c000)
            /lib64/ld-linux-x86-64.so.2 (0x00007f1969e01000)
    [zj@ZJ test]$ ldd /lib64/ld-linux-x86-64.so.2
            statically linked      #可以看到动态连接器文件是静态链接生成的，本身不依赖其他的动态库。特殊的是，该文件本身是可执行的。它是glibc的一部分
    ```

29. 自己编写的程序如果使用到自己的书写的共享库，最终生成可执行文件时，应该讲共享库拷贝到系统目录的lib下，再执行一遍链接，此时ldd中显示的依赖才变成系统目录中的库。这样发布给用户使用，也不会出问题。

30. 共享库的命名要符合规范例如  libadd.so库在gcc链接时，选项为-ladd

31. 操作系统在程序装载后，最开始执行的并不是main函数的第一行代码。而是运行库中的代码。它负责初始化运行环境，然后调用main函数。并且在main函数返回后，记录它的返回值，调用使用atexit注册过的函数，最后结束进程。

32. 以glibc为例，入口函数是由链接脚本所指定的，默认是_start。记录在elf文件头的入口点中。

56. 