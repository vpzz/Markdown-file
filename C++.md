# 基础

1. 1972年，C语言出现。1983年C++出现，AT&T的Bjarne Stroustrup，早期称为==C with Class==。

2. 第一个国际标准的是C++98（1.0），后续有C++03（小版本 TR1，Technical Report 1），C++11（大版本 2.0），C++14（小版本）。大部分使用的是C++98。C++98最重要的改进就是引入了STL。

3. C++除了语言本身还包括标准库，C也有标准库。使用标准库可以让大家更容易交流。标准库主要是使用模板，为了可以处理各种各样的对象，和面向对象的关系不大，虚函数使用很少。

4. 《C++Primer》的作者Stanley B. Lippman写出了C++第一个编译器。

5. 推荐书籍

   1. 《Effective C++》
   2. 《The C++ Standard Library》
   3. 《STL源码剖析》
   4. 《深度探索C++对象模型》

6. STL是标准库的前身，标准库中有七八成都是来自STL（Standard Template Library）。

7. C语言中，数据是公用的，任何函数都可以处理它。C++将数据和处理他的函数打包在一起。不过数据每个对象都有一份，函数是共有的，函数是通过this指针来知道要处理哪个对象的数据。

8. 根据类的成员中是否含有指针变量可以将类分为两类：

   1. complex，有两个double(或int)成员，分别表示实部和虚部。这种类大部分不用自定义拷贝控制成员。
   2. string，有一个指针成员变量，字符串存储在堆中开辟的内存。

9. ==基于对象== object based：单一的class。

10. ==面向对象== object oriented：多个class之间有关系。

11. include标准库文件，用< >包括起来，标准库文件在安装编译器时获得，编译器会自动寻找，因此只用给出文件名即可，不用路径。include非标准库文件，就需要用" "括起来，这个路径可以用相对或绝对路径。

12. __cplusplus宏表明了编译器当前支持的C++版本，对于C++98和03，该宏为199711L，对于C++11，该宏伟201103L。

13. C++和C对待void\*的态度不同，C语言中void\*可以默认地转化为任意指针类型，而C++中则不可以，必须要强制类型转换。这是因为C++中根据参数类型来严格匹配函数的重载。

    ```c++
    int* p = malloc(10);   //C++会报错。 需要 int* p = (int*)malloc(10);
    p[0] = 6;
    printf("%d", p[0]);
    
    void foo(int*);
    void foo(char*);
    foo(malloc(10));  //由于不会进行默认的隐式类型转换，因此这里会报错，找不到对应的函数。要想正确使用，必须进行强制类型转换。
    ```
    
14. 设计一个类，应该做到以下几点：

    1. 成员变量是否都在private内。
    2. 构造函数是否使用了初始化列表来初始化成员变量。
    3. 不修改对象的成员函数是否用了const进行修饰。
    4. 参数和返回值是否尽量使用引用传递，是否尽量使用了const。

15. cpplint是Google开发的一个用来检查C++代码是否符合Google代码风格的Python脚本。

16. string和vector是最重要的两种标准库类型，前者支持可变长的字符串，后者支持可变长的序列。他们都是对内置数组的抽象，更方便使用。

23. 在实践中，不必全面地使用C++的全部特性，而是根据工程项目的实际情况，使用它的一个子集。相关取舍，可以参考Google发布的C++ Style Guide。


# 开始

1. 函数的定义包含4个部分：返回类型，函数名，一个括号包围的参数列表（允许为空）以及函数体。

2. main函数的返回类型必须为int，它是内置类型，即语言自身定义的。

3. 函数体是一个由`{ }`包括的语句块。

4. 当return语句包括一个值时，则它的类型必须与函数的返回类型相容。return末尾的分号不能省略。

5. 通常，main函数的通过返回0表示成功，非0表示失败，具体错误由系统定义。通过如下命令访问：

   ```shell
   echo $?  #Unix
   echo %ERRORLEVEL%  #Windows
   ```

6. 一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算。

7. 程序处理的数据都保存在变量中，每个变量都有自己的类型。

8. 不同的编译器使用不同的源文件后缀约定，最常见的有：`.cc .cxx .cpp .cp .C`。头文件的后缀名常见的有.H .hpp .hxx等。

9. 标准库的头文件通常不带后缀，编译器一般不关心头文件名的形式，但是一些IDE对此有要求

10. 在Windows的命令行执行程序时，可以忽略.exe后缀。Unix中可执行文件不需要有特定的后缀名。

11. VS和GNU工具链的对应：

    ```shell
    g++       cl   #c++编译器
    -Wall     /W4  #开启所有警告
    ```

12. 每个使用标准库设施的程序都必须包含相关的头文件，#include和头文件的名字必须写在同一行。通常情况下，#include指令必须出现在所有函数之外。一般将一个程序的所有#include指令都放在源文件的开头。

17. #include后面可以有两种形式给出头文件，`" "`和`< >`。编译器对于这两种形式给出的文件名会在不同的目录下以不同的顺序搜寻。

21. 字符串字面值常量（string literal）是由一对双引号包围起来的字符序列，例如`"abc"`。

22. std::endl是一个操作符，写入它的效果是结束当前行，并将与设备关联的缓冲区（buffer）中的内容刷到（flush）设备中。这样可以保证之前的写入不只是停留在内存中。

23. 前缀std::指明了cout和endl是定义在std命名空间中的。标准库的所有名字都是定义在std中的。

25. ::是作用域运算符，使用命名空间中的名字时，必须要使用该运算符。

26. 使用命名空间可以避免不经意的名字定义冲突，以及使用不同库中相同名字时导致的冲突。

27. 初始化一个变量就是在变量定义的同时为它赋值，例如`int a=3;`。

28. 错误的注释比完全没有注释更糟糕，因为会误导读者。因此当修改代码时，也应该修改注释。C++有两种注释：

    1. 单行注释，以//开始，以换行符结束，可以包含任何文本，包括额外的双斜线，除了换行符。

    2. 界定符注释，继承自C语言，以`/*`开始，以`*/`结束。可以包含除了`*/`以外的任何内容，包括换行符。这种注释可以跨越多行，为了更清晰地表示中间行都是注释，可以在中间行的开头加上`*`，一般会让`*`对齐。

       ```c++
       /*注释
        *第一行
        *第二行
        */
       ```

29. 界定符注释可以放置在任何允许放置制表符，空格，换行的地方。

30. 界定符注释不能嵌套，编译器对这种错误给出的信息可能是令人迷惑的。因此如果要注释多行代码，建议用多个单行注释。

31. while语句的形式：

    ```c++
    while (condition)  //首先检测condition条件，当它为真时，执行statement，然后再检查，如此往复。直到条件为假，此时直接退出循环。
        statement      //
    ```

32. 语句块就是用花括号包围的零或多条语句的序列。语句块也是语句的一种，在任何要求使用语句的地方都可以使用语句块。因此当while的语句只有一条时，可以省略语句块的{}。

33. +=是复合赋值运算符，本质是一个加法和赋值的结合。

34. for语句可以看作是一种特殊的while语句，将while循环体内对变量的检测和修改放到了for语句的循环头中。

35. for语句分为循环头和循环体，循环头由3个部分组成，一个初始化语句，一个循环条件，一个表达式。

36. 初始化语句只在入口时执行一次，每次执行循环体之前都会先检查循环条件是否满足。表达式在循环体后执行。执行完表达式后，会检查循环条件。

37. 循环，分支语句头中定义的变量只在其内部有效，例如：

    ```c++
    for (int j = 0; j < 3; j++) { //在第一个分号之后就可以访问到j了。
    	std::cout << j << std::endl;  
    }
    std::cout << j;  //会报错这里访问不到j。
    ```

30. 编译器只能检查形式上的错误，而不能检查出逻辑上的错误。常见的编译器错误有：

    1. 语法错误，syntax，例如括号不匹配，少了分号等。

    2. 类型错误，type，实参和形参类型不相容，赋值等号两侧类型不相容等。

    3. 声明错误，declaration，名字没有先声明就使用了。标准库的名字没有加std::，名字拼写错误。

42. 一个好的习惯是从前往后看错误提示，修改一个就编译一下。

43. =和==都可以出现在条件中，注意区分。

44. C++程序是自由格式free form的，例如函数体的左花括号可以放在上一行末尾，也可以放在下一行开头。不过左花括号必须是形参列表后第一个非空，非注释的字符。

45. 不存在唯一正确的风格，但是保持一致的风格很重要。

46. 一个类（class）定义了一个类型（type，类型名就是类名）以及与其关联的一组操作。C++的设计初衷就是能定义使用上像内置类型一样自然的类类型（class type）。

47. 为了使用一个类，需要知道类名是什么，在哪里定义的，它支持什么操作。

48. 成员函数（member function）是定义为类的一部分的函数，有时也成为方法（method）。

49. 点运算符只能用于类类型的对象，右侧是该类型一个成员名，结果为对应的成员。

50. 对于成员函数，使用点运算符获取之后，可以手机用调用运算符`()`来调用它。


# 类型

## 基本类型

1. C++是静态数据类型语言，类型检查发生在编译时，因此编译器必须知道每个变量对应的数据类型，从而为其分配内存。
2. C++自带的基本数据类型分为算术类型和空类型（void）。
   1. 算术类型包括整型（包括字符和布尔类型），浮点型。算术类型的尺寸在不同的机器上不同，标准只规定了最小尺寸，允许编译器用更大的尺寸进行实现。
   2. 空类型不对应任何具体的值，仅用于一些特殊的场合，例如函数的返回值如果是void类型，则表明函数不返回任何值。
3. 算术类型有：bool、char、wchat_t、char16_t、char32_t、shrot、int、long、long long、float、double、long double。
4. 布尔类型的取值为true或false。
5. C++提供了四种字符类型，基本的是char，一个char的空间应确保可以放下机器的基本字符集的任意一个字符对应的数字值，也就是和一个机器字节相同。wchar_t确保可以放下机器最大扩展字符集的任意一个字符。char16_t和char32_t为Unicode字符集服务。后三种是扩展的字符类型，都是无符号的。
6. C++标准规定，int至少和short一样大，long至少和int一样大，long long至少和long一样大。long long是C++11新定义的。
7. 内存中是比特序列，可寻址的最小内存块称为字节byte（通常由8个比特组成），存储的基本单元称为字word，通常由几个字节组成。
8. 通过内存地址只能索引到内存中的具体字节，无法直到是否包括其前后的多个字节。因此只有内存地址是不够的，还需要知道类型，从而知道一共有多少个字节，如何解析这些数据。
9. long double称为扩展精度。C++为每个类型指定了有效数字的下限（精度）。通常来说，编译器会将float实现为32位的，具有7个有效数字。double为64位的，具有16个有效数字。而long double则为96或128位，有效数字不定，常被用于由特殊浮点需求的硬件。标准规定long double的精度不低于double。
10. unsigned int可以缩写为unsigned。
11. 字符型被分为了三种：char、signed char、unsigned char。但是实际表现却只有2种，类型char会表现为后两种中的一种，具体由编译器决定。
12. 无符号类型中的所有比特都用来存储值，例如8比特的unsigned char可以表示从0到255内的所有整数。
13. C++标准并没有规定带符号类型应该如何存储，但是约定了表示范围内的正数和负数的量应该平衡。因此8bit的带符号整型理论上应该为-127→+127。不过实际实现为-128→+127。
14. 类型选用建议：
    1. 当明确直到数值不可能为负时，选用无符号类型。

    2. 优先使用int进行整型运算，因为short太小，而long一般又和int一样大。如果数值超过了int的范围，可以使用long long。

    3. 不要使用char和bool类型数据进行算术运算，只是在存放字符或布尔值时才是用他们。因为char在不同机器上可能被解释为带符号或无符号的。这会影响跟他一起进行算术运算的其他数据。如果需要一个不大的整数，应明确说明char是否带符号。

    4. 执行浮点运算优先选用double，因为float的精度往往不够，而且执行单精度和双精度浮点运算的性能消耗几乎一样。对于某些机器来说，double甚至还更快。long double提供的精度一般是用不到的，其增加的消耗却不可忽视。

15. 类类型变量如果未指定初值，则按照类定义的方式进行初始化。==未归属==

## 字面值常量

### 整型和浮点型

1. 一个形如42的值被称为字面值常量（literal）。每个字面值常量都对应一种数据类型，他的形式和值决定了其数据类型。

2. 可以将整型字面值写成10、2（以0b或0B开头）、8（以0开头）、16（以0x或0X开头）进制等形式。

3. 2进制整数字面值是在C++14中引入的。

4. 默认情况下，十进制字面值是带符号数，2，8，16进制字面值可能是带符号，也可能是无符号数。

   1. 十进制字面值的类型是int、long、long long中能容纳数值的尺寸最小的那个类型。
   2. 2，8，16进制字面值的类型是int、unsigned int、long、unsigned long、long long、unsigned long long中能容纳数值的尺寸最小的那个类型。上述类型从左往右依次进行适配。
   3. 如果最大类型都放不下这个字面值，则会编译错误。short没有对应的字面值。

5. 尽管整型字面值可以存储在带符号类型中，严格来说，十进制字面值不会是负数，例如使用了-42这个负的十进制字面值，负号并不在字面值之内，他的作用仅仅是对字面值42取负值而已。

6. 浮点型字面值表现为小数或科学计数法表示的指数。指数标识可以用e或E。默认情况下，浮点型字面值是double类型。

   ```c++
   3.15    3.15e0    0.    0e0    .001  //这五个都是浮点数
   ```

### 字符和字符串

1. 由单引号包括起来的一个字符为char型字面值。双引号包括起来的零个或多个字符构成字符串型字面值。字符串字面值的类型实际上是由常量字符构成的数组。编译器会在每个字符串的结尾处添加一个空字符'\0'。因此字符串字面值占据的空间要比它的内容多1个字节。例如"abc"的类型是const char [4]。

2. 如果两个字符串字面值的位置紧邻，且仅由空格，制表符，换行符分隔，编译器会将他们合并为一个整体。

   ```c++
   "abc"  "def"   //等价于 "abcdef"。前一个字符串的'\0'会被去掉。
   cout << "abc"  //如果一行写不下，可以分开书写。等价于"abcdef"
       "def"
   ```

3. C++11新增了一种叫原始字符串（Raw String Literals）的类型。在原始字符串中，字符表示的就是它自己，而无需使用`\`转义，例如，`\n`不表示换行符，而是表示两个常规字符：`\`和`n`。 原始字符串使用"( 和)"作为定界符，并使用R来标识原始字符串。这个功能在python中也有，`r"abc"`：

   ```c++
   R"(Hello,"C++".)"; //等价于 "Hello,\"C++\"."
   //因此若想要在字符串中出现)或"，则必须自定义定界符，在"和(之间的任意字符，空格，斜杠，括号除外：
   R"+*("(Who is it?)" It's your neighbor.)+*" //左右定界符为"+*(和)+*"。等价于：
   "\"(Who is it?)\" It's your neighbor."
   ```

4. 

5. 


### 转义序列

1. 有两类字符程序员不能直接使用：不可打印的字符，例如退格或其他控制字符，因为他们没有可视的图符；C++语言中有特殊含义的字符，例如单/双引号，问号，反斜线。这两种情况下，需要使用到转义序列（escape sequence）：

   ```c++
   // C++规定的转义序列有如下：
     \n       \t       \a       \v        \b     \"     \\     \?     \'     \r     \f
   换行符  横向制表符  响铃   纵向制表符  退格符  双引号  反斜线  问号  单引号  回车符  进纸符(换页)
   ```

2. 在程序中，转义序列会被当做一个字符使用，可以将转义序列和普通字符一样使用，融入到字符串中。也可以使用泛化的转义序列，形式为\x后面跟1个或多个16进制数字；或\后面跟1、2、3个八进制数字。数字部分是字符集中字符对应的数值。

   ```c++
    \0     \40  \115   \x4d
   空字符  空格  字符M  字符M  //因为八进制的115=十六进制的4d。
   char p[] = "\x4dO\115";   //等价于"MOM"
   ```

3. 如果\后面跟着的8进制数超过3个，则只有前三个和\构成转义序列。相反，\x会和后面的所有十六进制数字构成转义序列。

   ```c++
   "\1234"   //实际上是3个字符 '\123'，'4'和'\0'。
   "\x1234"  //只是1个字符，这表示一个16位的字符。超过8位的16进制字符需要配合扩展字符类型来使用。
   ```


### 指定字面值的类型

1. 通过给字面值添加前缀或后缀，可以改变他们的默认类型：

   ```c++
   //字符和字符串字面值
   u'\x1234'     //Unicode 16字符，类型为char16_t
   U'\x12345678' //Unicode 32字符，类型为char32_t
   L'中'         //宽字符，类型为wchat_t,值为\x4e2d
   u8"hi"        //UTF-8(仅用于字符串字面值常量)，类型为char
   //整型字面值
   21     //有符号证书，实际类型为int
   2111111111111111111 //有符号整数，实际类型为long long
   21U    //无符号整数，实际类型为unsigned int
   21L    //有符号整数，实际类型为long
   21LL   //有符号整数，实际类型为long long
   21UL   //无符号整数，实际类型为unsigned long
   21ULL  //无符号整数，实际类型为unsigned long long
   //浮点型字面值
   1.2345678987;    //默认的double，不会损失精度
   1.2345678987F;   //float类型，1.2345679F，损失精度，并非按照四舍五入原则保留7位有效数字，因为1.2345678287F的结果也是1.2345679F，
   1.2345678987L;   //long double，不会损失精度。在windows下是64位。
   ```

2. 对于整型字面值来说，能够分别指定它是否带符号和所占的空间大小。后缀中有u或U，则属于无符号，只能从unsigned int，unsigned long，unsigned long long中进行匹配。如果后缀中有l或L，则在long，unsigned long，long long，unsigned long long中匹配；如果后缀中有ll或LL，则在long long，unsigned long long中匹配。因此后缀一共有5种：U，L，LL，UL，ULL。这里推荐全用大写，因为小写的l和数字1很像，容易认错。L包括LL，而LL不包括L。


### 布尔和指针

1. true和false是布尔类型的字面值。
2. nullptr是指针字面值。

## 类型转换

1. 类型所能表示的范围决定了类型转换的过程：

   1. 把一个非bool的算术值赋值给bool类型，0的结果为false，其余的都是true。
   2. 把bool值赋值给非布尔类型，false的结果为0，true的结果为1。
   3. 把浮点数赋值给整型，数值进行了取整，小数部分被去掉了。
   4. 把整数赋值给浮点类型，小数部分记为0，如果整数的位数过长，超过了浮点数的有效数字位数，会有精度损失。
   5. 把一个超过其范围的值赋给无符号类型时，结果是该值对该无符号类型能表示的总数取模后的余数。例如将-1赋值给unsigned char，后者表示范围为0→255，一共256个数，计算-1/256=-1……255，因此结果为255。这也是溢出的原理。
   6. 把一个超过其范围的值赋给带符号类型时，结果是未定义的。

2. 未定义的行为意味着程序可能继续工作，崩溃或产生垃圾数据。它来源于编译器无需（有时候无法）检查的错误。在某些情况下，包含未定义行为的程序仍然会正常工作，但是换一个编译器编译，或者换一台机器执行，程序就可能报错。这种bug难以发现。

3. 程序应该避免依赖环境的行为，例如，如果把int看做是恒定不变的32位大小，那么这种程序就是不可移植的。因为在不同的嵌入式平台上，类型的大小变化很多。

4. 一个算术表达式中，既有无符号数，又有int时，int就会转换为无符号数。这里把int转换为无符号数的过程和将int值赋给无符号类型是一样的。

   ```c++
   unsigned int u = 10;
   int i = -42;
   std::cout << i + i << std::endl;  //结果为 -84
   std::cout << u + i << std::endl;  //结果为 4294967264，因为-42转化为无符号数为2^32-42=4294967254,然后再+10，就是4294967264。
   ```

5. 当从一个无符号数中减去一个值时，不论这个值是不是无符号数，都不必须确保结果不能是一个负值。实际上如果减数是有符号的，会被转为无符号数。无符号数的算术运算结果还是无符号数（取余即可）。

   ```c++
   unsigned int u1 = 42,u2 = 10;
   std::cout << u1 - u2 << std::endl;  //结果为32。
   std::cout << u2 - u1 << std::endl;  //结果为4294967264。
   ```

6. 无符号数不会<0的这个特点，关系到循环的写法。

   ```c++
   for (unsigned int i = 5; i >= 0; i--) {  //这是个死循环，因为当i=0时，下一步就变成了2^32，这也是>=0的。
       std::cout << i << std::endl;
   }
   //有两种修改方法：使用有符号数作为循环变量；将继续进行循环的条件改为i>0，不过这样会少进行一次循环。
   ```

7. 上面的类型转换都是静态，隐式的，在编译阶段由编译器完成的。

9. 算术类型之间的隐式转换被设计为尽可能避免损失精度。因此整数会转换成浮点数。

10. 隐式转化的情形：

   1. 大多数表达式中，比int小的整型值会先被提升到较大的整数类型。
   2. 在条件中，非bool值会转换为bool类型。
   3. 初始化是，初始值变为变量的类型；赋值时，右侧运算对象转换成左侧运算对象的类型。
   4. 如果算术或关系运算的对象有多个类型，则需要转化为同一种类型。
   5. 函数调用时会发生类型转化。

11. 对于bool，unsigned char，char，signed char，short，unsigned short等类型来说，只要他们所有可能的值都能存在int内，就会提升为int，否则提升为unsigned int。

    ```c++
    char x = 3;
    auto y = x+1;  //y的类型为int，因为计算x+1时，会先将x的值提升为int。
    ```

12. 较大的char类型（wchar_t，char16_t，char32_t）提升为int，unsigned int，long，unsigned long，long long，unsigned long long中能容纳原类型所有可能值的最小类型。

13. 如果某个运算对象是无符号类型，那么转换的结果依赖于机器中各个整数类型的相对大小。

    1. 首先进行整型提升，如果结果的类型匹配，则不用再进一步转换。

       ```c++
       auto a = 3.14L+'a';  //'a'首先被提升为int，然后该int值提升为long double。结果为100.14L。
       auto b = 3+5.2;      //将int转化为double，结果为8.2。
       auto c = 3.2f+5.2;   //将float转化为double，8.4。
       int d = -3.2;        //去除浮点数的小数部分，结果为-3。
       bool flag = 4.3;     //因为4.3非0，所以为true。
       auto e = 4.2f+'a';   //先将'a'提升为int，在转化为float，结果为101.199997
       short f = 5;
       auto g = f+'a';      //short和'a'都会被转换为int。因为类型匹配，所以不用再转化。结果为102。
       ```

    2. 如果提升后类型不匹配，且两个运算对象都是有符号或无符号类型，则小类型的运算对象转换成大类型的。

       ```c++
       auto a = 'a'+5L;  //'a'首先被提升为int，然后因为int和long类型不匹配，且都是有符号类型，则int转化为long，结果为102L
       ```

    3. 如果提升后类型不匹配，且一个是有符号，一个是无符号，且无符号类型不小于有符号的，则有符号类型转为无符号的。例如：两个运算对象分别是unsigned int 和int类型，则int转换为unsigned int。需要注意的是，如果int类型的值为负数，那么转换后，应该是一个非常大的无符号数。

       ```c++
       auto a = 5+3ul;  //类型不匹配，一个有符号，一个无符号，且无符号类型不小于有符号，因此int转化为unsigned long，结果为8ul。
       auto b = -5 + 1ul; //msvc会报错，提示负整型常量转换为无符号类型。
       ```

    4. ==上面的例子应该是试一下gcc==

    5. 如果提升后类型不匹配，且一个是有符号，一个是无符号，且无符号类型小于有符号的，则转换结果依赖于机器。如果无符号类型的所有值都能存储到该有符号类型中，则无符号转为该有符号类型。反之，有符号转为无符号。例如两个运算对象分别是long和unsigned int，如果long和int一样大。则long转化为unsigned int。如果long比int大，则unsigned int转化为long。

       ```c++
       unsigned short a = 3;
       auto b = a+4;  //根据unsigned short和int的空间大小进行提升，一般来说short占16字节，int占32字节，所以unsigned short会被提升为int，结果为7。
       auto c = 3u+5l; //根据unsigned int和long的空间大小进行转换，一般来说，二者都占32字节。unsigned int小于long，由于不能将unsigned int的所有值都存到long中，所以long转为unsigned int，结果为8u。不过MSVC中结果为8ul。
       ```

    6. ==上面的例子应该试试gcc。==

14. 上面说的类型大小不是所占空间的多少，而是根据 char，short，int，long，long long来排序的。

15. 可以看出，算术类型的隐式转换的规则特别复杂，如果可以还是使用显式类型转换，这样可以避免很多错误。

16. 除了算术类型的隐式转换以外，还存在以下几种隐式类型转换：

    1. 大多数情况下数组名被自动转化为指针，但是在decltype，&，sizeof，typeid等运算符时，不会发生这种转换。

       ```c++
       int arr[3];
       int *p1 = arr; //正确，arr被当做指向一个首元素的指针。
       decltype(arr) x; //等价于 int x[3];
       int (*p2)[3] = &arr; //正确
       sizeof(arr);  //结果为3*4=12字节
       typeid(arr) == typeid(int*); //false
       ```

    2. 字面值0和nullptr可以自动转换为任意指针类型；指向任意非常量的指针可以自动转化为void *；指向任意对象的指针能自动转化为const void *；派生类到基类的自动转换，能把派生类对象当做基类对象使用，能将基类的指针或引用绑定到派生类对象的基类部分：

       ```c++
       int *p1 = 0;
       void *p2 = nullptr;
       
       int a = 3;
       const int b = 5;
       void *p3 = &a;
       void *p4 = &b;  //错误非常量对象的指针不能转化为const void*。
       const void *p5 = &a; //正确，const void*可以接受任意类型的指针。
       const void *p6 = &b;
       ```

    3. 任意算术类型和指针类型都可以自动转化为bool类型如果只为0，则转化为false，反之为true。

    4. 允许自动将指向非常量的指针转化为指向常量的指针，引用也是一样的，反之不允许：

       ```c++
       int i;
       const int &j = i; //正确，允许添加底层const
       const int *k = &i;
       int &r = j,*q = p; //错误，不允许删除底层const
       ```

    5. 类类型能定义编译器自动执行的转换，例如隐式的转换构造函数，不过编译器每次只能执行一步类类型转换，同时提出多步转换，编译器将拒绝：

       ```c++
       string s = "abc"; //string定义了转换构造函数，接受一个const char*参数
       if (cout << 3){ } //IO库为cout对象定义了到bool类型的转换函数。
       ```

17. 虽然有时候不得不使用强制类型转换，但是这种方法是非常危险的。

18. 命名强制类型的转换形式为cast-name\<type\>(expr)，如果type为引用，则结果为左值，cast-name有4种：

    1. static_cast，任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast：

       ```c++
       int i=4,j=5;
       auto slope = static_cast<double> (i)/j;  //结果为0.8，double类型。
       //当需要把一个较大的算术类型赋值给较小类型时，static_cast非常有用。这告诉程序的读者和编译器，程序的编写者知道并且不在乎潜在的精度损失。一般来说，如果编译器发现一个较大的数试图赋值给一个较小的类型，就会发出警告信息，如果使用static_cast则不会。
       
       //static_cast对于编译器无法自动执行的类型转换非常有用，可以使用它来将void*指针转化为特定类型的指针
       int d = 3;
       void *p1 = &d;
       int *p2 = static_cast<int*>(p1);  //不能直接用p1来初始化p2。但是C语言可以自动将void*转化为任意类型的指针。
       ```

    2. dynamic_cast，支持运行时类型识别

    3. const_cast，只能改变对象的底层const，因此只能作用于指针或引用。经常用在重载函数的参数中。利用转化后的指针来修改内容是未定义行为，可能会引发运行时错误，这需要程序员去辨识。

       ```c++
       char str[] = "abc";  //用常量区的字符串来初始化栈中的字符数组。
       const char * pc = str;  //底层const;
       char *p = const_cast<char*>(pc);  //不能直接用pc初始化p
       p[1] = 'h';   //此时可以用p来修改pc指向的内容，但是仍然不能用pc来修改它。
       //下面的代码中，仍然不能通过p来修改pc指向的内容。因为"abc"的位置是在静态区，这部分内容是被编译器设定了内存为只读的，通过任何方式都不能修改。
       const char * pc = "abc";
       char *p = const_cast<char*>(pc);
       p[1] = 'h';  //会引发运行时错误
       ```

    4. reinterpret_cast，为运算对象的位模式提供较低层次上的重新解释。

       ```c++
       int *ip;  //ip指向一个int数据，占有4个字节。
       char *pc = reinterpret_cast<char*>(ip); //此时pc和ip的值相同，但是所指对象占用的空间大小不同，类型也不同。
       string(pc); //错误
       ```

19. 只有const_cast可以改变表达式的常量属性。使用其他类型的cast都会引发编译错误。同样，const_cast也不能用来改变表达式的类型。

    ```c++
    const char *p = "abc";
    char *q = static_cast<char*>(p);   //错误，static_cast不能去掉底层const
    auto x = static_cast<std::string>(p);  //正确，x为string类型，内容为abc
    auto y = const_cast<std::string>(p);  //错误，const_cast的模板参数必须是指针或引用。
    ```

# 变量

1. 变量提供一个具名的可供程序操作的存储空间，C++的每个变量都有其数据类型，它规定了变量的内存大小和布局方式，存储值的范围以及能参与的运算。

2. 对于C++程序来说，变量和对象两个词可以互换使用。一些人仅在与类有关的场景下才使用“对象”这个词。一些人则把命了名的对象称之为变量，未命名对象还称为对象。另一些人则把对象和值区分开，认为对象是能被修改的数据，值是只读的数据。

3. 变量定义的基本形式：首先是类型说明符，然后是一个或多个变量名组成的列表，用逗号分隔，最后以分号结束。列表中的每个变量的类型都是一样的。定义时还可以为一个或多个变量赋初值。

   ```c++
   int sum =0,value;  //定义2个int类型的变量，并为第一个变量赋初值。
   std::string book("test");  //定义了一个std::string类型的对象，用字符串字面值初始化。
   ```

4. 初始化：当对象在创建时获得了一个特定的值。可以用任意复杂的表达式来初始化一个变量。当一次定义了多个变量时，对象的名字随着定义就可以立刻使用了：

   ```c++
   int a = 1,b = a+1; //正确，先定义并初始化a，然后定义b，并用a+1初始化b。
   ```

5. 

6. 在C++中，等号可以进行初始化和赋值，但是他们是完全不同的两个操作。在很多程序语言中，二者的区别不重要，在C++中有时也不重要，但是不能混用。

   1. 初始化是创建变量时赋予一个初始值。
   2. 赋值时把变量的当前值擦除，用一个新的值代替。

7. C++语言定义了好几种不同的初始化方法：

   ```c++
   //以下四种都可以。
   int a = 0;
   int a = {0};  //列表初始化，这是C++11提出的。也可以用这种方法来赋值。
   int a{0};     //也是列表初始化。不推荐使用，因为不清晰，只有初始化类对象和结构体时才会用到。
   int a(0);
   ```

8. 将列表初始化用于内置类型时，如果初始值存在丢失信息的风险，则编译器会报错：

   ```c++
   long double ld = 3.1415926536;
   int a{ld}, b = {ld}; //错误，转换未执行，因为存在丢失信息的风险。小数部分可能会丢失，同时long double的数值可能超过int的范围。因此编译器拒绝了这种请求。
   int c(10), d = ld;   //正确，转换执行，确实丢失了部分值。
   ```

9. 如果定义变量时没有指定初始值，则变量会被默认初始化，此时变量被赋予了默认值。默认值由变量的类型决定，同时定义变量的位置也会影响默认值。

   1. 如果内置类型的变量未被显式初始化，则它的值由定义位置决定。如果定义在任何函数体之外则被初始化为0；如果定义在函数体之内，则不被初始化。一个未被初始化的内置类型变量的值是未定义的。读取未初始化的变量是造成很多bug的原因。

   2. 类的对象如果没有显式地初始化，则其值由类决定。

   3. 每个类各自决定其初始化对象的方法。而且是否允许不经初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么。绝大多数类都支持无需显式初始化而定义对象，这样的类提供一个合适的默认值。

      ```c++
      std::string s1; //使用默认构造函数初始化s1,其内是一个空字符串。
      //如果类中不存在显式或合成的默认构造函数，则必须显式初始化。
      ```

   4. 一些类要求每个对象都显式初始化，如果创建了一个该类的对象，而未对其做明确的初始化操作，将报错。

10. 以上几种初始化大部分情况下可以互相等价使用，但是存在例外：

    1. 使用拷贝初始化(使用=)时，只能提供一个初始值。

       ```c++
       string s = "abc";
       ```

    2. 如果提供的是一个类内初始值，只能使用拷贝初始化或以花括号初始化的方法。

    3. 如果提供的是初始值的列表，只能把初始值都放到花括号内，不能放到圆括号内。

       ```c++
       vector<string>v1{"a","bcd"};  //正确
       vector<string>v2("a","bcd");  //错误
       ```

14. 为了允许把程序分成几个逻辑部分编写，C++支持分离式编译机制，每个源文件可以独立编译。这就需要有在文件之间共享代码的方法。一个文件中的代码可能需要使用另一个文件中的名字，例如标准库。

18. 为了支持分离式编译，C++将声明和定义分离开来。

    1. 声明使得一个名字为程序所知，一个文件如果想使用别处定义的名字，则必须包含对那个名字的声明。
    2. 定义则创建于名字关联的实体。

19. 声明和定义都规定了变量的类型和名字。不同点是定义还申请了内存空间，也可能为变量赋初值。

20. 如果想要声明而非定义一个变量，应该在变量名前添加extern，而且不要显式初始化它。任何包含了显式初始化的声明就会变成定义。

    ```c++
    extern int i;  //声明了变量i。
    int j;         //声明并定义了变量j，默认初始化。
    extern int k = 3; //可以给extern关键字标记的变量赋初值，这样会抵消extern的作用，使之变为一个定义。不过在函数内部初始化一个extern标记的变量会报错。
    ```

21. 变量能且只能被定义一次，但可以被声明很多次。如果要在多个文件之间使用同一个变量，就需要将声明和定义严格区分开。变量的定义只能出现在一个文件中，其他文件如果需要用到该变量，声明即可，但是不能重复定义。

22. C++的类型检查（type checking），发生在编译阶段，主要检查数据类型是否支持要执行的运算。要求使用任何变量前，至少要声明。编译阶段可以只有声明，具体的变量内存可以在链接阶段再寻找。

23. C++的标识符由字母，数字和下划线组成。必须以字母或下划线开头。长度没有限制，对大小写敏感。

24. C++为标准库保留了一些名字，用户自定义的标识符应该满足以下要求：

    1. 不能出现连续两个下划线。

    2. 不能以下划线紧连大写字母开头。

    3. 定义在函数体外的标识符不能以下划线开头。

25. 关于标识符的约定：

    1. 要体现具体含义。

    2. 变量名一般用小写，用户自定义的类名一般大写字母开头。不过标准库的所有标识符都是全小写。

    3. 如果标识符以多个单词组成，单词间要有明显的区分。用下划线或驼峰。student_index或studentIndex。

26. 在任何位置使用到的名字都会指向一个特定的实体，变量，函数或类型等。同一个名字出现在不同的位置可能指向不同的实体。

27. C++中大多数作用域都用`{}`进行分割。名字的有效区域开始于声明语句处，结束于声明语句所在的作用域末端。

28. 定义在所有函数体之外的名字具有全局作用域。一旦声明以后，在程序的任何位置都可以使用。定义在`{}`内的名字具有块作用域。

29. 一般来说，在对象第一次使用前再进行定义是一个比较好的选择，这样更容易找到变量的定义，同时也方便赋一个合理的初值。

30. 作用域能嵌套，但是不能交叉。作用域内一旦声明了某个名字，则其内层的所有作用域都能访问该名字。允许在内层作用域中重新定义外层作用域中已有的名字，外层名字会被暂时隐藏，不过不推荐这么做。

    ```c++
    int main() {
    	int a = 3;  //外层作用域的变量
    	{
    		cout << a << endl;  //结果为3
    		int a = 5;  //会暂时隐藏外层作用域的变量，直到内层作用域结束
    		cout << a << endl; //结果为5
    	}
    	cout << a << endl; //结果为5，外层作用域的变量
    	return 0;
    }
    ```

31. 在任意作用域中使用`::`都可以访问全局作用域的名字，符号左侧为空，因为全局作用域没有名字。

    ```c++
    int a = 1;
    int main() {
    	int a = 3;
    	cout << ::a << endl;  //结果为1
    	{
    		int a = 5;
    		cout << ::a << endl;  //结果为1
    	}
    	system("pause");
    	return 0;
    }
    ```

# 复合类型

1. 复合类型是指基于其他类型定义的类型，例如引用，指针和数组。

2. 一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成，每个声明符命名了一个变量，并指明该变量为与基本数据类型有关的某种类型，简单声明语句中声明符就是变量名，此时变量的类型就是声明的基本数据类型。

3. 类型修饰符是声明符的一部分，int \*p和int\* p等价，建议使用前一种，不容易产生误解。

   ```c++
   int* a,b;  //实际上是定义了一个指向int数据的指针a,一个int变量b。这里类型修饰符是*
   ```


## 引用

1. 引用为对象起了一个别名，引用类型可以引用另外一种类型，引用并非对象，而是为一个已经存在的对象起的另一个名字。

2. 引用的初始化并不是拷贝变量的值，而是将名字绑定（bind）到初始值上。一旦初始化完成，就不能改变引用绑定的对象，因此引用必须初始化。

   ```c++
   int a = 3,b = 5;
   int &ref = a;     //ref是a的另外一个名字
   int &ref1;        //错误，引用必须被初始化。
   ref = b;          //这是为引用赋值，并非改变引用绑定的对象，而是为引用绑定的对象赋值。
   int c = ref;      //以引用为初始值，实际以引用绑定的对象为初始值。
   int &ref3 = ref;  //由于引用并非对象，因此无法定义引用的引用，所以这是将ref3和ref绑定到同一个对象上。
   ```

3. 定义了引用之后，对其进行所有操作都是对绑定的对象进行的。

4. C++11中新增了一种引用，右值引用，主要用于内置类，默认情况下，引用指的就是左值引用。

5. 引用的定义：

   ```c++
   //通过将声明符写成&d的形式，来定义引用类型，其中d是声明的变量名。
   //允许在一条语句中定义多个引用，其中每个引用标识符都必须以&开头。
   int i = 1024, &j = i;  //i是int类型变量，j是int&类型。
   ```

6. 可以定义绑定到字面量的引用，不过因为字面都是常量，因此必须要用常量引用。

   ```c++
   int &a = 5;  //错误，非常量引用的初始值必须为左值。
   const int &b = 11; //正确
   b++;  //错误，因为11++是非法的，因为11是右值。
   ```

7. 除了以下两种情况以外，引用和指针的类型都要和绑定的对象严格匹配。不能将int&绑定到一个double对象上，也不能将一个int*指针指向double对象。

   1. 允许使用任意表达式初始化常量引用，只要该表达式能够转化为引用的类型即可。



## 指针

1. 指针和引用都实现了对对象的间接访问，不同的是：指针本身是一个对象，指针可以先后指向不同的对象；指针无需在定义时赋初值。和其他内置类型一样，定义在函数内的指针不会被默认初始化，将拥有一个不确定的值。

2. 定义指针类型的方法：将声明符写成`*d`的形式，其中d是变量名。如果一条语句中定义了多个指针变量，则每个变量前都必须有`*`。

3. 引用不是对象，没有实际地址，因此无法定义指向引用的指针。

4. 使用取地址符&获取对象的地址，使用解引用符*来访问对象。解引用操作只适用于确实指向了某个对象的有效指针。

5. 指针变量的值应该处于以下4种状态之一：

   1. 指向一个对象。

   2. 指向紧邻对象所占据空间的下一个位置。

   3. 空指针，意味着指针没有指向任何对象。

   4. 无效指针，上述情况之外的其他值，例如未初始化的指针。

6. 访问未初始化的指针可能会出错，也可能不会出错，这种bug很难发现。因此建议在定义时进行初始化，如果不知道初始化为何值，可以先初始化为空指针。

7. &和*在不同的位置由不同的含义，如果紧随类型名出现，则是声明的一部分，如果出现在表达式中，则是取地址或解引用符号。

8. 空指针不指向任何对象，在试图使用一个指针前，应该检查其是否为空。推荐使用nullptr这个字面量，避免使用NULL。

   ```c++
   //生成空指针的方法：
   int *p1 = nullptr;  //C++11标准增加的。特殊类型的字面值，可以被转换成任意其他指针类型，这里就转化成了int*类型。
   int *p2 = 0;        //和上面一句相同。
   int p3 = 0;
   int *p4 = p3;       //不能用int类型值初始化int*变量，值恰好等于0也不行。
   
   #include <cstdlib>
   int *p5 = NULL;  //必须要包含cstdlib头文件，实际上NULL在该文件中用宏定义为0。
   ```

9. 当且仅当指针为空指针时，其条件值为false。对于两个相同类型的合法指针，可以用==或!=进行运算，结果为布尔类型。指针相等意味着指向同一个对象，或都是空指针，或都指向了同一个对象的下一个地址。一个指针指向某个对象，另一个指针指向另外一个对象的下一个时，二者也有可能相等。

10. void*是一种特殊类型的指针，可以用于存放任意对象的地址。不能直接操作void\*指针，因为我们不知道对象是什么类型的，就无法确定可以执行的操作。用途：

   1. 拿它和其他指针比较
   2. 作为函数参数和返回值的类型
   3. 赋值给另外一个void*的指针

11. 在一个定义语句种，可以定义出不同类型的变量：

    ```c++
    int i = 1, *p = &i, &r = i; //基本数据类型只有int一个，但是声明符可以由多种形式。
    ```

12. 声明符中的修饰符个数并没有限制。可以定义指针的引用。

    ```c++
    int a = 3;
    int *p1 = &a;
    int **p2 = &p1; //二级指针
    **p2 = 5; //修改a的值
    
    int a = 3, b = 4;
    int *p = &a;
    int *&r = p; //r是对一个int指针的引用
    *r = 5;  //修改a的值。
    r = &b;  //修改p的值，现在p指向b。
    //复杂类型的阅读应从右往左进行。先从离变量名最近的开始，&r表明r是一个引用，然后有一个*表明是这个引用绑定在指针上，最后是int。
    ```

# nullptr

1. C和C++中关于NULL的定义并不相同，NULL并不是关键字，而是一个宏定义：

   ```c++
   // MSVC都使用在vcruntime.h中的定义,不同的时如果文件是.cpp后缀名，则会定义__cplusplus这个宏，具体内容为支持的C++标准。
   #ifndef NULL
       #ifdef __cplusplus
           #define NULL 0             //C++会将NULL定义为0。
       #else
           #define NULL ((void *)0)   //C语言会将NULL定义为 ((void*)0)。
       #endif
   #endif
   ```

2. C++之所以没有继续采用C语言中的NULL定义，是因为C++为了保证函数重载的有效进行，不允许void*类型隐式转化为任意类型，进而没有再使用((void\*)0)作为NULL的定义。但是C++还是允许用void\*类型接受任意类型的数据的地址：

   ```c++
   int* v1 = NULL;  //这个NULL实际上就是0，但是又不能修改为其他整数。
   int* v1 = 2;  //会报错，提示int类型的值不能用于初始化int*类型的实体。
   int* v1 = ((void*)0);  //如果继续使用C语言中的NULL定义，会发生报错，提示void*类型的数据不能用于初始化int*类型的实体。
   ```

3. C++11提出了一个新的关键字nullptr，可以完全用它来代替NULL。不过C语言程序不认识nullptr关键字。但是不可以将它赋值给int类型或者和int类型比较。

   ```c++
   int* p1 = 0;
   int* p2 = nullptr;
   p1 == 0;  //true
   p2 == 0;  //true
   p1 == nullptr; //true
   p2 == nullptr; //true
   p1 == p2; //true
   if(nullptr) {}          //会被当做false。
   
   
   int n1 = 0;             // ok  
   int n2 = nullptr;       // error,会提示std::nullptr_t类型的值不可以初始化为int类型的实体。
   if(n1 == nullptr) {}    // error  
   nullptr = 0             // error  提示表达式必须是可修改的左值。
   ```

4. 在函数重载时，NULL和nullptr有着不同的行为，主要还是因为两者的类型不同：

   ```c++
   void foo(int)   {cout << "int" << endl;}
   void foo(char*) {cout << "pointer" << endl;}
   
   foo(0);       // calls foo(int)  ,如果只定义了foo(char*),该函数也可以运行成功。
   foo(nullptr); // calls foo(char*)  ,如果只定义了foo(int),该函数会报错。
   ```

5. std::nullptr是std::nullptr_t类型的一个实例。std::nullptr_t不是指针类型，但可以隐式转换成任意一个指针类型。

# const限定符

1. 使用const可以让编译器检查，不修改某个变量。

2. const对象一旦创建后，就不能再修改，因此必须初始化。初始值可以是任意复杂的表达式：

   ```c++
   const int a = 3;  //编译时初始化
   const int b = get_size();  //运行时初始化
   const int c;  //错误，没有初始化
   ```

3. const对象只能执行非const对象的一部分操作。

4. const和非const对象可以互相初始化，因为拷贝一个对象并不会改变他的值。常量属性仅在执行要改变对象的操作时才会起作用。

   ```c++
   const int a = 1;
   int b = a;
   
   int c = 3;
   const int d = c;
   ```

5. 默认情况下，const对象仅在文件内有效。

   1. 对于编译时进行初始化（初始值是一个常量表达式）的const对象，编译器会找到所有使用到该对象的地方，用初始值替换。要做到这一点，就必须在所有用到const对象的文件中都有对它的定义。同时又为了避免重复定义，所以const对象被设定为仅在文件内有效。多个文件中出现同名的const变量时，互相独立。

      ```c++
      //a.cpp
      const int a = 4;
      //b.cpp
      const int a = 6; //不会报错，和上面的是两个实体
      ```

   2. 对于运行时初始化的const对象，如果需要在文件间共享（不希望编译器为每个文件单独生成一个），可以对该变量的声明和定义都添加extern，这样只需定义一次就行了。

      ```c++
      //file1.cpp
      extern const int a = fun1();  //定义并用一个非常量表达式初始化
      //file1.h  这里file1.cpp和file.h是对应的，使用file1中的类或函数时，#include "file.h"即可，这样也会共享常量a。
      extern const int a ;  //仅声明，extern表明这个变量并非本文件所独有，它的定义出现在别处。这里的a和上面定义的是同一个实体。
      ```


## const和引用

1. 对常量的引用（reference to const）：绑定到常量对象的引用。不能通过引用来改变对象的值，简称为==常量引用==。严格来说并不存在常量引用，因为引用本身不是一个对象，更不能让他本身恒定不变。实际上C++不允许引用重新绑定到新对象上，从这个意义上来说，所有的引用都是常量的，这里的常量指的是绑定的对象的属性。

   ```c++
   const int a = 4;
   const int &r = a; //正确
   r = 5; //错误，不能通过常量引用修改它绑定的对象。
   int &r2 = a;  //错误，因为这里试图将int&绑定到const int上，会使得const丢失。如果可以的话，就能通过r2修改a的值了，产生了漏洞。
   ```

2. 允许使用任意表达式初始化常量引用，只要该表达式能够转化为引用的类型即可。

   ```c++
   int a = 3;
   const int &r1 = a;  //可以绑定到非常量对象上
   const int &r2 = 42;  //可以绑定到字面值上
   const int &r3 = a + 2; //绑定到临时对象5上
   ```

3. 编译器会将引用绑定到表达式生成的临时量对象上。临时量对象就是：编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象。临时对象都不能当左值。

   ```c++
   double dval = 3.14;
   const int &r5 = dval; //正确，因为为了确保r5能够绑定一个整数，编译器会把上述代码变成如下2步：
   const int tmp = dval; //产生一个临时量对象，这是合法的，因为会发生隐式类型转换，截断小数部分。因此编译器也会报warning：“初始化”: 从“double”转换到“const int”，可能丢失数据。
   const int &r5 = tmp;  //让r5绑定到这个临时量对象3上。
   
   int a = 3;
   const int &r1 = a;
   int &r4 = r1 * 2;  //错误，因为会将r4绑定到一个临时量对象上去，而非常量引用一般是想要修改对象内容的。因为大家不会想要修改一个临时量对象的值，因此C++将这一行为定义为非法。非常量引用的初始值必须为左值。
   ```

5. 常量引用仅对引用本身可以参与的运算做了限定，但是引用的对象本身不一定要是一个常量。允许通过其他途径改变对象，这只是常量引用自以为是，自觉不去修改。

   ```c++
   int a = 4;
   const int &r = a;
   int &b = a;
   b = 6; //正确
   ```


## const和指针

1. ==C++primer中常量指针和指针常量跟通常的说法正好相反。==

2. 常量指针和指针常量的区分：从左往右，先遇到const就是常量指针，先遇到*就是指针常量。

3. 类似于常量引用，指向常量的指针不能通过指针改变其所指对象的值，但是简称为常量指针（pointer to const）。只能使用常量指针指向常量对象。

   ```c++
   const int a =3;
   int *p1 = &a;  //错误，如果允许的话，就可以通过p1修改a了，产生漏洞。
   const int *p2 = &a; //正确，也可以不初始化。这里const修饰的是*p2。
   
   //以下两种方法都可以，都是常量指针。
   const int* p; //推荐这种
   int const* p;
   ```

4. 允许令一个常量指针指向一个非常量对象。

   ```c++
   int a = 3;
   const int *p = &a;  //但是不能通过p来改变a。
   ```

5. 指针常量（const pointer）：因为指针是对象，因此允许把指针本身定义为const，这样就不能改变它的指向。和其他常量对象一样，定义时必须初始化。

   ```c++
   int a = 3,b =5;
   int * const p = &a;  //指针常量，将const放在p前面，意味着const修饰的是p本身。
   p = &b;   //错误
   *p = 7;   //正确，可以通过p修改指向的对象。
   ```

6. 可以定义指向常量的指针常量，这意味着指针和指针指向的对象都不能修改。

   ```c++
   int a =3;
   const int * const p = &a;
   ```

7. 为了方便区分，可以用顶层const表示指针本身是一个常量，底层const表示指向的对象是一个常量。顶层是直接的，底层是间接的。一般的，顶层const可以表示任意的对象是常量，而底层const只能用于指针和引用。指针可以是顶层的，也可以底层的，也可以二者都是。而引用一定是顶层的，可以是底层的。普通的非指针或引用的变量，const都是顶层的。

   ```c++
   int a = 3;
   const int *const a = &a; //第一个const是底层，第二个是顶层。
   ```

8. 执行拷贝操作不会改变等号两侧对象的值，因此是否是顶层const都可以进行拷贝。但是底层const不能赋值给非底层const，反之则可以。

   ```c++
   int a = 1;
   const int *p1 = &a;
   int *p2 = p1;  //错误，因为p1是底层const，p2是非底层的
   
   const int &r1 = 42;
   int &r2 = r1;  //错误，非常量引用的初始值只能是左值。同上
   
   int b = 3;
   const int c = 2;
   c = b; //错误，不能认为b是顶底都不const，而c是顶层const。因为二者都不是指针或引用。上面的规则只对指针或引用的拷贝有效。
   ```

## 常量表达式和constexpr

1. 常量表达式：值不会改变并且在编译期间就能得到计算结果的表达式。C++在很多地方必须用到常量表达式，例如数组大小。常见的有：

   1. 字面值
   2. 用常量表达式初始化的const对象

2. 一个对象或表达式是否是常量表达式，由它的数据类型和初始值共同决定。

   ```c++
   const int a =3;  //是常量表达式
   const int b = a+3;  //是常量表达式，常量表达式具有传递效应。
   int c =5;  //不是常量表达式，尽管初始值是一个字面值常量，但是它的类型不是const int。
   const int d = get_size();  //不是常量表达式，因为初始值要到运行时才可以获得。
   ```

3. 鉴于在一个复杂系统中，很难分辨一个初始值到底是不是常量表达式，C++11允许将变量声明为constexpr，这样编译器会验证变量的值是否是常量表达式。声明为constexpr的变量一定是个常量，且必须用常量表达式初始化，如果违反，会报错。因此为了保险起见，如果认定一个变量是常量表达式，就应该使用constexpr。

   ```c++
   constexpr int a = 4;
   constexpr int b = a+2; //正确
   constexpr int c = size(); //只有当size也是一个constexpr函数时，才正确。
   
   constexpr int size() {  //将函数声明为constexpr，这种函数足够简单以致于编译阶段就能得到计算结果。
   	int a = 3;
   	return a;
   }
   ```

4. 只有字面值类型 literal type（算术类型，引用，指针）能定义常量表达式，一般的类类型不能，字面值常量类和枚举类型可以。constexpr指针的初始值只能是nullptr/0或某个存储于固定地址的对象。函数内部定义的变量都是存储在栈上，地址不固定。定义于所有函数外边的变量的地址固定不变，定义在函数内部的static变量也具有固定地址，可以用来初始化constexpr指针。constexpr的引用也只能绑定到具有固定地址的对象上。

   ```c++
   int a = 3;
   int main() {
       int b = 5;
       static int c = 7;
       constexpr int *p1 = &a;  //正确
       constexpr int *p2 = &b;  //错误
       constexpr int *p3 = &c;  //正确
   }
   ```

5. 使用constexpr声明定义的指针都是顶层const。

   ```c++
   const int *p1 = nullptr;       //p1是一个底层const
   constexpr int *p2 = nullptr;   //p2是一个顶层const，类似于int * const p2 = nullptr
   constexpr const int *p3 = nullptr; //p3是顶层+底层const。
   ```

# 处理类型

## 类型别名

1. 随着类型越来越复杂，可以使用类型别名，两种方法：

   1. C语言定义的typedef。typedef作为声明语句中基本数据类型的一部分出现，含有typedef的声明语句定义的不再是变量，而是类型别名  ，可以嵌套使用。

      ```c++
      typedef double wages;   //wages是double的同义词
      typedef wages base, *p; //base是double的同义词，p是double*的同义词。
      ```

   2. C++11允许使用别名声明（alias declaration）。

      ```c++
      using SI = Sales_item;  //Sales_item是一个类类型。
      SI item1; //等价于Sales_item item1;
      ```

2. 类型别名和类型名等价，可以相互替换，但是遇到const和指针时，需要谨慎。

   ```c++
   typedef char *pstring;  //pstring 是char*类型
   const pstring cstr = 0; //cstr是顶层const，等价于char * const cstr = 0，即不能像宏一样将pstring直接替换进去。否则就是const char *cstr，变成底层const了。思路是先不替换pstring，将它看做一个普通的类型，则cstr是pstring的顶层const常量对象。
   const pstring *p; // p是指向pstring类型的底层const。p是一个指针，指向的对象是const的pstring对象。等价于char * const *p;
   const pstring *p;
   char * const *p2 = p;
   ```

## auto

1. C++11引入了auto类型说明符，让编译器替我们去分析表达式的类型，可以简化编程压力，可以随返回值类型的改变而改变，代码的适应性增强。

2. auto定义的变量要分析初值的类型，因此必须有初值。

   ```c++
   auto item = v1+v2; //使用v1+v2的结果来推荐item的类型。
   //auto可以一次性声明多个变量，不过需要各自的推断出来的auto类型相同
   auto i = 0, *p = &i;   //正确，因为两次推断出来的auto都是int。
   auto sz= 0, pi = 3.14; //错误，两个auto的类型不同。
   ```

3. 编译器推断出来的auto类型有时和初始值的类型不一定完全一样：

   ```c++
   //当使用引用来初始化另一个对象时，实际参与的是被引用的对象，因此推断出的类型也是被引用对象的类型，而非引用。
   int i = 0,&r = i;
   auto a = r;  //auto为int
   ```

4. auto会忽略掉顶层const，但是会保留底层const。

   ```c++
   int i = 0;
   const int a = 3, &r = a;
   auto b = a;   //auto为int，忽略掉了顶层const。
   auto c = r;   //auto为int，同上
   auto d = &i;  //auto为int*
   auto e = &a;  //auto为const int *。对常量对象取地址是一种底层const，会被保留。
   //如果希望推断出的auto是一个顶层const，需要明确指出：
   const int a =3;
   const auto f = a;  //等价于const int f = a;
   //还可以将引用设为auto
   const int a =3;
   auto &g = a;  //等价于 const int &g = a;底层const。
   auto &h = 42; //错误，不能将一个非常量引用绑定到字面值上。
   const auto &i = a;  //等价于 const int &i = a;
   ```

## decltype

1. C++11引入了decltype类型说明符，作用是返回操作数的数据类型。编译器会分析表达式的类型，但是不会计算表达式的值，相当于半个auto的功能。

   ```c++
   decltype (f()) a ; //获取f()的返回值的类型，定义一个同类型的变量a。并不会执行f函数。
   ```

2. 和auto不同，decltype保留顶层const和引用类型。引用从来都是作为绑定对象的同义词出现的，只有在decltype处例外。

   ```c++
   const int a = 3, &r = a;
   decltype(a) x = 0;  //等价于const int x = 0
   decltype(r) y = 0;  //等价于const int &y = 0
   ```

3. 如果对表达式使用decltype，而不是变量，则返回表达式结果对应的类型。

   ```c++
   int a = 3, &r = a;
   decltype(r) x = 0; //等价于 int &x = 0，会报错。
   decltype(r+0) x1 = 0; //表达式r+0结果的类型是int。所以等价于 int x1 = 0;
   //如果表达式的内容是解引用操作，则decltype的结果也是引用。
   int i = 42, *p  =&i, &r = i;
   decltype(*p) y = i;  //等价于 int &y = i;
   ```

4. decltype和auto的一个重要区别是，decltype和表达式的类型密切相关。变量名和(变量名)不同，前者直接获得是变量的类型，后者会被当做一个表达式。变量是一种可以作为左值的特殊表达式。decltype(变量)，只有当变量本身是一个引用时，结果才是引用。

   ```c++
   const int i = 42;
   decltype (i) k = i;   //等价于 int k = i; 单层括号的结果只有当括号内本身是一个引用时，才是引用。
   decltype ((i)) j = i;  //等价于 int& j = i; 双层括号的结果永远是引用。
   ```


# 表达式和运算符

1. 表达式是由运算对象和运算符组合而成。表达式的求值产生一个结果。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。复合表达式是指含有多个运算符的表达式，表达式可以分为子表达式。

2. 三元运算符有三个运算对象，函数调用也是一种特殊的运算符，运算对象数量不限。

3. 要理解表达式的含义，首先要理解运算符的优先级，结合律，求值顺序。优先级和结合律决定了运算对象的组合方式。

4. 在表达式求值的过程中，运算对象常常由一种类型转化成另一种类型。一般运算符都要求两侧的运算对象是同类型的，不过只要他们可以转化成同一类型，也可以参与运算。

5. 当运算符作用于类对象时，用户可以自定义其含义，这成为运算符重载（overload）。

6. C++的表达式只能是左值或右值。这两个名字都是从C语言继承过来的，左值可以位于赋值语句的左侧，右值则不能。但是在C++语言中，区别更为复杂：

   1. 左值表达式的求值结果是一个对象或一个函数。
   2. 虽然某些表达式的求值结果是对象，但是他们是右值，例如常量对象不能出现在赋值语句的左侧。

7. 当一个对象被用作左值时，使用的是对象的身份，即内存的位置；被用作右值时，使用的是对象的值。

8. 除了右值引用以外，在需要右值的地方，都可以用左值替代，此时使用的是它的值，反之则不可以。

9. 常见的用到左值的运算符的地方：

   1. 赋值运算符要求（非常量）左值作为左侧运算对象，结果仍然是一个左值。

   2. 取地址符作用于一个左值对象，结果是一个右值指针。

   3. 内置的解引用运算符`*`，下标运算符`[]`，迭代器解引用运算符`*`，string和vector的下标运算符`[]`的求值结果都是左值。

   4. 内置类型和迭代器的递增递减运算符作用于左值，前置版本所得的结果是左值，后置版本的结果为右值。

      ```c++
      int a = 3;
      ++a = 4; //正确
      a++ = 4; //错误
      ```

10. 观察一个运算符时，需要注意其运算对象是否是需要是左值，求值结果是否是左值。

11. decltype作用于左值（不是变量）时，得到的是一个引用，作用于右值时，就还是其本身：

    ```c++
    int a = 3;
    int *p;
    decltype(a) x;       //等价于 int x;
    decltype(*p) r = a;  //等价于 int& r = a
    decltype(&p) ptr;    //等价于 int** ptr; 因为&p是右值。
    ```

12. 复合表达式是指含有多个运算符的表达式。此时需要使用优先级和结合律将运算对象和运算符合理地组合起来，相当于加括号。从下表可以发现同一优先级的运算符，结合律是相同的。

    ```c++
    /*结合律  运算符        功能       用法*/
    左       ::          全局作用域     ::name
    左       ::          类作用域       classname:name
    左       ::         命名空间作用域    namespacename::name
    -------------------------------------------------------
    左       .           成员选择        object.member
    左       ->          成员选择        pointer->member
    左       []           下标            arr[index]
    左       ()          函数调用       func(arg_list)
    左       ()          类型构造        type(arg_list)
    -------------------------------------------------------
    右       ++          后置递增          lvalue++
    右       --          后置递减          lvalue--
    右       typeid      类型ID           typeid(type)
    右       tpeid       运行时类型ID      type(id)
    右    explicit_cast  类型转换       cast_name<type>(expr)
    -------------------------------------------------------
    右       ++          前置递增          ++lvalue
    右       --          前置递减          --lvalue
    右       ~           按位求反           ~expr
    右       ！           逻辑非            !expr
    右       -           一元负号           -expr
    右       +           一元正号           +expr
    右       *           解引用             *pointer
    右       &           取地址             &expr
    右       ()          类型转换           (type)expr
    右       sizeof      对象的大小         sizeof(expr)      //括号可以省略
    右       sizeof      类型的大小         sizeof(type)      //括号不能省略
    右       sizeof...   参数包的大小       sizeof...(name)
    右       new         创建对象           new type
    右       new[]       创建数组           new type[size]
    右       delete      释放对象           delete expr
    右       delete[]    释放数组           delete[] expr
    右       noexcept    能否抛出异常       noexcept(expr)
    -------------------------------------------------------
    左       ->*         指向成员选择的指针  ptr->*ptr_to_member
    左       .*          指向成员选择的指针  obj.*ptr_to_member
    ---------------------------------------------------------
    左       *  /  %     乘 除 取余
    ---------------------------------------------------------
    左       + -         加 减
    ---------------------------------------------------------
    左       << >>       左移 右移
    ---------------------------------------------------------
    左       < <= > >=   小于 小于等于 大于 大于等于
    ---------------------------------------------------------
    左       == !=       判断相等或不等
    ---------------------------------------------------------
    左       &           按位与
    ---------------------------------------------------------
    左       ^           按位异或
    ---------------------------------------------------------
    左       |           按位或
    ---------------------------------------------------------
    左       &&          逻辑与
    ---------------------------------------------------------
    左       ||          逻辑或
    ---------------------------------------------------------
    右       ?:          三元条件             expr?expr:expr
    ---------------------------------------------------------
    右       =           赋值
    ---------------------------------------------------------
    右  *= /= %= += -= <<= >>= &= |= ^=     复合赋值
    ---------------------------------------------------------
    右      throw        抛出异常            throw expr
    ---------------------------------------------------------
    左       ,            逗号               expr,expr
    ```

13. 高优先级的运算符比低优先级的运算符更为紧密地组合运算对象。如果优先级相同，则组合规则由结合律决定。算术运算符满足左结合律，意味着如果优先级相同，将按照从左往右的顺序组合。

    ```c++
    //根据运算符的优先级
    3+4*5; //运算对象4两侧的运算符为+和*，*的优先级更高，因此等价于3+(4*5)
    int ia[] = {1,2,3};
    int last = *(ia+3); //如果不加括号，结果就不是ia[3]了，而是ia[0]+3，等于4。
    //根据运算符的结合律
    5-3+2; //-和+的优先级相同，因此等价于(5-3)+2
    cout << a << b;     //优先级相同，<<满足左结合律，因此等价于(cout << a ) << b
    ```

14. 优先级和结合律规定了运算对象的组合方式，但是并没有规定运算对象按照什么顺序求值，大多数情况下也不会明确指定。对于那些没有明确指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，那么将会引发错误的并未定义的行为。

    ```c++
    int i = f1() * f2(); //可以肯定的是f1和f2一定会在乘法进行前调用，但是无法确定那个函数会先执行。
    int i = 0;
    cout << i << " " << ++i << endl;  //结果未定义，因为编译器可能先求右边的++i的值，再求左边i的值，此时结果1 1；也可能先求左边i的值，再求右边++i的值，结果为0 1。
    ```

15. 有4种运算符明确规定了运算对象的求值顺序：

    ```c++
    //逻辑运算符短路求值
    a && b ;  //先求左侧对象的值，只有当左侧对象为真时，才会求右侧对象的值。
    a || b ;  //先求左侧对象的值，只有当左侧对象为假时，才会求右侧对象的值。
    //条件运算符
    a ? b : c; //先求第一个运算对象的值，为真才会求第二个运算对象的值，反之求第三个运算对象的值。只对b或c求值。
    //逗号运算符
    a , b; //从左往右依次求值。
    ```

16. 运算对象的求值顺序和优先级，结合律无关。例如：

    ```c++
    f()+g()*h()+j();
    //优先级规定g()的返回值和h()的返回值相乘
    //结合律规定f()的返回值和乘积先加，然后再和j()的返回值相加。
    //但是并没有规定这些函数的调用顺序，如果这几个函数不改变同一个对象的状态，也不执行I/O任务，则先后顺序无所谓，否则应该将他们拆开成多个表达式。
    ```

17. 一般情况下，运算对象的可以按任意顺序进行求值，但是如果一条子表达式中改变了某个运算对象的值，而另一个子表达式又要用到该运算对象的值，则会引发未定义行为：

    ```c++
    auto beg = s.begin();
    while(beg != s.end() && !isspace(*beg)){
        *beg = toupper(*beg++);  //赋值运算符的左右两端都用到了beg，而且右端还更改了beg的值。如果先执行左侧，等价于*beg = toupper(*beg);beg++;  如果先执行右侧，等价于*(beg+1) = toupper(*beg);beg++; 
    //VS2022是先对右侧求值。先对右侧求值会导致结果不是string("ABCD efg")。同时会对尾后位置解引用。
    }
    string s("abcd efg");
    //将字符串s中的第一个单词改成大写形式。
    for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it){ //将解引用it和递增it放在两个表达式中，结果不会受求值顺序影响。使用&&来规定求值顺序，只有当it不是尾后时才会对it解引用。
        *it = toupper(*it);
    }
    ```

18. 复杂情况，一般不建议书写复杂的表达式，建议将其拆分，提高代码的可读性。：

    ```c++
    //使用迭代器逐个对容器对象进行操作，比较很常见的用法。
    *++iter; //因为必须进行++操作，才可以进行解引用，此时解引用的是递增后的。
    *iter++; //后置递增的优先级比解引用高。因此相当于*(iter++)，不过解引用的还是递增前的。
    int a[] = {1,2,3,4,5};
    for (auto beg = begin(a); beg != end(a);) {   //功能是输出，再递增
        std::cout << *beg++ << std::endl;  //依次输出 1 2 3 4 5
    }
    for (auto beg = begin(a); beg != end(a)-1;) { //功能是递增，再输出
        std::cout << *++beg << std::endl;  //依次输出 2 3 4 5 -858993460
    }
    ```

19. C++语言没有规定大部分二元运算符的求值顺序，这给编译器优化留下了空间，这种策略是在代码生成效率和程序潜在缺陷之间进行了权衡。

20. 算术运算符有7个，+ - * / % + -，%是取余，最后是一元正号和一元负号。算术运算符的运算对象和求值结果都是右值。算术运算符都能作用于所有的算术类型，同时一元正号，加法，减法还可以作用于指针。

21. 一元正号作用于一个指针或算术值时，返回运算对象值提升后的一个副本；一元负号作用于算术值时，返回结果是提升后的：

    ```c++
    short a = 4;
    auto b = +a;  //  b的类型为int。
    auto c = -a;  //  c的类型为int。
    bool d = true;
    auto e = -d;  //e的类型是int，结果为-1。实际上先将d提升为int，结果为1。
    bool f = -d;  //f的结果为true。实际上是将-d的结果，一个int类型的-1用来初始化f。
    ```

22. 整数相除的结果还是整数，小数部分会被舍去。C++语言的早期版本允许结果为负值的商向上或向下取整，C++11标准中规定一律向0取整，也就是直接取出小数部分。取余运算的运算对象必须是整数。

    ```c++
    auto a = 22 / 7;  //结果为3，int类型。
    auto x = 22 % 7.5;  //错误。
    ```

23. 取余运算需要满足：$(m/n)*n+m%n$​的结果和m相等。也就是说如果m%n不等于0，那么他的符号和m的相同。C++的早期版本允许m%n的符号匹配n的符号，且商向负无穷一侧取整。不过这一做法在新标准中已经被禁止了。除了-m导致溢出的情况，其他时候都满足下面的式子：

    ```c++
    (-m)/n == m/(-n) == -m/n ; //三个的结果相等。
    m%(-n) == m%n;
    (-m)%n == -m%n;
    ```

24. 关系运算符作用于算术和指针类型，有 <  <=  >  >=  ==  !=；逻辑运算符作用于任意能转化为bool值的类型，有!  &&  ||。关系运算和逻辑运算的结果都是bool类型的右值。

25. 关系运算符返回值为bool值，连用的话会引发意外：

    ```c++
    int i=-2,j=-1,k=0;
    bool x = i < j < k;  //x的结果为false。因为i<j的结果是true，因此会计算1 < k。
    bool y = (i<j)&&(j<k); //结果为true
    ```

26. 可以将一个算术对象或指针当做条件，来测试他们的真值。这种方法比和true比较要好：

    ```c++
    if (val){}  //当val非零，则为真，会进入if条件。
    if (!val){} 
    //错误写法
    if(val == true){} //这种写法冗长，且如果val不是bool值时，==运算符比较的不是两个布尔值。会先将true转化为val的类型，在进行相等比较。例如当val=2时，val == true的结果为false。
    //上面的代码等价于判断val是否等于1。
    ```

27. 赋值运算符的结果是它的左侧运算对象，仍然是一个左值。如果左右两侧运算对象的类型不同，会先将右侧的转换为左侧的。

    ```c++
    int a ;
    a = 3.4;   //等价于a = 3;
    ```

28. C++11标准允许使用花括号括起来的初始值列表作为赋值运算符的右侧对象。对于类类型来说，赋值细节由类来定义，vector模板重载了赋值运算符，==会调用拷贝赋值函数，是不是只适用于单个对象的拷贝，还是也适用于初始化列表？==

    ```c++
    int k;
    k = {3,4,5};  //如果左侧对象是内置类型，那么初始值列表最多只能包含一个值。
    k = {3.4};  //错误，因为存在丢失信息的风险，所以编译器会拒绝赋值。
    vector<int> vec;
    vec = {1,2,3,4};  //正确
    //可以是空列表{}
    k = {};  //等价于k = {0};
    vec = {};  //vec还是空的，没有任何元素
    ```

29. 赋值运算符满足右结合律，这一点和其他二元运算符不同。

    ```c++
    int ival, jval;
    ival = jval = 0;  // 相当于  ival = (jval = 0);
    
    int ival, *pval;
    ival = pval = 0;  //错误，虽然0可以赋值给ival和pval，但是不能连起来写，因为pval=0的结果是一个int*类型的数据，不能赋值给ival。
    ```

30. 赋值语句的优先级较低，如果放在条件中的话，需要加括号：

    ```c++
    int i;
    if ((i = getval()) !=3){ /*可以在此处使用i*/  }   //先执行getval函数，再赋值给i。判断是否等于3
    ```

31. C++允许使用相等运算符作为条件，但是可能会带来意外，有的编译器会提示这点。常见的错误是使用=代替\==进行比较运算。

32. 每种算术和位运算符都有其复合赋值的形式。按位求反运算符没有复合赋值形式。

    ```
    += -= *= /= %=
    >>= <<= &= ^= |=
    ```

33. 递增，递减运算符可以应用于迭代器，因为很多迭代器对于算术运算是不支持的。这两种运算符分为前置和后置版本，必须作用于左值，前置版本返回左值，后置版本返回右值。

    ```c++
    int a = 0, b;
    b = ++a;  //前置版本，递增a，然后将新的a作为表达式的求值结果。b=1
    b = a++;  //后置版本，先保存一个a的副本tmp，递增a，然后将tmp作为表达式的求值结果。b=0
    
    int* c = &a;
    c = &(++a);  //c的值没有发生改变，还是a的地址。
    c = &(a++);  //错误，后置运算符返回的是右值，无法取地址。
    ```

34. 除非必须，否则不用后置版本的运算符，因为后置版本要保存一个临时值用于返回，前置版本可以避免不必要的工作。对于整数和指针来说，编译器可能对这种额外的工作进行优化，但是对于相对复杂的迭代器类型，这种额外的工作就比较大了。

35. 在一个表达式中，递增变量，并使用原来的值，可以用后置运算符。后置递增运算符的优先级高于解引用符，因此不用加括号。

    ```c++
    vector<int> vec = {1,2,3,4,5};
    auto pbeg = vec.begin();
    while(pbeg!=vec.end()){
        cout << *pbeg++ << endl; //输出的是迭代器原来指向的元素，然后将迭代器移动到下一个元素，退出循环时，迭代器指向尾后位置。如果使用前置运算符，会略去首元素，而且会解引用尾后位置并不存在的元素，引发运行时错误。
    }
    ```

36. 箭头运算符作用于指针或迭代器时，结果是左值。点运算符作用于左值时，结果是左值；作用于右值时，结果是右值。

    ```c++
    string s("abc"),*p = &s;
    auto c = p->size(); //等价于(*p).size()，括号不能省略，因为点运算符的优先级比解引用运算符高。
    ```

37. 条件运算符允许将简单的if-else语句嵌入到单个表达式中。当条件运算符的后两个表达式都是左值或能转换成同一种左值类型时，结果也是左值，否则，结果为右值。条件运算符的优先级特别低，因此一般都要加括号：

    ```c++
    int grade = 30;
    cout << (grade < 60 ? "fail" : "pass") << endl;  //正确，输出fail或pass
    cout << (grade < 60) ? "fail" : "pass" << endl;  //语法错误，先执行 grade<60 ，然后将结果输出到cout，然后将cout作为条件运算符的条件，如果上一步输出没错误，则cout为有效，条件表达式的结果为"fail"，然后执行 "fail" << endl。
    cout << grade < 60 ? "fail" : "pass" << endl;    //语法错误。先输出grade，然后试图比较cout和60。
    ```

38. 位运算符作用于整数类型的运算对象，把运算对象看做二进制位的集合，也就是位串。提供检查和设置二进制位的功能。标准库bitset类型支持任意大小的二进制位集合，也可以使用位运算符。位运算符都满足左结合律。运算对象可以是带符号的，也可以是无符号的。如果运算对象是有符号的，且是负的，那么位运算符如何处理符号位依赖于机器，此时左移可能会改变符号位，因此是一种未定义的行为。因此强烈建议仅将位运算作用于无符号数。

    ```c++
    //一共有6个
    <<   >>   &  |  ~   ^
    //左移 右移  与 或 取反 异或
    ```

39. 移位运算要求右侧运算对象不能为负数，而且该值必须小于移位运算结果的位数，否则将产生未定义的行为。移位运算移出边界的位会被舍去。

    ```c++
    unsigned char bits = 0233;  //八进制数，二进制表示为10011011
    bits << 8;  //bits先被提升为int类型提升是，高位补0，然后向左移动8位，结果为00000000 00000000 10011011 00000000。因为结果是int类型，所以允许移动0→31位。
    bits << 31;  //结果为 10000000 00000000 00000000 00000000。
    bits >> 3;   //结果为 00000000 00000000 00000000 00010011。
    
    ~bits;  //首先被提升为int类型，然后按位求反，结果为 11111111 11111111 11111111 01100100
    //异或，相等为0，不等为1。
    unsigned char bits1 = 0b000,bits2 = 0b101;
    auto x = bits1 ^ bits2;  //结果为 0b101
    ```

40. 左移运算符就是在右侧插入0，右移运算符的行为依赖于左侧运算对象的类型，如果是无符号数，则插入0，如果是有符号数，插入符号位或0,，具体行为依赖于环境。

41. 可以通过位运算来设置，清除，查询指定的位的状态：

    ```c++
    unsigned long a = 0b00001111;  //32位都是0
    a |= 1ul << 3;     //将第3位设为1，从右往左开始计数，从0开始。
    a &= ~(1ul << 3);  //将第3位设为0。
    auto x = a &(1ul << 3); //查看第3位的状态，结果非零表示第三位为1，反之为0。结果为0b00001000。可以用bool值接收，也可以再将结果右移3位。
    ```

42. 移位运算符满足左结合律。优先级不高不低，比算术运算符低，比关系，赋值，条件运算符高。因此用来进行IO时，建议多加括号。

43. sizeof运算符返回表达式或一个类型名所占的字节数。结果为size_t类型的常量表达式。sizeof作用于表达式时返回的是结果类型的大小，但并不计算对象的值。两种使用方法，加不加括号都行：

    ```c++
    int *p = nullptr;
    sizeof *p;  //不会报错，因为sizeof 不会对表达式求值。不需要解引用，也可以知道所指对象的类型。
    
    Sales_data s1;
    sizeof s1.revenue;
    sizeof Sales_date::revenue;  // C++11允许使用作用域运算符获取类成员的大小，这样不用借助类的对象。
    int arr[3];
    sizeof arr;  //结果为3*4=12。sizeof不会将数组名转化为指针来计算。
    constexpr size_t cnt = sizeof arr/sizeof arr[0];  //结果为3，可以据此计算数组中元素的个数。
    vector<int> vec;
    sizeof vec;  //结果为16，计算的是类中维持操作所需要的数据成员大小，元素是单独存储的，不计入这里。
    vec.push_back(1);
    sizeof vec; //结果同上，实际上sizeof是在编译时就得出结果的，即使vec的大小发生了变化，也无法反映出来。
    ```

44. 逗号运算符，有两个运算对象，规定了运算对象求值的顺序。先求左侧的，把值丢弃，再求右侧的值，作为表达式的结果。如果右侧运算对象是左值，最终结果也是左值。经常用在for循环内：

    ```c++
    for (int a = 5, b = 4; (a > 0) && (b > 0); a--, b--) {
        cout << a << "  " << b << endl;
    }
    ```

45. 大部分的运算符都是左结合的，也就是说同一个优先级的运算符并列，会优先计算左边的运算，相当于给左边加了括号。赋值运算，复合赋值运算就是右结合的：

    ```c++
    a+b+c  //相当于(a+c)+c，当然由于加法具有交换律，看不出来差异。
    a/b/c  //相当于(a/b)/c，如果除法是右结合的，那么结果就是a/(b/c)，二者就不同了。
    a+=b+=c  //相当于a+=(b+=c)
    ```

46. <<和>>操作符的运算顺序都是从左往右。

47. 使用点运算符.来获取类对象的成员；使用调用运算符()来调用函数，括号内为实参列表。

48. C语言标准库在iso646.h定义了一批常见运算符的可选拼写，这些宏可以帮助非QWERTY键盘的用户使用C语言的逻辑运算符：

    ```c++
    #define and &&　
    #define and_eq &=　
    #define bitand &　
    #define bitor |　
    #define compl ~　
    #define not !　
    #define not_eq !=　
    #define or ||　
    #define or_eq |=　
    #define xor ^　
    #define xor_eq ^=　
    ```

49. and虽然不是C++的保留关键字，但是C++的保留替代标记。在c++语言中可以直接使用and。但是在C语言中需要包含iso646.h才可以。有的C++编译器不支持and，包含\<ciso646\>即可。类似的还有：

    ```c++
    and     not    or      xor
    not_eq  or_eq  xor_eq  and_eq
    bitand  bitor
    compl
    ```

# 基于对象程序设计

1. 如果初始化类对象是由类本身规定的，一个类可以定义多种初始化方法，它们之间必须有区别，例如初始值的数量或类型的不同。
2. 一个类既可以定义通过函数名调用的操作，也可以定义各种运算符作用在它的对象上面的含义。


## 类的定义

1. 类以关键字struct或class开头，后面是类名和类体。类体由花括号包围形成了一个新的作用域。类内部定义的名字必须是唯一的，可以和外部定义的名字重复。

2. 类体的右`}`后必须用分号结束，这是因为类体后面可以紧跟变量名，用来直接定义该类的对象，不过不建议这么做。

   ```c++
   class base{
       //类体可以为空
   } newbase1, *pbase;  //定义了一个base类型的对象newbase1，和一个指向base对象的指针pbase。
   ```

3. C++11标准规定，可以为类的数据成员提供一个类内初始值（in-class initializer）。创建对象时，类内初始值将用于初始化该数据成员，没有初始值的成员会被默认初始化。

   ```c++
   class Sales_data{
       std::string bookNo;          //被默认初始化为空字符串
       unsigned int units_sold = 3; //使用类内初始化初始化
       double revenue = 5.0;        //使用类内初始化初始化
   }
   ```

4. 类内初始值的形式比变量初始化要少一种方法：

   ```c++
   class Sales_data{
       int a = 0;
       int b = {0}; 
       int c{0};
       int d(0);  //错误
   }
   ```

5. 可以将类定义在函数内（局部类），但是不推荐。一个类可能会被多个文件使用，为了使各个文件中的类保持一致，类通常被定义在头文件中，而且类所在的头文件的名字应该和类名一致。例如Sales_item类定义在Sales_item.h中。

6. 成员函数可以在类中定义，也可以类内只写声明，在类外定义。在类外定义的时候要加上类名::，否则视为普通函数。在类内部使用类的成员不用限定符::，例如：

   ```c++
   class complex{
   public:
       complex (double r = 0, double i = 0):re (r),im (i){}   //在初始化列表中使用实参初始化成员变量，函数体为空。
       complex& operator += (const complex&);  //类内仅声明
       double real() const {return re;}
       double imag() const {return im;}
   private:
       double re,im;
   };    //类的结尾要加分号;
   
   complex& complex::operator += (const complex& c){  //类外的定义
       //这里已经进入到类的作用域内了，可以直接使用类的成员。
       this.re += c.re
       this.im += c.im
       return *this;
   }
   
   complex c1;   //在栈上创建对象。
   c1.re = 5;   //会报错，在类外访问私有变量。
   ```

7. C++中函数分为两大类，一种是类的成员方法，必须在类内声明，但可以在类内或类外定义，另一种是普通函数。

8. 在类外定义的函数如果具有默认参数，只需在声明处写上默认参数即可，定义处不用也不能再写，否则会报错：

   ```c++
   Student(int a = 3 , char *n = "default name"); //函数声明
   Student::Student(int a, char *n ) { }    //函数实现
   //还有默认参数的函数定义了一组函数，只能有一个共同的函数体。
   ```

9. 普通函数例如操作符重载，声明写在.h文件中，定义写在.cpp中。如果都写在.h中会出现重定义，因为该类的cpp和main.cpp都会包含这个函数，这两个cpp文件各自编译，其内部都有该普通函数的实现，会造成冲突。如果非要将普通函数的实现写在.h中，可以加上inline避免重复定义。

10. 全局变量为了避免重复定义，都应只写在.cpp中，在其他类中使用该全局变量，使用extern int glint之类的语法说明。如果是只有一个.h的类。就可以都写在.h文件中。

    ```c++
    /*student.h*/
    #include<iostream>
    using namespace std;
    ostream& operator <<(ostream& os, const student& stu);
    
    /*student.cpp*/
    #include "student.h"
    int glint;
    ostream& operator <<(ostream& os, const student& stu){
        //实现
    }
    
    /*main.cpp*/
    #include "student.h"
    extern int glint;
    ```

11. C语言中使用struct定义结构体这种复合数据类型，使用该类型时还要加上struct关键字，为了方便可以使用typedef化简。在C++中则不用typedef，可以直接省略struct来将它当做一个类来使用。和class不同的是，如果不显式声明访问级别，struct的成员默认是public，class的成员默认是private。

    ```c++
    /*  C语言写法  */
    typedef struct _tag_student student;  //可以放在结构体的定义前。
    struct _tag_student { //定义了一个结构体类型struct _tag_student。
        char name[10];
        int age;
    };
    //使用
    struct _tag_student s;
    student s1; //使用别名
    
    /*  C++写法  */
    struct _tag_student {
    	char name[10];
    	int age;
    };
    //使用
    _tag_student s1;
    ```

## 访问级别

1. 类的成员可以使用public，private，protected关键字来规定==访问级别==。可以分段写，不过相同权限的一般都写在同一块。直到遇见下一个权限关键字之前，一直有效。一般来说成员变量都应该放在private中。数据应该是封装起来，不应直接被外界任意操作。protected和继承相关。
2. 使用set或get函数来设置或访问类的成员变量有如下好处，当成员变量的存储空间或名称发生变化时，只需要修改类的成员函数即可。如果没有这层封装，就需要对所有使用到该成员变量名的地方进行修改。
3. 编译器自动生成的各种构造，拷贝构造，析构函数都是public的。

## 构造函数

1. 构造函数：创建对象的时候会被自动调用。构造函数名和类名相同，没有返回值类型，因为返回值就是创建的对象，不必写，写了还容易写错。

2. 构造函数一共有以下几类：

   1. 默认构造函数，可以是编译器合成的，也可以是自定义的，特点是没有参数。

   2. 拷贝构造函数，只有一个参数，就是该类型的引用 T&。const与否都行，一般应该是const。
   3. 移动构造函数，只有一个参数，是该类型的的右值引用 T&&。const与否都行，一般应该是const。
   4. 转换构造函数，只有一个参数，一般是是其他类型的对象的引用。const与否都行，一般应该是const。
   5. 普通构造函数，除了以上的都是这一种。

3. 创建对象的方式：

   ```c++
   complex c1(1,2);  //显示调用构造函数创建对象。对象放在栈上。
   complex c2;       //调用默认构造函数。等价于complex c2()。对象放在栈上。
   complex* p = new complex(4,5);  //在堆上创建对象，new返回一个指针。
   complex& r = *(new complex(4,5)); //对象也在堆上，只不过用引用接受对象。
   complex s = *(new complex(4,5)); //先在堆上创建了临时对象，然后通过拷贝构造又在栈上创建了一个对象s。原来的堆上的临时对象变成了内存泄露。需要避免这种情况。
   complex* p1 = NULL;  //并不创建对象，只是在栈上定义了一个指针而已。
   complex(1,2);      //创建了一个未命名的临时对象，也成为匿名对象。
   ```

4. 一般情况下不会像调用普通函数那样直接调用构造函数，例如 complex (1, 2)。这种方式会生成一个匿名的临时对象，该对象在该行结束后就被析构。

5. 构造函数不负责分配对象占用的存储空间，而是在已经分配空间后，进行初始化的。

6. 任意函数的参数都可以有默认值，构造函数也不例外。如果没有人为定义任何构造函数，编译器会生成一个默认的无参构造函数，什么都不做。

   ```c++
   class complex{
   private:
       double real,img;
   public:
       complex(double r, double i=0);  //这样就不会生成默认的无参构造函数。
   };
   /*使用*/
   complex c1; //会报错，因为没有对应的构造函数。
   ```

7. 构造函数具有初始化列表(其他函数没有有)，写在参数列表之后，用：分隔。初始化列表是用来为对象的成员进行初始化的，它在构造函数体之前执行。

   ```c++
   class complex{
   public:
       complex(double r=0, double i=0)
           : re(r),im(i)  //初始化列表，这里是初始化。结果相同，阶段不同。可以不用单独一行。
           {...}
       //另一种写法是写在{}内部
       complex(double r=0, double i=0){
           re = r;        //这是赋值,浪费了初始化阶段，虽然结果相同，效率会比上面的低。
           im = i;
       }
   }
   ```

8. 初始化列表也可以用来初始化类的成员对象：

   ```c++
   class Tyre {
   	int radius;
   public:
   	Tyre(int radius) :radius(radius) {}
   };
   class Car { //对于封闭类，必须有自定义构造函数，因为编译器默认的构造函数，不知道如何初始化其中的成员对象。
   	int price;
   	Tyre t;
   public:
   	Car(int price, int radius) :price(price), t(radius) {}  //编译器会自动调用构造函数来初始化t。
   };
   Car c1(20000,10);
   ```

9. 初始化列表中（）内可以是任意的表达式。但一个类中有多个成员对象时，初始化的顺序和声明顺序相同，和初始化列表的顺序无关。实际上是按照内存布局的先后来初始化。

10. 有时为了控制对象的创建，可以将构造函数放在private区域内，然后用另一个成员函数来调用构造函数产生对象。这样可以在该成员函数内控制对象的创建。单例模式可以用这个方式实现。

11. 变量的值设定有两个阶段，一个是初始化，一个是赋值。

12. 构造函数不能是常量成员函数，即不能再()后面加const，这个位置正好留给初始化列表使用。

## this指针

1. 类的成员函数都会带有一个隐藏的参数this指针，就是指向调用对象指针。但是书写成员函数时，不能显式地写出来。编译的时候会自动传参和使用，有可能是第一个参数，也有可能是最后一个。

2. 默认情况下，一个成员函数要区分地处理多个对象，是依靠调用函数时传入的this指针：

   ```c++
   complex c1,c2;
   c1.real();   //相当于调用complex::real(&c1);
   c2.real();   //相当于调用complex::real(&c2);
   ```

3. 成员函数中如果要使用对象的成员变量，可以用this->变量名，也可以直接用变量名，编译器会自动加上指针：

   ```c++
   class complex{
   public:
       double real()const{return re;} //相当于return this->re;  不同的对象调用该成员函数，this会指向特定的对象。
   }
   ```

4. this本质上是一个指针常量（complex * const this），不可以修改this的指向，但是可以修改*this的内容。

5. 在构造函数的初始化列表中无法使用this指针，但是构造函数内部是可以使用this。实际上在初始化列表执行之前，对象就已经构建成功了，此时this指向是有效的，但是编译器认为对象需要先初始化之后才可以被使用。

   ```c++
   complex(int re = 0, int im = 0):re(re), im(im)   //构造函数的参数名称可以和成员变量相同，编译器可以区分初始化列表中的这两个。不必也不能使用this->re(re)
   {
       this->im=3;  //这里是成员变量的赋值。
       std::cout << "create a complex object" << std::endl;
   }
   ```

6. 在类的成员函数中操作成员变量时，可以直接使用变量名，也可以使用this->变量名。如果方法中存在==和成员变量名称相同的参数==，则形参会覆盖成员变量名，成员变量只能通过this->变量名来使用。

   ```c++
   class Point {
   public:
       Point(int x, int y) : x(x), y(y) {}
   	void setX(int x) {x = x;} //形参x覆盖了成员变量x。
   public:
   	int x,y;
   }; 
   Point p(1, 2);
   p.setY(4);      //此时p仍然为(1,2)
   ```

7. 大多数编译器通过ecx寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。

8. 空指针调用函数：

   ```c++
   class A{
       int i;
   public:
       void hello(){cout<< "hello" <<endl;}
       void printi(){cout<< i <<endl;}
   };
   /*使用*/
   A* p = NULL;
   p->hello();  //运行正确，this为NULL。
   p->printi(); //运行时错误，因为尝试去读取NULL。
   ```

## 类的拷贝

1. 一个类的拷贝控制成员有5种函数，分别为拷贝构造函数，拷贝赋值函数，移动构造函数，移动赋值函数，析构函数。一个类的拷贝构造，拷贝赋值，析构函数被称为它的Big Three。

2. 拷贝构造和拷贝赋值函数，如果类没有显式写出，则编译器会自动生成一个合成的，只是进行逐个复制对象的成员。对于complex类是没有问题的，而对于类内含有指针的string类，就不行了，因为这样会导致不同对象的指针成员变量指向同一块内存。

3. 拷贝构造函数的参数只能是本类的引用或const引用，不能是本类的对象。

   ```c++
   class complex{
       complex(complex&);
       complex(const complex&); //该函数和上面的函数可以同时存在。不过编译的时候会报warning,提示有多个拷贝构造函数。一般都用const版本的。
   };
   ```

4. 如果一个函数的形参接受一个类的对象，而不是引用或指针，那么传参时会调用拷贝构造函数，在函数创建一个局部的对象。返回值的情形也是一样的：

   ```c++
   complex A(complex a) {
   	return a;
   }
   /*使用*/
   complex c1(1, 2);
   A(c1);  //会调用两次拷贝构造函数，一次是传参，一次是返回值。
   ```

5. 如果要在类内定义静态成员变量用于记录对象的个数，那么就需要在所有构造函数（包括拷贝构造函数），还有析构函数中进行++或--的操作。

6. 内部不含指针变量的类进行==浅拷贝==即可，例如complex。内部有指针变量的类需要进行==深拷贝==，例如string。默认的拷贝构造和拷贝赋值函数都是浅拷贝。

7. 拷贝构造和拷贝赋值的区别，前者会调用构造函数创建新的对象，后者只是修改一个已有的对象，使之和参数对象一样。

8. 具体调用场景：

   ```c++
   complex rc1(c1);    //拷贝构造
   complex rc2 = c1;   //和上面的等价，也是拷贝构造，不建议这么写。
   rc2 = c1;           //拷贝赋值，此时rc2已经存在了
   complex& rc3 = c1;  //不进行拷贝，相当于创建了一个引用变量，也就一个指针的大小。
   ```

9. 像string这样的类，真正的字符串内容一般不是以数组的形式存储在对象内，而是在堆上开辟一块内存（方便自适应大小），对象内留有该内存的指针。一般来说栈上的空间较小，容易发生栈溢出stack overflow。占据大量空间的对象需要在堆上创建，而且栈上的内存大小是编译时就确定的，不能满足string可变大小的要求。

10. 带有指针变量的类的拷贝赋值函数，在最开始需要检测一下是否是自我赋值，如果是自我赋值，可以避免重新释放申请资源，效率提高。检测是否是自我赋值，可以节省很多步骤，提高效率。除此之外，不检测的话，会导致释放完资源后，后面在复制的源就变得不确定了。

    ```c++
    class string{
    public:
        string(const char* cstr = 0){    //构造函数
            if (cstr){
                m_data = new char[strlen(cstr)+1];
                strcpy_s(m_dta,strlen(cstr)+1,str);
            }else{
                m_data = new char[1];  //如果new的数组只有一个，则可以省略[1]。这么写是为了和上面统一。同时在析构函数中，可以用delete[]统一释放内存。
                *m_data = '\0';
            }
        }
        string(const string& str){       //拷贝构造函数
            m_data = new char[strlen(str.m_data) + 1];
            strcpy_s(m_data, strlen(str.m_data) + 1, str.m_data);
        }
        string& operator =(cosnt string& str){   //拷贝赋值运算符
            if(this == &str){  //判断是否是自我赋值。这样是检测是否是同一个对象,不推荐使用检测成员变量是否相同来判定是否是自我赋值的方法。
               return *this;   //不可以return str,因为const不能赋值给非const。同时,内置类型的赋值运算的结果都是等号左侧的运算对象。
            }
            delete [] m_data;
            m_data = new char[strlen(str.m_data)+1];
            strcpy_s(m_data,strlen(str.m_data)+1,str.m_data);
            return this;
        }
        ~string(){
            delete [] m_data;     //释放掉m_data指向的内存。
        }
        char* get_c_str() const { return m_data; };
    private:
        m_data;
    }
    ```

11. string类如果使用默认拷贝构造，会造成两个对象共享同一块堆内存。如果使用默认的拷贝赋值，会使得等号左边对象的堆内存没有指针指向，造成内存泄漏，同时两个对象又都共享了右边对象原来的堆内存。

12. 带指针的类的合理的拷贝构造函数应该new一块新的内存，然后将被拷贝对象的堆内存memcpy到左边对象新分配的内存中。合理的拷贝赋值函数应该先执行类似拷贝构造的操作，即new一块内存，然后将右边对象的堆内存memcpy到左边对象新分配的内存中，然后再delete左边对象原来的内存指针。

## 析构函数

1. 所有类都只能有1个析构函数，要么是自定义的，要么是自动生成的，没有指针变量的类一般不需要手动写析构函数，默认的就够用了，默认的只会释放类的成员变量占据的内存空间。

2. 析构函数没有参数，没有返回值，不能被重载，且不能主动调用。

3. 析构函数会在栈上的对象离开作用域时自动调用，堆上的不会自动，因为它的作用域是全局的，heap又被称为system heap。通过delete 指针来隐式调用析构函数，并释放占据的内存空间。

   ```c++
   {  //作用域开始
       String s1;   //栈上的对象，超出作用域会主动调用析构。
       String s2("hello");//栈上的对象，超出作用域会主动调用析构。
       String* p = new String("world");  //堆上的对象，作用域是全局的，任何地方都可以直接访问，因此不会主动调用析构。
       delete p;    //析构p指向的对象。p本身是一个局部的指针变量，在栈上，会被自动回收的。
       static String s4;  //直到程序退出时才会自动调用析构函数。
   }  //作用域结束
   String s5;  //全局对象，在main前被构造，main结束时析构。静态局部对象和全局对象都是最后析构，全局对象更靠后些，因为C++语法规定，先被构造的对象，后被析构。
   ```

4. 数组对象也会依次调用构造和析构函数：

   ```c++
   {
       complex ca[3] = { 1,2,3 }; //从前往后依次调用构造函数，从后往前依次调用析构函数。二者的顺序正好相反。
   }
   ```

## 常量成员函数

1. 类的成员函数根据是否会改变调用它的对象的成员变量，可以分为常量和非常量成员函数。只有成员函数才可以在()后使用const，普通函数只能对参数限定const，因为const实际上修饰的是this指向的对象。

2. 常量成员函数需要在参数后，函数体前面加上const修饰（即()后，{}前）。如果一个函数设计上不会改变对象（即*this）的数据，则应加上const，这是接口设计时应该确定的。这样调用者在使用时，也会放心。因为this是隐式传入的，无法对他指定const，因此只能在函数层面指定const。这样this会变为 const complex * const this类型的了。

3. 一个成员函数是否可以加const和是否修改静态成员变量无关，因为静态成员不属于任何一个对象，不是用this来索引的。同时也不能调用该类的非常量成员函数，因为这样会发生const指针赋值给非const指针，静态成员函数除外，因为它没有this。

4. 常量对象（对象的数据不能被改变）只能调用常量成员函数，否则编译器认为类型保护被削弱了。常量对象只能在定义时进行初始化，之后便不能再赋值。一般对象两种函数都可以调用：

   ```c++
   double complex::real() const {return re;}
   double complex::imag() const {return im;}
   double imag1()const;  //声明和定义分开的函数需要这样写。
   const complex c1(2,1);   //创建一个常量对象。
   c1.re = 4;  //会报错，因为c1只能在初始化的时候设定值，之后不能再赋值。这里即使re是public的也会报错。
   cout << c1.real();     //如果real函数不是const修饰的。那么这次调用编译器会报错。
   ```

5. 构造函数和五大拷贝控制成员都不能加const。因为他们都会修改成员变量。

6. 成员函数的常量和非常量版本可以作为重载而同时存在。如果只有非常量版本存在，const对象调用该函数会报错，普通对象则不会。如果只有常量版本存在，任何对象调用该函数都不会报错。如果同时存在，const对象只会调用const版本的成员函数，普通对象只会调用普通版本的成员函数。

7. 

8. 标准库中的字符串类basic_string(string就是basic_string重新定义了下名字)，对操作符[]进行了两种形式的重载，const和非const的。

   ```c++
   charT operator[] const (){ }   //由于不会改变对象的数据，因此不用考虑COW。
   reference operator[] (){  }    //可能会修改到对象的数据，因此内部需要进行COW的考虑。
   ```

9. 标准库中的字符串使用了引用计数功能，可以实现Copy on Write。因此在函数可能会修改到内容的地方都要设计复制新内容的部分。

## 类型转换函数

1. 有时候需要将类的对象转化为其他类型的数据，或者将其他类型的数据转化为类的对象。转换函数的名称可以是任何编译器认识的类型，不一定要是基本数据类型。

2. 转换函数不可以有参数，相当于一元运算符。返回值类型也不用写，也不能写，和函数名相同。转换函数不会改变对象本身，因此应加上const。例如将分数类转化为浮点数：

   ```c++
   class Fraction{
   public:
       Fraction(int num, int den = 1):m_numerator(num), m_denominator(den){}
       operator double() const {return (double)(m_numerator/m_denominator)}
       operator std::String() const { ... }   //将Fraction对象转化为String对象。
   private:
       int m_numerator;  //分子
       int m_denominator;//分母
   };
   /*使用*/
   Fraction f(3,5);
   double = 4+f;     //结果为d=4.6。
   double(f);        //转换函数也可以显式调用。
   ```

3. 编译器在编译最后一行时，会进行如下操作：

   1. 寻找是否存在一个全局的+操作符重载函数，第一个参数为int或double(因为int可以隐式转化为double)，第二个参数为Fraction对象。
   2. 寻找Fraction类是否有一个double的转换函数。
   3. 以上步骤不分先后，找到且只找到一个才可以编译通过，不能重复。

## 转换构造函数

1. 转换构造函数和拷贝构造函数的区别是前者的参数可以是任意类型的，后者只能是该类型的。

2. 下面Fraction类的构造函数是2个parameter，但是1个argument，因为den参数有默认值，即只需要一个实参就可以创建对象。

3. 这种构造函数也可以起到转换的功能，将其他类型的对象，转化为该类型的对象，和前面类型转换函数不同的是，这个是构造函数，因为要产生一个该类的对象。

   ```c++
   class Fraction{
   public:
       Fraction(int num, int den = 1):m_numerator(num), m_denominator(den){}
       Fraction operator +(const Fraction& f) const {return Fraction(...)}
   private:
       int m_numerator;  //分子
       int m_denominator;//分母
   };
   
   Fraction f(3,5);
   Fraction f = 12; //会调用类型转换构造函数,但是不会创建临时对象,相当于Fraction f(12)。
   f =9;  //先调用类型转换构造函数，生成一个临时对象，然后调用拷贝赋值函数，给f赋值。
   Fraction f1 = f+4;  //先调用构造函数生成一个临时对象，在调用+重载函数，最后不会调用拷贝构造函数。不过如果将+4去掉，则会调用拷贝构造函数。
   ```

4. 编译器在编译最后一行时，会进行如下操作：

   1. 寻找是否存在一个全局的+操作符重载函数，第一个参数为Fraction对象，第二个为int(double)。
   2. 寻找Fraction类是否有一个+操作符重载的成员函数，接受int(double)参数。
   3. 以上步骤不分先后，找到且只找到一个才可以编译通过，不能重复。

5. 上面的第一步没有找到，第二步中也没有找到，但是发现了一个类似的+操作符重载的成员函数，该成员函数接受一个Fraction对象，由于Fraction中存在一个非显式单参的构造函数，因此可以将4转化为Fraction对象，然后调用operator +(const Fraction& f)函数。

6. 需要注意的是，仅有一个非显式单参构造函数不足以让f+4可以通过编译，operator +(const Fraction& f)的存在才使得这条路可以走的通。

7. 如果上面的非显式单参构造函数和double转换函数并存，那么编译器不知道是将对象f转化为浮点数，还是将4转化为Fraction。从而会产生错误。

8. 如果在单参的构造函数前加上explicit，则表明，该构造函数只能被显式调用，不可以用于类型转换。

   ```c++
   explicit Fraction(int num, int den = 1):m_numerator(num), m_denominator(den){}
   ```

9. explicit关键字只用在构造函数前，用于限制类型转换。非explicit，又是单参的，可以当做转换构造函数。


## 友元

1. 一个类可以将两类东西声明为自己的友元：函数，类。友元关系是单向的，类A是类B的友元，反之不成立。

2. 友元函数：该关系发生在函数和类之间，这里的函数可以是普通函数，也可以是其他类的成员函数。一般来说，类的private成员不可以被类的作用域外部通过对象访问，但是允许被标记了友元的函数通过对象访问，该函数只能在类内声明，类外定义。

   ```c++
   class complex{
   private:
       double re,im;
       friend complex& __doapl (complex*,const complex&);
       friend string::dosth;  //另一个类的成员函数。
   };
   complex& __doapl (complex* ths,const complex& r){
   	ths->re +=r.re;
       ths->im +=r.im;    //可以在类的友元函数内直接访问该类对象的private成员。
   }
   ```

3. 友元成员函数的两种情况：

   1. 这两个类定义在同一个cpp文件中

      ```c++
      //友元成员函数
      class Car;  //这里是为了使得第5行编译通过。并不会使得第13行编译通过。
      class Driver{ 
      public:
      	void ModifyCar(Car* car);
      };
      class Car {
      private:
      	int price;
      	friend void Driver::ModifyCar(Car* car);  //标记Driver类的该方法为Car类的友元。
      };
      void Driver::ModifyCar(Car* car) {  //该函数必须定义在Car类后面。因为这里不仅需要知道Car是一个类，还需要确认它的成员变量。
      	car->price += 1000;
      }
      ```

   2. 两个类各自定义在自己的cpp文件中，编译的主体是cpp文件，在对应的.h中include其他头文件，也可以include到cpp文件中，不过需要注意顺序。

      ```c++
      //complex.h
      #include "Fraction.h"   //这里不能用class Fraction; 否则会提示不允许使用不完整的类型。也可以移动到第9行后面。
      class complex{
          friend int Fraction::chechComplex(complex& c);
      private:
      	int re, im;
      }
      //complex.cpp
      #include "complex.h"
      
      //Fraction.h
      class complex;
      class Fraction {
      public:
          int chechComplex(complex& c);
      }
      //Fraction.cpp
      #include "Fraction.h"
      #include "complex.h"
      int Fraction::chechComplex(complex& c) {
      	return c.im;
      }
      ```

4. 友元类：如果A是B友元类，那么A中的所有成员函数都是B的友元函数，比一个一个定义友元函数更便捷。友元类关系是单向的，不能传递，不能继承。

   ```c++
   class Car;
   class Driver{ 
   public:
   	void ModifyCar(Car* car);
   };
   class Car {
   private:
   	int price;
   	friend class Driver;  //标记Driver类为Car类的友元。
   };
   ```

5. 友元函数不受类中的访问权限关键字限制，可以把它放在类的公有、私有、保护部分，结果是一样的。

6. 友元函数破坏了面向对象程序设计类的封装性，所以友元函数如不是必须使用，则尽可能少用。如果不将类声明为友元，也可以使用类的public接口来访问对象的private成员。多调用一次函数效率会比较低。

7. 同一个类的各个对象，互为友元，不过并没有友元对象这个说法。

   ```c++
   class complex{
   public:
       double func(const complex& param){return param.re+param.im;}
   private:
       double re,im;
   }
   complex c1,c2;
   c2.func(c1);//c2和c1互为友元，可以在c2中直接访问c1的private成员。
   //实际原因是，func函数已经进入了类的作用域内，此时访问任意对象的成员都是可以的。
   ```

8. 当将操作符重载为普通函数时，建议将该函数设置为对应类的友元，这样读写对象的属性要方便的多，省略函数调用的过程。

# 引用

1. 引用可以说是一种漂亮的指针，所有的编译器都是通过指针来实现引用机制的，Java里边所有的变量都是引用。引用传递的速度相当快，引用的使用又没有指针那么复杂：

   ```c++
   A a;   //使用A的默认构造函数创建一个对象a
   A& b;  //声明了一个引用变量b，此处并没有创建类A的对象。实际上这种写法也是不允许的，引用变量必须在声明的时候初始化。
   
   b.re;    //引用通过.来获取成员变量。
   pb->re;  //指针通过->来获取成员变量。
   ```

2. 引用和指针最大区别就是引用不能为空，而指针可以为空，即NULL。引用的一个作用就是弱保证非空。

3. &出现在类型的后面表示声明引用类型，&出现在变量的前面，表示获取变量的地址。

4. 引用是已有对象的代表，因此在声明新的引用时，一定要赋予初始值。引用一旦代表某个对象，就不会再代表其他对象，之后的=都是赋值操作，因此也将引用的初始化成为绑定。

5. ```c++
   double x = 0;
   double* p = &x;  //p指向x,p是一个变量，占据一定的内存空间。
   double& r = x;   //r代表x,r虽然在底层占据新的内存空间，但是r的地址是和x的地址名义上相同的，这是编译器故意为之。同时，sizeof(x) 和sizeof(r) 也被编译器做成了相同，都是x的大小。
   double x1 = 5;
   r = x1;   //这并不是让r代表x1了，而是将x1的值赋值给r。现在r和x的值都是5。
   double& r2 = r;  //现在r2也代表r,相当于代表x,此时x,r,r2这三个变量在使用者开来是完全相同的。
   ```

6. 指针的大小是确定的，32位程序就是4个字节，而引用的大小是不确定的，它代表的对象有多大，引用的大小就有多大。指针是CPU提供支持的，而引用是编译器将指针进行了封装，汇编级别都是指针。

7. 通常很少直接声明一个变量为引用，大部分情况下是参数和返回值传递使用引用。

   ```c++
   int& x = 1; //会报错，提示非常量引用只能使用左值初始化，引用的含义是代表，这里用x代表1是不合适的。在int前加上const也可以，不过之后x的值就不能再变了。
   ```

8. 常引用，即不能通过引用去修改它代表的值：

   ```c++
   complex& c = complex(2,3);  //会报错，提示和上面相同，在前面加上const变为常引用即可。
   complex& c = *&complex(2,3);  //不会报错。
   complex& c = *(new complex(2,3));  //也不会报错。
   
   int a = 5;
   const int b=3;
   const int& c = a; //a为常引用，并不会影响b的状态。
   int& d = b;  //会报错，因为const赋值给非const要使用强制类型转换。之所以不允许是因为，b本来是不能被修改的，这样一做，就使得可以通过d来修改b，造成b的不安全。
   a = 3; //会报错。
   b = 7; //不会报错。
   ```

9. 引用和数组：

   1. 引用的数组，本质是一个数组，每个元素都是一个引用。例如：int& a[5]; 这个几乎很少使用，因为引用要求在定义时就初始化，而无法同时对整个数组进行初始化。

   2. 数组的引用，本质是一个引用，代表一个数组。例如：int(&a)[5];   

      ```c++
      int n3[3] = {2, 4, 6};
      int (&rn3)[3] = n3;     //数组的引用
      
      void TestRef(int(&array)[9]) {   ////使用引用接受实参。数组长度不可以省略，参数不灵活。
      	cout << "size:" << sizeof(array) << endl;  //array实参的类型为 int[9]就是sizeof(a)=36B。
      	for (int i = 0; i < sizeof(array) / sizeof(int); i++)
      	{
      		cout << array[i] << " ";
      	}
      }
      void TestPtr(int array[],int n) { //使用指针int*接受实参,[]内可以省略数组长度。但是必须要额外一个参数指定数组的长度。
      	cout << "size:" << sizeof(array) << endl;  //array实参的类型为int*。
      	for (int i = 0; i < n; i++)
      	{
      		cout << array[i] << " ";
      	}
      }
      /*使用*/
      int a[] = { 2,5,3,6,8,4,9,7,1 };
      TestRef(a);  //传入的是数组名，也是数组的首地址
      TestPtr(a, sizeof(a) / sizeof(a[0]));
      ```

10. 从上面的代码可以看出，数组引用完全可以用指针来替代，因为指针传递速度和引用一样快，同时指针传递的参数更灵活。

# 参数和返回值传递

1. 形参parameter，实参argument。

2. 参数和返回值的接受类型必须与传递类型相容。

3. 参数和返回值的传递有两种方式：==值传递和引用传递==，不推荐使用指针传递。尽量不要使用值传递，可以减少对象拷贝的开销，同时在函数内修改会影响到外边。如果参数类型为const T&（常引用），这样函数内就不能修改该参数。

4. 使用引用传递，只需要在函数的参数和返回值类型中加上&即可。

5. 函数的参数和返回值传递方式取决于函数的定义者，而不是使用者。

6. 对象通过引用传递的时候其构造函数不会被调用。值传递对于内置类型来说就是直接赋值，对于对象来说，要调用拷贝或移动构造函数。尽量使用引用传递类的对象，内置类型变量也可以使用值传递。

   ```c++
   inline complex& __doapl(complex* ths){
       return *ths;   //返回指针指向的对象，返回的是值，但是通过函数的返回值类型，可以看出是引用传递。
   }
   ```

7. 使用引用传递的好处是方便了函数的使用者：形参和返回值类型是引用还是值类型，对于使用着来说没有区别，而如果是指针类型，那就得传递地址。

8. 有一种情况，不可以返回引用，即返回的内容是在函数中的栈创建的局部对象。因为函数返回后，该对象会被销毁，引用变得不确定了。如果需要在函数内构造对象，而这个对象又需要在函数结束后还可以被使用，有两种方案：

   1. 可以在堆上创建该对象。不过要小心，在外部使用完该对象后，记得delete，否则会造成内存泄露。如果是一个人编写的代码还好，这样的写法尽量不要称为对外的接口，否则相当于把责任转给了使用者。

      ```c++
      inline complex& __dopl(complex& a, complex& b){
          complex* c = new complex(a.re + b.re, a.im + b.im);  //在堆上创建对象。
          return *c;
      }
      ```

   2. 在栈上创建对象，然后返回值而不是引用，这样返回时会将栈中的对象拷贝到调用者的栈中，在外部仍然有效。

      ```c++
      inline complex __dopl(complex& a, complex& b){
          return complex(a.re + b.re, a.im + b.im);  //在栈上创建临时对象，返回时拷贝到外部。
      }
      ```


# inline

1. 函数的调用会将参数，返回值入栈，返回时还将这些参数出栈，当函数体较为简单时，这种调用开销就和函数体本身执行开销相当。

2. 编译器会将内联函数的代码插入到调用的地方，不会产生call语句，效率会提高，不会程序的体积会增大。

   ```c++
   int max(int a, int b){
       (a>b)?a:b;
   }
   k =max(n1,n2);
   
   //以上两句会编译为:
   tmp=(n1>n2)?n1:n2;
   k=tmp;
   ```

3. 内联inline函数，像宏一样，不过没有宏的缺点，执行速度快。有以下几种情况：

   1. 如果成员函数在类内部定义，会成为inline候选(不能显式声明)。如果成员函数在类外定义时可以加inline，使之成为内联候选，否则会报链接错误，因为肯定不会被内联。

      ```c++
      //complex.h
      class complex {
      	inline int real()const;
      }
      //complex.cpp
      #include "complex.h"
      inline
      int complex::real()const { return this->re; }
      //main.cpp
      #include "complex.h"
      int main(){
          complex c1;
      }
      /*---------错误情景-----------*/
      //complex.h
      class complex {
      	int real()const;
      }
      int complex::real()const { return this->re; }
      //complex.cpp
      #include "complex.h"
      //main.cpp    链接时会提示重定义符号，因为complex.cpp和main.cpp里都有该函数的定义。不过将在函数前添加inline，就不会被报错了，因为内联的函数不会再被链接。
      #include "complex.h"
      int main(){
          complex c1;
      }
      ```

   2. 普通函数，如果使用了inline关键字，也会成为inline候选。

4. 内联候选是否真的会被内联，由编译器决定（如果函数体比较复杂，编译器也不会内联该函数）。

5. 

6. 内联函数必须在所有使用到它的地方定义，inline的作用是文件层面的，例如：

7. 下面的代码会报链接错误，因为该函数被要被inline，但是在编译main.cpp时没有将函数体编译进去，就会提示找不到符号。解决的方法是取消String.cpp中函数的inline标记，或者将该函数的实现移动到.h中，此时inline可以保留。

   ```c++
   /*String.h*/
   class String{
     String(const char* str = 0);
   };
   /*String.cpp*/
   inline
   String(const char* str){
       
   }
   /*main.cpp*/
   #include "String.h"
   int main(){
       String s1("hello");
   }
   ```

# 函数重载

1. 相同函数名的函数有多个，称为重载overload。通过参数个数和类型来区分具体调用哪个函数。

2. 构造函数经常被重载，用于按照不同的要求来创建对象。

3. 重载的函数编译后（汇编语言助记符）是不重名的。类的成员函数也可以和普通函数构成重载。

   ```c++
   Complex类的real函数编译后的实际名称可能是:
   ?real@Complex@@QBENXZ
   ?real@Complex@@QAENABN@Z
   ```

4. 函数的==重载和默认参数==结合使用时，需要避免完全重复，否则会报错。带默认参数的函数相当于是定义了一个函数族。

   ```c++
   complex(double r=0,double i=0):re(r),im(i){ //这里相当于定义了4个构造函数，其中一个就是默认构造函数。
       
   }
   complex():re(0),im(0){   //此处是显式定义了默认的构造函数，因此和上面的构造函数参数列表发生了重复。如果不显式写出来这个函数，是不会被认为重复的，因为这时编译器是不会自动为类创建合成的默认构造函数。    
   }
   complex c1;   //此时不知道调用哪个构造函数。
   ```

5. 编译器通过函数签名来判断两个函数是重复还是重载，从函数名开始，到函数体之前构成函数的签名，签名和返回值类型无关，引用类型和值类型可以替换。

   ```c++
   double imag(const double& im){}
   double imag(const double im){}  //这两个函数不是重载，是重复。
   
   double imag const(const double& im){}
   double imag (const double& im){}     //这两个函数是重载，const是函数签名的一部分。
   ```

6. 函数的默认参数可以用在功能扩充上，例如一个函数最开始只有2个参数，后续需要扩充功能，要添加一个参数，那么这个参数就应该为默认参数，否则之前调用该函数的位置都要加上新的实参了。也可以重载原函数，多一个新的参数，在新函数内调用原函数。

   ```c++
   //原始函数
   void draw(Circle& c);  //绘制圆形
   //增加一个颜色的参数。
   void draw(Circle& c, Color& co =Color::black); //默认是黑色。
   //或者重载一下原函数
   void draw(Circle& c,Color& co){
       ...//处理颜色
       draw(c);
   }
   ```

7. 编译器通过参数类型匹配判断来决定调用重载的哪个函数。在所有候选集中选择最优匹配的，如果最优匹配不止一个，则会报错。成员函数和非成员函数的重载在编译器看来地位是相同的。

# 运算符重载

1. 运算符重载（overload）本质上是函数重载，主要是方便使用。运算符重载，是为已经存在的运算符赋予了另外一层含义。用户能够自定义运算对象和返回值的类型，但是不能修改运算对象的个数，运算符的优先级，结合律。

2. 为了更方便地操作对象，可以对操作符进行重载，有两种方法：

   1. 使用该类的成员函数进行重载，c1 += c2 这个操作相当于调用成员函数 c1.operator +=(c2)。
   2. 使用普通函数进行重载，c1 += c2 这个操作相当于调用普通函数 operator +=(c1, c2)。没有this指针，所有操作数都要传递。

3. c1+c2 ,c1+5,5+c1这三个表达式，需要写三个重载函数，参数都是两个，按照操作数的顺序。

4. 所有的二元运算符都是作用在左侧运算对象上的。也就是说c1+c2会变成 c1.operator +(c2)，而不是 c2.operator +(c1)。这个规则是C++定义的，和数学无关。

5. 操作符经常连用，例如c3+=c2+=c1; 计算顺序是从右往左，先计算c2+=c1，在计算c3+=c2。此时返回值的类型就是该类型的值或引用，而不是void。

6. operator和符号中间的空格可以省略。

7. 一个运算符可以有多种使用方法，例如-可以表示两个数相减，也可以表示取相反数。分别是两目和一目运算。编译器根据使用方法来区分调用哪个重载的函数，参数的个数不同。

8. 不带等号的操作符重载，都应返回值类型。不过也有例外：

   ```c++
   inline complex operator +(const complex& x){
       return x;  //这个正号操作就不用做任何事情，因此可以直接返回。
   }
   //侯捷老师说这里可以使用引用传递返回值。不过返回值类型必须为const complex &，而不能为complex& 。这样做确实会提高效率，但是存在一个问题。就是参数原本可能非const的，执行+运算后就获得了一个const引用，这样用户可能会用来继续做其他可能改变对象的行为，此时就会报错，例如：
   complex c1(1, 2);  //非const对象
   (+c1) += 3; //执行+=操作将编译报错。因为左侧运算对象已经是一个const对象了，不能调用+=。
   ```

9. 如果涉及到标准库或基本数据类型的操作符重载，且该对象又在运算符的左侧，则需要写成非成员函数的形式，因为无法修改标准库，也无法对基本数据类型定义成员函数，其余的任意：

   ```c++
   ostream& operator << (ostream& os, const complex& c){
       return os<<'c'<<real(x)<<','<<imag(x)<<')';    //可以发现os对象会被修改，而c对象不会。
   }
   
   cout << c1;  //这种操作符的使用理论上可以有两种重载的方法，一个是写成cout的成员函数，一个参数；一个数写成非成员函数，两个参数。而cout是标准库里的，不能再被修改了，因此只能用第二种。
   c1 << cout; //也可以这样写，这样虽然可以将<<写为成员函数，但是违背通常的使用习惯，即<<运算符的内在含义。
   
   inline complex
   operator + (double x, const complex& y){ //因为c++的二元运算符都是作用在第一个操作数上，由于无法对double书写成员函数，因此只能使用普通函数重载的方法。
       return complex(x+y.re, y.im);
   }
   ```

10. ++或--运算符，为了区分前置和后置的运算符重载，C++规定后置的运算符的参数比前置的多一个(必须是int类型，实参默认为0，可以不写变量名)，从下面可以看出来：前置的++运算符较为简单， 后置的运算符还需要调用两次拷贝构造函数。同时后置运算符可以将部分功能由前置运算符实现。

    ```c++
    class complex{
        complex& operator ++(){     //会被前置的运算符调用
            re++;
            return *this;
        }
        complex operator++(int){//会被后置运算符的调用,这里不能返回引用
            complex tmp(*this); //调用1次拷贝构造函数,保存原来的对象。
            ++(*this);
            return tmp; //调用1次拷贝构造函数。
        }
    private:
        int re,im;
    };
    /*使用*/
    int main(){
        complex c(3);
        cout << &c << endl;
        cout << &(c++) << endl;; //调用后置++运算符,在第7行调用拷贝构造函数，第8行调用前置++运算符，第9行执行拷贝构造创建返回对象。然后调用析构函数,分解tmp。回到17行，调用析构函数分解返回对象。这里输出的地址和c的地址不同因为他是新构造的对象,他也和栈中创建的tmp的地址不同。
        cout << &(++c) << endl; //地址和c的地址相同。
    }
    ```

11. 对于a<b?a:b 这样的条件运算符，实际上只用重载<即可。

12. 操作符重载不会改变优先级，C++不允许定义新的操作符。()  []  ->  = 这几种运算符只能被重载为成员函数。以下几种操作符不允许被重载：

    ```c++
    // .            .*                ::       ?:            sizeof
    // 成员索引   对象调用成员函数指针  作用范围  条件运算符     获得类型大小
    ```

13. 特殊的是，赋值运算符对于任意类，不用定义运算符重载即可使用，因为编译器会生成合成的拷贝赋值函数。默认的功能就是两个对象的内存拷贝。赋值运算符只能被重载为成员函数。不过赋值运算符还可以在不同类型之间运算，例如：

    ```c++
    class complex{
    private:
        int re,im;
    public:
        complex& operator =(const complex& c) {  //拷贝赋值函数
    		this->re = c.re;
    		this->im = c.im;
    		std::cout << "copy assign a complex object" << std::endl;
    		return *this;
    	}
        complex& operator =(int re){  //转换赋值函数，只能有一个参数
            this.re =re;
            return *this;
        }
    };
    /*使用*/
    complex c1(1,2);
    complex c2(3,4);
    c1 = c2 = 5;  //先调用转换赋值函数,c2=(5,4)，然后调用拷贝赋值函数c1=(5,4)。
    complex c2 = 6;  //这里会调用构造函数complex(int)。
    ```

# static

1. 栈上的对象称为local object，又称为stack object。这是因为离开作用域时，析构函数会自动调用。

2. static可以修饰对象，成员变量，成员函数：

   1. 如果用static修饰对象，那么就会变成静态对象，它会在离开作用域后仍然存在。直到程序结束才会被自动析构。它和全局对象的区别是全局对象在进入main之前被构造，在main返回后才会被析构，作用域比main大。可以反复执行生成该static对象的代码，不过实际对象只会有一份。可以利用这一特点实现单例模式。

   2. 如果用static修饰成员变量，那么所有对象的静态成员变量都是同一份，共有的。如果某个成员是整个类的属性，可以将它设置为静态成员变量，所有的对象的该成员都是相同的，只保留一份即可，==静态成员变量需要在类外进行初始化==。例如银行账户类中，成员变量存款利率就可以是static的，所有账户共享相同的利率。sizeof 不会计算静态成员变量，只计算单个对象占有的空间。

   3. 如果用static修饰成员函数，那么该函数在被调用时，不会默认传递this指针，因此函数内也不能使用this指针。他只能获取类的静态成员，而不能获取对象的私有成员。静态函数一般是用来操作类的静态成员变量的。静态函数可以通过对象.调用，也可以通过类名::调用。非静态函数只能通过对象.调用。没有对象时，也可以调用静态成员函数。

      ```c++
      class Account{
      public:
          static void set_rate(const double &x){m_rate = x;}  //不能用this->m_rate，只能使用Account::m_rate替代。
      private:
          static double m_rate;
      }
      double Account::m_rate = 8;  //必须要在类外声明一下,否则链接会报错,也可以顺便初始化。
      int main(){
          Account::set_rate(5.0);  //通过类名调用，因为静态函数是用来处理静态变量的，静态变量在没有创建对象的时候就存在。
          Account a;
          a.set_rate(6.0);   //通过对象调用。
      }
      
      ```

3. 静态成员变量本质上是全局变量，即使一个对象也不存在，静态成员变量也存在。静态成员函数本质上是普通函数，之所以将它们写到类中，是为了更好的封装和保护，易于维护。静态成员函数内只能使用静态成员变量，因为其内部没有this指针。

4. 如果将构造函数放在private区域，则不可以在类外边创建对象。大部分情况下不会这么做，不过==单例模式==中就会这样做。该模式要求只存在一个该类的对象，该对象存在于静态区。单例模式可以用静态对象来实现，Singleton 是一个合成的单词，字典上没有。有如下两种实现方法：

   1. 使用类的静态成员来实现，不过这个静态成员就是该类的对象。通常来首一个类的成员不能是该类自己的对象。但是静态成员是可以的。

      ```c++
      class A {
      public:
      	static A& getInstance() { return a; }   //该静态函数就是用来获取惟一的静态对象的。
      private:
      	A();     //构造函数是private，因此在类外不能创建对象。
      	static A a;  //有一个静态成员，就是一个A类的对象。
      }
      A::getInstance();     //可以获取唯一的对象。
      ```

   2. 将单例对象写成一个类的私有成员会出现这样的问题，即使没有人使用到该对象，也会存在一份（初始化时就生成了）。如下写法可以动态的在第一次使用时创建一个单例对象。

      ```c++
      class A{
      public:
          static A& getInstance();  //这里的static表示静态方法，可以通过类名来调用。
      private:
          A();
          A(const A& rhs);
      };
      A& A::getInstance(){
          static A a;       //这里的static表示局部静态变量，当第一次调用getInstance时，会生成一个该类的对象，退出后不会销毁，重复调用也不会重复生成。
          return a;
      }
      A::getInstance();   //获得单例
      ```

# 面向对象程序设计

## 复合

1. 面向对象编程会涉及多个类，类和类之间常见的关系有复合，委托，继承。前两种会构成环形结构，继承会构成树状结构。

2. 错误的理解是，只有继承才是面向对象。

3. 复合(组合)Composition，表示has-a，即A类的对象中包含一个B类的对象，A对象往往被称为容器Container或封闭类，B对象往往被称为Component。这种关系在C语言的结构体就存在了。

4. 适配器模式就可以使用复合对象来实现，deque是一个功能强大的类，而此时需要一个部分功能的类queue。可以将deque包含在queue中，queue的成员函数可以调用它包含的deque得成员函数来实现功能，函数名也可以修改为需要的名字，也就是起到适配的作用。将一个功能强大的东西，包装一下就可以当做一个其他的类来使用。

   ```c++
   template <class T>
   class queue{   //先进先出的队列
   protected:
       deque<T> c;    //这是queue的底层容器。两端都可以进出。
   public:
       bool empty(){return c.empty();}
       size_type size(){return c.size();}
   };
   ```

5. 复合可以嵌套，大小上叠加即可。

   <img src="C++.assets/image-20210815231531532.png" alt="image-20210815231531532"  />

6. 构造由内而外：构造容器对象时，会先执行内对象的==默认==构造函数(如果要调用特定的构造函数，写在容器类构造函数的初始化列表处)，再执行容器的指定构造函数。

7. 析构由外而内：析构容器对象时，会先执行容器对象的析构函数，在执行内对象的析构函数。这一过程是编译器自动完成的，不用手动写，类似于如下代码：

   ```c++
   Container::Container():Component(){};   //使用了初始化列表
   Container::~Container(){
       ...
       innerObject.~Component();       //最后调用内部对象的析构函数
   }
   ```


## 委托

1. 委托 Delegation，A对象中存在一个指向B对象的指针。也是has-a，但是不是真正的拥有。也称为通过Composition by reference 通过引用复合，虽然成员变量是指针，但是通常不说指针而是说引用。

2. 委托和复合的区别是，复合是一种强耦合，委托是弱耦合，委托对象的容器和子对象的寿命可以不一致。

3. String类是对外的接口，所有具体的操作都在StringRep类中完成，这样不用重写String类的任何代码，也可以改变它的功能，不影响客户端的使用。这种方式称为pImpl(Pointer to Implementation)，接口类中有指针指向实现类。称为桥接Bridge模式，又称为Handle/Body，接口是handle，实现是body。这种又称为编译防火墙，接口类不用重新编译，只用重新编译实现类即可。

   ```c++
   //String.hpp
   class StringRep;  //提前声明
   class String{
   private:
       StringRep* rep; //Pointer to Implementation
   };
   
   //String.cpp
   #include "String.hpp"
   class StringRep{
       friend class String;
       int count;
       char* strrep;
   };
   ```

4. 上面的代码可以实现引用计数，例如有3个String对象，内部的rep指针都指向同一个StringRep对象。则这个StringRep对象的count成员为3。当引用计数为0时，会delete strrep的内存。

5. 如果要实现Copy on Write，则需要在StringRep的所有可能修改strrep的函数中进行判断，如果count不为1，那么需要深拷贝构造一个完全一样的StringRep对象供其修改。


## 继承

1. 继承 Inheritance，is-a的关系，也被称作派生。C++提供三种继承方式，public，protected，private，最有用的就是public。Java之类的语言只有public。父类的数据是被完整继承下来的，包括private成员变量，不过子类的成员函数是不能访问父类的private成员变量或函数。

   ```c++
   struct _List_node_base{
       _List_node_base* _M_next;  //由两个指向同类型对象的指针。
       _List_node_base* _M_prev;
   };
   template <typename _Tp>
   struct _List_node:public _List_node_base{  //子类是一个由模板生成的。
   	_Tp _M_data;
   };
   ```

2. 子类对象中包含着父类的部分。构造由内而外，首先调用父类的默认构造函数，然后才是子类的默认构造函数。析构由外而内，先执行子类的析构函数，再执行父类的析构函数。这部分操作也是编译器自动完成的。最终基类的析构函数必须是virtual，否则会出现未定义行为。如果父类没有定义默认的构造函数，就应该在子类的初始化列表中调用父类的特定构造函数。

   ```c++
   class A {
   public:
   	A(int a, int b) :m_data1(a), m_data2(b) {}
   	int m_data1, m_data2;
   };
   
   class B :public A {
   public:
   	B(int a, int b, int c) :m_data3(c), A(a, b) {}  //初始化列表中的顺序不重要，因为必定会先调用A的构造函数。实际的顺序是先构造父类，再初始化自定的成员。
   	int m_data3;
   };
   
   class C :public B {
   	C(int a, int b, int c, int d) :m_data4(d), B(a, b, c) {}
   	int m_data4;
   };
   /*使用*/
   A a(1,2);
   B b(1,2,3);
   C c(1,2,3,4);
   ```

3. 继承和复合可以联合使用，有两种情况：

   1. 子类含有复合对象，构造由内而外，会先执行Base类构造函数，然后再执行Component类构造函数。最后执行Derived的类的构造函数，析构顺序相反。
   2. 父类含有复合对象，先调用Component类的构造函数，然后调用Base类的构造函数，最后调用Derived的类的构造函数，析构顺序相反。

4. <img src="C++.assets/image-20220907204505865.png" alt="image-20220907204505865"  />

5. 继承和复合在内存布局上特别像，但是逻辑意义上不同：

   ```c++
   class Circle;
   class Point{
       double x,y;
       friend class Circle;   //一般应将container类设置为component类的友元类，这样就可以自由访问成员了。
   }
   class Circle{  //这里不能使用继承，因为圆和点的关系不是is-a,而是圆has-a点。
       Point center;  //圆心,两个成员变量的顺序无所谓。
       double r;      //半径
   }
   ```

6. 类的复合不能互相包含，如果需要互相包含可以用委托来设计。

   ```c++
   //示例代码
   ```

7. 基类的private成员函数只能被基类的其他成员函数和友元函数访问。基类的protected成员是在private成员的基础上+派生类的成员函数。派生类对象在成员函数外也是不可以访问基类的protected成员的。protected关键字是专门为继承预备的,这也是继承区别于复合最重要的情况。类之间的复合要么只能访问public，要么所有的成员都可以访问(友元类)。继承就多了一种隔离的方法。

   ```c++
   class Father{
   private:
       int nPrivate;
   public:
       int nPublic;
   protected:
       int nProtected;
   };
   class Son:public Father{
       void accessFather(Son& another){
           nPublic = 1;        //ok
           nPrivate = 1;       //wrong
           nProtected = 1;     //ok
           another.nProtected = 1;   //wrong,只能访问当前对象的protected成员，也就是this->nProtected。
       }
   }
   /*使用*/
   Father f;
   Son s;
   f.nPublic = 1;     //ok
   s.nPublic = 1;     //ok
   f.nPrivate = 1;    //wrong
   s.nPrivate = 1;    //wrong
   f.nProtected = 1;  //wrong,只能在派生类的成员函数内访问。
   s.nProtected = 1;  //wrong
   ```

8. 如果在派生类中要对基类进行带参初始化时，且基类有private成员时，派生类初始化必须用初始化列表来对基类进行初始化，因为在派生类中无法对基类的private成员进行赋值。

   ```c++
   class Bug {
   	int nLegs, nColor;
   public:
       Bug(){}
       Bug(int legs, int color) :nLegs(legs), nColor(color) {}
   };
   class FlyBug :public Bug {
   	int nWings;
   public:
   	FlyBug(int legs, int color, int wings) :nWings(wings),Bug(legs, color){} //初始化列表的顺序无所谓，因为一定会先初始化父类对象，然后按照子类成员变量的声明顺序来初始化。
       FlyBug(int legs, int color, int wings):nWings(wings){
           nLegs = legs;   //error,不能访问基类的private成员。
           nColor = color; //error
       }
   };
   /*使用*/
   FlyBug f(1,2,3);
   ```

9. 类之间存在复合关系时，构造函数初始化的初始化列表：

   ```c++
   class Circle;
   class Point{
       double x,y;
       Point(double x, double y):x(x),y(y){}
       friend class Circle;   
   };
   class Circle{  
       Point center;
       double r;
       Circle(double x, double y, double r):center(x,y),r(r){}   //复合对象使用成员变量名来初始化，而基类使用类名初始化。
   };
   ```

10. C++除了可以用public继承外，还支持protected和private继承，不过后两种很少使用。public继承有如下赋值兼容规则：

    ```c++
    class Base{}
    class Derived:public Base{}
    /*使用*/
    Base b;
    Derived d;
    b = d; //可以执行，因为派生类对象is-a基类对象。可以重载Base类的拷贝赋值=函数，来修改默认的规则。默认是将d中的b部分内存拷贝到b中。
    d = b; //不可以执行。
    Base& rb = d;   //可以执行，基类引用代表派生类
    Base* pb = &d;  //可以
    ```

11. A派生B，B派生C，则B是C的直接基类，A是C的间接基类。继承时，只需要写出直接基类就可以自动继承所有的间接基类。

12. 在UI框架中经常遇到这样的问题，需要对一份数据产生多个视图，每个视图内都可以修改数据，数据修改完成后，其他视图也要跟着变化。可以使用观察者模式来解决这种问题：

    ```c++
    class Subject{  //存放具体数据的类，也会关联所有的观察者。
        int m_value;  //具体的数据
        vector<Observer*> m_views; //存放所有关联到本数据的观察者的指针。
    public:
        void attach(Observer* obs){
            m_view.push_back(obs);
        }
        void set_val(int val){  //修改数据的函数
            m_value = val;
            notify();  //修改完执行通知功能
        }
        void notify(){ //执行通知的函数
            for (int i=0; i<m_view.size();++i){  //依次执行所有观察者的update函数。
                m_view[i]->update(this,m_value);  //将数据对象和新的数据值传递给观察者。由于m_value是private，所以应该提供它。
            }
        }
    }
    class Observer{ //数据观察者类，应该被继承并重写update函数。具体视图如何更新，取决于各个视图本身。
    public:
        virtual void update(Subject* sub, int value)=0;
    }
    ```

13. 文件系统中，文件夹会包含文件和文件夹，这种关系可以用复合模式来解决。定义两个类，Primitive和Composite。Composite中应该有一个指针的vector，可以容纳Primitive和Composite对象，不过这需要为这两个类定义一个公同基类，vector存放该基类指针即可。Primitive就是文件，Composite就是文件夹。

    ```c++
    class Component{
        int value;
    public:
        Component(int val):value(val){}
        virtual void add(Component* ){}  //这个函数必须在基类中定义，虽然基类不做任何事情，同时它的两个派生类只有Composite会使用这个函数，但是因为后续会使用基类指针来调用add函数，如果静态类型中没有该函数，则编译会报错。
    }
    class Composite:public Component{
        vector<Component*> c;
    public:
        Composite(int val):Component(val){}
        virtual void add (Component* elem){
            c.push_back(elem);
        }
    }
    class Primitive:public Component{
    public:
        Primitive(int val):Component(val){}
        virtual void add (Component* elem){
            throw Exception("file can't do addding");
        }
    }
    ```

14. 实际上只有文件夹才有add的能力，文件是没有这个功能的。要么在基类的add中判断一下是否是文件，给予报错。要么在Primitive中重写这个函数，给予报错。

15. 下图是上面代码的类图，其中空心三角形代表继承关系，空心菱形代表委托关系，实心菱形代表复合关系。private成员前面有一个减号，protected成员前有个#。下图中Component类的成员变量写错了，因改为  -value:int。下划线表示静态成员。画图的时候是先写成员名，再写类型，和代码中的正好相反。

16. <img src="C++.assets/image-20220907211330950.png" alt="image-20220907211330950" />

17. 有时候有这样的问题，已有的代码要创建未知的类的对象，但是它不知道未来的对象的类名称。这个问题可以用Prototype原型模式来解决。通过原型来创建未知类的对象。

    ```c++
    //Image.h
    #include <iostream>
    enum imageType{
        LSAT,SPOT
    };
    class Image{   //先定义的类
    public:
        static Image* findAndClone(imageType type){
            for(int i=0;i<_nextSlot;i++){
                if(_prototypes[i]->returnType() == type){  //逐个寻找，进行类型匹配。
                    return _prototypes[i]->clone();  //为对应的类型调用clone函数。
                }
            }
        }
    protected:
        virtual imageType returnType()=0;
        virtual Image* clone()=0;
        static void addPrototype(Image* image){
            _prototypes[_nextSlot++] = image;
        }
    private:
        static Image* _prototypes[10];
        static int _nextSlot;
    }
    Image* Image::_prototypes[10];  //静态成员变量需要在类外定义。
    int Image::_nextSlot;
    
    //LandSatImage.h
    #include "Image.h"
    class LandSatImage:public Image{  //后定义的类
    public:
        imageType returnType(){return LSAT;}
        Image* clone(){ //克隆一个对象。这个函数不能是静态的，因为现在不知道未来的类名，无法调用。
            return new LandSatImage(1);
        }
    private:
        static LandSatImage LSAT;
        LandSatImage(){
            addPrototype(this);
        }
        LandSatImage(int dummy){  //这个参数dummy只是为了和private的构造函数区分开。这个函数只会被clone调动。
            _id = _count++;
        }
        int _id;
        static int _count;
    }
    LandSatImage LandSatImage::LSAT;
    int LandSatImage::_count = 1;
    ```

18. <img src="C++.assets/image-20220907214300118.png" alt="image-20220907214300118"  />

## 虚函数和多态

1. ==有静态的虚函数吗？==

2. 有些程序语言有类和对象的概念，但是没有多态，这种只能被称为基于对象，而不能称为面向对象，例如visual basic。

3. 继承要搭配虚函数使用才能发挥更大的作用。在任何一个成员函数前加上virtual，它就变成了虚函数。成员函数从virtual的角度可以分为三种：

   1. 普通非虚函数，不希望子类重新定义。这种函数一般是子类和基类共同都能执行的操作，且和具体是子类还是派生类无关。
   2. 虚函数，希望子类重新定义，且父类中对该函数已经有默认定义。基类的虚函数可以什么也不做，但是不能只写声明，写成空函数即可。如果子类有更适合自己的定义，可以在自己的类内定义一个，覆盖基类的。
   3. 纯虚函数，子类必须要重新定义，父类中对该函数没有默认定义。

4. ```c++
   class Shape{
   public:
       virtual void draw() const =0;                   //纯虚函数
       virtual void error(const std::string& msg){ }   //虚函数
       int objectID() const{ }                         //非虚函数
   };
   class Retangle:public Shape{
       virtual void draw() const;        //子类中重新定义了纯虚函数，也要加virtual
   };
   class Ellipse:public Shape{
       virtual void draw() const;
       virtual void error(const std::string& msg){ }   //子类还重写了父类的虚函数。
   };
   ```

5. 从继承的角度看，数据被继承体现在内存中子类对象会包含父类对象的成员，而函数被继承体现在调用权上，即子类可以调用父类的函数。

6. 子类中出现和父类名称相同(参数也应相同)的成员函数，==这一行为称为重新定义，或复写override。==

7. 子类对象调用从父类继承来的成员函数，这里边成员函数的this指向子类对象。因此在调用到虚函数Serialize()的时候，就会调用子类复写的Serialize()。这个称为动态绑定 dynamic binding。

8. 多态：父类指针(引用)指向子类对象，这种行为称为多态Polymorphism。指针和引用都可以实现多态。多态和具体调用父类还是派生类的同名虚函数无关，不是只有调用派生类虚函数才叫多态。

9. ```c++
   Shape* s1 = new Retangle();   //多态，也被称为向上转型 up-cast。
   s1->draw();   //实际上调用的是子类对象的draw函数。动态绑定，这一行为需要draw是子类重写了的虚函数才可以。这一功能的完成依赖于虚指针vptr和虚函数表vtbl。
   
   /*以上多态和动态绑定的行为，用引用也可以实现*/
   Shape& s = *(new Retangle());  //或者 const Shape& s = Retangle();  这里必须要加const，因为普通引用必须绑定到对象上，常量引用可以绑定到非常量对象，字面量，甚至是一般表达式等等。
   s.draw(); //也会调用子类的虚函数。
   ```

10. 多态可以增加程序的可扩充性。例如类B是类A的子类，有一个函数接受一个类B的对象，如果形参写为类A的指针，那么将来类A增加一个派生类C，该函数也不用修改也可以接受类C的对象。

11. 多态机制在容器的使用中非常有用，父类派生的多个子类大小可能不同，因此list中不能直接存放子类对象，而应该存放子类的指针，但是不同子类的指针也不是同一个类型，因此可以向上转型为父类的指针。

    ```c++
    list<Shape*> l;   //可以向这个容器内添加 Retangle或Circle指针。
    l.push_back(new Retangle());
    l.push_back(new Circle());
    ```

12. 这是一个打开文件的框架，文件的打开大部分是相同的操作，只有特定后缀名文件的解析是不同的，因此可以事先书写好用于控制操作流程的父类，将实现具体细节的函数Serialize()定义为虚函数。如果要创建一个打开某种格式的子类，只需继承原来的父类，然后重写虚函数Serialize()即可。

13. 模板方法设计模式就是用了这个技巧。先定义好一个框架，指明大致步骤。至于每个步骤具体做的事情，可以有后续的类来继承，然后自定义虚函数来解决。应用程序框架经常用到这种方法，因为大部分程序的设计逻辑都差不多，具体的区别在于实现细节上。

14. <img src="C++.assets/image-20210817124346391.png" alt="image-20210817124346391"  />

15. 使用基类指针或引用调用基类中定义的虚函数时，就会发生多态，运行时根据动态类型来决定具体调用哪个函数。

16. 子类对象调用父类的非虚函数时（此时不是多态），如果在该函数内部又调用了虚函数，这个是通过this->来调用的，此时就会发生多态。

17. 构造函数和静态成员函数不能是虚函数。virtual关键字只用在类中的声明，如果在类外实现时(.h和.cpp分离)，不能加virtual。子类重新定义虚函数，可以省略virtual。

18. qsort可以基类指针数组进行排序，compare函数接受的是一个二级指针。

    ```c++
    class Shape {
    public:
    	virtual double area() const = 0;
    };
    class Retangle :public Shape {
    	double w, h;
    public:
    	Retangle(double w, double h) :w(w), h(h) {}
    	virtual double area() const {
    		return w * h;
    	}
    };
    class Circle :public Shape {
    	double r;
    public:
    	Circle(double r) :r(r) {}
    	virtual double area() const {
    		return 3.14*r*r;
    	}
    };
    int ShapeAreaCompare(const void* s1, const void* s2) {
    	Shape** p1 = (Shape**)s1;
    	Shape** p2 = (Shape**)s2;
    	return (*p1)->area() > (*p2)->area()?1:-1;  //当前面元素>后面元素时，才改变位置，否则都不变。这里不可以直接相减，因为返回值类型为int，例如当减法的结果为-0.7时，实际的返回值为0。意义改变了。
    }
    /*使用*/
    int main() {
    	Shape* a[4];
    	a[0] = new Retangle(3, 3);
    	a[1] = new Circle(4);
    	a[2] = new Retangle(5, 2);
    	a[3] = new Circle(2.5);
    	for (int i = 0;i < sizeof(a) / sizeof(a[0]);i++) {
    		cout << a[i]->area() << endl;  //面积依次为9  50.24  10  19.625
    	}
    	qsort(a, sizeof(a) / sizeof(a[0]), sizeof(a[0]), ShapeAreaCompare);
    	for (int i = 0;i < sizeof(a) / sizeof(a[0]);i++) {
    		cout << a[i]->area() << endl; //面积依次为9   10  19.625   50.24
    	}
    }
    ```

19. 在非构造函数和非析构函数中调用虚函数，也会引发多态行为。反之则不会，因为这种情况下，编译时就能区分调用的是自己的还是父类的。

    ```c++
    class Base {
    public:
    	void func1() { func2(); } //this->func2();
    	virtual void func2() {}
    };
    class Derived :public Base {
    public:
    	virtual void func2() {}
    };
    /*使用*/
    Derived d;
    Base* p = &d;
    p->func1();   //这里会调用Base::func1,然后转入Derived::func2。第二步才是多态。
    ```

## 虚指针和虚函数表

1. 如下三个类，C继承自B，B继承自A。所有类的非虚成员函数的调用方式和普通函数类似，汇编代码都是直接call地址，这称为静态绑定。通过指针(引用)来调用虚函数时，会通过指针找到虚指针vptr，再查询虚函数表vtbl，再call，这称为动态绑定。虚函数表是在编译时产生的，调用虚函数的代码也会被转化为虚指针的偏移。vptr和vtbl在C++语言层面不可见。

2. 动态绑定之所以可以实现多态，是因为调用虚函数时，虽然是父类指针，但是是在子类的虚函数表中查找的。具体调用的函数和实际的对象类型有关。

3. 从下图可以看出，一个子类对象是完全包含父类的成员变量的。

4. 当一个类有虚函数(无论是自己定义的，还是继承来的)时，他的对象就会有个虚指针，sizeof会多出一个指针的大小。该虚指针指向该类的虚函数表，一个类的所有对象，各自有各自的虚指针，但是共用一套虚函数表。

5. 虚函数表中的每一项都是一个虚函数的入口地址，最后一项为0。(p->vptr)[n]获得第n个虚函数的入口地址，相当于一个函数指针。通过(* 函数指针)(参数)的形式调用。这里的参数就是this。

6. <img src="C++.assets/image-20210819213611196.png" alt="image-20210819213611196" />

7. 子类可以有和父类中同名的成员变量，在子类对象中，默认使用的是子类的成员变量。可以使用::来使用父类的成员变量。

8. 普通函数一般子类不会重写(是可以的，见下面的func2)，虚函数子类可能会重写。如果一个函数要在子类中被重写，最好声明为虚函数，否则不会实现多态机制，这和一般的用法相违背。

9. 普通函数只有一份，虚函数只要重写一次，就多一份。因此在A和B对象看来，func1函数的地址是一致的，二者在调用时只有传入的this不同。而对于虚函数vfunc1，在A和B对象看来就是两个函数，地址也不相同。

10. ```c++
    class A {  //有2个虚函数,2个普通函数。
    public:
    	virtual void vfunc1() {}
    	virtual void vfunc2() {}
    	void func1() {}
    	void func2() {}
    	int m_data1, m_data2;
    };
    
    class B :public A {  //有2个虚函数,3个普通函数
    public:
    	virtual void vfunc1() {}
    	void func2() {}
    	int m_data3;
    };
    
    class C :public B {  //有2个虚函数,4个普通函数。
    public:
    	virtual void vfunc1() {}
    	void func2() {}
    	int m_data1, m_data4;
    };
    
    int main() {
    	A a;
    	B b;
    	C c;  //C类的对象中有5个成员变量，3个是继承来的，2个是自己的。
    	cout << c.m_data1 << endl;  //C类的成员变量m_data1会屏蔽A类中的同名变量。
    	cout << c.A::m_data1 << endl; //在变量明前使用类名::可以确保使用该类的成员变量。
    	A *p = &c;
    	p->func2(); //由于func2不是虚函数，因此调用的是A::func2函数。不能实现多态。  
        
        A a1 = b;  //通过拷贝构造函数，创建一个A类的对象，这将会扔掉b对象中多余的变量。
        a1.vfunc1(); //这样使用不会发生多态，将调用A::vfunc1
    ```

# 标准库

1. 内置类型是由C++语言直接定义的，它们大多是硬件本身具备的能力。标准库定义的类型并未直接实现到硬件中。
2. string表示可变长的字符序列，vector存放的是某种给定类型对象的可变长序列。数组是内置类型，其实现和硬件密切相关，因此灵活性不如前两个标准库类型。
3. C++标准一方面对库类型所提供的操作做了详细规定，另一方面还对库的实现者做出了性能上的需求，因此一般的应用场合中标准库都是足够效率的。
4. 一般来说，大多数标准库类型在设计时都力求在易用性上向内置类型看起，因此大多数库类型都支持=赋值操作。

   ```c++
   string s1(10,'c'), s2;
   s1 = s2; //赋值操作，将s2的副本替换s1的内容。
   ```

## string

1. 也可以提供一个字符串字面值，这样该字面值中除了最后的空字符以外的所有字符都会被拷贝到string对象中。string中不存在'\0'字符，size()更不会包括它。

   ```c++
   string s1;  //会调用默认构造函数，进行默认初始化，s1是空字符串，其中没有任何字符
   string s2 = s1;  //调用拷贝构造函数。
   string s3(s1);   //同上
   string s4 = "hiya"; //调用对应于char*的转换构造函数，内容是字符串字面值"hiya"的前4个字符。string中默认不包含'\0'字符，size(s4)结果为4。
   string s5("hiya");  //同上。
   string s6(10,'c');  //调用普通的构造函数，内容是10个字符c。
   ```

2. 使用等号初始化一个变量，实际是进行拷贝初始化，编译器将等号右侧的对象的值拷贝到新建的对象中。如果不使用等号，则是直接初始化，实际上就是显式地调用构造函数（包括拷贝构造函数），编译器会根据参数匹配最优的。因此直接初始化可以有多个初始值，拷贝初始化只能有一个初始值。

3. 各类初始化和各种构造函数不是一一对应的。直接初始化也可能调用拷贝构造函数，例如s3；拷贝初始化可以不调用拷贝构造函数，例如s4。

   ```c++
   string s2 = s1;     //拷贝初始化
   string s3(s1);      //直接初始化，可以将拷贝初始化转化为对应的直接初始化，来判断调用的是哪个函数。
   string s4 = "hiya"; //拷贝初始化
   string s5("hiya");  //直接初始化
   string s6(10,'c');  //直接初始化，2个初始值，分别为10和'c'。
   //如果有多个初始值，又非要使用拷贝初始化，可以先构造一个临时对象：
   string s7 = string(10,'c') //
   ```

4. 常见的操作：

   ```c++
   os << s;        //将s的内容输出到流os中，返回os。
   is >> s;        //从输入流is中读取字符串赋值给s，会自动忽略开头的空白，从第一个真正的字符开始读取，直到遇见下一处空白结束，返回is。
   getline(is,s);  //从输入流is中获取一行，换行符也会被读取，但是不会存入string中。如果一开始就遇到换行符，则s为空string。这个函数不会忽略任何空白。返回值为输入流is。
   s.empty();      //如果为空，则返回true。
   s.size();       //返回字符个数。
   s[n];           //返回第n个字符的引用，char&类型，下标从0开始。
   s1 + s2;        //字符串拼接。得到一个新的临时对象，不改变s1和s2。
   s1 += s2;       //追加，会修改s1。
   s1 = s2;        //用s2的副本替代s1中原来的字符。
   s1 == s2        //如果包含的字符完全一样，则为true，大小写敏感。
   s1 < s2;        //根据字典顺序比较对应的字符，大小写敏感。如果两个string的长度不同，且较短对象的每个字符都和较长对象的对应字符相同，则较短对象<较长对象。
   ```

5. string类和大多数标准库类型一样，都定义了配套的类型，这些类型体现了标准库的机器无关性。例如string::size_type就是string类中定义的一个类型。它不是成员变量，也不是成员函数，而是成员类型。不同的实现会使用具体的类型来模拟，例如vc下，string::size_type就是unsigned int。不过建议使用配套的类型，这样移植性好。

6. size成员函数返回值的类型为string::size_type类型。它是一种无符号类型，足以存放下任何string对象的大小。C++11中可以用auto或decltype来推断变量的类型：

   ```c++
   auto a = s.size();  //a是string:size_type类型的。这种代码的移植性较好。
   ```

7. 字符串字面值可以和string相加，左右都可以，但是两个字符串字面值不可以相加。

   ```c++
   string("abc") +"def";  //正确
   "abc" + string("def"); //正确
   "abc" + "def";         //错误，应该使用"abc" "def"，编译阶段就完成拼接了。
   string("abc") + "def" + "hij";  //正确，会从左往右依次相加。
   "abc" + "def" + string("hij");  //错误，因为会从左往右进行。
   ```

8. 标准库允许字符字面值和字符串字面值自动转化为string对象。在需要string对象的地方可以使用二者代替，反之不可以。

9. 为了和C语言兼容，字符串字面值和C++的标准库string对象不是同一类型。

10. 标准库的cctype头文件中定义了一组函数用来处理单个字符。

   ```c++
   isalnum(c);  //字母或数字时为true。
   isalpha(c);  //字母是为true。
   iscntrl(c);  //控制字符是为true。
   isdigit(c);  //数字时为true。
   isgraph(c);  //可打印的非空白字符时为true。有时返回非零值。
   islower(c);  //小写字母时为true。
   isupper(c);  //大写字母时为true。
   isprint(c);  //可打印字符时为true。
   ispunct(c);  //标点符号时为true。除了控制字符，数字，字母，可打印空白以外的字符。
   isspace(c);  //空白字符时为true，包含空格，横向/纵向制表符，回车符，换行符，进纸符。
   isxdigit(c); //十六进制字符时为true。
   toupper(c);  //如果是小写字母，转化为对应的大写，否则原样输出。
   tolower(c);  //如果是大写字母，转化为对应的小写，否则原样输出。
   ```

11. 下标运算符接受的参数是string::size_type类型的值，可以传递一个有符号数，不过会被自动转换为无符号数。s[s.size()-1]是最后一个字符，当size等于0时，这个不成立，因为0-1的无符号数是一个特别大的数，会超出下标范围，产生out_of_range异常。

12. C++标准并不要求标准库检查下标的合法性，不过用户应该自己检查。

13. 如果s为空，s[0]的结果是未定义的。在每次使用下标前都要判断是否是合理的，string对象的下标n必须满足，$0<=n<size$。

    ```c++
    string s("abc");
    //使用下标来遍历的标准流程：
    for (decltype(s.size()) index = 0; index != s.size(); index++){
        s[index];  //将index设置为size_type类型的，这样index总是>=0，然后只需让它不等于s.size()即可。
    }
    ```

## C风格字符串

1. C++支持C风格的字符串，但是程序中最好不要使用，因为特别容易引发漏洞。

2. C风格字符串不是一种类型，而是为了表达和使用字符串形成的一种约定的写法。一般用指针来操作这些字符串。头文件cstring中包含了一些操作函数，以下函数的参数必须指向以空字符作为结束的字符数组：

   ```c++
   strlen(p);     //返回字符串的长度，不包含末尾的空字符。
   strcmp(p1,p2); //逐个比较两个字符串的字符，如果都相等，返回0。如果前面的大，返回正值，否则返回负值。
   strcat(p1,p2); //将p2附加到p1后面，返回p1。要求p1指向的内存是可写的，且有足够的空间。这也是容易发生错误的地方。
   strcpy(p1,p2); //将p2拷贝给p1，返回p1。要求p1指向的内存是可写的，且有足够的空间。
   ```

3. C风格字符串的比较和string的比较不同，要想逐个字符比较，应该用strcmp：

   ```c++
   string s1 = "abc";
   string s2 = "abd";
   auto x = s1 < s2;   //逐个字符比较，结果为true。
   const char p1[] = "abc";  //p1的值为0x004ffcfc
   const char p2[] = "abd";  //p2的值为0x004ffcf0
   x = p1 < p2;  //比较指针的值，而不是字符。结果一般为未定义值，本次为false。
   ```

5. C++语言专门提供了一组功能用来处理C风格字符串和string的关系。

   ```c++
   string s1("abc");  //用C风格字符串构造string对象或为string对象赋值。
   s1 = "def";
   
   char cs [] = "abc";
   string s2(cs);  //允许使用以空字符结尾的字符数组来构造string对象或为string对象赋值。
   s2 = cs;
   ```

6. 如果程序中需要某个C风格字符串，不能直接使用string替代。

   ```c++
   string s("abc");
   char *str = s;  //错误
   const char *str1 = s.c_str();  //正确，不能省略const。因为c_str返回的是const char*类型。无法保证c_str返回的指针一直有效，事实上如果改变s，可能会改变使得str1无效。
   //如果像一直使用返回的字符串，可以使用strcpy拷贝到其他地方一份。
   ```

## vector

1. vector可以用来表示对象的集合，因此常被称为容器。其中存储的所有对象都必须是同类型的。引用不是对象，因此无法创建包含引用的vector。

2. vector实际是一个类模板（class template），而非类。

3. 可以创建vector的vector。早期版本中，必须在外层vector的右尖括号和元素类型之间加一个空格，新版本则不用。因为早期的编译器在进行词法分析时是遵循最长匹配原则，因此会将`>>`当作右移运算符，现代的编译器会在语法分析时纠正这个错误。：

   ```c++
   vector<vector<int> > v1;
   ```

4. 定义和初始化vector：

   ```c++
   vector<T> v1;  //调用默认构造函数，创建一个空的vector，不包含任何元素。
   vector<T> v2(v1); //调用拷贝构造函数，等价于vector<T> v2 = v1;它们的类型必须相同。
   vector<T> v3 (n,val); //创建一个包含n个元素的vector，每个元素都用val进行初始化。
   vector<T> v4(n);  //创建一个包含n个元素的vector，每个元素都进行默认初始化。内置类型会被初始化为0，类类型由类进行默认初始化。如果类没有默认构造函数，那就必须提供初始值。
   vector<T> v5{a,b,c}; //列表初始化，3个元素，依次用对应元素进行初始化。等价于vector<T>v5 = {a,b,c};
   
   //括号可以看作是调用构造函数。{}可以看做是列表初始化。
   vector<string> vs1{"a","b","c"}; //正确，只有列表初始化可以接收初始值的列表。
   vector<string> vs2("a","b","c"); //会报错，没有与参数列表匹配的构造函数。
   vector<int> v1(10);  //10个元素，都是0
   vector<int> v2{10};  //1个元素，为10
   vector<int> v3(10,1);  //10个元素，都是1
   vector<int> v4{10,1};  //2个元素，一个10，一个1。
   //如果使用了花括号形式，但是提供的值又不能用来列表初始化，则会尝试调用构造函数，例如s3,s4。
   vector<string> s1{"hi"};   //一个元素，内容为hi。列表初始化。
   vector<string> s2("hi");   //错误，没有对应的构造函数。
   vector<string> s3{10};     //10个元素，都是空字符串，等价于vector<string> s3(10);这里不会将10转化为"10"。
   vector<string> s4{10,"hi"};//10个元素，都是hi，等价于vector<string> s4(10,"hi" );
   ```

5. 要想使用列表初始化vector对象，花括号中的值必须与元素类型的构造函数相容。例如提供字符串字面量来初始化string对象。

6. 程序在运行时可以高效地向vector中添加元素。因此一般来说，创建vector就没有必要指定其大小（指定了效率反而可能更差），使用默认的空即可，然后向其中添加元素。

7. 常用操作，大多数与string的类似：

   ```c++
   v.empty();  //为空时返回true
   v.size();   //返回元素的个数，类型为vector<T>::size_type，而不是vector::size_type，具体由无符号类型实现。
   v.push_back(t); //将元素t添加到v的尾端
   v[n];       //返回第n个位置上元素的引用
   v1 = v2;    //调用拷贝赋值运算符
   v1 = {a,b,c}; //用列表中的元素拷贝替换v1中的元素，完成后v1只有三个元素。v1之前有多少个元素都可以，也不影响操作的结果。
   v1 == v2    //对应元素如果都相等，则返回true
   v1 < v2;    //逐个元素进行比较，需要元素也支持<操作
   ```

8. 不能使用下标形式添加元素：

   ```c++
   vector<int> v1; //创建一个空的vector
   v1[0] = 4;  //编译正常，但会触发运行时错误，而在Python等语言中是支持这种操作的。
   v1.push_back(4); //只能使用这种方法添加元素
   ```

9. 不允许vector来初始化数组，但是可以用数组来初始化vector。

   ```c++
   int int_arr[] = {0,1,2,3,4,5};
   vector<int> ivec(begin(int_arr),end(int_arr));  //将int_arr中的元素逐个用来初始化ivec中的元素。
   vector<int> ivec2(int_arr+1, int_arr+3);       //用int_arr[1]到int_arr[2]这2个元素初始化ivec2。不包括第二个指针所指的元素。
   ```

## 迭代器

1. 对于vector或string之类的容器可以使用下标进行随机访问，同时也能使用更通用的迭代器进行顺序访问。标准库的容器只有少数支持下标访问，但是都支持迭代器。

2. 严格来说，vector属于容器，string不属于容器，但是支持很多与容器类型类似的操作。

3. 类似于指针类型，迭代器提供了对元素的间接访问。迭代器可以在元素之间移动，存在有效和无效之分，迭代器指向某个元素或最后一个元素的下一个位置时是有效的。

4. 和指针不一样的是，获取迭代器不用取地址符，支持迭代器功能的类型一般含有多个成员函数，可以返回特定的迭代器。例如begin，end成员函数。begin迭代器指向第一个元素，end指向最后一个元素的下一个位置，也称为尾后迭代器。如果元素数量为0，则首迭代器和尾后迭代器相同，都是尾后。

5. 尾后迭代器没有实际含义，仅仅是一个标记，表明已经处理完所有元素了。

6. 迭代器对象支持的运算：

   ```c++
   *iter;       //返回迭代器所指元素的引用，无效或尾后迭代器不可以解引用。编译正常，运行时报错。
   iter->mem;   //获取迭代器所指元素的mem成员，等价于(*iter).mem。必须要加括号，因为.运算符的优先级比*高。->箭头运算符是C++特有的。将解引用和成员访问两个操作结合起来。
   ++iter;      //移动迭代器，指向下一个元素，不能对尾后迭代器进行++。
   --iter;      //移动迭代器，指向上一个元素，不能对首迭代器进行--。
   iter + n;    //结果为一个新的迭代器，相当于原来迭代器向后移动n次。
   iter += n;   //将iter + n的结果赋值给iter。
   iter1 - iter2;   //计算两个迭代器的距离，结果可能为负，类型为 容器::difference_type，有符号类型。两个迭代器必须属于同一个容器。
   iter1 == iter2;  //当且仅当两个迭代器指向同一个元素，或它们是同一个容器的尾后迭代器时，才返回true。
   iter1 < iter2;   //如果iter1指向的元素更靠前，则返回true。
   ```

7. 所有标准库容器的迭代器都支持递增运算，递减则不一定。

8. C和Java程序员在for循环条件中喜欢使用<和使用下标来获取元素。而C++程序员更喜欢使用!=作为条件和使用迭代器来获取元素。C++标准库中的所有容器都是使用这种编程风格。标准库的所有容器的迭代器都定义了==和!=，但是大多数都没定义<。因此建议多使用!=和迭代器。

9. 迭代器有三种含义：

   1. 迭代器概念本身，它规定了迭代器应该具有的行为。
   2. 由容器定义的迭代器类型，`vector<int>::iterator`
   3. 迭代器类型的某个对象，`vector<int>::iterator it1;`

10. 拥有迭代器的容器会在其内部定义2个类类型，分别为iterator和const_iterator：

    ```c++
    vector<int>::iterator it1;  //it1可以读写vector<int>中的元素
    vector<int>::const_iterator it2;  //it2只能读取vector<int>中的元素。常量指针差不多，可以移动，但是不能写入。
    //容器除了定义这两个类类型外，还要为他们实现应有的操作，例如++，!=等。
    ```

11. 如果容器本身是常量，则只能使用const_iterator，begin和end返回const_iterator；如果不是常量，可以使用iterator和const_iterator，begin和end返回iterator。

    ```c++
    const vector<int> v1; //const的空vector，不能向其中添加元素。
    vector<int> v2;
    auto a = v1.begin();  //a的类型为vector<int>::const_iterator
    auto b = v2.begin();  //b的类型为vector<int>::iterator
    auto c = v2.cbegin(); //C++11引入，也可以用cbegin,cend强制获取const_iterator，不论vector是否是常量。
    ```

12. 不应在范围for循环内向vector对象添加元素。因为它的底部使用的是迭代器，而任何一种可能改变容器大小的操作（例如push_back），都会使得迭代器失效。

13. 

14. 容器一般搭配迭代器使用。一般的智能指针只用处理*和->运算，而迭代器智能指针还需要处理++和--等普通指针可以进行的运算。

15. 双向链表形式的容器结点内部除了存储特定类型的对象，每个结点都还有两个指针，分别指向其前后的结点。迭代器对象内部有一个指针node，该指针指向容器内的某个结点。迭代器对象需要将++操作，转化为node指向下一个容器结点的行为。next和prev指针是指向结点的，而不是对应指针的。

16. 迭代器的使用者，不(也没有必要)知道prev，next的存在，因此对迭代器对象解引用时，应该获得的是data，而不是结点。

17. <img src="C++.assets/image-20210818105430616.png" alt="image-20210818105430616" />

18. ```c++
    template<class T, class Ref, class Ptr> //实际上只有一种类型要传入，Ref是T&,Ptr是T*。
    struct __list_iterator{ //链表迭代器
        typedef __list_iterator<class T, class Ref, class Ptr> self;
        typedef Ptr pointer;
        typedef Ref reference;
        typedef __list_node<T>* link_type;
        link_type node;
        Ref operator *(){return (*node).data;} //或者node->data也行。
        Ptr operator ->(){return &(node->data);} //或者&(operator*())也行。
        self& operator ++(){node = link_type(node->next); return *this;} //这里不进行强制类型转换也行，因为next是void*类型，他可以隐式转化为任意指针类型。
    };
    template <class T>
    struct __list_node{   //链表结点
        void* prev;
        void* next;
        T data;
    };
    /*使用*/
    list<Foo>::iterator ite;
    *ite;     //这里应获得Foo类型的对象。
    ite->method();   //这里应该是Foo::method()
    ```

## 数组

1. 数组也是存放相同类型对象的容器，也需要通过下标来访问。和vector不同的是，数组的大小确定不变，运行时不需要动态改变大小，因此性能较好。如果不清楚元素的确切个数，应使用vector。

2. 数组是一种复合类型，数组大小属于数组类型的一部分，必须大于0，可以有空vector，但是不能有空数组。编译的时候数组大小应是已知的，也就是说数组大小必须是一个常量表达式：

   ```c++
   int* arr2[10];     //数组有10个元素，每个都是int*。
   unsigned int cnt = 42;
   constexpr unsigned int sz = 5; //常量表达式0
   string bad[cnt];  //错误，因为cnt不是常量表达式。
   int aa[sz]; //正确
   ```

3. 定义数组时必须指定元素的类型，不允许使用auto从初始值列表推断。不能创建元素为引用的数组。

   ```c++
   auto arr[4] = { 1,2,3,4 }; //auto类型不能出现在顶级数组类型中
   ```

4. 和内置类型的变量一样，如果在函数内定义了某种内置类型的数组，那么数组中的元素不会被初始化，是未定义的值。

   ```c++
   int main(){
   	int arr1[3];  //三个元素都是随机值
       string arr2[3]; //三个元素都被初始化为空字符串
   }
   ```

5. 可以对数组元素进行列表初始化，此时允许忽略数组的维度，编译器会根据初始化列表的大小来计算数组的维度。如果指明了维度，则初始化列表中的元素数量不能超过维度大小。

   ```c++
   int a[] = {1,2,3};  //int a[3]
   int b[5] = {1,2,3}; //5个元素，后两个为0
   int c[2] = {1,2,3}; //错误，初始值过多。
   int d[5] = {};   //全部初始化0，相当于省略了5个0。
   ```

6. 字符数组是一种特殊的数组，可以用字符串字面值初始化。注意字面值末尾的'\0'也会被拷贝到字符数组中。

   ```c++
   char a[] = {'a','b','c'};   //列表初始化，没有空字符，char a[3]。
   char b[] = "abc";  //字符串字面值初始化，char b[4]。
   char c[3] = "abc"; //编译错误，没有空间存放末尾的空字符。
   ```

7. 不能将数组的内容拷贝给其他数组进行初始化和赋值。一些编译器支持数组的赋值，这是编译器扩展，不建议使用。

   ```c++
   int a[] = {0,1,2};
   int a2 [] = a;  //错误
   a2 = a;  //错误
   int *arr = a;  //正确，可以将数组名赋值给指针，等价于int *arr= &a[0];此时arr和a指向同一个数组区域，不过二者的类型不同，a是int[3]。
   ```

8. 复杂的数组声明，定义数组的指针和引用，最好的方法是从名字开始由内向外阅读，数组的名字紧跟着维度，括号十分重要：

   ```c++
   int *ptrs[10];  //ptrs中有10个元素，都是int*类型。
   int &refs[10] = /*?*/;  //错误，不存在元素是引用的数组。
   int arr[10];
   int (*parray)[10] = &arr;  //parray是一个指针，指向一个数组，该数组中存放着10个int元素。
   int (&rarray)[10] = arr;   //rarray是一个引用，绑定着一个数组，该数组中存放着10个int元素。
   int * (&refarray)[10] = ptrs; //refarray是一个引用，绑定着一个数组，该数组中存放着10个int*元素。
   ```

9. 数组的维度是类型的一部分，因此编译器知道，vector的维度可以由它的size函数获得。因此都可以使用范围for循环。

10. 使用数组时，编译器一般会将它转化为指向数组首元素的指针。因此关于数组的操作，很多时候就是指针的操作。用auto推断数组名时，会得到指针。但是会用decltype推断时，会得到数组类型。

    ```c++
    int ia[] = {1,2,3};
    auto ia2(ia); //ia2也是一个int*类型，指向ia[0]。等价于 auto ia2(&ia[0])，[]的优先级比&高。
    decltype(ia) ia3 = {4,5,6}; //相当于 int ia3[] = {4,5,6}
    //指针和数组最大区别不是是否可以用下标运算符，而是指针可以用另一个指针赋值。数组名却不能用指针赋值，因为数组名相当于一个指针常量。
    int ia[] = { 1,2,3 }; //相当于 int *const ia;但是又不能写成这样，因为指针不能接收多个初始值。
    int x = 4;
    ia = &x;  //报错，提示表达式必须是可修改的左值
    const int ii[] = {1,2,3}; //相当于const in *const ii;无法通过ii修改其元素。
    ```

11. 

12. 数组名可以看做是一级指针，但是数组名的地址并不是二级指针。因为数组名并不是一个变量，没有地址：

    ```c++
    int arr[3];
    int *p1 = arr;  //正确
    int **p2 = &arr; //错误，此时不能将arr当做指针，而是要当做数组
    int (*p3)[3] = &arr; //正确
    ```

13. 

14. 指向数组元素的指针可以使用迭代器支持的所有操作。C++11引入了两个全局函数begin和end，定义在iterator头文件中。接受数组名为参数，分别返回首元素指针和尾后指针。

    ```c++
    #include<iterator>
    int arr[] = { 1,2,3 };
    int* beg = std::begin(arr);
    int* end = std::end(arr);
    ```

15. 两个不同类型的指针无法相减，不同数组的指针相减没有意义。

    ```c++
    int ia[] = { 1,2,3 };
    double ia2[] = { 1.1,2.2 };
    ia - ia2; //编译错误，类型不匹配。
    //同类型指针相减得到的并不是指针的值相减的结果，而是该结果除以指针指向元素大小的结果，也就是两个指针之间的元素个数。
    int ia[] = { 1,2,3 };
    int *p = &ia[2];
    ptrdiff_t diff = p-ia;//结果是2。标准库使用ptrdiff_t类型存储两个指针的差，带符号类型。
    ```

16. 允许给空指针加上值为0的常量表达式，两个同类型的空指针可以相减，结果为0：

    ```c++
    int* p1 = nullptr;
    int* p2 = nullptr;
    double *p3 = nullptr;
    p1 - p2; //结果为0
    p1 + 0;  //结果为0
    p1 - p3; //错误，两个空指针的类型不同。
    ```

17. 数组下标从0开始，类型为size_t，定义在cstddef头文件中，无符号类型，被设计为足够大以便能表示内存中任意对象的大小。

18. 数组和vector都可以使用下标运算符[ ]，但是原因不同，数组是因为C++语言定义的，vector是因为标准库中重载了该运算符。

19. 下标运算可以拆分为指针加减法和解引用的结合。

    ```c++
    int ia[] = { 1,2,3 };
    ia[2] == *(ia+2); //结果为true
    ```

20. 标准库类型规定下标必须是无符号类型，而指针的下标则无此要求，只要指向的元素是原数组中有意义的元素即可。

    ```c++
    int *p = &ia[2];  // p等于ia+2
    p[0];   //相当于*(p+0)，等于*(ia+2)，等于ia[2]。
    p[-1];  //相当于*(p-1)，等于*(ia+1)，等于ia[1]。
    ```

## 多维数组

1. 严格来说，C++中没有多维数组，通常说的多维数组其实是元素为数组的数组。根据距离数组名的距离远近，依次为第一，第二等维度。

   ```c++
   //由内而外阅读数组的声明。
   int arr[3][4];  //arr是一个数组，有3个元素，每个元素都是一个包含4个int的数组。
   ```

2. 对于二维数组来说，经常把第一个维度称为行，第二个称为列，所以`a[3][4]`称为3行4列的数组。

3. 允许使用花括号括起来的一组值来初始化多维数组：

   ```c++
   int ia1[3][4] = {
       {0,1,2,3},  //第一行的初始值
       {4,5,6,7},  //第二行
       {8,9,10,11} //第三行
   };  //多行更容易观察，也可以写到一行。
   //也可以省略内层嵌套的花括号
   int ia2[2][3] = {0,1,2,3,4,5}; //
   //可以省略部分元素使用默认初始化，此时内层花括号不能随意去掉
   int ia3[2][3] = {{0,1},{3}};  //等价于用 {{0,1,0},{3,0,0}} 进行初始化。
   int ia3[2][3] = {0,1,3};      //等价于用 {{0,1,3},{0,0,0}} 进行初始化。
   ```

4. 可以使用下标来访问多维数组中的元素。数组的每个维度对应于一个下标运算符。如果下标运算符的数量和数组的维度一样多，那么结果是给定类型的元素，如果下标运算符的数量较小，则是给定索引处的一个内层数组。

   ```c++
   int arr[2][3];
   int (&arr1)[3] = arr[1]; //arr[1]是一个int[3]类型。arr1是一个引用，指向一个int[3]的数组。
   ```

5. 使用auto来推断数组：

   ```c++
   int arr[3];
   int ia[2][3];
   auto x = arr;   //等价于 int* x = arr;
   auto &xr = arr; //等价于 int (&xr)[3] = arr;
   auto y = ia;    //等价于  int (*y)[3] = ia;
   auto &yr = ia;  //等价于  int (&yr)[2][3] = ia;
   ```

6. 用范围for处理多维数组：

   ```c++
   int ia [2][3] = {0,1,2,3,4,5};
   for (auto &row : ia){  //因为要改变元素的值，所用引用。row是一个引用类型，绑定在int[3]类型上
       for (auto &col : row){  //col是绑定int的引用
           col += 1;  //每个元素都加1
       }
   }
   //之所以使用引用，除了要改变元素的值，还有一个原因是如果不用引用来推断数组名，则会得到一个指向首元素指针。
   for (auto row : ia){  //使用auto来接收ia[0]即int[3]，推断得到的row为int*类型，分别为&ia[0][0]和&ia[1][0]。
       for (auto col : row){   //错误，无法对int*类型使用范围for循环
           cout << col << endl;
       }
   }
   //正常的嵌套for循环
   for (auto p = ia; p != ia + 2; ++p){   //p为int(*)[3]类型
       for (auto q = *p; q != *p+3; ++q){ //*p为int[3]类型
           cout << *q << endl;
       }
   }
   //也可以使用标准库函数begin和end来简化上述循环
   for (auto p = begin(ia); p != end(ia); ++p){
       for (auto q = begin(*p); q != end(*p); ++q){
           cout << *q << endl;
       }
   }
   ```

7. 使用多维数组名时，编译器会自动将其转换为数组首元素的指针，多维数组的首元素也是一个数组，因此结果是指向第一个内层数组的指针：

   ```c++
   int ia[3][4];
   int(*p)[4] = ia;  //正确，ia等于&ia[0]，是一个指向int[4]的指针，可以用p来接收，*p等于ia[0]。
   p[i][j] == ia[i][j]; //结果为真，p可以像ia一样当作二维数组使用。
   p = &ia[2];  //将p指向ia最后一个元素
   *p == ia[2]; //结果为true
   ```

8. 可以使用类型别名来定义数组类型：

   ```c++
   using int_array = int[4]; //C++11新增的
   typedef int int_array2[4]; //同上
   int_array ia1 = { 1,2,3,4 };  //等价于 int ia1[4]
   int_array* ia2 = &ia1; //等价于 int (*ia2)[4]
   int_array& ia3 = ia1;  //等价于 int (&ia3)[4]
   ```

## 仿函数（函数对象）

1. 一个对象，可以像函数一样被调用，可以丰富函数的功能。主要是重载类的()操作符，也被称为函数调用操作符。

2. 标准库内的仿函数都会继承一些奇特的类，例如unary_function。

3. ```c++
   template <class T1, class T2>
   struct pair {    //GNU C中的有序对,两个类型可以不相同。
   	typedef T1 first_type;
   	typedef T2 second_type;
   	T1 first;
   	T2 second;
   	pair() :first(T1()), second(T2()) {}
   	pair(const T1& a, const T2& b) :first(a), second(b) {}
   };
   
   template<class Arg, class Result>
   struct unary_function {           //该类没有成员变量
   	typedef Arg arugment_type;
   	typedef Result result_type;
   };
   
   #include <iostream>
   template<class T>
   struct select1st : public unary_function<T, typename T::first_type> {
   	select1st() { std::cout << "创建仿函数对象" << std::endl; }
   	const typename T::first_type operator () (const T& p) const { return p.first; }
   };
   /*使用*/
   pair<int, int> p1(3, 5);
   select1st<pair<int, int>> s;   //创建一个仿函数对象,嵌套类型。
   int i = s(p1);             //调用重载的()，结果为3。
   ```
   
4. 在模板定义语法中，class和typename用法完全一样，用于指出其后的名称是类型而非变量名。最早 Stroustrup 使用 class 来声明模板参数列表中的类型是为了避免增加不必要的关键字；后来C++委员会认为这样混用可能造成概念上的混淆才加上了 typename 关键字。

5. 不过typename还在嵌套依赖类型中发挥作用，例如下面的代码编译时会报错，因为在模板被实例化前，无法确定const_iterator是类型还是变量，同时，由于无法确定const_iterator的类型，因此模板不能被实例化。因此C++标准委员会引入了一个新的关键字typename，不过由于class已经使用了很长时间，为了现有代码的兼容性，也不会删除class。在T::const_iterator前加上typename，编译器就不会将它当做变量名称了。

   ```c++
   template<typename T>
   void fun(const T& proto){
       T::const_iterator it(proto.begin());
   }
   ```

6. T::const_iterator的类型依赖于模板参数T，称为从属名称。当T是一个类时，它称为嵌套从属名称。编译器很明确地知道模板参数是类型，因此在使用T时，前面不用加typename。

## for循环遍历容器

1. C++11提供新的范围for循环来进行容器的遍历：

   ```c++
   //语法如下：
   for (declaration : expression) //expression是一个对象，用于表示序列，declaration负责定义一个变量，每次迭代，该变量会被初始化为序列的下一个元素值。
       statement
   
   for (int i : {1,2,3,5,6}){ } //编译器会逐个将右边的容器中的元素赋值给左边的变量，然后执行循环体。{1,2,3,5,6}也是C++11的特性，构成一个容器。
   vector<double> vec;
   for (auto m: vec){}   //值传递
   for (auto& m: vec){}  //引用传递，如果想要改变容器中的值，必须使用引用类型来接收。
   ```
   
2. 遍历容器的方法：==for each 或 iterator 详细了解==。

3. 如果循环体内含有向vector对象添加元素的语句，则不能使用范围for循环。范围for循环体内不应改变序列的大小。


# 内存管理

## new,delete

1. new运算符的两个用法，以下两种用法的返回值类型都是int* ：

   ```c++
   //分配一个变量的内存
   int* p = new int;  //可以是基本数据类型。
   //分配一个数组的内存
   int* p = new int[5];  //返回的为数组首元素的地址。
   ```

2. 用delete关键字回收new分配的内存：

   ```c++
   int* p = new int;
   p[0] = 3;
   delete p;
   delete p;  //会报运行时异常。
   
   int* p =new int[5];
   p[0] = 2;
   delete []p;  //正确释放。
   ```

3. 使用array new创建多个对象：

   ```c++
   complex arr[3] = { { 1,2 },4,{5} };  //会调用3次构造函数，单个参数可以不加{}。
   complex arr2[2] = {1,complex(2,3)};  //会调用2次构造函数。
   complex* p = new complex[3];  //这种方式只能调用默认的无参构造函数，因此要求类必须有默认的无参构造函数。
   complex* p[3] = {new complex(1,2),new complex(4)};  //调用两次构造函数，p[2]为NULL。
   ```

4. 对于基本数据类型，在new的时候加上()会自动初始化，否则不会。而对于用class或struct定义的复合数据类型，都会任何方式创建对象都会初始化，因为都会调用构造函数：

   ```c++
   int* p1 = new int;   //此时*p1为任意数。
   int* p2 = new int(); //此时*p2为0
   //array new也是一样。
   int *pia = new int[10]; // 每个元素都没有初始化
   int *pia2 = new int[10] ();  // 每个元素初始化为0
   //复合数据类型
   string *psa = new string[10];  // 初始化为空字符串
   string *psa = new string[10]();  // 初始化为空字符串
   ```

5. new的具体细节：先执行operator new函数分配内存（分配的字节数由编译时的sizeof确定，内部调用了malloc），然后将void * 强制类型转化为对应的类型，最后执行对象的构造函数。第二步结束的时候，对象就已经产生了，this指针也有效了。

   ```c++
   Complex* pc = new Complex(1,2);
   //编译器转化为如下代码:
   Complex* pc;
   void* mem = operator new (sizeof(Complex));  //分配内存
   pc = static_cast<Complex*>(mem);             //转化指针
   pc->Complex::Complex(1,2);                   //执行构造函数，实际为Complex::Complex(pc,1,2),会将pc当做this指针传入。
   ```

6. delete 会先调用对象的析构函数，==析构函数会释放掉类内额外申请的堆内存空间（也是调用delete）==。然后调用operator delete函数（内部调用了free），来释放对象所占据的堆上的内存。

   ```c++
   String* ps = new String("Hello");   //new的对象存放在堆内存中，而String的字符串也存放在堆内存中。因此这一个new表达式会申请两次内存。
   delete ps;
   //编译器会转化为如下代码:
   
   ps->String::~String();   //调用析构函数，实际为String::~String(ps)
   operator delete(ps);     //释放内存
   ```

7. new 和delete是表达式，表达式的行为是不可以改变的，不可以重载，但是operator new等可以被重载。

9. 内存池的设计会用到operator new的重载。可以重载全局的operator new函数（所有的没有自定义operator new的类，会使用全局的operator new），也可以重载类的operator new成员函数(这些类使用为该类定义的operator new，并屏蔽掉全局的operator new函数，此时可以使用::new来调用全局的)。

   ```c++
   /*全局的，不可以被声明在任何一个namespace中*/
   void* operator new(size_t size);
   void* operator new[](size_t size);
   void* operator delete(void* ptr);
   void* operator delete[](void* ptr);
   
   class Foo{
   public:
       void* operator new(size_t size);//这个size参数是由编译器生成的，对应要分配的内存大小，也就是该类型的对象的大小。如果类有虚函数，那么该类的对象占据的空间除了所有成员变量外，还有虚指针。
       void operator new[](size_t size);  
       void operator delete(void* ptr);
       void operator delete[](void* ptr);
   private:
       
   };
   
   Foo* p = new Foo();  //size参数为 sizeof(Foo)。
   delete p;
   Foo* pn = new Foo(3); //size参数为 sizeof(Foo)*3+4。多出来的4个字节是存放数组的大小的，值为3。分配完空间后，会调用3次构造函数，
   delete[] pn;  //按照构造的逆序来调用三次析构。
   ```

10. operator new函数还可以有另一种重载形式，称为placement new，第一个参数都必须是size_t类型的，也就是要申请的内存大小：

    ```c++
    class Foo{
    public:
        void* operator new(size_t size);  //一般的operator new重载
        void* operator new(size_t size, int a);
    };
    /*使用*/
    Foo* pf1 = new Foo();
    Foo* pf2 = new(300)Foo();  //会调用第二个operator new, 300会赋值给参数a。注意和Foo类的构造函数区分，这里都是调用的默认的构造函数。
    ```

11. 也可以多次重载operator delete，不过只有默认的operator delete会被delete表达式调用。只有当new调用的构造函数抛出异常时，才会调用对应的(参数类型完全相同的)重载版本的operator delete。主要用来对未完成创建对象的内存进行回收。因为当分配完内存后，调用构造函数失败，此时应该回收内存，否则会发生内存泄漏。

## 对象的存储

## 单个对象在堆内存中的布局

1. 32位 Visual C++一个complex对象在堆内存中的布局如下，不同的编译器会有不同的处理方式，但是都差不多。

2. complex对象的两个int型成员变量，一共占用8个字节，debug模式下，上下会各有32+4个字节的调试信息。

3. 最上面和最下面各有4个字节的cookie 00000041，用于标识这块内存所占的大小，将来free的时候会参考这里，因为delete的时候只会给一个指针，具体要回收多少字节的内存需要根据这个标识。

4. malloc时，总是分配16的倍数个字节，所以下面还会填补12个字节的pad。因此在调试模式下new的complex对象会占用64个字节，cookie=0x41=0x40+1，其中0x40标识整块内存的大小。1标识这块内存已经被分配出去。因为分配的内存大小总是16的倍数，所以最后的4个bit都是0。

5. 在release模式下，灰色的调试信息都没有了，16就是16的整数倍数，因此不需要添加pad。

6. 因此一个8字节的complex对象，在调试模式下会占用64字节，release，模式下会占用16字节。这是必要的浪费，这些信息在调试和内存回收时要用到。

7. <img src="C++.assets/image-20210815183212838.png" alt="image-20210815183212838"  />


## 对象数组在堆内存中的布局

1. 使用 array new产生的对象数组：

   ```c++
   complex* p = new complex[3];
   ```

2. 3个对象的成员变量紧密排列，上面有一个数组元素个数计数，其余的和单个对象相同。下图中的double应该全部都是int，占用4个字节。

3. <img src="C++.assets/image-20210815194702077.png" alt="image-20210815194702077"  />

4. array new要和array delete搭配使用，不然会出错。delete会先调用析构函数，再调用free回收内存。如果对array new的对象数组使用delete，则会只调用数组第一个对象的析构函数。然后回收整个数组的空间。这样会使得内部含有指针的对象发生内存泄漏，因为少调用了2次析构函数。堆对象本身占据的空间仍然会全部收回。

5. 上面的这种情况对于complex这类内部没有指针变量的对象是不会造成内存泄露的，但是也应搭配使用array new和array delete。

# 标准输入输出

1. C++语言并未定义任何I/O语句，它包含了一个全面的标准库来提供I/O机制。

2. iostream库包含2个基础类型istream和ostream，分别表示输入流和输出流。一个流就是一个字符序列，从I/O设备读出或写入。流的意思是逐个字符，按照顺序处理。

3. 标准库定义了4个IO对象，可以直接使用。系统常常将这些对象和所运行的窗口关联起来，因此当读写这些对象时就会读写窗口。

   1. cin是istream类的对象，也成为标准输入。

   2. cout是ostream类的对象，也成为标准输出。

   3. cerr也是ostream类的对象，称为标准错误，用来输出warning和error信息。

   4. clog也是ostream类的对象，用来输出运行时的一般性信息，记录日志。

4. 通常为了调试，会添加打印语句，这类语句应该时刻刷新流，以确保在程序崩溃前能及时输出，这样能够提高对崩溃位置的推断。

5. \>\>可以看做是将左边的东西丢进右边。\<\<可以看做是将右边的东西丢进左边。而cin或cout只能出现在运算符左边。因此\>\>是标准输出，\<\<是标准输入。

6. `<<`是输出运算符，接收2个对象，左侧需要是一个ostream对象，右侧是要打印的值。此运算符将该值写入到给定的ostream对象中，结果是其左侧的那个ostream对象。

7. `>>`是输入运算符，接收2个对象，左侧是一个istream对象，右侧是一个任意对象，它从给定的istream中读入数据，并存入右侧对象中，结果是其左侧的那个istream对象。

8. 标准库定义了不同版本的输入输出运算符，来处理这些不同的右侧对象。

9. cout可以看做是ostream子类的一个对象。

   ```c++
   class _IO_ostream_withassign
       :public ostream{      //继承自ostream
   };
   extern _IO_ostream_withassign cout;   //cout继承自ostream。
   class ostream
       :virtual public ios{
           ostream& operator << (int n);  //ostream中重载了所有内置类型的输出运算。
           ...
   };
   ```

10. <\< 和 \>\>这两个称为流插入和流提取运算符，是左移，右移运算符的重载。std::cout是定义在\<iostream\>中的ostream类的对象。std::cin是该文件下的istream类的对象。这两个操作符的返回值都是左侧对象，因此可以连用。

    ```c++
    int a, b;
    cin >> a >> b;
    cout << a << endl << b << endl;
    class complex{
        friend std::istream& operator >>(std::istream& is,  complex& r) {  //普通函数，complex类的友元，方便直接获取私有变量。
    		is >> r.re >> r.im;  //cin会将接收到的内容按照空格，tab键分块，每次只提取一块。
    		return is;
    	}
    };
    /*使用*/
    complex c(3);
    cin >> c; //输入5 8回车，结果c为(5,8)
    ```

11. 可以使用`while(std::cin >> value)`来读取数量不定的输入数据。这里循环条件是读取后的cin对象，实际是检测流的状态，如果流是有效的，即没有遇到错误，那么条件满足，若遇到文件结束符（EOF）或者遇到一个无效的输入（读入的值和value变量的类型不匹配），则该流的状态会变为无效，此时条件不满足。

    ```c++
    //预先不知道有多少个数，只能不断读取，知道没有新的输入为止。
    int i = 0, sum = 0;
    while (std::cin >> i) {  //每次输入一个数字，然后按回车。
    	sum += i;
    }
    //上述代码的使用有两种方法：
    //第一种，每次输入一个数字，然后按回车。想要终止输入时，按Ctrl+D，再按回车即可，此时std::cin>>i返回的cin，进行bool求值，结果是false，于是退出循环。
    //第二种，一次性输入多个数字，每个数字之间用空格分隔，然后按Ctrl+D，再按回车结束。cin会一次性把刚才输入的多个数字都存放到缓冲区中，然后每次读取一个整型数据，赋值给i。
    ```

12. cin的策略是，只要开始一次输入调用，就会允许用户输入，然后将输入的所有内容都存放到缓冲区中。然后每次从缓冲区出一个预定类型的数据赋值给变量，只要缓冲区还有内容，就会直接使用，而不是要求用户重新输入。

13. 如果cin是从键盘读入时，可以使用如下方式来键入一个文件结束符。

    ```shell
    Ctrl+Z然后按回车  #Windows
    Ctrl+D           #Unix
    ```

14. `>>`输入运算符的类型匹配比较复杂：==xxx==。

# 智能指针

1. C++的类设计出来可能会像指针或者函数。它比传统的指针功能更丰富，称为智能指针。指针允许的操作，智能指针对象都应提供。智能指针实际上是一个对象，重载了指针相关的运算符。

2. C++ 11前有一个智能指针，称为auto pointer，C++ 11之后，有多个智能指针。

3. C++11提供了shared_ptr这个类模板，用于创建特定类的智能指针。

4. 智能指针的特点：

   1. 内部存在一个成员变量，是要指向对象类型的普通指针。
   2. 存在*和->等操作符重载函数。

   ```c++
   template<class T>
   class shared_ptr{
       T& operator *() const {return *px;}
       T* operator -> () const {return px;}
       shared_ptr(T* p):px(p){}
   private:
       T* px;
   };
   /*使用*/
   Struct Foo{
     void method();  
   };
   
   shared_ptr<Foo> sp (new Foo());new一个Foo的对象，将他的地址作为参数构造一个智能指针对象sp。
   Foo f(*sp);     //*sp可以获得智能指针sp指向的对象。
   sp->method();   //sp->被重载，智能指针指向的对象的指针->，即px->method();
   ```

5. 从理论上来看，sp->会变成px，这样就少了一个->，不过->有个特点就是作用完还会再补充一个->，方便使用。


# 临时对象

1. 临时对象，使用类名()生成的，可以有参数，没有对象名。函数内生成的临时对象，不可以使用引用或指针接受。因为该对象在栈上，函数返回后再使用就可能出错。标准库中使用较多。临时对象只能在创建的那一行使用，后面就抓不到他了。临时对象超出所在行就会调用析构函数。

   ```c++
   //最佳写法
   inline complex operator + (const complex& x, const complex& y){  //operator和符号中间的空格可以省略
       return complex(real(x)+real(y),imag(x)+imag(y));     //这里是+运算不是+=，因此不能赋值给操作数，因此要返回一个新的对象，同时返回值类型也应为值类型，而不是引用。这里会调用构造函数创建一个临时对象，然后调用拷贝构造函数将临时对象从被调函数的局部空间拷贝会调用者所在的空间。然后再销毁临时对象，最后返回。
   }
   //第二种写法
   inline complex operator + (const complex& x, const complex& y){  //operator和符号中间的空格可以省略
       const complex& tmp = complex(real(x)+real(y),imag(x)+imag(y));     //基本过程同上，只不过是在函数内的栈中多了一个局部变量tmp。
       return tmp;
   }
   //第三种写法
   inline complex operator + (const complex& x, const complex& y){
       complex tmp(real(x)+real(y),imag(x)+imag(y));     //和第二种一样。
       return tmp;
   }
   ```

# 头文件

1. 一般来说，C++程序应该使用类似cstdio的头文件，而不是stdio.h。而且应该使用std来使用其中的名字。

2. C标准库的头文件在C++中仍然可以使用，不过都被包装成了C++的样子，例如给stdio.h套了一层壳就有了cstdio。同时将C标准库的名字都放到了std命名空间种。C++程序不推荐使用C的标准库。

   ```c++
   //<csdtio>的写法
   #include <stdio.h>
   namespace std {
   	using :: printf  //这使得std::printf就是stdio.h中定义的printf。
       ...
   }
   //有以下两种写法：
   printf("aaa");      //C语言的，使用#iclude<stdio.h>或<cstdio>都可以使用这个。
   std::printf("abd"); //C++推荐的，只有#include<cstdio>才可以用
   ```

3. 预处理变量不属于任何命名空间，它是由预处理器处理的，直接使用即可，例如NULL。

4. 头文件通常包含那些只能被定义一次的实体，例如类、const变量、constexpr变量。有了防卫式声明，可以确保这些实体只被定义一次。

5. 头文件也经常用到其他头文件的功能，例如xx.h用到了string类，则必须包含string头文件。xx.cpp也会用到string，也应包含string头文件。一般来说xx.cpp也会包含xx.h。因此xx.cpp就包含了两次string头文件。因此每个头文件都需要使用防卫式声明。

6. 头文件一旦更改，所有使用到它的源文件必须被重新编译，以便使用更新过的声明。

7. 预处理变量有两种状态，已定义和未定义。#define将一个名字定义为预处理变量，#ifdef 当且仅当变量已定义时返回true，#ifndef当且仅当变量未定义时返回true。两个#if都要和#endif配合使用，可以嵌套，但是不能交叉。

8. 整个程序中，每个头文件的防卫式声明必须唯一，通常使用类名，而且全大写，这是为了避免和程序中的其他实体发生冲突。

9. 标准库的头文件扩展名在不同的平台上可能不同。自定义的头文件也可以使用任意的扩展名，因为预处理器不检查扩展名。

   ```c++
   #include <iostream>   //标准库的头文件
   #include "complex.h"  //自己定义的头文件
   ```

10. 自定义的头文件需要有防卫式声明，为了使每个头文件只被引入一次，宏名前后都应该有两个下划线，这是为了和操作系统或标准库的头文件区分开。宏名应该和文件名一致，一般全大写。头文件名一般要和类名一致，建议都用小写，标准库的头文件都是小写。

11. 标准的头文件框架如下，一个头文件一般由一个或多个类组成：

    ```c++
    #ifndef __COMPLEX__
    #define __COMPLEX__
    //正式内容
    
    #include <cmath>  //引入其他头文件
    
    class ostream;
    class complex;  //类的前置声明，一般会将本文件中定义的类写在这里，这样用户可以一眼就知道本文件中定义了哪些类，同时也可以起到声明的作用，防止发生编译错误。
    
    class complex{
        ...
    };  //类内声明，所有的成员变量和成员函数都在这里声明，部分想要内联的成员函数可以定义在类内部。
    
    complex::function ...   //类外定义，只要是没有在类内定义的函数都要在此定义。需要加上类名限定符。
    
    #endif
    ```

12. 为某个类专门定义的普通函数（例如操作符重载函数），必须在头文件中声明，否则类的用户无法编译通过。如果只在头文件中声明的话，会报链接错误，即找不到函数，即使在其他地方定义也不行的。如果定义在.cpp文件中的话，要在头文件中对应的声明前加上extern。当然也可以直接在类的头文件中定义。前者是在链接时找到函数定义，后者是在编译时找到。

    ```c++
    //complex.h
    class complex{...}
    extern inline const complex& operator +(const complex& x);
    
    //complex.cpp
    inline const complex& operator +(const complex& x) {
    	return x;
    }
    
    //main.cpp
    #include "complex.h"
    int main() {
    	complex c1(1, 2);
    	+c1;
    }
    ```

# .hpp文件

1. hpp（Header Plus Plus），其实质就是将.cpp的实现代码混入.h头文件当中，定义与实现都包含在同一文件，则该类的调用者只需要include该hpp文件即可，hpp文件不会被单独编译，不再生成单独的obj，采用hpp将大幅度减少调用 project中的cpp文件数与编译次数，也不用再发布烦人的lib与dll,因此非常适合用来编写公用的开源库。
2. .hpp文件中不能包含全局对象和普通函数，因为它可能被多次#include，链接时就会造成符号重定义错误。需要去除全局对象，将普通函数封装为类的静态方法。
3. http://blog.chinaunix.net/uid-24118190-id-75239.html

# 类型检查

1. C++中对类型检查非常严格，不支持也没有默认数据类型，所有的标识符都必须显式声明类型，除了auto这种可以自动推导类型的，这么做的原因是因为C++中函数重载就是根据类型检测来选择函数的。而C语言中，函数如果没有声明返回值或参数类型，则默认为int类型。

   ```c++
   //C语言
   f(i){  //变量i默认为int类型。函数的返回值默认为int类型。
       printf("i=%d\n",i);  //函数返回值为输出的字符个数，这里为4。
   }
   g(){ //该函数可以接受任意多个参数。
       return 5;
   }
   h(void){
       
   }
   int main(){
       int x =f(1);  //x的值为4。
   }
   
   //C++
   void f() { //该函数不能返回任何值，即使不需要返回值，void也不能省略。
   	return 3;//会报错，因为函数声明中了允许返回任何值，只用return就可以了。
   }
   int g(){
       return; //会报错，因为函数声明了必须返回一个int值，在return后加上一个具体的数值即可。
   }
   ```

2. 关于可变参数问题，C和C++的用法也不同：

   1. int f()在C语言中表示返回值为int，接受任意多个参数的一个函数。
   2. f(void)在C语言中表示返回值为int的无参函数，不过也可以给该函数传参，会报warning。
   3. int f()在C++中表示返回值为int，不接受任何参数的函数。如果尝试给函数传参，会报error。
   4. int f(void)在C++中的含义同上。

# 函数指针

1. 普通函数的函数指针和成员函数的函数指针存在差异，使用成员函数指针和对象(指针)来调用对应的函数，需要用到.\*或->\*运算符：

   ```c++
   class complex{
   private:
       int re,im;
   public:
   	int real()const { return this->re; }
   };
   int func(int a) {   //普通函数
   	return ++a;
   }
   /*成员函数*/
   int(complex::*pf)()const;  //定义了一个complex类的成员函数指针变量。
   pf = &complex::real;  //这里必须要加&,普通函数可以省略&
   complex c(3);
   (c.*pf)();  //第一个括号必须加
   complex* cp1 = new complex(5);
   (cp1->*pf)();  //使用对象指针来调用成员函数指针，需要用到->*运算符。
   /*普通函数*/
   int(*pf1)(int);  //定义一个函数指针变量
   pf1 = func;      //函数指针的赋值可以省略&。
   pf1 = &func;
   pf1(3);         //函数指针的调用也可以省略*。
   (*pf1)(4);      //如果使用*,那么第一个()就必须加上。
   /*定义函数指针类型*/
   typedef int(*Tpf1)(int);  //定义一个普通函数指针类型
   Tpf1 pf1 = func;          //使用上面的类型定义一个函数指针变量
   Tpf1 pf2 = func;          //和上面的函数指针指向同一个函数。
   ```

# 命名空间

1. 命名空间（namespace），类似于其他语言的模块和包，是为了避免重名。标准库所有的内容都被包含在std中，可以分段来写，也可以出现在不同文件中，最终会自动结合：

   ```c++
   namespace std{
   	//这里边的函数，对象，类都包含在该namespace中。
   }
   //三种使用方法：
   std::cout;  //最一般的使用方法。通过作用域运算符来使用。
   
   using namespace std; //using指示。完全暴露整个命名空间中的所有名字，他的位置和头文件的包含位置没有关系，只要在使用前放置即可。
   cout;
   
   using std::cin;   //using声明。逐个暴露。
   cin;
   std::cout;     //没有被暴露的需要加上命名空间。
   ```

2. namespace可以用于隔离环境，测试的时候可以使用，不同部门编写的程序应该自己封装一下。

3. 使用命名空间中的名字的简单又安全的方法：使用using声明。不过只有包含了相应的头文件才可以使用using来简化步骤，也就是using声明不能代替名字本来的声明，因为using声明没有类型信息：

   ```c++
   using std::cin;  //之后就可以直接使用cin了。
   cout;            //错误，因为没有using std::cout；每个名字都需要独立的using声明。
   using std::string; using std::cerr;  //可以将多个using声明写到一行，不过每个应有单独的分号。
   ```

4. 头文件中的代码一般来说不应该使用using声明，因为头文件会被拷贝到其他文件中去，可能会不经意包含某些名字，污染该文件中的名字。


# 命名粉碎

1. C++语言为了使得重载的函数能够在链接时被正确识别，会使用命名粉碎（name mangling）的技术，即将参数，命名空间，返回值，调用方式等信息加入到函数名中，这样就可以区分重载的函数了。在需要进行反射操作时，也要解析名称。不同的编译器有不同的粉碎规则，都提供了逆向解析名称的工具。

   ```shell
   #VS的工具undname在D:\Program Files (x86)\Microsoft Visual Studio\2019\Community>，也可以使用工具链命令行直接调用。
   undname ??2@YAPAXI@Z #结果为  "void * __cdecl operator new(unsigned int)"
   #gcc的工具c++filt可以直接调用
   c++filt _ZN6PersonC1Ev #结果为Person::Person()
   #也有在线的网站可以使用http://demangler.com/
   ```

2. gcc还提供了一个库cxxabi可以嵌入到其他程序中来进行名称还原。

   ```c++
   #include <iostream>
   #include <cstdlib>
   #include <cxxabi.h>
   
   struct empty { };
   template <typename T, int N> struct bar { };
   
   int main() {
       int     status;
       char* realname;
       struct bar<struct empty, 17> u;
       const std::type_info& ti = typeid(u);
       realname = abi::__cxa_demangle(ti.name(), NULL, NULL, &status);//第一个参数为待解析的名字，status接收错误状态
       std::cout << ti.name() << "\t=> " << realname << "\t: " << status << '\n';
       //输出为 3barI5emptyLi17EE       => bar<empty, 17>       : 0
       std::free(realname); //由于__cxa_demangle函数使用C语言编写的，所有需要手动释放返回的指针
   }
   ```

3. Name Mangling就是一种规范编译器和链接器之间用于通信的符号表示方法的协议。

4. 写在extern "C" { }内的名字不会被粉碎，因为会被当作C语言代码来处理，而C语言不进行名字粉碎。

5. 可以使用工具查看目标文件或可执行文件中导出的符号：

   ```shell
   #linux下使用nm -s
   #Windows下使用dumpbin工具
   ```

# 属性说明符

1. 自C++11起，C++就正式引入了属性说明符，它允许程序员给编译器提供额外的信息让其对程序进行优化、检查、约束。它并不是新东西，各家编译器本来就有自带的各种属性，标准属性把一些经典的属性给标准化了。
2. 具体见https://zhuanlan.zhihu.com/p/663893518和https://en.cppreference.com/w/cpp/language/attributes。
