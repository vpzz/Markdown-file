

# 16进制计数法

1. 二进制是现代主流计算机的基础，他可以简化硬件设计，使用开关电路就可以模拟。另一方面二进制与我们熟悉的十进制数存在一一对应关系。不好的一点是，表达同样大小的一个数，二进制所用的位数较多，这也是要使用16进制表示的原因。

2. 将26一直除2，直到商为0，把之前的所有余数倒序排列就得到了26对应的二进制数。

3. ![image-20200827121220004](x86汇编语言：从实模式到保护模式.assets/image-20200827121220004.png)

4. 16进制数之间的乘法需要使用到类似于99乘法口诀一样的东西，不过他是16x16的乘法口诀，比较复杂，可以先将他们分别转化为10进制，计算完成后再转化为16进制。

# 处理器、内存和指令

1. 实际上第一个处理器是Intel4004。处理器会在振荡器脉冲的激励下，从内存取指然后执行。
2. 参与运算的数据通过CPU的引脚送进去，这是需要用一个称为寄存器（因为数据只在这里存在一小会，运算完毕后就没用了）的电路锁住，这是因为存在引脚复用，即同一个引脚接下来还要用来输入其他的参与运算的数据。
3. 寄存器的每一位都是一个触发器，一旦触发器的开关被打开，触发器就会持续输出锁存时的输入，不论后续的输入如何变化。
4. 加法电路在计算加法时，首先将加数锁存到寄存器中，然后将被加数和寄存器内的加数相加，然后再锁存到寄存器中。一般将输入的数成为“外数”。
5. 随着寄存器的增多，寄存器和输入，寄存器之间的运算所需要的开关数量迅速增多。此时使用每个开关来单独完成一个运算就很低效了，可以使用开关的组合来对应之前的单个开关的操作。这样一开可以发挥二进制的指数效应。也就形成了指令。原来5个开关只可以控制5个运算，现在可以控制$2^5$个运算。
6. <img src="x86汇编语言：从实模式到保护模式.assets/image-20200827182247697.png" alt="image-20200827182247697"  />
7. 寄存器是双向器件，可以在一端接受输入并锁存，同时在另一端产生一模一样的输出。算术逻辑单元（ALU）和寄存器相连，它是专门负责运算的电路。ALU计算得到的结果会输入另一个寄存器锁存。
8. 处理器内部还有一个控制器，他负责给各个部件发送控制信号，负责协调，避免冲突。
9. 早期的处理器中的寄存器只有8，16位等，现在的一般都是64位的。
10. 寄存器中的位，按照从右到左，由低到高的顺序来排列。
11. <img src="x86汇编语言：从实模式到保护模式.assets/image-20200827124359943.png" alt="image-20200827124359943"  />
12. 内存按照字节来组织,每个字节对应一个地址，最低地址为0x0000。最小访问单位为1字节，但是可以按照字节，字，双字，四字进行访问，即访问一次就能处理搞到64位的二进制数。处理器通过字长信号来控制一次访问的大小，如果给出的字长是16位，地址为0x0002，则会一次性访问0x0002和0x0003这两个字节。成块的内存地址为最低地址。
13. 内存上有地址线，数据线和控制线（不仅指明要进行读还是写，还要指明操作的单位是字节还是字或双字）。地址线的大小决定可以访问的内存容量大小。数据线的大小决定可以一次操作的内存单元的数量。二者并不一定相同。
14. <img src="x86汇编语言：从实模式到保护模式.assets/image-20200827185806206.png" alt="image-20200827185806206"  />
15. 早期的内存是下图这种磁芯存储器。后来的core dump中的core也来源于磁芯的概念。因此core dump也称作内存dump。
17. 一般来说，指令由操作码和操作数构成，但也有一部分指令只有操作码，例如停止指令。指令的长短不一，最短为1个字节，最常可能有十多个字节。
18. 下图第一条指令的操作码为B8，是一条传送指令，第一个操作数是寄存器，第二个操作数直接包含在指令中，紧跟在操作码之后，可以立即从指令中获得，所以叫做立即数。同时操作码B8还指明了该寄存器是RA，16位寄存器，所以要将其后的2个字节0x005D传送到RA中。
19. <img src="x86汇编语言：从实模式到保护模式.assets/image-20200827130957711.png" alt="image-20200827130957711" />
20. 操作码中隐藏了很多信息，包含了指令的长度，因此CPU读取到该指令的操作码后，就知道下条指令相对于这条指令的位置。
21. 第一条指令中的立即数之所以是0x005D，不是0x5D00，是因为Intel处理器对于按照字，双字等来访问内存时，采用的是小端（低端）顺序。即按照字的方式来读取内存地址0x0001时，会读到0x005D。高地址对应高字节，低地址对应低字节。如果是一次读取一个双字，则读取到的是0x1E8B005D。
22. 对于复杂的指令来说，一个字节的操作码可能不够，所以第二条指令的操作码为，8B1E，2个字节，它也是个传送指令（将一个内存地址中的数据传送到寄存器中），第一个操作数是RB寄存器（已经隐含在操作码中），第二个操作数是内存地址0x003F。这一个操作相当于高级语言里的指针。这一步会将0x003F处的一个字的数据（0x1002）复制到RB寄存器中。
23. 以上所说的传送，其实都是复制，原数据不会发生任何改变。
24. 从这两条指令可以看出，立即数就是不需要再访问内存，直接在指令中就可以获得的操作数。
25. 指令和非指令只是对CPU而言的，一般无法区分，因此为了避免CPU运行非指令内容，要将指令和数据分开存放。存放指令的区域成为代码区，存放数据的区域成为数据区。
26. 一个处理器能够识别的指令的集合成为指令集，一般有几百条指令。指令可以分为以下几种：算术运算，逻辑运算，数据传送（寄存器之间，寄存器和内存寄存器和外存之间），处理器状态控制指令（权限管理，保护模式的切换等）。
27. 8086是Intel第一款16位处理器。它是整个32位架构（IA-32）处理器的鼻祖。同时他也是一款非常成功的产品。他前面有4004→8008，这两款都是8位的处理器。处理器的位数说的是寄存器和ALU的位数。后续的产品有80286→80386。
28. CPU主要分为以下三个部分，总线接口部件和外部的地址线和数据线连接，指令执行部件包含了很多寄存器，参与运算，它的核心是算术逻辑部件ALU。控制部件负责协调控制处理器的运行状态，调控取指执行的循环。
29. <img src="x86汇编语言：从实模式到保护模式.assets/image-20200827191436744.png" alt="image-20200827191436744"  />
30. 汇编语言程序要经过汇编程序处理，才可以被机器识别。第一个汇编程序一定使用机器指令编写的。
31. 8086内部有8个16位通用（可以用于多种目的）寄存器。分别为AX，BX，CX，DX，SI，DI，BP，SP。同时这8个寄存器中的前4个，又可以单独拆分为2个8位的寄存器单独使用，互不影响。
32. 2个地址指针寄存器：BP(base pointer),SP(stack pointer)；2个变址寄存器：SI(source index),DI(destination index)
33. <img src="x86汇编语言：从实模式到保护模式.assets/image-20200827131951878-1737717304140-1.png" alt="image-20200827131951878"  />
34. 内存中段的划分是逻辑上的，因为指令和数据集中存放是对程序有利的。
35. 8086有16根数据线，它的宽度和寄存器的大小相同。有20根地址线。

# x86保护模式

## 段寄存器

1. 段寄存器一共有8个ES，CS，SS，DS，FS，GS，LDTR，TR。
2. 段寄存器有96位，分为4个部分，只有低16位是可见的，selector，称为段选择子。base表示当前段的的起始地址。limit表示当前段的长度。attribute表示当前段是可读，可写还是可执行的。实际的地址应该在[base,base+limit]的范围内。
3. ![image-20210526102559740](x86汇编语言：从实模式到保护模式.assets/image-20210526102559740.png)
4. 段寄存器的读写，mov ds,ax 写段寄存器的时候是根据段选择子ax来查询GDT或LDT中的表项，将表项中的base，limit和attribute还有slector赋值给96位的ds寄存器：
5. <img src="x86汇编语言：从实模式到保护模式.assets/image-20210526102802336.png" alt="image-20210526102802336" style="zoom: 67%;" />
6. 可执行表示当前段修饰的地址可以复制给EIP。
7. 内存地址本身没有可读，可写，可执行的属性。而我们访问地址往往是通过段来访问的。段就是拥有相同属性的内存的集合。同一个内存在不同的段中，可以有不同的属性。

## GDT

1. GDT全局描述符表，LDT局部描述符表。当执行mov ds,ax之类的指令时，CPU根据AX的值来查表，将段描述符赋值给ds。

2. LDT在Windows中并没有使用。GDT表的开始位置和大小记录在GDTR寄存器（共48位，32位是GDT的地址，16位是占用的字节数）中。从下面可以发现GDT表的开始位置在内存的8003f00处，大小为3ff个字节。

   ```
   kd> r gdtr
   gdtr=8003f000
   kd> r gdtl
   gdtl=000003ff
   ```

4. GDT表的每一项称为段描述符，8个字节为一个。结构如下：

5. ![image-20210526110217386](x86汇编语言：从实模式到保护模式.assets/image-20210526110217386.png)

6. 例如第2个段描述符的64位为00cf9300-0000ffff。分别对应上图的上下两部分。

7. ![image-20210526110320535](x86汇编语言：从实模式到保护模式.assets/image-20210526110320535.png)

8. mov ds,ax其中ax就是段选择子，共16位。例如ax=001B即00000000 00011011，那么RPL=3，TI=0，Index=3。即查询GDT表的第3个段描述符。也就是内存地址为0x8003f000+3*8。

9. ![image-20210526120122606](x86汇编语言：从实模式到保护模式.assets/image-20210526120122606.png)

10. 除了mov指令，还可以用LES，LSS，LDS，LFS，LGS来修改段寄存器。CS不能通过上述指令单独修改，因为CS要和EIP一起修改。下面的高2个字节给es寄存器实际上是将高2个字节当做段选择子，去GDT中找到相关的段描述符，整理后赋值给96位的段寄存器es。

    ```assembly
    char buffer[6];
    __asm{
    	les ecx,fword ptr ds:[buffer]  #fword表示6个字节。从ds:[buffer]开始，高2个字节给es，低4个字节给ecx。ecx的值没有用
    }
    ```

11. 上述操作要成功需要满足段选择子的RPL<=目标段描述符的DPL，这里有段权限检查。

12. 段描述符的高4字节的第15位称为P位，P=1表示段描述符有效，P=0表示无效。将段描述符加载至段寄存器时，会先检查该段描述符是否有效。

13. 16位的attribute是从段描述符的高4字节的第8-23位。base分成了3段，之所以是这样是为了向下兼容。

14. limit分成了2段，一共20位。取值范围从00000\~FFFFF，还少12位。如果G位=0，limit的单位为字节，即向高位追加12个0，最大为FFFFF个字节，=1MB。如果G为=1，limit的单位为1页，4KB大小，向低位追加12个1，最大为FFFFF个页，=1M个页=4GB。

15. 段描述符的S位=1，表示当前段描述符为代码段或数据段的描述符，S=0表示当前段描述符为系统段描述符。

16. 段描述符的type域，当S位=1时，type域含义如下，确定了当前段是代码还是数据，还有读写执行权限：

17. ![image-20210526125302367](x86汇编语言：从实模式到保护模式.assets/image-20210526125302367.png)

18. 数据段的三种属性：

    1. W位表示当前段描述符是只读还是可读可写的。
    2. A位表示当前段描述符在最后一次被操作系统清零后，是否被加载过。每当处理器将该段描述符置入段寄存器时，就会将A位置为1。
    3. E位表示当前段描述符是向上扩展还是向下扩展的。向上扩展表示当前段描述符描述的有效地址为base~base+limit范围内。向下扩展表示在之前的范围外。

19. 代码段的三种属性：

    1. A位和数据段的含义相同。
    2. R位表示当前段描述符是否是可读的。
    3. C位是一致位，C=1表示一致代码段，C=0表示非一致代码段。

20. 可见数据段都是可读的，不一定可写。代码段都是可执行的，不一定可读。

21. 系统段描述符的含义（S=1）：

22. ![image-20210526131335153](x86汇编语言：从实模式到保护模式.assets/image-20210526131335153.png)

23. 从上图可以看到系统段中有TSS，调用门，中断门，陷阱门等。

24. 段描述符的D/B位：

    1. 对CS段（将段描述符加载到CS寄存器）的影响，D=1，则采用32位寻址方式。D=0则采用16位寻址方式。
    2. 对SS段（将段描述符加载到SS寄存器）的影响，D=1，隐式堆栈访问指令（call，push，pop，ret）使用32位的栈指针寄存器ESP。D=0则使用16位的。
    3. 对于向下扩展的数据段，D=1表示段的上限为4GB，0\~base和(base+limit)\~4G，D=0表示段的上限为64KB，0\~base和(base+limit)\~64KB。

25. <img src="x86汇编语言：从实模式到保护模式.assets/image-20210526132258985.png" alt="image-20210526132258985"  />

## 特权级别

1. CPU是分为多个特权级别的，这也是实现保护模式的核心，因为有些特权指令只能在0环运行。Windows只是用了0环和3环。驱动和内核都运行在0环。数值越大，权限越低。

2. CPL，当前CPU的特权级别。当前程序的CS寄存器中段选择子的最低两位。SS的低两位永远和CS的相同。

3. DPL，段描述符特权级别，规定了将该段描述符载入段寄存器所需要的特权级别。当CPL<=DPL时，才可以访问。

4. RPL，段选择子的请求特权级别。

5. 下面两个指令的段选择子指向的都是同一个段描述符index=1，但是RPL不同。

   ```assembly
   mov ax,0008
   mov ds,ax #段选择子为00000000-00001000，RPL为0
   
   mov ax,000B
   mov ds,ax #段选择子为00000000-00001011，RPL为3
   ```

6. CPL在段寄存器中，DPL在段描述符中（内存），RPL在段选择子中。

7. 加载数据段的检查，（代码段和系统段的检查不一样）：

8. ![image-20210526134833565](x86汇编语言：从实模式到保护模式.assets/image-20210526134833565.png)

9. 数据段的权限检查比代码段要简单地多。如果特权级别检查不通过，会产生异常，进入异常处理程序。

10. CPL：CPU当前的权限级别。

11. DPL：如果你想访问我，你应该具备什么样的权限。

12. RPL：用什么权限去访问一个段。

## 代码间的跳转

1. 能够改变程序执行路线的指令有：

   1. 同时修改CS和EIP的指令：JMP FAR，CALL FAR，RETF，INT，IRETED。可以实现代码的跨段执行。
   2. 只修改EIP的指令：JMP，CALL，JCC，RET。

2. JMP FAR指令执行步骤：

   ```assembly
   JMP 0x20:0x004183D7
   ```

   1. 段选择子为0x20,据此确定RPL=0，TI=0，Index=4。
   2. 查询GDT表的第4项段描述符。确定当前段描述符的种类，以下四种情况可以用jmp跳转，代码段，调用门，TSS任务段，任务门。后三种是系统段描述符。
   3. 权限检查，如果是非一致代码段，要求CPL=DPL且RPL<=DPL。如果是一致代码段，要求CPL>=DPL。
   4. 如果之前的检查都通过了，CPU会将段描述符加载到CS段寄存器中。但是CS的低两位也就是CPL会用段描述符的DPL来替代。
   5. 将新的CS段寄存器的cs.base+offset(0x004183D7)写入EIP。执行CS:EIP处的代码。跨段跳转结束。

3. 为了对数据进行保护，非一致代码段（普通代码段，大部分的代码段都是这样的）是不允许不同级别的数据相互访问的。由于CPL=DPL，可以看出3环→3环，0环→0环都是可以的，而3→0或0→3是不可以。

4. 如果内核想要给应用程序提供一些功能，可以选择用一致代码段来修饰，这样低级别程序可以在不提升CPL的前提下访问，因此也称为共享段。由于CPL>=DPL，0环→3环不允许。从3环→0环可以访问，但是并不会改变CPL的值，也就是不会提权。

5. 因此长短JMP（不操作栈）和短CALL都不会提升CPL，只能通过调用门提升CPL。

6. 类似于JMP FAR，CALL FAR可以实现段间的调用，也叫长调用。由于会影响堆栈，因此比较复杂。

7. 短调用只影响EIP和ESP。长调用：

   ```assembly
   CALL 0x1B:0x12344321     #0x1B是段选择子，在GDT中的段描述符必须是一个调用门，后面的EIP是废弃的，会被自动忽略。
   ```

8. 如果CPL=DPL，则称为跨段不提权。

9. 不提权的长调用：会依次入栈当前CS寄存器的段选择子（低16位，但是当做32位占用一个栈单元）和返回地址的EIP。调用完毕需要通过长返回RETF来恢复。

10. <img src="x86汇编语言：从实模式到保护模式.assets/image-20210607110346783.png" alt="image-20210607110346783"  />

11. 提权的长调用：会依次将当前的SS寄存器的段选择子（当做32位），当前的ESP，当前CS寄存器的段选择子（当做32位）和返回地址的EIP压入0环的堆栈。原来的堆栈不改变。主要原因是由3环→0环，堆栈也要进行切换。之所以要将3环的栈指针压入0环的栈中，是因为一会要返回3环的时候要设置栈指针。

12. <img src="x86汇编语言：从实模式到保护模式.assets/image-20210607110509699.png" alt="image-20210607110509699"  />

13. CS的权限和SS的权限是同步改变的，二者的等级必须一样。

## 调用门

1. 为了能够进行跨段提权，CPU提供了4种特殊的门描述符来使用：调用门，中断门，陷阱门，任务门。中断门和陷阱门是用来进行中断处理和调用异常的，任务门是用来切换任务的。

2. 调用门允许程序进行可控地提权跳转（目的地址记录在调用门描述符中）。调用门描述符可以存在于GDT，LDT中，但是不在IDT中。调用门描述符中的段选择子指明了要访问的代码段。偏移地址指明了代码段内的偏移。

3. 门描述符的P位总是1，表示该门描述符是有效的。Windows并没有使用调用门，但是使用了中断门。

4. 门描述符中包含了要跳转的代码段的选择子，如果该选择子对应的段描述符的DPL=0，那么通过这个门描述符就可以进入0环。并不是调用门描述符的DPL。

5. 调用门的执行步骤：
   1. 根据CALL CS:EIP 中的段选择子CS，来查询GDT表，发现对应的段描述符是一个调用门。S=0 type=1100。
   2. 调用门描述符的低4字节的16-31位存储着一个段选择子，低4字节的0-15加上高4字节的16-31合起来是一个偏移地址。
   3. 该段选择子对应的描述符的base+上边合起来的偏移地址，是真正要跳转的地址。
   4. 将当前的SS，ESP，CS，返回地址压入到新的栈中，新的栈的SS和ESP是由TSS决定的（因为调用门中存储不了这么多信息了）。新的CS寄存器中的段选择子为调用门描述符中的段描述符。

6. 调用门描述符的各个位的含义：

8. ![image-20210607121800419](x86汇编语言：从实模式到保护模式.assets/image-20210607121800419.png)

9. 使用调用门来切换代码段，一共涉及到了4个特权级别，分别是：
   1. CALL 执行前的CPL
   2. CALL指令操作数中的RPL
   3. 调用门描述符的DPL
   4. 调用门描述符指向的代码段的DPL    这个决定了真正要切换到的特权级别

10. CALL或JMP调用门时要进行的权限检查。

11. ![image-20210607131435099](x86汇编语言：从实模式到保护模式.assets/image-20210607131435099.png)

12. 调用门的param.Count这4位，记录了需要传递的参数个数。参数需要手动push入栈，call该调用门的时候，CPU会将入栈的参数复制到新的栈中。

    ```c
    int g_a, g_b, g_c;
    __declspec(naked) void getParam(int a, int b, int c) {
    	__asm {
    		// int 3 // 取消注释可以在WinDbg中看R0栈数据
    		pushad // 0x20 B
    		pushfd // 0x04 B
    		//             .- 8 个通用寄存器和标志寄存器占用大小
    		//             |     .- cs 和 eip 占用大小
    		//             |     |
    		mov eax, [esp+0x24+0x08+0x08] // 参数 1
    		mov g_a, eax
    		mov eax, [esp+0x24+0x08+0x04] // 参数 2
    		mov g_b, eax
    		mov eax, [esp+0x24+0x08+0x00] // 参数 3
    		mov g_c, eax
    		popfd
    		popad
    		retf 0x0c
    	}
    }
    int main(int argc, char* argv[])
    {
    	// 构造cs:eip
    	char cs_eip[6] = {0, 0, 0, 0, 0x48, 0};
    	__asm {
    		push 1
    		push 2
    		push 3
    		call fword ptr [cs_eip];
    	}
    	printf("g_a = %d\ng_b = %d\ng_c = %d\n", g_a, g_b, g_c);
    	return 0;
    }
    ```

13. 下图是带有三个参数的调用门，刚执行完CALL指令后0环栈的情况。栈顶保存的是3环的返回地址。

15. 使用调用门时，开始执行的指令地址由调用门描述符决定，但是使用RETF返回时，返回的地址由CALL该调用门之前压入栈中的值决定。

16. 调用门跳转到的程序应该是这样的：

    ```assembly
    __asm {
    		pushfd #将EFLAGS寄存器入栈
    		pushad #将所有的32位通用寄存器入栈
    ...
    		popad #将所有的32位通用寄存器出栈
    		popfd #将EFLAGS寄存器出栈
    		retf
    }
    ```

    

## 中断门

1. 中断门一般用在系统调用和调试中。调试的时候，就是将对应的指令修改为0xcc，这就是int 3指令的硬编码。
2. 中断门也是查表，不过是IDT表。IDTR寄存器存储着中断描述符表的位置和大小。GDT表中的第一项是全0，而IDT表不是。

   ```
   kd> r idtr
   idtr=8003f400
   kd> r idtl
   itdl=000007ff
   ```
3. IDT中存储的都是系统段描述符，例如任务门，中断门，陷阱门描述符。
5. <img src="x86汇编语言：从实模式到保护模式.assets/image-20210607134338260.png" alt="image-20210607134338260" style="zoom:80%;" />
6. 可以看到中断门和陷阱门描述符的type域中有一位是D，D=1表示该门是32位的，D=0表示该门是16位的。
7. 中断门不允许传参数，段选择子一项指明了要跳转的代码段。
8. 如果要通过中断门进行提权，那么中断门也会进行栈的切换，基本步骤和调用门类似，只不过中断门多做一件事，将当前的EFLAGS寄存器压入0环栈中。之所以要保存EFLAGS，是因为他要将IF置为0，忽略可屏蔽中断。也就是中断门内部的代码执行时，不会再被中断，避免中断被中断。
9. 陷阱门和中断门唯一的区别：中断门执行时，会将IF位清零，陷阱门不会。IF位如果为0，则表明忽略可屏蔽中断，例如键盘的按下。不可屏蔽中断一般都是发生了灾难性时间，例如电源掉电，总线奇偶位错位等。
10. 可以用int 指令来产生软中断，该指令有一个操作数，称为中断向量，从0到255。CPU通过中断向量号在中断向量表中查找对应的中断门（中断描述符表的基址+中断向量号*8），进而跳转到中断处理程序。0-31号中断由CPU保留，例如int 3会让程序断下来，可以进行调试。
11. 在0环可以执行LIDT和SIDT来读写IDTR寄存器，从而从一个新的地方来读取中断描述符表。
12. 在中断处理程序中使用iretd指令来返回到中断前的位置继续执行。
13. 中断可以是外围部件产生的，通过CPU的针脚传递进CPU，进而获得CPU的服务。x86 CPU有两条中断请求线：非屏蔽中断线NMI，可屏蔽中断线INTR。如果ELAGS寄存器的IF位为0，表示通过INTR线传过来的可屏蔽中断都会被忽略，不可屏蔽中断无法通过IF位来屏蔽。80x86CPU的2号中断是不可屏蔽的。Windows系统的IRQ0是时钟中断，在10-20ms之间。这样即使OS可以在不同的进程之间切换。
14. ![image-20210609020006229](x86汇编语言：从实模式到保护模式.assets/image-20210609020006229.png)
15. ![image-20210609020243388](x86汇编语言：从实模式到保护模式.assets/image-20210609020243388.png)
17. 缺页异常产生的情况：
    1. 当PDE/PTE的P位为0时，但是试图访问时。
    2. 当PDE/PTE的属性为只读，但程序试图写入时。
17. 当物理内存使用紧张时，OS可能会将属于某个进程A的物理页的内容写入到文件中，同时将PDE和PTE的P位置为0，然后将该物理页腾出来给进程B使用。而当进程A再次访问该物理页时，发现PDE或PTE的P位为0，就会产生缺页异常，执行对应的处理程序，OS会检测PTE和PDE，如果发现是之前使用过的页面，就去将进程B占据的物理页内容换出到文件，同时去对应的文件中读取出来内容，换入物理页中。整个过程对于程序来说是透明的。程序执行时，缺页异常是经常发生的。
18. 硬件级别，可屏蔽中断是由一块专门的芯片来处理的，称为中断控制器，分配中断资源和管理各个中断源发出的中断请求。为了方便标识，中断管理器通常用IRQ(Interrupt Request) 后面加上数字来表示不同的中断。
19. ![image-20210607213215052](x86汇编语言：从实模式到保护模式.assets/image-20210607213215052.png)
20. 当TF被设置为1时，CPU进入单步模式，所谓单步模式就是CPU在每执行一步指令后都产生一个单步中断。主要用于程序的调试。
21. 例如在单核模式下运行多线程程序，就可以通过将IF置为0，来屏蔽时钟中断，进而实现原子操作。
23. 中断与异常的区别：
    1. 中断来自于外部设备，是中断源（比如键盘）发起的，CPU是被动的。
    2. 异常来自于CPU本身，是CPU主动产生的.
    3. INT N虽然被称为“软件中断”，但其本质是异常。EFLAG的IF位对INT N无效。

## TSS

1. 在调用门，中断门，陷阱门等中，一旦发生了权限的切换，就会切换堆栈，新的堆栈位置是存储在TSS（任务状态段）中的，通过TR寄存器找到该TSS。
2. TSS是一块内存，有104个字节大小。存储着所有的通用寄存器+段寄存器+标志寄存器+3套堆栈的寄存器+EIP。
3. ![img](x86汇编语言：从实模式到保护模式.assets/2012033110185826.png)
4. CPU层面的任务就是线程，Intel设计的思想是，通过TSS来保存当前线程的执行现场，切换到下一个线程。但是Windows和Linux都没有这样做，主要是这种切换速度非常慢，一条指令要消耗100-200个时钟周期。TSS的工作仅仅是一次性替换一堆的寄存器。
5. CPU通过一个96位的段寄存器TR。TR寄存器的base指明了TSS的基址，limit指明了TSS的大小。TR寄存器是当系统启动时，从GDT中的TSS描述符中加载得来的。
6. Type域如果为1001表示当前TSS描述符还没有被加载到TR寄存器中。，为1011表示当前TSS描述符已经被加载到了TR寄存器中。
7. ![image-20210607140352176](x86汇编语言：从实模式到保护模式.assets/image-20210607140352176.png)
8. ![image-20210607140406201](x86汇编语言：从实模式到保护模式.assets/image-20210607140406201.png)
9. GDT中可以保存多个TSS段描述符（每个都对应到一段TSS内存中），只有TR寄存器指向的那个是正在使用的。
10. LTR指令，接受一个段选择子，去GDT中寻找TSS段描述符，将其加载到TR寄存器中。并不会修改内存中的TSS。该指令只能在0环使用。加载后TSS段描述符的B位会置为1。
11. STR指令可以将TR寄存器的段选择子读出来。
12. 可以在GDT中构造一个TSS段描述符，他指向一块104字节的TSS内存。修改TR寄存器，使其载入该TSS段描述符。从而达到同时切换一堆寄存器的目的。
13. LTR指令只能在0环使用，在3环可以使用JMP FAR访问一个任务段。例如JMP 0x48:0x123456，如果0x48是一个任务段描述符，步骤如下：
    1. 把当前的需要保存的寄存器（TSS中存在的那些）保存到当前TR指向的TSS中。
    2. 根据新的段选择子0x48，将新的任务段描述符加载到TR寄存器中。
    3. 根据TR.base找到新的TSS，将当前和TSS相关的寄存器修改为新的值。
    4. 跳转到新的CS:EIP处执行。
14. 可以通过CALL任务段来切换TSS，也可以通过触发任务门来完成同样的目的，后者更加便捷。任务门存在于IDT表中。
15. IDT中所有的门描述符中都有一个段选择子。通过段选择子查询GDT，找到段描述符，载入到对应的寄存器中。

# 页的机制

1. x86系统为每个进程分配了4GB的地址空间，并不是真实的内存空间。

3. C语言通过&获取到的变量的地址实际上是有效地址。有效地址指的是段内的偏移地址。线性地址是段基址+偏移地址。一般情况下，段基址都是0，FS除外。

4. ```assembly
   mov eax, dword ptr ds:[0x12345678]   #0x12345678是有效地址，ds.base+0x12345678为线性地址。
   ```

5. CPU会将线性地址转化为物理地址，实际读写的就是物理地址对应的内存单元。物理地址还不是真实的内存条上的内存单元地址，不过到这一步就已经可以了。

6. 页是CPU提供的一种管理内存的方式，就是固定大小的内存块，有两种，4KB的小页面，4MB的大页面。对于前一种，4G的地址空间被划分成了1M个页，每页4KB。第1页的地址范围为0x00000000-0x00000FFF。最后一页的地址范围为0xFFFFF000-0xFFFFFFFF。

7. 4GB的物理内存被分隔成了1M个物理页，每个物理页都有一个编号，20位的编号(0x00000-0xFFFFF)就可以索引整个物理内存。如果物理内存是1MB，可以被分隔为256个物理页。8位编号(0x00-0xFF)就可以索引。但是在32位系统中，也用20位编号(0x00000-0x000FF)来存储。页面编号左移12位就可以找到该页面的起始物理地址。

8. 从线性地址→物理地址x86有两种转换方式：10-10-12分页和2-9-9-12分页。

## 10-10-12分页

1. 一个物理页面需要20位来索引，CPU将这20位分成了2个10位，分别对应线性地址的高10位和次高10位。物理页面内有4096个B，需要12位来寻址，对应于线性地址的低12位。

2. 每个进程的CR3寄存器保存了这个进程的页目录表所在的物理地址(所有寄存器中，只有这个寄存器使用的是物理地址)，因此又被称为页目录基址寄存器。

3. 每个进程的CR3不同，因此每个进程的地址空间映射不同，因此不同进程的相同的线性地址可能会映射到不同的物理页上，进而做到进程的地址空间隔离。这样进程的地址空间组织就非常自由。当CPU切换到该进程时，会将该进程TSS中的CR3值加载到CR3寄存器中。

4. 页目录表占用一个单独的物理页，每个表项占4个字节，一共存储$2^{10}$个表项。线性地址的高10位是用来在页目录表中找到对应的表项的。

5. 页目录表中的每个表项的高20位是页表的编号，低12位是该页表的属性。页表编号<<12位可以得到该页表的起始物理地址。每个页表也是占用一个单独的物理页。线性地址的次高10位是用来在页表内找到对应的表项的。

6. 页表中每个表项的高20位是页的编号，低12位是该页的属性。页编号<<12位就可以得到该页的起始物理地址。线性地址的低12位是页内的偏移地址。页的起始地址+偏移地址就得到线性地址对应的真实物理地址。一共经历了3次偏移。

7. 例如：线性地址为0x003729a0，按照10-10-12分开为：

   ```c
   void *pLinearAddress = 0x003729a0;
   int s1 = pLinearAddress>>22   //0x0
   int s2 = (pLinearAddress & 0x003FFFFF)>>12  //0x372
   int s3 = pLinearAddress & 0x00000FFF0  //0x9a0
   
   int CR3 = 0x19656000;  //第0x19656个物理页
   int PDE = (*(int*)(CR0+4*s1)) & 0xFFFFF000  //0x1410d000
   int PTE = (*(int*)(PDT+4*s2)) & 0xFFFFF000  //0x0736c000
   void *realAddress = PTT+s3  //0x0736c9a0
   ```

8. 首先根据CR3寄存器找到一级页表(页目录)的真实物理地址为page_dir_tables=0x19656000。然后通过\*(int\*)(0x19656000+4\*0x0)得到例如0x1410d067，高20位0x1410d是二级页表的编号，低12位是该页面的属性。0x1410d000是对应的二级页表的真实物理地址。然后通过\*(int\*)(0x1410d000+4*0x372)得到0x0736c067，同理页面编号为0x0736c，该物理页的基址为0x0736c000，最后通过0x0736c000+0x9a0=0x0736c9a0，这个就是真实的物理地址。以上地址指的都是物理地址。

13. x86内存的映射分为两级，第一级称为页目录表PDT，每项称为PDE。第二级称为页表PTT，每项称为PTE。将线性地址经过两次映射+一次页内偏移就可以得到物理地址了。最终可以索引1024*1024个物理页，因此一共是4GB内存。

14. ![image-20210607235804871](x86汇编语言：从实模式到保护模式.assets/image-20210607235804871.png)

15. 一个PTE可以不指向任何物理页，多个PTE可以指向同一个物理页。但是一个PTE只能指向一个物理页。

16. 如下进程的CR3=0x08444000发现0地址对应的PTE是全0的，它的最后一位是0，表示该PTE是无效的。因此读写该物理页会发生访问错误。即线性地址0没有对应到任何物理页上的。

18. PDE和PTE的属性：

19. ![image-20210608204824174](x86汇编语言：从实模式到保护模式.assets/image-20210608204824174.png)

20. 一个线性地址对应的物理页的属性=PDE的属性&PTE的属性。可见一个物理页的属性是相同的。

    1. P位是有效位，P=1表示指向的物理页是有效的
    2. R/W位是读写位，=0表示只读，=1表示可读可写。
    3. U/S位是特权位，U/S=0表示该页只允许特权用户ring0访问，U/S=1表示该页普通用户也可以访问。内核的代码和数据都是被这个位保护起来的。
    4. P/S位只对PDE有意义，是pagesize的意思，当P/S位=1时，PDE指向的不是PTE而是物理页，该物理页是一个4MB的大页，使用线性地址的低22位在页内偏移寻址。这样线性地址就被拆分成了两段10-22。
    5. A位是访问位，只要PDE或PTE被访问过(读或写)，就置为1。
    6. D位是写位，如果PDE或PTE指向的页被修改过，就置为1。

## 页目录基址

1. 通过CR3可以获得页目录基址，但是在程序中（包括操作系统），无法通过CR3来寻址，因为程序中，是看不到真实地址的，都是线性地址。

2. 页目录表存储在一个物理页中，因此也有一个线性地址对应到这个物理页上，就是0xc0300000。这一点可以通过CR3来查询验证：

3. 下面的程序的CR3=0x24450000，查看它所在的物理页内容：

4. ![image-20210608221048504](x86汇编语言：从实模式到保护模式.assets/image-20210608221048504.png)

5. 查询0xc0300000所在的物理页内容：

   ```c
   void *pLinearAddress = 0xc0300000;
   int s1 = pLinearAddress>>22   //0x300
   int s2 = (pLinearAddress & 0x003FFFFF)>>12  //0x300
   int s3 = pLinearAddress & 0x00000FFF0  //0x000
       
   int CR3 = 0x24450000;  //第0x24450个物理页
   int PDE = (*(int*)(CR3+4*s1)) & 0xFFFFF000  //0x24450063 可以发现是有效，可读可写，特权位
   int PTE = (*(int*)(PDT+4*s2)) & 0xFFFFF000  //0x24450063 可以发现是有效，可读可写，特权位
   void *realAddress = PTT+s3  //0x2445000
   ```

6. 可以发现这个线性地址对应的物理地址就是CR3对应的页目录表基址。因此可以在线性地址空间中通过0xc0300000找到页目录表。从上面的PDE和PTE的属性分析，可以看出页目录表是有效的，可读可写，需要ring0才可以访问。

7. 可以看到该线性地址对应的PDT基址=PTT基址，都是第0x24450个物理页。该物理页既是页目录表，又是页表。

8. 因此页目录表可以看做一个特殊的页表，它的每一项指向一个页表，而普通页表的项指向一个物理页。

## 页表基址

1. 根据线性地址0xc0300000可以找到页目录表的物理页，但是还需要找到对应页表的基址才可以在线性地址空间定位到页表，进而通过偏移定位到物理内存单元。

2. 页表也是一个物理页，也有一个线性地址与之对应，一共有1024个页表。线性地址0xC0000000对应的物理页是页目录表中第一个页表对应的物理页。查询页目录表中第0个页表的内容：

3. ![image-20210609001013854](x86汇编语言：从实模式到保护模式.assets/image-20210609001013854.png)

4. 页目录表中第1个页表的内容：

5. ![image-20210609001121206](x86汇编语言：从实模式到保护模式.assets/image-20210609001121206.png)

6. 查询0xC0000000所在的物理页内容：

   ```c
   void *pLinearAddress = 0xC0000000;
   int s1 = pLinearAddress>>22   //0x300
   int s2 = (pLinearAddress & 0x003FFFFF)>>12  //0x0
   int s3 = pLinearAddress & 0x00000FFF0  //0x000
   
   int CR3 = 0x24450000;  //第0x24450个物理页
   int PDE = (*(int*)(CR3+4*s1)) & 0xFFFFF000  //0x24450063 可以发现是有效，可读可写，特权位
   int PTE = (*(int*)(PDT+4*s2)) & 0xFFFFF000  //0x3e9e8067 可以发现是有效，可读可写，特权位
   void *realAddress = PTT+s3  //0x399e8000
   ```

8. 可以发现就是第一个页表所在的物理页。同理可以发现0xC0001000对应的物理页就是第二个页表所在的物理页。线性地址的差距也是4KB。因此页目录表0xc0300000是在第0x300(768)个页表的地方。

9. 1024个页表被映射到了0xC0000000到0xC03FFFFF线性地址空间中，一共4MB大小。页目录表中的第0x300项指向自己。

10. ![image-20210609002826900](x86汇编语言：从实模式到保护模式.assets/image-20210609002826900.png)

11. 通过上面的这两个地址可以获得任意线性地址的PDE和PTE属性。因此OS在线性地址模式下可以对进程的内存进行权限设置。

12. 例如想要让线性地址0x12345678对应的页具有读写权限。那么需要找到该线性地址对应的PDE和PTE。步骤如下：

    ```c
    void *pLinearAddress = 0x12345678;
    int s1 = pLinearAddress>>22;   //0x48  在页目录表中的编号
    int s2 = (pLinearAddress & 0x003FFFFF)>>12;  //0x345    在对应页表中的编号
    int s3 = pLinearAddress & 0x00000FFF0;  //0x678
    
    int PDE = 0xC0300000+4*s1;  //修改当前地址开头的4个字节数据的低12位即可修改线性地址0x12345678对应PDE的属性。
    int PTE = 0xC0000000+4096*s1+s2*4;  //修改当前地址开头的4个字节数据的低12位即可修改线性地址0x12345678对应PTE的属性。
    ```

13. 以上步骤就是操作系统在进程地址空间内存进行权限设置时使用的方法，操作系统和应用程序一样，都只能使用线性地址，CR3寄存器是给CPU使用的。

## 2-9-9-12分页

1. 这种分页方式是10-10-12分页的扩展，支持更多的物理地址，又称为PAE分页。
2. 页的大小不变，还是4KB。如果想要增大物理内存的访问范围就要增大PTE的大小，考虑到内存对齐，选用8字节来存储。这样1个物理页就只能存储$2^9=512$个PTE了，需要9位来索引。同样PDE也变成了8个字节，一个物理页存储$2^9=512$个PDE，需要9位索引。由于32-12-9-9=2，因此再页目录表前面又增加了一个页目录指针表PDPT。该表一共有4项PDPTE，每项8个字节。
3. ![image-20210609012503992](x86汇编语言：从实模式到保护模式.assets/image-20210609012503992.png)
4. PAE模式下能够寻址的最大物理内存为。
5. PDPT表项，8个字节，12-35位一共24位指向PDT表。最低位为有效位。
8. ![image-20210609013240690](x86汇编语言：从实模式到保护模式.assets/image-20210609013240690.png)
9. ![image-20210609013628458](x86汇编语言：从实模式到保护模式.assets/image-20210609013628458.png)
13. 寻址方式：
14. ![image-20210609013207424](x86汇编语言：从实模式到保护模式.assets/image-20210609013207424.png)

## 控制寄存器

1. 控制寄存器主要用于控制或确定CPU的操作模式。从CR0-CR4，一共有5个。CR1是保留的。
2. CR0的PE位=1表示表示启用保护模式，PE=0是实地址模式。该标准仅是开启段级保护，并未启用分页保护，没有操作系统工作在此模式下。
3. CR0的PG位=1表示开启了分页，分页必须在保护模式下开启，即CR0的PE为=1。
4. 对于486及以上的CPU，CR0的WP位=1表示开启写保护，CPU会禁止ring0的程序(CPL<3)向用户级的只读页面写入数据。
5. ![image-20210609095107469](x86汇编语言：从实模式到保护模式.assets/image-20210609095107469.png)
6. CR2寄存器是当产生缺页异常时，CPU会将对应的线性地址存放到CR2。之所以要保存这个，是因为一旦发生异常，就立即进入异常处理程序，找不到原来是访问哪个地址发生的异常，不利于排查错。
7. CR4的PAE位=1表示使用的是2-9-9-12分页，否则使用10-10-12分页。
8. CR4的PSE位=1表示PDE中的PS位有效，允许使用大页面。PSE=0表示所有的物理页都是小页面，4KB。
9. ![image-20210609100306666](x86汇编语言：从实模式到保护模式.assets/image-20210609100306666.png)
10. 除了TLB(线性地址和物理地址的对应关系)缓存，CPU中还有想当大的一块缓存cache。里边存储的是物理地址和其对应的内容。
11. PDE和PTE的PWT(page write through)位=1表示向该页写入数据时，除了写入缓存，还要求也写入到内存中。PWT=0表示向缓存中写入时，不会自动同步到内存中，会等CPU的cache控制器决定何时同步。
12. PDE和PTE的PCD(page cache disable)位=1表示向该页写入时，不允许写入缓存，直接写入内存。比如用来存储页表的物理页，已经在TLB中了，就没必要再放入缓存了。